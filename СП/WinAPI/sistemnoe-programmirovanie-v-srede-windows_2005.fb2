<?xml version="1.0" encoding="Windows-1251"?>
<FictionBook xmlns="http://www.gribuser.ru/xml/fictionbook/2.0" xmlns:l="http://www.w3.org/1999/xlink">
 <description>
  <title-info>
   <genre>comp_osnet</genre>
   <genre>comp_programming</genre>
   <author>
    <first-name>Джонсон</first-name>
    <middle-name>М.</middle-name>
    <last-name>Харт</last-name>
    
    <email>jmhart@world.std.com</email>
   </author>
   <book-title>Системное программирование в среде Windows</book-title>
   <annotation>
    <p>Эта книга посвящена вопросам разработки приложений с использованием интерфейса прикладного программирования операционных систем компании Microsoft (Windows 9х, Windows XP, Windows 2000 и Windows Server 2003). Основное внимание уделяется базовым системным службам, включая управление файловой системой, процессами и потоками, взаимодействие между процессами, сетевое программирование и синхронизацию. Рассматривается методика переноса приложений, написанных в среде Win32, в среду Win64. Подробно описываются все аспекты системы безопасности Windows и ее практического применения. Изобилие реальных примеров, доступных также и на Web-сайте книги, существенно упрощает усвоение материала.</p>
    <p>Книга ориентирована на разработчиков и программистов, как высокой квалификации, так и начинающих, а также будет полезна для студентов соответствующих специальностей.</p>
   </annotation>
   <date>2005</date>
   <coverpage>
    <image l:href="#_.jpg"/></coverpage>
   <lang>ru</lang>
   <src-lang>en</src-lang>
   <translator>
    <first-name>А.</first-name>
    <middle-name>Г.</middle-name>
    <last-name>Гузикевич</last-name>
   </translator>
  </title-info>
  
  <publish-info>
   <book-name>Системное программирование в среде Windows. Третье издание</book-name>
   <publisher>Издательский дом "Вильямс"</publisher>
   <city>Москва • Санкт-Петербург • Киев</city>
   <year>2005</year>
   <isbn>5-8459-0879-5</isbn>
  </publish-info>
 </description>
 <body>
  <title>
   <p>Джонсон М. Харт</p>
   <p>Системное программирование в среде Windows</p>
   <p>Третье издание</p>
  </title>
  <section>
   <title>
    <p>Введение</p>
   </title>
   <section>
    <p>В этой книге описывается разработка приложений с использованием интерфейса прикладного программирования (Application Programming Interface, API) операционных систем Windows компании Microsoft, причем основное внимание уделяется базовым системным службам, включая управление файловой системой, процессами и потоками, межпроцессное взаимодействие, сетевое программирование и синхронизацию. Пользовательские интерфейсы, внутренние функции Windows и драйверы ввода/вывода в данной книге не рассматриваются, хотя сами по себе эти темы не менее важны и представляют не меньший интерес. Для примеров преимущественно выбирались реалистичные сценарии, и поэтому многие из них вполне могут служить в качестве основы для построения реальных приложений.</p>
    <p>Win32/Win64 API, или обобщенно Windows API, поддерживаются семейством 32– и 64-разрядных операционных систем компании Microsoft, в которое в настоящее время входят Windows XP, Windows 2000 и Windows Server 2003. К числу ранних представителей этого семейства относятся операционные системы Windows NT, Windows Me, Windows 98 и Windows 95; в настоящее время эти системы считаются устаревшими, однако многие из приведенных в книге примеров программ способны выполняться и под их управлением. Вопросы перехода от платформы Win32 к развивающейся платформе Win64 обсуждаются по мере необходимости. Win64, поддерживаемый в качестве 64-разрядного интерфейса в некоторых версиях Windows Server 2003 и Windows XP, почти идентичен Win32.</p>
    <p>Не вызывает сомнений, что Windows API является важнейшим фактором, который оказывает влияние на весь процесс разработки приложений, и во многих случаях вытесняет поддерживаемый операционными системами UNIX и Linux POSIX API, поскольку считается более предпочтительным или, по крайней мере, предоставляющим те же возможности для приложений, ориентированных на настольные и серверные системы. Поэтому многие опытные программисты заинтересованы в скорейшем изучении Windows API, и данная книга призвана содействовать этому.</p>
    <p>Прежде всего, необходимо рассказать вам о том, что представляет собой Windows API, и показать, как им пользоваться в реальных ситуациях, причем этот рассказ должен быть как можно более кратким и не перегруженным излишними деталями. Поэтому данная книга предназначена не для использования в качестве справочного руководства, а для ознакомления с основными свойствами наиболее важных функций и демонстрации возможностей их применения в ситуациях практического программирования. Вооружившись этими знаниями, читатель сможет воспользоваться обширной справочной документацией, предоставляемой компанией Microsoft, для самостоятельного углубленного изучения отдельных вопросов, расширенных возможностей и менее приметных функций в соответствии с возникшими потребностями или заинтересованностью. Лично мне при таком подходе изучение Windows API далось легко, а разработка Windows-программ доставила огромное удовольствие, хотя и без неприятных минут также не обошлось. Мои порывы энтузиазма легко просматриваются в некоторых местах книги, что, собственно, и неудивительно. Впрочем, это вовсе не свидетельствует о том, что я безоговорочно соглашусь с превосходством Windows API над API других операционных систем (ОС), но относительно того, что у него есть масса положительных качеств, вряд ли кто-либо станет возражать.</p>
    <p>Авторы многих книг, посвященных Windows, значительное внимание уделяют объяснению того, что представляют собой процессы, виртуальная память, межпроцессное взаимодействие, вытесняющий планировщик, но при этом не показывают, как все это используется в реальных ситуациях. Программистам, имеющим опыт работы с системами UNIX, Linux, IBM MVS, Open VMS и некоторыми другими ОС эти понятия уже знакомы, и они заинтересованы лишь в том, чтобы как можно быстрее перейти к изучению того, как эти возможности реализованы в Windows. К тому же, в большинстве книг по Windows важное место отводится методам программирования на основе пользовательского интерфейса. С целью концентрации внимания лишь на самых главных базовых возможностях, предоставляемых системой, в данной книге тема пользовательского интерфейса не затрагивается, и мы ограничиваемся обсуждением лишь простого консольного символьного ввода/вывода.</p>
    <p>В соответствии с принятой в данной книге точке зрения Windows — это всего лишь API операционной системы, предоставляющий набор вполне понятных средств. Потребность в ускоренном изучении Windows испытывают многие программисты, независимо от уровня их опыта, и без знания Windows немыслимо обсуждение таких, например, тем, как модель компонентного объекта (Component Object Model, СОМ), разработанная компанией Microsoft. В некоторых отношениях системы Windows превосходят остальные системы, в других — отстают от них или находятся примерно на том же уровне. Задача данной книги состоит в том, чтобы продемонстрировать, как эффективнее всего использовать эти возможности в реальных ситуациях для разработки полезных, высококачественных и высокопроизводительных приложений.</p>
   </section>
   <section>
    <title>
     <p>Потенциальная аудитория</p>
    </title>
    <p>• Все, кто хочет быстро научиться разрабатывать приложения, независимо от уровня подготовки.</p>
    <p>• Программисты и специалисты по разработке программного обеспечения, перед которыми стоит задача переноса существующих приложений, написанных, в частности, для UNIX, на любую из платформ Windows. В книге демонстрируются сравнительные возможности функций и моделей программирования, связанных с использованием Windows, UNIX и стандартной библиотеки С. Каждая из обычных функциональных возможностей UNIX, включая управление процессами, синхронизацию, файловые системы и межпроцессное взаимодействие, рассматривается в терминах Windows.</p>
    <p>• Читатели, приступающие к разработке новых проектов, которые не ограничены в своих действиях необходимостью переноса имеющихся программных кодов на другие платформы. В книге охвачены многие аспекты проектирования и реализации программ и продемонстрированы способы использования функций Windows для создания полезных приложений и решения обычных задач программирования.</p>
    <p>• Программисты, использующие СОМ и .NET Framework, которые найдут здесь массу полезной информации, облегчающей изучение принципов работы динамически подключаемых библиотек (dynamic link libraries, DLL), моделей потоков и способов их применения, интерфейсов и синхронизации.</p>
    <p>• Студенты, изучающие компьютерные дисциплины на старших курсах вузов или занятые подготовкой дипломных работ, связанных с системным программированием или разработкой приложений. Книга будет полезна также тем, кто изучает многопоточное программирование или сталкивается с необходимостью создания сетевых приложений. Ее также можно использовать в качестве полезного дополнения к таким, например, источникам, как книга У. Ричарда Стивенса (W. Richard Stevens) <emphasis>Advanced Programming in the UNIX Environment</emphasis> (см. библиографию), что позволит студентам сравнить возможности Windows и UNIX. Эта книга будет хорошим подспорьем и для студентов, проходящих курс ОС, поскольку в ней показано, какими именно средствами обеспечивается базовая функциональность ОС, представляющих интерес в коммерческом отношении.</p>
    <p>Единственным допущением, которое неявно присутствует во всем вышесказанном, является предположение о том, что читатели имеют опыт программирования на языке С.</p>
   </section>
   <section>
    <title>
     <p>Изменения в третьем издании</p>
    </title>
    <p>Наряду со значительным обновлением и реорганизацией по сравнению с первыми двумя изданиями, в третьем издании добавлен обширный объем нового материала. Это издание призвано решать следующие задачи:</p>
    <p>• Охватить новые возможности, появившиеся в Windows XP, Windows 2000 и Windows Server 2003, а также рассмотреть вопросы перехода к платформе Win64.</p>
    <p>• Исключить материал, учитывающий специфику ОС Windows 95, Windows 98 и Windows ME (семейство "Windows 9x"), как устаревший, поскольку на поставляемых в настоящее время персональных системах устанавливается Windows XP, и ограничения, свойственные Windows 9х, уже потеряли свою актуальность.<a l:href="#n_1" type="note">[1]</a> В примерах программ без каких бы то ни было оговорок используются средства, которые входят лишь в текущие версии Windows, хотя в результате этого в Windows 9x некоторые программы работать не будут.</p>
    <p>• Предоставить более полное освещение темы потоков и синхронизации, включая связанные с этим аспекты производительности, масштабируемости и надежности. Глава 9, равно как и некоторые из примеров в главе 10, являются новыми.</p>
    <p>• Подчеркнуть все возрастающее влияние Windows 2000 и Windows Server 2003 и входящих в их состав новых средств на возможности высокопроизводительных, масштабируемых, многопоточных серверных приложений.</p>
    <p>• Исследовать зависимость производительности программ от принципов их построения, обратив особое внимание на многопоточные программы с синхронизацией и на особенности эксплуатации этих программ в условиях симметричных многопроцессорных (Symmetrical Multiprocessor, SMP) систем.</p>
    <p>• Учесть замечания читателей и студентов, касающиеся исправления недочетов и улучшения стиля изложения, а также все их советы и пожелания, как важные, так и самые незначительные.</p>
   </section>
   <section>
    <title>
     <p>Как организована эта книга</p>
    </title>
    <p>Расположение глав соответствует их тематической направленности, и поэтому сначала рассматриваются средства, необходимые для работы исключительно однопоточных приложений, затем средства, используемые для управления процессами и потоками, и лишь после этого обсуждаются вопросы сетевого программирования в среде с многопоточной поддержкой. Благодаря такой организации книги читателю будет легко следить за логикой изложения, последовательно переходя от файловых систем к управлению памятью и отображению файлов, далее — к процессам, потокам и синхронизации, а затем — к межпроцессному и сетевому взаимодействию и вопросам защиты приложений. Кроме того, такая организация позволяет естественным образом достраивать примеры по мере их усложнения, во многом подобно тому, как действует разработчик, когда сначала создает простой прототип, а затем постепенно вводит в него дополнительные возможности. Рассмотрение вопросов повышенной сложности, таких как асинхронный ввод/вывод и проблемы защиты, перенесено в самый конец книги.</p>
    <p>В пределах каждой главы, после краткого обсуждения отдельной функциональности, например, управления процессами или отображения файлов, подробно рассматриваются наиболее важные из соответствующих функций Windows и их взаимосвязь между собой. Изложение сопровождается иллюстративными примерами. В основной текст включены лишь наиболее существенные части листингов программ; полные тексты программ, а также необходимые включаемые файлы, вспомогательные функции и прочий код приведены в приложении А или доступны на Web-сайте книги (http://www.awprofessional.com/titles/0321256190). Во всех случаях, когда какие-либо возможности поддерживаются только текущими версиями Windows (XP, 2000 и Server 2003) и не поддерживаются предыдущими, например, Windows 9x и Windows NT, в которых не реализованы многие из усовершенствованных возможностей, делаются отдельные оговорки. В каждой главе приводится список дополнительной рекомендованной литературы и предлагается несколько упражнений. Многие упражнения акцентируют внимание на вопросах, которые имеют важное значение и представляют определенный интерес, но не были отражены в основном тексте, тогда как другие упражнения заставляют читателя глубже разобраться в темах более сложного или специального характера.</p>
    <p>В главе 1 предлагается высокоуровневое введение в семейство ОС Windows и Windows API. Используемая в качестве примера простая программа демонстрирует основные элементы стиля программирования Windows и создает фундамент для реализации усовершенствованных возможностей Windows. Win64 и проблемы межплатформенной миграции программ предварительно рассматриваются в главе 1, более полно изучаются в главе 16, и обсуждаются по мере изложения в остальной части книги там, где это оказывается необходимым.</p>
    <p>В главах 2 и 3 рассматриваются файловые системы, операции консольного ввода/вывода, блокирование файлов и управление каталогами. В главе 2 также рассказывается о кодировке Unicode — расширенном символьном наборе, который используется в Windows. Соответствующие иллюстративные примеры охватывают последовательный и прямой доступ к содержащимся в файле данным, обход дерева каталогов и архивирование файлов. Глава 3 заканчивается обсуждением программного управления реестром, имеющего много общего с управлением файлами и каталогами.</p>
    <p>Глава 4 знакомит читателя с обработкой исключений в Windows, включая структурную обработку исключений (Structured Exception Handling, SEH), которая будет широко использоваться на протяжении всей книги. Во многих книгах изучение SEH откладывается до последних глав, однако мы, ознакомившись с этим средством уже на начальной стадии, получим возможность сразу же пользоваться им, что значительно упростит для нас некоторые задачи программирования и позволит повысить качество программ. Кроме того, здесь описано также одно из новейших средств — векторная обработка исключений.</p>
    <p>В главе 5 рассмотрены вопросы управления памятью в Windows и показано, каким образом отображение файлов используется не только для упрощения программирования, но и для повышения производительности программ. В этой же главе рассмотрена организация библиотек DLL.</p>
    <p>В главе 6 приводятся начальные сведения о процессах, управлении процессами и простых методах синхронизации в Windows. Далее в главе 7 эти понятия используются для описания управления потоками. Примеры в каждой из глав иллюстрируют многочисленные преимущества, включая упрощение программ и повышение их производительности, которые обеспечивает использование потоков и процессов.</p>
    <p>Главы 8, 9 и 10 предлагают углубленный анализ одного из наиболее мощных средств Windows — синхронизации потоков. Синхронизация — сложная тема, и поэтому в данных главах содержатся многочисленные примеры и описания вполне понятных моделей, которые должны помочь читателю в полной мере воспользоваться преимуществами потоков для повышения эффективности программирования и производительности программ и вместе с тем обойти множество подводных камней. В эти главы включен новый материал, охватывающий вопросы повышения производительности и масштабируемости, что приобретает особое значение при создании серверных приложений, включая те из них, которые предположительно должны выполняться на SMP-системах.</p>
    <p>Главы 11 и 12 посвящены межпроцессным и межпоточным взаимодействиям, а также сетевому программированию. В главе 11 главное внимание уделено средствам, являющимся частью Windows, а именно, анонимным каналам, именованным каналам и почтовым ящикам. В главе 12 обсуждаются сокеты Windows (Windows Sockets), обеспечивающие возможность взаимодействия с системами, не входящими в семейство Windows, посредством стандартных протоколов, главным образом, TCP/IP. И хотя интерфейс Windows Sockets, строго говоря, не является частью Windows API, он способен обеспечивать связь и взаимодействие через сети и Internet, так что предмет рассмотрения данной главы согласуется с остальной частью книги. На примере многопоточной клиент-серверной системы проиллюстрировано, каким образом можно обеспечить межпроцессное взаимодействие наряду с потоками.</p>
    <p>В главе 13 показано, каким образом Windows позволяет превращать серверные приложения, аналогичные созданным в главах 11 и 12, в службы Windows (Windows Services), которыми можно управлять как фоновыми серверами. Преобразование сервера в службу требует внесения лишь незначительных изменений в программу.</p>
    <p>В главе 14 показано, как осуществлять операции асинхронного ввода/вывода с использованием перекрывающегося ввода/вывода, а также событий и процедур завершения. Тех же результатов можно добиться и с помощью потоков, поэтому приводятся примеры, позволяющие сравнить различные решения с точки зрения простоты и производительности соответствующих программ. В то же время, создание масштабируемых серверов с многопоточной поддержкой требует привлечения портов завершения, использование которых иллюстрируется на примере серверов, созданных в предыдущих главах. Описаны также таймеры ожидания, рассмотрение которых требует привлечения понятий, введенных ранее в этой главе.</p>
    <p>Глава 15 посвящена вопросам безопасности объектов Windows, а в качестве примера рассмотрена эмуляция системы защиты файлов в стиле UNIX, в которой для выполнения тех или иных операций с файлом требуется наличие соответствующих полномочий. Дополнительные примеры иллюстрируют, какими средствами обеспечивается защита процессов, потоков и именованных каналов. Дополнения, обеспечивающие безопасность, могут быть введены после этого в ранее рассмотренные примеры.</p>
    <p>Глава 16 завершает изложение основного материала рассмотрением вопросов программирования для Win64, а также обеспечения программной совместимости с этой платформой. После этого один из рассмотренных ранее примеров преобразуется к виду, допускающему перенос программы на платформу Win64.</p>
    <p>Основной материал книги дополнен тремя приложениями. В приложении А содержатся описания программ, доступных на Web-сайте книги, и рекомендации по их использованию. Приложение Б содержит несколько таблиц, в которых функции Windows сравниваются с аналогичными им функциями, предоставляемыми системой UNIX и стандартной библиотекой С. В приложении В сравнивается производительность альтернативных вариантов реализации некоторых из примеров, приведенных в основном тексте, что позволяет читателю составить собственное представление о сравнительных достоинствах и недостатках средств Windows, как базовых, так и усовершенствованных, и средств, предоставляемых библиотекой С.</p>
   </section>
   <section>
    <title>
     <p>Сопоставление с UNIX и библиотекой С</p>
    </title>
    <p>По ходу изложения материала мы сопоставляем стилевые и функциональные особенности средств Windows и аналогичных им средств, входящих в UNIX (Linux) и стандартную библиотеку ANSI С. Как уже отмечалось, в приложении Б приведены таблицы, содержащие полный перечень сопоставимых функций. Включение этой информации мы сочли целесообразным, поскольку многие читатели знакомы с UNIX, и результаты сравнения обеих систем между собой, несомненно, будут представлять для них интерес. Те же, кто не знаком с системой UNIX, могут смело пропустить соответствующие разделы, которые, чтобы их было легче отличить, набраны мелким шрифтом и выделены отступами.</p>
   </section>
   <section>
    <title>
     <p>Примеры</p>
    </title>
    <p>При подготовке примеров автор руководствовался следующими соображениями:</p>
    <p>• Примеры должны предоставлять образцы обычного, наиболее характерного и практически полезного применения функций Windows.</p>
    <p>• Они должны соответствовать реальным ситуациям из сферы программирования, с которыми приходится сталкиваться в процессе разработки программного обеспечения, оказания консультаций и обучения. Некоторые из моих клиентов и слушателей использовали коды примеров при построении собственных систем. При оказании консультаций мне часто попадаются коды программ, аналогичные тем, которые включены в эту книгу, а в нескольких случаях ко мне приходили даже с кодами, непосредственно взятыми из первого или второго изданий. (Кстати, вы также можете использовать примеры из книги в своей работе, а если включите в документацию еще и благодарность в мой адрес, то я буду только рад.) Нередко эти коды встречались мне и в виде отдельных частей объектов СОМ или C++. Примеры, с учетом ограничений на время их подготовки и допустимый объем кода, приближены к "реальной жизни" и решают "реальные" задачи.</p>
    <p>• Примеры должны подчеркивать фактическое поведение и взаимодействие функций, которые не всегда совпадают с тем, чего можно было бы ожидать после прочтения документации. В этой книге и текст, и примеры фокусируют внимание не на самих функциях, а на том, как они взаимодействуют между собой.</p>
    <p>• Программные коды примеров должны строиться по принципу их постепенного наращивания и расширения для добавления новых функциональных возможностей в предыдущее решение простым и понятным способом, а также демонстрировать альтернативные методики реализации.</p>
    <p>• Многие из примеров в нескольких первых главах реализуют такие команды UNIX, как ls, touch, chmod и sort, и тем самым представляют функции Windows в знакомом для части читателей контексте, одновременно создавая полезный набор вспомогательных функций.<a l:href="#n_2" type="note">[2]</a> Кроме того, наличие разных вариантов реализации одной и той же команды упрощает оценку преимуществ в отношении производительности, достигаемых за счет использования усовершенствованных средств Windows. Соответствующие результаты тестирования приведены в приложении В.</p>
    <p>Примеры, приводимые в начале книги, отличаются, как правило, небольшой длиной программ, однако по мере усложнения материала в последующих главах размеры иллюстративного программного кода в необходимых случаях существенно возрастают.</p>
    <p>В упражнениях, представленных в конце каждой главы, читателю предлагается разработать альтернативные варианты решений, самостоятельно исследовать рекомендуемые темы или ознакомиться с дополнительными функциональными возможностями, которые, несмотря на существующий к ним интерес, не могут быть подробно рассмотрены в данной книге. Некоторые из упражнений весьма просты, в то время как с другими у вас могут возникнуть затруднения. Нередко вашему вниманию предлагаются также явно неудачные решения, ибо выявление и устранение ошибок предоставит вам прекрасные возможности для оттачивания своего мастерства.</p>
    <p>Все примеры отлажены и протестированы в средах операционных систем Windows XP, Windows 2000 и Windows Server 2003.– В необходимых случаях тестирование проводилось под управлением операционных систем Windows 9x и Windows NT. И хотя для разработки программ в основном использовались однопроцессорные системы на базе процессоров Intel, большинство программ тестировались также на многопроцессорных системах. При тестировании приложений с клиент-серверной архитектурой использовались одновременно несколько клиентов, взаимодействующих с сервером. Тем не менее, никогда нельзя с полной уверенностью заявлять о корректности или завершенности программ и их пригодности для тех или иных целей. Несомненно, даже простейшие примеры могут иметь недостатки и при определенных обстоятельствах вообще не работать — такова участь почти любого программного обеспечения. Поэтому автор будет искренне благодарен всем, кто пришлет сообщения о любых дефектах, обнаруженных в программах, а еще лучше — об ошибках. </p>
   </section>
   <section>
    <title>
     <p>Web-сайты, посвященные этой книге</p>
    </title>
    <p>На Web-сайте книги (http://www.awprofessional.com/titles/0321256190) находится загружаемый файл, содержащий весь программный код и проекты для всех примеров, которые приведены в книге, решения ряда упражнений, альтернативные варианты реализации некоторых примеров, указания, а также результаты тестовых оценок производительности. Эта информация по мере надобности периодически обновляется с целью включения в нее нового материала и внесения необходимых исправлений.</p>
    <p>На моем персональном Web-сайте (http://www.world.std.com/~jmhart/windows.htm) вы найдете список опечаток, обнаруженных в книге, а также дополнительные примеры, письма читателей и дополнительные объяснения, не считая многого другого. Сюда же включены слайды PowerPoint, которые могут быть использованы в некоммерческих учебных целях. Этими слайдами уже воспользовались слушатели многих профессиональных курсов, но они вполне пригодны также для использования в колледжах.</p>
    <p>По мере выявления недостатков и ошибок и получения откликов читателей этот материал будет периодически обновляться. В случае возникновения каких-либо затруднений при работе с программами или любым другим материалом, содержащимся в книге, посетите сначала указанные сайты, где вам, возможно, удастся найти необходимые объяснения или получить информацию об обнаруженных к этому времени ошибках. Если же подобная попытка получения ответа на интересующий вас вопрос окажется безрезультатной, обращайтесь непосредственно ко мне по следующему адресу электронной почты: jmhart@world.std.com.</p>
   </section>
   <section>
    <title>
     <p>Благодарности</p>
    </title>
    <p>Во время подготовки третьего издания множество людей оказывали мне действенную помощь, делились советами или просто поддерживали добрым словом, а читатели подсказали целый ряд ценных идей и замечаний. На Web-сайте автора выражена горячая признательность всем тем, чьи советы и замечания нашли свое отражение в третьем издании книги, тогда как в первых двух изданиях содержатся благодарности в адрес тех, кто еще раньше дал нам ценные советы. Кроме того, прекрасный подробный анализ содержания книги был дан в недавних рецензиях Вагифа Абилова (Vagif Abilov), Билла Дрейпера (Bill Draper), Хорста Д. Клаузена (Horst D. Clausen), Майкла Девидсона (Michael Davidson), Дэниела Джанга (Daniel Jiang), Эрика Ландеса (Eric Landes), Клауса X. Пробста (Klaus H. Probst) и Дугласа Рейли (Douglas Reilly), которые отнеслись к этой работе с гораздо большим вниманием, чем того требовали бы одни формальные обязанности; их советы и рекомендации заслуживают самой глубокой благодарности, и мне лишь остается надеяться, что с не меньшим вниманием и я отнесся к результатам их труда. Отдельной благодарности заслуживают мои друзья из ArrAy Inc.; у них я многому научился.</p>
    <p>Анни X. Смит (Anne H. Smith), выполнявшая верстку, приложила все свое мастерство, настойчивость и терпение, готовя книгу к публикации; без ее вклада выход книги в свет был бы просто невозможен. Элисса Армер (Elissa Armour), готовившая макеты для первых двух изданий, тем самым заложила фундамент и для настоящего Издания, сделав этот переход как нельзя более гладким.</p>
    <p>Криста Мидоубрук (Chrysta Meadowbrooke), редактор рукописи, значительно улучшила точность, ясность и связность изложения материала. Ее внимательное отношение к содержанию книги, острые вопросы и проницательность помогли глубже осветить целый ряд вопросов.</p>
    <p>Сотрудники издательства Addison-Wesley Professional проявили такой профессионализм и знание дела, что работать с ними было сплошным удовольствием. Стефани Накиб (Stephane Nakib), редактор, и Карен Гетман (Karen Gettman), главный редактор, работали над проектом с самого начала, когда надо, торопили меня, устраняли все помехи в работе и следили за тем, чтобы я ни на йоту не отклонялся от рабочего графика. Эбони Хейт (Ebony Haight), помощник редактора, осуществлял общее руководство всеми этапами работы, а производственная группа Джона Фуллера (John Fuller) и Патрика Кэш-Петерсона (Patrick Cash-Peterson), координатора производства, заставили считать, что с производственным процессом не могут быть связаны никакие сложности.</p>
    <p>Эта книга посвящается горячо любимым Бобу (Bob) и Элизабет (Elizabeth).</p>
    <cite>
     <text-author><emphasis>Джонсон (Джон) М. Харт</emphasis></text-author>
     <text-author><emphasis>(Johnson (John) M. Hart)</emphasis> </text-author>
     <text-author>jmhart@world.std.com </text-author>
     <text-author>Август 2004 года.</text-author>
    </cite>
   </section>
   <section>
    <title>
     <p>От издательства</p>
    </title>
    <p>Вы, читатель этой книги, и есть главный ее критик и комментатор. Мы ценим ваше мнение и хотим знать, что было сделано нами правильно, что можно было сделать лучше и что еще вы хотели бы увидеть изданным нами. Нам интересно услышать и любые другие замечания, которые вам хотелось бы высказать в наш адрес.</p>
    <p>Мы ждем ваших комментариев и надеемся на них. Вы можете прислать нам бумажное или электронное письмо, либо просто посетить наш Web-сервер и оставить свои замечания там. Одним словом, любым удобным для вас способом дайте нам знать, нравится или нет вам эта книга, а также выскажите свое мнение о том, как сделать наши книги более интересными для вас.</p>
    <p>Посылая письмо или сообщение, не забудьте указать название книги и ее авторов, а также ваш обратный адрес. Мы внимательно ознакомимся с вашим мнением и обязательно учтем его при отборе и подготовке к изданию последующих книг.</p>
    <p>Наши координаты:</p>
    <p>E-mail: info@williamspublishing.com</p>
    <p>WWW: http://www.williamspublishing.com</p>
    <p>Информация для писем из: России: 115419, Москва, а/я 783 Украины: 03150, Киев, а/я 152</p>
   </section>
  </section>
  <section>
   <title>
    <p>ГЛАВА 1</p>
    <p>Знакомство с Win32 и Win64</p>
   </title>
   <section>
    <p>В этой главе вы познакомитесь с семейством операционных систем (ОС) Microsoft Windows и интерфейсом прикладного программирования (Application Programming Interface, API), который используется всеми членами этого семейства. Здесь также кратко описывается новейший 64-разрядный API Win64 и достаточно подробно обсуждается проблема переносимости программного обеспечения между Win32 и Win64. Для удобства изложения мы будем ссылаться, главным образом, просто на Windows и Windows API. Как правило, раздельные ссылки на Win32 и Win64 будут делаться лишь в тех случаях, когда различия между этими интерфейсами будут иметь существенное значение. Сориентироваться в том, что именно автор имеет в виду, когда говорит о Windows, — операционную систему или интерфейсе для разработки программ, — читателю поможет контекст.</p>
    <p>Подобно API любой другой ОС, Windows API также располагает собственным набором соглашений и приемов программирования, укладывающихся в рамки философии Windows. Co стилем программирования Windows вы ознакомитесь на примере обычного копирования файлов, однако тот же стиль используется при управлении файлами, процессами, памятью, а также такими более развитыми средствами, как синхронизация потоков. Для упомянутого примера будет приведен также код, в котором используется стандартная библиотека С, что облегчит вам сравнение стиля программирования, принятого в Windows, с более распространенными стилями.</p>
    <p>Мы начнем с общего обзора основных средств, предоставляемых любой современной операционной системой, чтобы понять, как эти средства используются в Windows.</p>
   </section>
   <section>
    <title>
     <p>Основные возможности операционных систем</p>
    </title>
    <p>Windows обеспечивает доступность базовых средств ОС в столь непохожих друг на друга системах, как мобильные телефоны, карманные устройства, переносные компьютеры и серверы масштаба предприятия. Возможности ОС можно охарактеризовать, рассмотрев наиболее важные ресурсы, которыми управляют современные операционные системы.</p>
    <p>• <strong>Память. </strong>ОС управляет сплошным, или плоским (flat), виртуальным адресным пространством большого объема, перемещая данные между физической памятью и диском или иным накопительным устройством прозрачным для пользователя образом.</p>
    <p>• <strong>Файловые системы. </strong>ОС управляет пространством именованных файлов, предоставляя возможности прямого и последовательного доступа к файлам, а также средства управления файлами и каталогами. Используемые в большинстве систем пространства имен являются иерархическими.</p>
    <p>• <strong>Именование и расположение ресурсов. </strong>Файлы могут иметь длинные, описательные имена, причем принятая схема именования распространяется также на такие объекты, как устройства, а также объекты синхронизации или межпроцессного взаимодействия. Размещение именованных объектов и управление доступом к ним также являются прерогативой ОС.</p>
    <p>• <strong>Многозадачность. </strong>ОС должна располагать средствами управления процессами, потоками и другими единицами, способными независимо выполняться в асинхронном режиме. Задачи могут планироваться и вытесняться в соответствии с динамически определяемыми приоритетами.</p>
    <p>• <strong>Взаимодействие и синхронизация. </strong>ОС управляет обменом информацией между задачами и их синхронизацией в изолированных системах, а также взаимодействием сетевых систем между собой и сетью Internet.</p>
    <p>• <strong>Безопасность и защита. </strong>ОС должна предоставлять гибкие механизмы защиты ресурсов от несанкционированного или непреднамеренного доступа и нанесения ущерба системе.</p>
    <p>Microsoft Windows Win 32/Win64 API обеспечивает поддержку не только этих, но и множества других средств ОС, и делает их доступными в ряде версий Windows, некоторые из которых постепенно выходит из употребления, а некоторые поддерживает лишь то или иное подмножество полного API.</p>
   </section>
   <section>
    <title>
     <p>Эволюция Windows</p>
    </title>
    <p>Windows API поддерживается несколькими версиями Windows. Существование ряда различных версий Windows может вносить некоторую неразбериху, однако с точки зрения программиста все они аналогичны друг другу. В частности, все версии поддерживают подмножества <emphasis>идентичных</emphasis> Windows API. Программы, разработанные для одной системы, без особых трудностей будут выполняются и в любой другой, и при этом обеспечивается переносимость исходных, а в большинстве случаев — и бинарных кодов.</p>
    <p>Каждая новая версия в определенной степени расширяла функциональные возможности API, хотя уже с самого начала API в целом отличался замечательной стабильностью. Ниже перечислены главные факторы, которые определяют эволюционное развитие Windows:</p>
    <p>• <strong>Масштабируемость. </strong>Новые версии способны выполняться на более широком спектре систем, включая серверы масштаба предприятия, использующие оперативную память большого объема и запоминающие устройства повышенной емкости.</p>
    <p>• <strong>Интеграция. </strong>Каждый новый выпуск системы интегрирует в себя элементы дополнительных технологий, такие, например, как использование мультимедийных данных или подключение к беспроводным сетям, Web-службы или самонастраивающиеся (plug-and-play) устройства. В целом, рассмотрение этих технологий выходит за рамки данной книги.</p>
    <p>• <strong>Простота использования. </strong>Элементы улучшения внешнего вида графического рабочего стола или средства, упрощающие пользование системой, без труда обнаруживаются в каждом новом выпуске системы.</p>
    <p>• <strong>Совершенствование API. </strong>За время своего существования API был дополнен новыми замечательными возможностями. Именно API является центральной темой данной книги.</p>
   </section>
   <section>
    <title>
     <p>Версии Windows</p>
    </title>
    <section>
     <p>ОС Windows, в виде развивающейся последовательности версий, используется, начиная с 1993 года. Во время написания данной книги на Web-сайте компании Microsoft в качестве основных фигурировали следующие версии:</p>
     <p>• <strong>Windows XP, </strong>включая выпуски Home, Professional и ряд других, которая ориентирована на индивидуальных пользователей. Большинство коммерческих PC, поступающих на рынок на сегодняшний день, включая лэптопы и ноутбуки, поставляются с уже установленной Windows XP соответствующего типа. В рамках данной книги различия между версиями, как правило, существенного значения не имеют.</p>
     <p>• <strong>Windows Server 2003, </strong>которая выпускается в виде продуктов Small Business Server, Storage Server 2003, а также некоторых других, и ориентирована на управление приложениями для предприятий и серверными приложениями. В системах, работающих под управлением Windows Server 2003, часто применяется симметричная многопроцессорная обработка (Symmetric Multiprocessing, SMP), характеризующаяся использованием одновременно нескольких независимых процессоров. Новые 64-разрядные приложения, требующие Win64, появляются преимущественно на системах Windows Server 2003.</p>
     <p>• <strong>Windows 2000, </strong>которая доступна в виде выпусков Professional и нескольких разновидностей выпусков Server и по-прежнему широко используется как в персональных, так и в серверных системах. Со временем Windows XP и будущие версии Windows вытеснят Windows 2000, продажа которой уже прекращена.</p>
     <p><strong>• Windows Embedded, Windows СЕ и Windows Mobile, </strong>которые представляют собой специализированные версии Windows, ориентированы на использование в малых системах, таких, например, как ручные (palmtop) и встроенные (embedded) устройства обработки данных, и предоставляют широкие подмножества возможностей Windows.</p>
    </section>
    <section>
     <title>
      <p>Устаревшие предыдущие версии Windows</p>
     </title>
     <p>В настоящее время продолжает использоваться ряд предыдущих версий Windows, которые считаются устаревшими и более не предлагаются или не поддерживаются компанией Microsoft, однако многие, хотя и не все, из обсуждаемых в данной книге примеров будут выполняться и под управлением этих систем. Перечень таких систем, постепенно выходящих из употребления, приводится ниже.</p>
     <p>• <strong>Windows NT </strong>3.5, 3.5.1 и 4.0, предшествовавшие современным версиям NT и восходящие своими корнями к 1993 году, из которых наибольшей популярностью пользовалась версия Windows NT 4.0, модернизированная с помощью пакета обновлений Service Pack 3 (SP3). Первоначально системы NT предназначались для профессиональных пользователей и серверов, в то время как версиями, распространяемыми для персональных и офисных нужд, служили версии Windows 9x (см. ниже). Первоначально Windows 2000 называлась Windows NT Version 5.0, в связи с чем многие пользователи, имея в виду системы Windows 2000, Windows Server 2003 или Windows XP, все еще употребляют названия Windows NT или Windows NT5. Несмотря на важные исключения, что особенно касается последних глав, под управлением NT Version 4.0 будут корректно, хотя и не всегда оптимально, работать почти все программы из числа тех, которые представлены в данной книге.</p>
     <p>• <strong>Windows 95, 98 и Windows ME</strong> (или просто — <strong>Windows 9x,</strong>поскольку различия между указанными системами вряд ли могут считаться существенными), которые предназначались главным образом для настольных (desktop) и переносных (laptop) компьютеров и не включали в себя, помимо прочего, средств безопасности Windows NT. В настоящее время эти системы вытесняются системой Windows XP, которая объединяет предоставляемые ими средства со средствами Windows NT. Многие примеры программ, хотя и не все, особенно из числа тех, которые приводятся в начальных главах книги, будут корректно выполняться и под управлением Windows 9x.</p>
     <p>Возвращаясь назад в прошлое, можно отметить, что до появления Windows 95 доминировала 16-разрядная ОС Windows 3.1, графический пользовательский интерфейс (Graphical User Interface, GUI) которой можно считать предшественником современных Windows GUI. Вместе с тем, многие важнейшие возможности ОС, такие как истинная многозадачность, управление памятью и средства защиты, она не поддерживала.</p>
     <p>Если обратиться к еще более отдаленному прошлому, к концу восьмидесятых годов прошлого столетия, то в качестве исходной "IBM PC-системы можно указать DOS. В DOS имелся всего-навсего простейший интерфейс командной строки, но DOS-команды используются и по сей день. В действительности, большинство из программ, рассматриваемых в данной книге в качестве примеров, написаны в виде консольных приложений и поэтому могут запускаться из командной строки, а для тестирования производительности даже специально предусмотрены пакетные файлы DOS.</p>
    </section>
    <section>
     <title>
      <p>Windows NT 5.x</p>
     </title>
     <p>По отношению к системам Windows 2000, Windows XP и Windows Server 2003 используют собирательное название Windows NT Version 5.x или просто NT5. В каждой из трех указанных систем эксплуатируется пятая версия ядра Windows NT, хотя младший номер версии ("х" в "5.x") может быть различным. Так, в Windows XP используется ядро версии NT 5.1.</p>
     <p>Несмотря на то что многие программы будут выполняться и под управлением предыдущих версий Windows, мы, как правило, предполагаем применение версии NT5, некоторые возможности которой отсутствуют в предыдущих версиях. Поскольку любая современная Windows-система обладает возможностями NT5, такое предположение не чревато никакими осложнениями, но зато снимает любые ограничения на использование усовершенствованных возможностей ОС. Вместе с тем, на многих устаревших системах все еще могут оставаться установленными ранние версии Windows NT или Windows 9x, и поэтому программы примеров сразу же после запуска проверяют номер версии Windows и в необходимых случаях прекращают свою работу с выводом сообщения об ошибке.</p>
     <p>В документации по Microsoft API приводятся требования к номеру версии, сформулированные в терминах NT, Windows (что в данном контексте относится к версиям 9х) и СЕ, и ряд других требований. В случае любого рода сомнений относительно возможности использования тех или иных функций API в конкретной версии Windows следует обратиться к документации.</p>
    </section>
    <section>
     <title>
      <p>Другие интерфейсы программирования для Windows</p>
     </title>
     <p>Windows (под этим термином, если отдельно не оговаривается иное, мы подразумеваем API Win32 и Win64, а также NT5) способна обеспечивать также поддержку среды других "подсистем", хотя этой возможностью пользуются редко и прямого отношения к тематике данной книги она не имеет. Ядро ОС NT имеет действительно надежную защиту от воздействия со стороны приложений. Windows является для него лишь одной из нескольких возможных сред. Так, предоставляемый компанией Microsoft набор инструментальных средств Windows Resource Kit включает подсистему POSIX, но кроме того существуют подсистемы POSIX, предлагаемые в рамках проекта разработки программного обеспечения с открытым исходным кодом.</p>
    </section>
    <section>
     <title>
      <p>Поддержка процессоров</p>
     </title>
     <p>Хотя это не и не входит в сферу непосредственных интересов разработчика приложений, вам следует знать, что Windows поддерживает самые различные базовые процессоры и архитектуры систем, для чего предусмотрен уровень аппаратных абстракций (Hardware Abstraction Layer, HAL), который обеспечивает переносимость программ на системы с другой архитектурой процессора.</p>
     <p>Windows выполняется преимущественно на процессорах семейства Intel x86, новейшими представителями которого являются процессоры Pentium и Xeon, а одним из предыдущих — Intel 486. Широкое распространение получили совместимые с ними процессоры компании Advanced Micro Devices (AMD). Кроме того, Windows изначально проектировалась таким образом, чтобы обеспечивалась независимость от типа процессора. Что немаловажно, Windows Server 2003 поддерживается процессором Intel Itanium, новая 64-разрядная архитектура которого самым радикальным образом отличается от классической архитектуры процессоров семейства х86.</p>
     <p>Другими примерами независимости Windows от архитектуры процессоров, относящимися как к прошлому, так и к настоящему, могут служить следующие:</p>
     <p>• Windows СЕ способна выполняться на целом ряде процессоров, не принадлежащих семейству х86.</p>
     <p>• Windows NT первоначально поддерживалась Alpha-процессорами компании Digital Equipment Corporation (которая была приобретена сначала компанией Compaq, а затем компанией Hewlett Packard).</p>
     <p>• 64-разрядные процессоры компании AMD Athlon 64 и Opteron (AMD64) обеспечивают 64-разрядное расширение архитектуры х86, отражающее иной подход по сравнению с тем, который используется в архитектуре Itanium.</p>
     <p>• Недавно объявленные компанией Intel 32/64-разрядные процессоры будут представлять собой 64-разрядные расширения процессоров х86.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Воздействие Windows на ситуацию на рынке</p>
    </title>
    <p>Тот факт, что система Windows способна обеспечивать важнейшие функциональные возможности на нескольких платформах, вряд ли можно считать уникальным. В конце концов, этим могут похвастаться многие коммерческие ОС, не говоря уже об ОС с открытым исходным кодом, a UNIX<a l:href="#n_3" type="note">[3]</a> и Linux уже в течение длительного времени эксплуатируются на самых разнообразных системах. Между тем, использование Windows и разработка приложений для Windows сулят значительные преимущества как в коммерческом, так и в техническом отношении.</p>
    <p>• Windows занимает на рынке, особенно на рынке настольных систем, господствующее положение, которое прочно удерживается ею в течение многих лет.<a l:href="#n_4" type="note">[4]</a> Поэтому перед приложениями Windows открыт огромный целевой рынок, емкость которого исчисляется десятками миллионов систем, вследствие чего остальные настольные системы, включая UNIX, Linux и Macintosh, играют на рынке значительно меньшую роль.</p>
    <p>• Приложения Windows могут использовать GUI, знакомый десяткам миллионов пользователей, а для многих приложений предусмотрена возможность их адаптации, или "локализации", в соответствии с региональными требованиями, предъявляемыми к языку и внешнему виду интерфейса.</p>
    <p>• Windows поддерживает SMP-системы. Сфера применения Windows не ограничивается настольными системами и охватывает как серверы масштаба подразделения и предприятия, так и высокопроизводительные рабочие станции.<a l:href="#n_5" type="note">[5]</a></p>
    <p>• Windows (правда, это не относится к Windows 9x и Windows СЕ) сертифицирована Управлением национальной безопасности (National Security Agency, NSA) как система, обеспечивающая уровень безопасности С2.</p>
    <p>• Применение большинства других ОС, отличных от UNIX, Linux и Windows, ограничивается только системами, предоставляемыми единственным поставщиком.</p>
    <p>• Операционные системы семейства Windows предлагают ряд возможностей, которые в стандартной системе UNIX отсутствуют, хотя и могут быть доступными в некоторых реализациях. В качестве примера можно привести систему безопасности уровня С2, а также службы NT Services.</p>
    <p>Windows предоставляет функциональность современных ОС, а диапазон систем, которые могут работать под ее управлением, простирается от текстовых процессоров и почтовых программ до интегрированных систем предприятия и серверов крупных баз данных. На принятие решений относительно способа разработки Windows-приложений оказывают влияние как соображения технического порядка, так и корпоративные требования.</p>
   </section>
   <section>
    <title>
     <p>Windows, стандарты и открытые системы</p>
    </title>
    <section>
     <p>Эта книга посвящена разработке приложений с использованием Windows API. Вполне естественно, что у программистов, воспитанных на UNIX и открытых системах, могут возникнуть следующие вопросы: "Является ли Windows открытой системой?", "Представляет ли собой Windows промышленный стандарт?", "Не является ли Windows всего лишь очередным патентованным API?" Ответы на эти вопросы во многом зависят от того, что именно понимается под определениями <emphasis>открытая</emphasis> (open), <emphasis>промышленный стандарт</emphasis> (industry standard) или <emphasis>патентованный</emphasis> (proprietary), а также от того, какие преимущества ожидаются от использования открытых систем.</p>
     <p>Windows API полностью отличается от API стандарта POSIX, поддерживаемого системами Linux и UNIX. Windows не подчиняется стандарту Х/Open, как не подчиняется и никакому другому открытому промышленному стандарту из тех, которые были предложены соответствующими органами стандартизации или промышленными консорциумами.</p>
     <p>Windows контролируется единственным поставщиком. Хотя Microsoft и заявляет о своей готовности приспосабливаться к требованиям отрасли и учитывать их, в этих вопросах сама же она является арбитром и исполнителем в одном лице. Отсюда следует, что, помимо других преимуществ, пользователи Windows получают многие из выгод, которые обычно предлагают открытые стандарты.</p>
     <p>• Унифицированные реализации быстрее достигают рынка.</p>
     <p>• Отсутствуют какие-либо неожиданные фирменные "улучшения" или "расширения", с которыми потом приходится бороться программисту, хотя небольшие различия, существующие между различными платформами Windows, все же приходится учитывать.</p>
     <p>• Вся совокупность полноценных ОС-продуктов, предлагающих все необходимые возможности, определена и реализована одним и тем же поставщиком. Разработчикам приложений остается решать только высокоуровневые задачи.</p>
     <p>• Базовая аппаратная платформа является открытой. Разработчики могут выбирать любого из многочисленных поставщиков платформ по своему усмотрению.</p>
     <p>Жаркие споры относительно того, к добру ли такая ситуация для пользователей и компьютерной индустрии в целом, или она только вредит общему делу, еще не закончились. Мы не будем пытаться участвовать в этом споре; задача данной книги состоит лишь в том, чтобы помочь разработчикам приложений как можно скорее приступить к работе в Windows.</p>
     <p>В действительности системы Windows поддерживают многие важные стандарты. Так, Windows поддерживает стандартные библиотеки С и С+ и целый ряд открытых стандартов межплатформенного взаимодействия. В качестве примера можно привести сокеты Windows (Windows Sockets), предоставляющие стандартный интерфейс сетевого программирования, который обеспечивает возможность использования TCP/IP и других сетевых протоколов и тем самым открывает возможности доступа в Internet и взаимодействия с системами, не принадлежащими семейству Windows. To же самое остается справедливым и по отношению к протоколу удаленного вызова процедур (Remote Procedure Calls, RPC).<a l:href="#n_6" type="note">[6]</a> Системы самой различной природы могут связываться с высокоуровневыми системами управления базами данных (СУБД) при помощи языка структурированных запросов (SQL). Наконец, в общий круг предложений Windows входит поддержка Internet, обеспечиваемая Web-серверами и серверам иного рода. Windows поддерживает такие ключевые стандарты, как TCP/IP, а на активно действующем рынке поставщиков решений Windows вам предлагают приобрести за разумную плату множество других ценных дополнительных продуктов, в том числе клиенты и серверы X Window.</p>
     <p>Резюмируя, можно утверждать, что Windows поддерживает наиболее важные из стандартов межплатформенного взаимодействия, и хотя основной API является собственностью компании, он доступен по умеренной цене для широкого ряда систем.</p>
    </section>
    <section>
     <title>
      <p>Библиотеки совместимости</p>
     </title>
     <p>Несмотря на наличие библиотек совместимости (compatibility libraries), ими пользуются очень редко. Существуют две возможности.</p>
     <p>• В системах на основе UNIX, Linux, Macintosh и некоторых других может быть развернута одна из библиотек совместимости Windows, например, эмулятор Windows с открытым исходным кодом Wine, что обеспечивает переносимость исходного кода из Windows.</p>
     <p>• За счет использования программного обеспечения с открытым исходным кодом и набора инструментальных средств Windows Resource Kit компании Microsoft поверх подсистемы Windows может быть развернута библиотека совместимости POSIX. Весьма ограниченная по своим возможностям библиотека совместимости входит в состав среды визуальной разработки при ложений Microsoft Visual C++.</p>
     <p>Таким образом, имеется, пусть даже и редко используемая, возможность выбора одного API и развертывания разработанных с его помощью переносимых приложений на системах Windows, POSIX и даже Macintosh.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Принципы, лежащие в основе Windows</p>
    </title>
    <p>Полезно никогда не забывать о некоторых базовых принципах Windows. В Windows API имеется множество как самых незаметных, так и значительных отличий от других API, таких как POSIX API, с которым знакомы программисты, работающие в UNIX и Linux. И хотя с применением Windows не связаны какие-либо специфические трудности в работе, она потребует от вас внесения некоторых изменений в привычные стиль и методику программирования.</p>
    <p>Ниже описаны некоторые из важнейших характеристик Windows, с которыми вы ближе познакомитесь по мере дальнейшего изложения материала.</p>
    <p>Многие системные ресурсы Windows представляются в виде <emphasis>объектов ядра</emphasis> (kernel objects), для идентификации и обращения к которым используются <emphasis>дескрипторы</emphasis> (handles). По смыслу эти дескрипторы аналогичны дескрипторам (descriptors) файлов и идентификаторам (ID) процессов в UNIX.<a l:href="#n_7" type="note">[7]</a></p>
    <p>• Любые манипуляции с объектами ядра осуществляются только с использованием Windows API. "Лазеек" для обхода этого правила нет. Подобная организация работы согласуется с принципами абстрагирования данных, используемыми в объектно-ориентированном программировании, хотя сама система Windows объектно-ориентированной не является.</p>
    <p>• К объектам относятся файлы, процессы, потоки, каналы межпроцессного взаимодействия, объекты отображения файлов, события и многое другое. Объекты имеют атрибуты защиты.</p>
    <p>• Windows — богатый возможностями и гибкий интерфейс. Во-первых, одни и те же или аналогичные задачи могут решаться с помощью сразу нескольких функций; так, имеются вспомогательные функции (convenience functions), полученные объединением часто встречающихся последовательностей функциональных вызовов в одну функцию (к числу подобных функций принадлежит и функция CopyFile, используемая в одном из примеров далее в этой главе). Во-вторых, функции часто имеют многочисленные параметры и флаги, многие из которых обычно игнорируются. Данная книга не претендует на роль энциклопедического справочника, и основное внимание в ней концентрируется лишь на наиболее важных функциях и параметрах.</p>
    <p>• Windows предлагает многочисленные механизмы синхронизации и взаимодействия, обеспечивающие удовлетворение самых разнообразных запросов.</p>
    <p>• Базовой единицей выполнения в Windows является поток (thread). В одном процессе (process) могут выполняться один или несколько потоков.</p>
    <p>• Для функций Windows используются длинные описательные имена. Приведенные ниже в качестве примера имена функций иллюстрируют не только соглашения об использовании имен, но и многоликость функций Windows:</p>
    <p><code>WaitForSingleObject </code></p>
    <p><code>WaitForSingleObjectEx </code></p>
    <p><code>WaitForMultipleObjects </code></p>
    <p><code>WaitNamedPipe</code></p>
    <p>Существует также несколько соглашений, регулирующих порядок использования имен типов:</p>
    <p>• Имена предопределенных типов данных, необходимых API, также являются описательными, и в них должны использоваться прописные буквы.</p>
    <p>К числу наиболее распространенных относятся следующие типы данных:</p>
    <p>BOOL (определен как 32-битовый объект, предназначенный для хранения одного логического значения) </p>
    <p>HANDLE</p>
    <p>DWORD (вездесущее 32-битовое целое без знака)</p>
    <p>LPTSTR (указатель на строку, состоящую из 8– или 16-битовых символов) </p>
    <p>LPSECURITY_ATTRIBUTES</p>
    <p>С другими многочисленными типами данных вы будете знакомиться по мере изложения материала.</p>
    <p>• В именах предопределенных типов указателей операция * не используется, и они отражают дополнительные отличия между указателями различного типа, как, например, в случае типов LPTSTR (определен как TCHAR *) и LPCTSTR (определен как const TCHAR *). <emphasis>Примечание.</emphasis> Тип TCHAR может обозначать как обычный символьный тип char, так и двухбайтовый тип wchar_t.</p>
    <p>• В отношении использования имен переменных, — по крайней мере, в прототипах функций, — также имеются определенные соглашения. Так, имя lpszFileName соответствует "длинному указателю на строку, завершающуюся нулевым символом", которая содержит имя файла. Этот пример иллюстрирует применение так называемой "венгерской нотации", которой мы в данной книге, как правило, не стремимся придерживаться. Точно так же, dwAccess — двойное слово (32 бита), содержащее флаги прав доступа к файлу, где "dw" означает "double word" — "двойное слово".</p>
    <cite>
     <p><strong>Примечание</strong></p>
     <p>Будет очень полезно, если вы просмотрите системные заголовочные (включаемые) файлы, в которых содержатся определения функций, констант, флагов, кодов ошибок и тому подобное. Многие из представляющих для нас интерес файлов, аналогичных тем, которые предложены ниже в качестве примера, являются частью среды Microsoft Visual C++ и обычно устанавливаются в каталоге Program Files\Microsoft Visual Studio.NET\Vc7\PlatformSDK\Include (или Program Files\Microsoft Visual Studio\VC98\Include в случае VC++ 6.0):</p>
     <p>WINDOWS.H (файл, обеспечивающий включение всех остальных заголовочных файлов)</p>
     <p>WINNT.Н </p>
     <p>WINBASE.H </p>
    </cite>
    <p>Наконец, несмотря на то что оригинальный API Win32 с самого начала разрабатывался как совершенно независимый интерфейс, он проектировался с учетом обеспечения обратной совместимости с API Winl6, входившим в состав Windows 3.1. Это привело к некоторым досадным с точки зрения программиста последствиям:</p>
    <p>• В названиях типов встречаются элементы анахронизма, как, например, в случае типов LPTSTR и LPDWORD, ссылающихся на "длинный указатель", который является простым 32– или 64-битовым указателем. Необходимость в указателях какого-либо иного типа отсутствует. Иногда составляющая "длинный" опускается, и тогда, например, типы LPVOID и PVOID являются эквивалентными.<a l:href="#n_8" type="note">[8]</a></p>
    <p>• В имена некоторых символических констант, например WIN32_FIND_DATA, входит компонент "WIN32", хотя те же константы используются и в Win64.</p>
    <p>• Несмотря на то что упомянутая проблема обратной совместимости в настоящее время потеряла свою актуальность, она оставила после себя множество 16-разрядных функций, ни одна из которых в этой книге не используется, хотя и могло бы показаться, что эти функции играют весьма важную роль. В качестве примера можно привести функцию OpenFile, которая, судя по ее названию, нужна для открытия файлов, тогда как в действительно сти для открытия существующих файлов всегда следует пользоваться только функцией CreateFile.</p>
   </section>
   <section>
    <title>
     <p>Подготовка к работе с Win64</p>
    </title>
    <p>Интерфейс Win64, который во время написания данной книги поддерживался Windows XP и Windows Server 2003 на процессорах семейства AMD64 (Opteron и Athlon 64) компании AMD и процессорах семейства Itanium (ранее известных под кодовыми названиями Merced, McKinley, Madison и IA-64) компании Intel, будет играть все более важную роль при создании крупных приложений. Существенные отличия между Win32 и Win64 обусловлены различиями в размере указателей (64 бита в Win64) и объеме доступного виртуального адресного пространства.</p>
    <p>Проблемы переноса приложений на платформу Win64 обсуждаются по мере изложения материала на протяжении всей книги, а программы организованы таким образом, чтобы создание их в виде приложений Win64 обеспечивалось простым указанием соответствующих параметров на стадии компиляции. В находящихся на Web-хосте книги проектах с программами примеров в необходимых случаях предусмотрен вывод сообщений, предупреждающих о возникновении проблем при переходе к 64 разрядам, но большинство ситуаций (хотя и не полностью все), которые могли бы приводить к генерации таких сообщений, из программного кода исключены.</p>
    <p>С точки зрения программиста основные отличия при переходе к Win64 обусловлены размерами указателей и необходимостью помнить о том, что длины указателя и целочисленной переменной (LONG, DWORD и так далее) не обязательно должны совпадать. С этой целью определены, например, типы DWORD32 и DWORD64, позволяющие явно управлять размером переменных. Два других типа, POINTER_32 и POINTER_64, позволяют управлять размером указателей.</p>
    <p>Как вы сами убедитесь, приложив лишь самые незначительные усилия, можно добиться того, чтобы программы работали как в Win32, так и в Win64, и поэтому мы будем часто ссылаться на API просто как на Windows или, иногда, Win32. Дополнительная информация относительно Win64 содержится в главе 16, где, в частности, обсуждаются вопросы совместимости исходных и двоичных кодов. </p>
    <cite>
     <p>Программисты, работающие с UNIX и Linux, столкнутся в Windows с рядом интересных особенностей. Так, в Windows дескрипторы HANDLE являются "непрозрачными". Они не представляют собой ряд последовательно возрастающих целых чисел. В то же время, например, в UNIX дескрипторы файлов 0, 1 и 2 имеют специальное назначение, что должно обязательно учитываться при написании программ. Ничего подобного в Windows вы не обнаружите.</p>
     <p>Многие из различий, например грань между идентификаторами процессов и дескрипторами файлов, в Windows оказываются стертыми. В Windows объекты обеих типов описываются дескрипторами типа HANDLE. Во многих важных функциях могут наравне использоваться дескрипторы файлов, процессов, событий, каналов и других объектов.</p>
     <p>Программистам, которые, работая в UNIX, привыкли к коротким именам функций и параметров и использовали преимущественно строчные буквы, придется приспосабливаться к более пространному стилю Windows. Стиль Windows близок к стилю интерфейса компании Hewlett Packard (ранее — DEC и Compaq); программистам, работающим с OpenVMS, многое покажется знакомым. Указанное сходство между OpenVMS и Windows частично объясняется тем, что Дэвид Катлер (David Cutler), создатель первоначальной архитектуры VMS, предполагал, что она должна играть ту же роль, что и NT или Windows.</p>
     <p>Радикальные отличия касаются такого хорошо знакомого нам всем понятия, как процессы. В Windows процессы не обладают свойствами наследования, хотя и могут быть организованы в виде объектов заданий.</p>
     <p>В завершение следует отметить, что в текстовых файлах Windows конец строки отмечается последовательностью управляющих символов CR-LF, а не LF, как в это принято в UNIX. </p>
    </cite>
   </section>
   <section>
    <title>
     <p>О целесообразности привлечения функций стандартной библиотеки C для обработки файлов</p>
    </title>
    <p>Несмотря на всю уникальность возможностей Windows, старый добрый язык С и его стандартная библиотека ANSI С по-прежнему могут с успехом использоваться при решении большинства задач, связанных с обработкой файлов. Кроме того, библиотека С (указание на ее соответствие стандарту ANSI С мы будем часто опускать) содержит большое число очень нужных функций, аналогов которых среди системных вызовов нет. К их числу относятся, например, функции, описанные в заголовочных файлах &lt;string.h&gt;, &lt;stdlib.h&gt; и &lt;signal.h&gt;, а также функции форматированного и символьного ввода/вывода. В то же время, имеются и такие функции, как fopen и fread, описанные в заголовочном файле &lt;stdio.h&gt;, для которых находятся близко соответствующие им системные вызовы.</p>
    <p>В каких же случаях при обработке файлов можно обойтись библиотекой С, а в каких необходимо использовать системные вызовы Windows? Тот же вопрос можно задать и в отношении использования потоков (streams) ввода/вывода C++ или системы ввода/вывода, которая предоставляется платформой .NET. Простых ответов на эти вопросы не существует, но если во главу угла поставить переносимость программ на платформы, отличные от Windows, то в тех случаях, когда приложению требуется только обработка файлов, а не, например, управление процессами или другие специфические возможности Windows, предпочтение следует отдавать библиотеке С и потокам ввода/вывода C++. Вместе с тем, многими программистами ранее уже делались попытки выработать рекомендации относительно адекватности использования библиотеки С в тех или иных случаях, и эти же рекомендации должны быть применимы и в отношении Windows. Кроме того, с учетом возможностей расширения функциональности, а также повышения производительности и гибкости программ, обеспечиваемые Windows, нередко оказывается более удобным или даже необходимым не ограничиваться библиотекой С, в чем вы постепенно станете убеждаться уже начиная с главы 3. К числу возможностей Windows, не поддерживаемых библиотекой С, относятся блокирование и отображение файлов (необходимое для разделения общих областей памяти), асинхронный ввод/вывод, произвольный доступ к файлам чрезвычайно крупных размеров (4 Гбайт и выше) и взаимодействие между процессами.</p>
    <p>В случае простых программ вам будет вполне достаточно использовать функции библиотеки С, предназначенные для работы с файлами. Воспользовавшись библиотекой С, можно написать переносимое приложение даже без изучения Windows, однако возможности выбора при этом будут ограниченными. Так, в главе 5 для повышения производительности программы и упрощения программирования применено отображение файлов, однако библиотека С такие возможности не предоставляет. </p>
   </section>
   <section>
    <title>
     <p>Что требуется для работы с данной книгой</p>
    </title>
    <p>Ниже перечислено все то, что необходимо вам для создания и выполнения примеров, приведенных в этой и последующих главах книги.</p>
    <p>Разумеется, прежде всего, вам потребуется весь ваш опыт в области разработки приложений; предполагается также, что язык С вам знаком. Однако прежде, чем браться за решение упражнений и разбор примеров, вы должны убедиться в том, что располагаете всем необходимым аппаратным и программным обеспечением, перечень которого приводится ниже.</p>
    <p>• Система с установленной ОС Windows.</p>
    <p>• Компилятор С и любая подходящая среда разработки приложений, например, Microsoft Visual Studio .NET или Microsoft Visual C++ версии 6.0. Имеются также системы разработки приложений от других поставщиков, и хотя примеры из книги нами на них не тестировались, из поступивших от нескольких читателей писем нам стало известно, что примеры, пусть даже после внесения в них незначительных изменений, в некоторых случаях успешно выполнялись даже при использовании других систем. Кроме того, в приложении А содержится информация, касающаяся использования инструментальных средств с открытым исходным кодом. <emphasis>Примечание.</emphasis> Наше внимание будет сосредоточено на разработке консольных приложений Windows, и поэтому возможности Microsoft Visual Studio .NET будут задействованы далеко не в полной мере.</p>
    <p>• Достаточный для разработки программ объем ОЗУ и наличие свободного места на жестком диске. Практически любая коммерчески доступная система предоставит вам достаточный объем памяти, место на диске и процессорную мощность, которых хватит для запуска примеров и среды разработки приложений, однако предварительно необходимо проверить, какие именно требования к ресурсам предъявляет эта среда.<a l:href="#n_9" type="note">[9]</a></p>
    <p>• Привод компакт-диска, системного или сетевого, для установки среды разработки приложений.</p>
    <p>• Оперативная документация наподобие той, которая поставляется вместе с Microsoft Visual C++. Желательно, чтобы вы установили эту документацию на своем жестком диске, поскольку к ней будет требоваться частый доступ. Дополнительную информацию вы всегда сможете получить на Web-сайте компании Microsoft.</p>
   </section>
   <section>
    <title>
     <p>Пример: простое последовательное копирование файла</p>
    </title>
    <section>
     <p>В следующих разделах приведены примеры коротких программ, реализующих простое последовательное копирование содержимого файла тремя различными способами:</p>
     <p>1. С использованием библиотеки С.</p>
     <p>2. С использованием Windows.</p>
     <p>3. С использованием вспомогательной функции Windows — CopyFile.</p>
     <p>Кроме того, что эти примеры дают возможность сопоставить между собой различные модели программирования, они также демонстрируют возможности и ограничения, присущие библиотеке С и Windows. Альтернативные варианты реализации усилят программу, увеличивая ее производительность и повышая гибкость.</p>
     <p>Последовательная обработка файлов является простейшей, наиболее распространенной и самой важной из возможностей, обеспечиваемых любой операционной системой, и почти в каждой большой программе хотя бы несколько файлов обязательно подвергаются этому виду обработки. Поэтому простая программа обработки файлов предоставляет прекрасную возможность ознакомиться с Windows и принятыми в ней соглашениями.</p>
     <p>Копирование файлов, нередко осуществляемое совместно с обновлением их содержимого, и слияние отсортированных файлов являются распространенными формами последовательной обработки файлов. Примерами других приложений, осуществляющих последовательный доступ к файлам, могут служить компиляторы и инструментальные средства, предназначенные для обработки текста.</p>
     <p>Несмотря на концептуальную простоту последовательной обработки файлов, эффективная реализация этого процесса, обеспечивающая оптимальную скорость его выполнения, может оказаться нелегкой задачей. Для этого может потребоваться использование перекрывающегося ввода/вывода, отображения файлов, потоков и других дополнительных методов.</p>
     <p>Само по себе копирование файлов не представляет особого интереса, однако сравнение программ не только позволит вам быстро оценить, чем отличаются друг от друга различные системы, но и послужит хорошим предлогом для знакомства с Windows. В последующих примерах реализуется ограниченный вариант одной из команд UNIX — cp, осуществляющей копирование одного файла в другой и требующей задания имен файлов в командной строке. В приведенных программах организована лишь простейшая проверка ошибок, которые могут возникать на стадии выполнения, а существующие файлы просто перезаписываются. Эти и другие недостатки будут учтены в последующих Windows-реализациях этой и других программ. <emphasis>Примечание.</emphasis> Реализация программы для UNIX находится на Web-сайте книги.</p>
    </section>
    <section>
     <title>
      <p>Копирование файлов с использованием стандартной библиотеки С</p>
     </title>
     <p>Как видно из текста программы 1.1, стандартная библиотека С поддерживает объекты потоков ввода/вывода FILE, которые напоминают, несмотря на меньшую общность, объекты Windows HANDLE, представленные в программе 1.2.</p>
     <subtitle>Программа 1.1. срC: копирование файлов с использованием библиотеки С</subtitle>
     <p><code>/* Глава 1. Базовая программа копирования файлов cp. Реализация, использующая библиотеку С. */ </code></p>
     <p><code>/* cp файл1 файл2: Копировать файл1 в файл2. */ </code></p>
     <p><code>#include &lt;stdio.h&gt; </code></p>
     <p><code>#include &lt;errno.h&gt; </code></p>
     <p><code>#define BUF_SIZE 256 </code></p>
     <empty-line/>
     <p><code>int main(int argc, char *argv[]) {</code></p>
     <p><code> FILE *in_file, *out_file;</code></p>
     <p><code> char rec [BUF_SIZE];</code></p>
     <p><code> size_t bytes_in, bytes_out;</code></p>
     <p><code> if (argc != 3) {</code></p>
     <p><code>  printf("Использование: срС файл1 файл2\n");</code></p>
     <p><code>  return 1;</code></p>
     <p><code> }</code></p>
     <p><code> in_file = fopen(argv [1], "rb");</code></p>
     <p><code> if (in_file == NULL) {</code></p>
     <p><code>  perror(argv[1]);</code></p>
     <p><code>  return 2;</code></p>
     <p><code> }</code></p>
     <p><code> out_file = fopen(argv [2], "wb");</code></p>
     <p><code> if (out_file == NULL) {</code></p>
     <p><code>  perror(argv [2]);</code></p>
     <p><code>  return 3;</code></p>
     <p><code> }</code></p>
     <p><code> /* Обработать входной файл по одной записи за один раз. */</code></p>
     <p><code> while ((bytes_in = fread(rec, 1, BUF_SIZE, in_file)) &gt; 0) {</code></p>
     <p><code>  bytes_out = fwrite(rec, 1, bytes_in, out_file);</code></p>
     <p><code>  if (bytes_out != bytes_in) {</code></p>
     <p><code>   perror("Неустранимая ошибка записи.");</code></p>
     <p><code>   return 4;</code></p>
     <p><code>  }</code></p>
     <p><code> }</code></p>
     <p><code> fclose (in_file);</code></p>
     <p><code> fclose (out_file);</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <p>Этот простой пример может служить наглядной иллюстрацией ряда общепринятых допущений и соглашений программирования, которые не всегда применяются в Windows.</p>
     <p>1. Объекты открытых файлов идентифицируются указателями на структуры FILE (в UNIX используются целочисленные дескрипторы файлов). Указателю NULL соответствует несуществующий объект. По сути, указатели являются разновидностью дескрипторов объектов открытых файлов.</p>
     <p>2. В вызове функции fopen указывается, каким образом должен обрабатываться файл — как текстовый или как двоичный. В текстовых файлах содержатся специфические для каждой системы последовательности символов, используемых, например, для обозначения конца строки. Во многих системах, включая Windows, в процессе выполнения операций ввода/вывода каждая из таких последовательностей автоматически преобразуется в нулевой символ, который интерпретируется в языке С как метка конца строки, и наоборот. В нашем примере оба файла открываются как двоичные.</p>
     <p>3. Диагностика ошибок реализуется с помощью функции perror, которая, в свою очередь, получает информацию относительно природы сбоя, возникающего при вызове функции fopen, из глобальной переменной errno. Вместо этого можно было бы воспользоваться функцией ferror, возвращающей код ошибки, ассоциированный не с системой, а с объектом FILE.</p>
     <p>4. Функции fread и fwrite возвращают количество обработанных байтов непосредственно, а не через аргумент, что оказывает существенное влияние на логику организации программы. Неотрицательное возвращаемое значение говорит об успешном выполнении операции чтения, тогда как нулевое — о попытке чтения метки конца файла.</p>
     <p>5. Функция fclose может применяться лишь к объектам типа FILE (аналогичное утверждение справедливо и в отношении дескрипторов файлов UNIX).</p>
     <p>6. Операции ввода/вывода осуществляются в синхронном режиме, то есть прежде чем программа сможет выполняться дальше, она должна дождаться завершения операции ввода/вывода.</p>
     <p>7. Для вывода сообщений об ошибках удобно использовать входящую в библиотеку С функцию ввода/вывода printf, которая даже будет использована в первом примере Windows-программы.</p>
     <p>Преимуществом реализации, использующей библиотеку С, является ее переносимость на платформы UNIX, Windows, а также другие системы, которые поддерживают стандарт ANSI С. Кроме того, как показано в приложении В, в том, что касается производительности, вариант, использующий функции ввода/вывода библиотеки С, ничуть не уступает другим вариантам реализации. Тем не менее, в этом случае программы вынуждены ограничиваться синхронными операциями ввода/вывода, хотя влияние этого ограничения будет несколько ослаблено использованием потоков Windows (начиная с главы 7).</p>
     <p>Как и их эквиваленты в UNIX, программы, основанные на функциях для работы с файлами, входящих в библиотеку С, способны выполнять операции произвольного доступа к файлам (с использованием функции fseek или, в случае текстовых файлов, функций fsetpos и fgetpos), но это является уже потолком сложности для функций ввода/вывода стандартной библиотеки С, выше которого они подняться не могут. Вместе с тем, Visual C++ предоставляет нестандартные расширения, способные, например, поддерживать блокирование файлов. Наконец, библиотека С не позволяет управлять средствами защиты файлов.</p>
     <p>Резюмируя, можно сделать вывод, что если простой синхронный файловый или консольный ввод/вывод — это все, что вам надо, то для написания переносимых программ, которые будут выполняться под управлением Windows, следует использовать библиотеку С.</p>
    </section>
    <section>
     <title>
      <p>Копирование файлов с использованием Windows</p>
     </title>
     <p>В программе 1.2 решается та же задача копирования файлов, но делается это с помощью Windows API, а базовые приемы, стиль и соглашения, иллюстрируемые этой программой, будут использоваться на протяжении всей этой книги.</p>
     <subtitle>Программа 1.2. cpW: копирование файлов с использованием Windows, первая реализация </subtitle>
     <p><code>/* Глава 1. Базовая программа копирования файлов cp. Реализация, использующая Windows. */</code></p>
     <p><code>/* cpW файл1 файл2: Копировать файл1 в файл2. */ </code></p>
     <p><code>#include &lt;windows.h&gt; </code></p>
     <p><code>#include &lt;stdio.h&gt; </code></p>
     <p><code>#define BUF_SIZE 256 </code></p>
     <empty-line/>
     <p><code>int main (int argc, LPTSTR argv []) {</code></p>
     <p><code> HANDLE hIn, hOut;</code></p>
     <p><code> DWORD nIn, nOut;</code></p>
     <p><code> CHAR Buffer [BUF_SIZE];</code></p>
     <p><code> if (argc != 3) {</code></p>
     <p><code>  printf ("Использование: cpW файл1 файл2\n");</code></p>
     <p><code>  return 1;</code></p>
     <p><code> }</code></p>
     <p><code> hIn = CreateFile(argv [1], GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);</code></p>
     <p><code> if (hIn == INVALID_HANDLE_VALUE) {</code></p>
     <p><code>  printf("Невозможно открыть входной файл. Ошибка: %х\n", GetLastError());</code></p>
     <p><code>  return 2;</code></p>
     <p><code> }</code></p>
     <p><code> hOut = CreateFile(argv[2], GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);</code></p>
     <p><code> if (hOut == INVALID_HANDLE_VALUE) {</code></p>
     <p><code>  printf("Невозможно открыть выходной файл. Ошибка: %x\n", GetLastError()); </code></p>
     <p><code>  return 3;</code></p>
     <p><code> }</code></p>
     <p><code> while (ReadFile(hIn, Buffer, BUF_SIZE, &amp;nIn, NULL) &amp;&amp; nIn &gt; 0) {</code></p>
     <p><code>  WriteFile(hOut, Buffer, nIn, &amp;nOut, NULL);</code></p>
     <p><code>  if (nIn != nOut) {</code></p>
     <p><code>   printf ("Неустранимая ошибка записи: %x\n", GetLastError());</code></p>
     <p><code>   return 4;</code></p>
     <p><code>  }</code></p>
     <p><code> }</code></p>
     <p><code> CloseHandle(hIn);</code></p>
     <p><code> CloseHandle(hOut);</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <p>Этот простой пример иллюстрирует некоторые особенности программирования в среде Windows, к подробному рассмотрению которых мы приступим в главе 2.</p>
     <p>1. В программу всегда включается файл &lt;windows.h&gt;, в котором содержатся все необходимые определения функций и типов данных Windows.<a l:href="#n_10" type="note">[10]</a></p>
     <p>2. Все объекты Windows идентифицируются переменными типа Handle, причем для большинства объектов можно использовать одну и ту же общую функцию CloseHandle.</p>
     <p>3. Рекомендуется закрывать все ранее открытые дескрипторы, если в необходимость в них отпала, чтобы освободить ресурсы. В то же время, при завершении процессов относящиеся к ним дескрипторы автоматически закрываются ОС, и если не остается ни одного дескриптора, ссылающегося на какой-либо объект, то ОС уничтожает этот объект и освобождает соответствующие ресурсы. <emphasis>(Примечание.</emphasis> Как правило, файлы подобным способом не уничтожаются.)</p>
     <p>4. Windows определяет многочисленные символические константы и флаги. Обычно они имеют длинные имена, нередко поясняющие назначение данного объекта. В качестве типичного примера можно привести имена INVALID_HANDLE_VALUE и GENERIC_READ.</p>
     <p>5. Функции ReadFile и WriteFile возвращают булевские значения, а не количества обработанных байтов, для передачи которых используются аргументы функций. Это определенным образом изменяет логику организации работы циклов.<a l:href="#n_11" type="note">[11]</a> Нулевое значение счетчика байтов указывает на попытку чтения метки конца файла и не считается ошибкой.</p>
     <p>6. Функция GetLastError позволяет получать в любой точке программы коды системных ошибок, представляемые значениями типа DWORD. В программе 1.2 показано, как организовать вывод генерируемых Windows текстовых сообщений об ошибках.</p>
     <p>7. Windows NT обладает более мощной системой защиты файлов, описанной в главе 15. В данном примере защита выходного файла не обеспечивается.</p>
     <p>8. Такие функции, как CreateFile, обладают богатым набором дополнительных параметров, но в данном примере использованы значения по умолчанию.</p>
    </section>
    <section>
     <title>
      <p>Копирование файлов с использованием вспомогательной функции Windows</p>
     </title>
     <p>Для повышения удобства работы в Windows предусмотрено множество вспомогательных функций (convenience functions), которые, объединяя в себе несколько других функций, обеспечивают выполнение часто встречающихся задач программирования. В некоторых случаях использование этих функций может приводить к повышению производительности (см. приложение В). Например, благодаря применению функции CopyFile значительно упрощается программа копирования файлов (программа 1.3). Помимо всего прочего, это избавляет нас от необходимости заботиться о буфере, размер которого в двух предыдущих программах произвольно устанавливался равным 256.</p>
     <subtitle>Программа1.3.cpCF: копирование файлов с использованием вспомогательной функции Windows</subtitle>
     <p><code>/* Глава 1. Базовая программа копирования файлов cp. Реализация, в которой для повышения удобства использования и производительности программы используется функция Windows CopyFile. */</code></p>
     <p><code>/* cpCF файл1 файл2: Копировать файл1 в файл2. */</code></p>
     <p><code>#include &lt;windows.h&gt; </code></p>
     <p><code>#include &lt;stdio.h&gt;</code></p>
     <empty-line/>
     <p><code>int main (int argc, LPTSTR argv []) {</code></p>
     <p><code> if (argc != 3) {</code></p>
     <p><code>  printf ("Использование: cpCF файл1 файл2\n");</code></p>
     <p><code>  return 1;</code></p>
     <p><code> }</code></p>
     <p><code> if (!CopyFile(argv[1], argv[2], FALSE)) {</code></p>
     <p><code>  printf("Ошибка при выполнении функции CopyFile: %x\n", GetLastError());</code></p>
     <p><code>  return 2;</code></p>
     <p><code> }</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code> </p>
    </section>
   </section>
   <section>
    <title>
     <p>Резюме</p>
    </title>
    <section>
     <p>Ознакомительные примеры, в качестве которых были использованы три простые программы копирования файлов, демонстрируют многие из отличий, существующих между программами, в которых применяется с одной стороны библиотека С, а с другой — Windows. Отличия в производительности различных вариантов реализации анализируются в приложении В. Примеры, в которых используется Windows, наглядно демонстрируют стиль программирования и некоторые соглашения, принятые в Windows, но дают лишь отдаленное представление о тех функциональных возможностях, которые Windows предлагает программистам.</p>
     <p>Целевыми платформами для данной книги и содержащихся в ней примеров являются системы NT5 (Windows XP, 2000 и Server 2003). Тем не менее, большая часть материала книги применима также к ранним версиям NT и системам Windows 9x (95, 98 и Me).</p>
    </section>
    <section>
     <title>
      <p>В следующих главах</p>
     </title>
     <p>Главы 2 и 3 посвящены гораздо более пристальному рассмотрению функций ввода/вывода и файловой системы. Они включают в себя такие темы, как консольный ввод/вывод, обработка символов ASCII и Unicode, работа с файлами и каталогами, а также программирование реестра. В указанных главах разрабатываются базовые методики и закладывается фундамент для остальной части книги.</p>
    </section>
    <section>
     <title>
      <p>Дополнительная литература</p>
     </title>
     <p>Полная информация о рекомендуемых ниже книгах приведена в библиографическом списке в конце книги.</p>
     <subtitle><emphasis>Win32</emphasis></subtitle>
     <p>Двумя доступными в настоящее время книгами, в которых вопросы программирования для Windows рассматриваются с всех возможных точек зрения, являются [5] и [31]. В то же время, существует множество других книг, которые не обновлялись и не отражают прогресс, достигнутый с момента выхода Windows 95 или Windows NT.</p>
     <p>По каждой функции Microsoft Visual C++ имеется оперативная гипертекстовая справочная документация, но ту же информацию можно получить, посетив домашнюю страницу компании Microsoft — http://www.microsoft.com, где вы найдете целый ряд ссылок на технические статьи, посвященные различным аспектам Windows. Начните с раздела MSDN (Microsoft Developer's Network) и произведите поиск по любой интересующей вас теме. Вы обнаружите огромное разнообразие официальной документации, описаний продуктов, примеров программного кода, а также другую полезную информацию.</p>
     <subtitle><emphasis>Win64</emphasis></subtitle>
     <p>Win64 обсуждается в нескольких книгах, но обширный материал по этой теме можно найти на домашней странице компании Microsoft. </p>
     <subtitle><emphasis>Архитектура Windows NT и история ее развития</emphasis></subtitle>
     <p>Читателям, которые хотят больше узнать о целях проектирования Windows NT или понять основные принципы, лежащие в основе ее архитектуры, будет полезна книга [38]. В этой книге рассматриваются объекты, процессы, потоки, виртуальная память, ядро и подсистемы ввода/вывода. Вместе с тем, собственно функции API, а также Windows 9x и СЕ в ней не обсуждаются. Рекомендуем время от времени заглядывать в упомянутую книгу для получения дополнительной информации. Кроме того, обратитесь к ранее вышедшим книгам [9] и [37], в которых содержится важный ретроспективный анализ эволюции NT.</p>
     <subtitle><emphasis>UNIX</emphasis></subtitle>
     <p>В книге [40], написанной ныне покойным Уильямом Ричардом Стивенсом (W. Richard Stevens), UNIX обсуждается во многом в тех же терминах, которые в настоящей книге используются для обсуждения Windows. Книга Стивенса по-прежнему остается стандартным справочником по средствам UNIX, но в ней не рассматриваются потоки. Стандартизация UNIX претерпела изменения, однако в книге Стивенса содержатся удобные рабочие определения всего того, что предлагается в UNIX, а также в Linux. В этой книге сопоставлены возможности функций файлового ввода/вывода библиотеки С и функций ввода/вывода системы UNIX, что имеет отношение и к Windows.</p>
     <p>Если вас интересуют сравнительные характеристики ОС и более глубокое обсуждение UNIX, обратитесь к книге [29] и ее русскоязычному изданию [49], которая помимо того, что является весьма полезной, еще и увлекательно написана, хотя некоторым читателям позиция автора может показаться несколько предвзятой.</p>
     <subtitle><emphasis>Программирование с использованием Windows GUI</emphasis></subtitle>
     <p>Пользовательский интерфейс в настоящей книге не рассматривается. В случае необходимости можете обратиться к [30] или [25].</p>
     <subtitle><emphasis>Теория операционных систем</emphasis></subtitle>
     <p>Существует масса хороших учебников по общей теории ОС. Одной из наиболее популярных является книга [35].</p>
     <subtitle><emphasis>Стандартная библиотека ANSI С</emphasis></subtitle>
     <p>Исчерпывающим руководством по этой теме служит книга [27]. Для получения беглого обзора можно обратиться к книге [20] или к ее русскоязычному изданию [48], которая содержит полное описание библиотеки и остается классическим учебником по языку программирования С. Эти книги помогут вам принять решение относительно того, достаточно ли возможностей библиотеки С для решения стоящих перед вами задач обработки файлов.</p>
     <subtitle><emphasis>Windows СЕ</emphasis></subtitle>
     <p>Тем, кто хочет применить материал настоящей книги к Windows СЕ, можно порекомендовать книгу [23].</p>
     <subtitle><emphasis>Эмуляция Windows в UNIX</emphasis></subtitle>
     <p>Для получения необходимой информации по этому вопросу и загрузки пакета с открытым исходным кодом Wine, позволяющего эмулировать Windows API поверх UNIX и X, посетите сайт http://www.winehq.com.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Упражнения</p>
    </title>
    <p>1.1. Скомпилируйте, скомпонуйте и выполните каждую из трех программ, предназначенных для копирования файлов. К числу других возможных вариантов реализации относится использование библиотек совместимости с UNIX, включая библиотеку Microsoft Visual C++ (программа, использующая эту библиотеку, доступна на Web-сайте книги). <emphasis>Примечание.</emphasis> На Web-сайте книги на ходятся исходные коды всех программ. Краткие рекомендации относительно порядка использования этих кодов в средах Microsoft Visual Studio .NET и Microsoft Visual C++ 6.0 вы найдете в приложении А.</p>
    <p>1.2. Ознакомьтесь с одной из сред разработки приложений, например, Microsoft Visual Studio .NET или Microsoft Visual C++. В частности, научитесь создавать в выбранной среде консольные приложения. Для проведения самостоятельных экспериментов с использованием рассмотренных в данной главе программ пользуйтесь отладчиком. Инструкции относительно того, как следует приступать к работе, содержатся в приложении А, а обширную дополнительную информацию вы найдете на Web-сайте компании Microsoft и в документации к используемой вами среде разработки приложений.</p>
    <p>1.3. В Windows в качестве метки конца строки используется последовательность символов "возврат каретки-перевод строки" (CR-LF). Определите, как изменится поведение программы 1.1, если входной файл открывать в двоичном режиме, а выходной — в текстовом, или наоборот. Как это будет проявляться в системе UNIX и в других системах?</p>
    <p>1.4. Выполните для каждой из программ хронометраж при копировании файлов большого размера. Получите соответствующие данные для как можно большего числа различных вариантов и сравните полученные результаты между собой. Вряд ли следует подчеркивать, что быстродействие программ зависит от множества факторов, однако, в предположении, что все остальные параметры системы остаются неизменными, сопоставление результатов, полученных с использованием различных вариантов реализации программы, может представлять определенную ценность. <emphasis>Совет.</emphasis> Для облегчения анализа результатов расположите их в виде таблицы. Программа, обеспечивающая количественный контроль длительности временных промежутков, приведе на в главе 6, а некоторые экспериментальные результаты представлены в приложении В.</p>
   </section>
  </section>
  <section>
   <title>
    <p>ГЛАВА 2</p>
    <p>Использование файловой системы и функций символьного ввода/вывода Windows</p>
   </title>
   <section>
    <p>Нередко самыми первыми средствами операционной системы (ОС), с которыми разработчик сталкивается в любой системе, являются файловая система и простой терминальный ввод/вывод. Ранние ОС для PC, такие как MS-DOS, не могли дать ничего больше, кроме возможностей работы с файлами и терминального (или <emphasis>консольного)</emphasis> ввода/вывода, но эти же ресурсы и сейчас занимают центральное место почти в любой ОС.</p>
    <p>Файлы играют очень важную роль в организации долговременного хранения данных и программ и обеспечивают простейшую форму межпрограммного взаимодействия. Помимо этого, многие аспекты файловых систем оказываются применимыми также к взаимодействию между процессами и сетям.</p>
    <p>На примере программ копирования файлов, которые рассматривались в главе 1, вы уже познакомились с четырьмя важными функциями, обеспечивающими последовательную обработку файлов: </p>
    <p><code>CreateFile </code></p>
    <p><code>ReadFile </code></p>
    <p><code>WriteFile </code></p>
    <p><code>CloseHandle</code></p>
    <p>В данной главе не только подробно описываются эти и родственные им функции, но и обсуждаются функции, предназначенные для обработки символов и обеспечения консольного ввода/вывода. Сначала будут кратко охарактеризованы существующие типы файловых систем и их основные свойства. Далее будет показано, каким образом введение расширенной формы символов в кодировке Unicode помогает приложениям справиться с проблемой поддержки национальных языков. Главу завершает введение в управление файлами и каталогами в Windows.</p>
   </section>
   <section>
    <title>
     <p>Файловые системы Windows</p>
    </title>
    <p>Windows поддерживает на непосредственно подключенных устройствах файловые системы четырех типов, но только первый из них будет иметь для нас существенное значение на протяжении всей книги, поскольку именно полнофункциональная файловая система этого типа рекомендуется компанией Microsoft для использования в качестве основной:</p>
    <p>1. Файловая система <emphasis>NT</emphasis> (NTFS) — современная файловая система, которая поддерживает длинные имена файлов, а также безопасность, устойчивость к сбоям, шифрование, сжатие, расширенные атрибуты, и позволяет работать с очень большими файлами и объемами данных. Заметьте, что на гибких дисках (флоппи-дисках, или дискетах) система NTFS использоваться не может; не поддерживается она и системами Windows 9x.</p>
    <p>2. Файловые системы <emphasis>FAT</emphasis> и <emphasis>FAT32</emphasis> (от <emphasis>File Allocation Table</emphasis> — таблица размещения файлов) происходят от 16-разрядной файловой системы (FAT16), первоначально использовавшейся в MS-DOS и Windows 3.1. FAT32 впервые была введена в Windows 98 для поддержки жестких дисков большого объема и других усовершенствованных возможностей; далее под термином FAT мы будем подразумевать любую из вышеуказанных версий. FAT является единственно доступной файловой системой для дисков (но не компакт-дисков), работающих под управлением Windows 9x, а также гибких дисков. Разновидностью FAT является TFAT — ориентированная на поддержку механизма транзакций версия, используемая в Windows СЕ. Постепенно FAT выходит из употребления и в большинстве случаев ее можно встретить лишь на устаревших системах, особенно тех, обновление которых после первоначальной установки на них Windows 9x выполнялось без преобразования типа существующей файловой системы.</p>
    <p>3. Файловая система <emphasis>компакт-дисков</emphasis> (CDFS), как говорит само ее название, предназначена для доступа к информации, записанной на компакт-дисках. CDFS удовлетворяет требованиям стандарта ISO 9660.</p>
    <p>4. <emphasis>Универсальный дисковый формат</emphasis> (Universal Disk Format, UDF) поддерживает диски DVD и, в конечном итоге, должен полностью вытеснить систему CDFS. Поддержка UDF в Windows XP поддерживает как чтение, так и запись файлов, тогда как в Windows 2000 для UDF обеспечивается только запись.</p>
    <p>Windows поддерживает, причем как на стороне клиента, так и на стороне сервера, такие распределенные файловые системы, как Networked File System (Сетевая файловая система), или NFS, и Common Internet File System (Общая межсетевая файловая система), или CIFS; на серверах обычно используют NTFS. В Windows 2000 и Windows Server 2003 обеспечивается широкая поддержка сетевых хранилищ данных (Storage Area Networks, SAN) и таких развивающихся технологий хранения данных, как IP-хранилища. Кроме того, Windows дает возможность разрабатывать пользовательские файловые системы, которые поддерживают тот же API доступа к файлам, что и API, рассматриваемый в этой и следующей главах.</p>
    <p>Доступ к файловым системам любого типа осуществляется одинаковым образом, иногда с некоторыми ограничениями. Например, поддержка защиты файлов обеспечивается только в NTFS. В необходимых случаях мы будем обращать ваше внимание на особенности, присущие только NTFS, но в этой книге, как правило, будет предполагаться использование именно этой системы.</p>
    <p>Формат файловой системы (FAT, NTFS или пользовательской), будь то для диска в целом, или для его разделов, определяется во время разбивки диска на разделы.</p>
   </section>
   <section>
    <title>
     <p>Правила именования файлов</p>
    </title>
    <p>Windows поддерживает обычную иерархическую систему имен файлов, соглашения которой, однако, несколько отличаются от соглашений, привычных для пользователей UNIX, и основаны на следующих правилах:</p>
    <p>• Полное имя файла на диске, содержащее путь доступа к нему, начинается с указания буквенного имени диска, например, А: или С:. Обычно буквы А: и В: относятся к флоппи-дисководам, а С:, D: и так далее — к жестким дискам и приводам компакт-дисков. Последующие буквы алфавита, например, Н: или K:, обычно соответствуют сетевым дискам. <emphasis>Примечание.</emphasis> Буквенные обозначения дисков не поддерживаются в Windows СЕ.</p>
    <p>• Существует и другой возможный вариант задания полного пути доступа — использование универсальной кодировки имен (Universal Naming Code, UNC), в соответствии с которой указание пути начинается с глобального корневого каталога, обозначаемого двумя символами обратной косой черты (\\), с последующим указанием имени сервера и <emphasis>имени разделяемого ресурса</emphasis> (share name) для определения местоположения ресурса на файловом сервере сети. Таким образом, первая часть полного пути доступа в данном случае будет иметь вид: \\servername\sharename.</p>
    <p>• При указании полного пути доступа в качестве <emphasis>разделителя</emphasis> обычно используется символ обратной косой черты (\), но в параметрах API для этой цели можно воспользоваться также символом прямой косой черты (/), как это принято в С.</p>
    <p>• В именах каталогов и файлов не должны встречаться символы ASCII, численные значения которых попадают в интервал 1-31, а также любой из перечисленных ниже символов:</p>
    <p><code>&lt; &gt; : " | ? * \ /</code></p>
    <p>В именах разрешается использовать пробелы. В то же время, если имена файлов, содержащие пробелы, указываются в командной строке, то каждое такое имя следует заключать в кавычки, чтобы его нельзя было интерпретировать как два разных имени, относящихся к двум отдельным файлам.</p>
    <p>• Строчные и прописные буквы в именах каталогов и файлов не различаются, то есть имена <emphasis>не чувствительны к регистру</emphasis> (case-insensitive), но в то же время они <emphasis>запоминают регистр</emphasis> (case-retaining); другими словами, если файл был создан с именем MyFile, то это же имя будет использоваться и при его отображении, хотя, например, для доступа к файлу может быть использовано также имя myFILE.</p>
    <p>• Длина имени каталога и файла не должна превышать 255 символов, а длина полного пути доступа ограничивается значением параметра МАХ_РАТН (текущим значением которого является 256).</p>
    <p>• Для отделения имени файла от расширения используется символ точки (.), причем расширения имен (как правило, два или три символа, находящиеся справа от самой последней точки, входящей в имя файла) обозначают предположительные типы файлов в соответствии с определенными соглашениями. Так, можно ожидать, что файл atou.EXE — это исполняемый файл, а файл atou.С — файл с исходным текстом программы на языке С. Допускается использование в именах файлов нескольких символов точки.</p>
    <p>• Одиночный символ точки (.) и два символа точки (..), используемые в качестве имен каталогов, обозначают, соответственно, текущий каталог и его родительский каталог.</p>
    <p>После этого вступления мы можем продолжить изучение функций Windows, начатое в главе 1.</p>
   </section>
   <section>
    <title>
     <p>Операции открытия, чтения, записи и закрытияфайлов</p>
    </title>
    <section>
     <p>Первой функцией Windows, которую мы подробно опишем, является функция CreateFile, используемая как для создания новых, так и для открытия существующих файлов. Для этой функции, как и для всех остальных, сначала приводится прототип, а затем обсуждаются соответствующие параметры и порядок работы с ней.</p>
    </section>
    <section>
     <title>
      <p>Создание и открытие файла</p>
     </title>
     <p>Поскольку данная функция является первой из функций Windows, к изучению которых мы приступаем, ее описание будет несколько более подробным по сравнению с остальными; для других функций часто будут приводиться лишь краткие описания. Вместе с тем, даже в случае функции CreateFile будут описаны далеко не все из возможных многочисленных значений ее параметров, однако необходимые дополнительные сведения вы всегда сможете найти в оперативной справочной системе.</p>
     <p>Простейшее использование функции CreateFile иллюстрирует приведенный в главе 1 пример ознакомительной Windows-программы (программа 1.2), содержащей два вызова функций, в которых для параметров dwShareMode, lpSecurityAttributes и hTemplateFile были использованы значения по умолчанию. Параметр dwAccess может принимать значения GENERIC_READ и GENERIC_WRITE.</p>
     <cite>
      <p><code>HANDLE CreateFile(LPCTSTR lpName, DWORD dwAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreate, DWORD dwAttrsAndFlags, HANDLE hTemplateFile)</code></p>
      <p><strong>Возвращаемое значение</strong>: в случае успешного выполнения — дескриптор открытого файла (типа HANDLE), иначе — INVALID_HANDLE_VALUE.</p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>Имена параметров иллюстрируют некоторые соглашения Windows. Префикс dw используется в именах параметров типа DWORD (32-битовые целые без знака), в которых могут храниться флаги или числовые значения, например счетчики, тогда как префикс lpsz (длинный указатель на строку, завершающуюся нулем), или в упрощенной форме — lр, используется для строк, содержащих пути доступа, либо иных строковых значений, хотя документация Microsoft в этом отношении не всегда последовательна. В некоторых случаях для правильного определения типа данных вам придется обратиться к здравому смыслу или внимательно прочесть документацию.</p>
     <p>lpName — указатель на строку с завершающим нулевым символом, содержащую имя файла, канала или любого другого именованного объекта, который необходимо открыть или создать. Допустимое количество символов при указании путей доступа обычно ограничивается значением МАХ_РАТН (260), однако в Windows NT это ограничение можно обойти, поместив перед именем префикс \\?\, что обеспечивает возможность использования очень длинных имен (с числом символов вплоть до 32 К). Сам префикс в имя не входит. О типе данных LPCTSTR говорится в одном из последующих разделов, а пока вам будет достаточно знать, что он относится к строковым данным.</p>
     <p>dwAccess — определяет тип доступа к файлу — чтение или запись, что соответственно указывается флагами GENERIC_READ и GENERIC_WRITE. Ввиду отсутствия флаговых значений READ и WRITE использование префикса GENERIC_ может показаться излишним, однако он необходим для совместимости с именами макросов, определенных в заголовочном файле Windows WINNT.H. Вы еще неоднократно столкнетесь с именами, которые кажутся длиннее, чем необходимо. </p>
     <p>Указанные значения можно объединять операцией поразрядного "или" (|), и тогда для получения доступа к файлу как по чтению, так и по записи, следует воспользоваться таким выражением:</p>
     <p><code>GENERIC_READ | GENERIC_WRITE</code></p>
     <p>dwShareMode — может объединять с помощью операции поразрядного "или" следующие значения:</p>
     <p>• 0 — запрещает разделение (совместное использование) файла. Более того, открытие второго дескриптора для данного файла запрещено даже в рамках одного и того же вызывающего процесса.</p>
     <p>• FILE_SHARE_READ — другим процессам, включая и тот, который осуществил данный вызов функции, разрешается открывать этот файл для параллельного доступа по чтению.</p>
     <p>• FILE_SHARE_WRITE — разрешает параллельную запись в файл.</p>
     <p>Используя блокирование файла или иные механизмы, программист должен самостоятельно позаботиться об обработке ситуаций, в которых осуществляются одновременно несколько попыток записи в одно и то же место в файле. Более подробно этот вопрос рассматривается в главе 3.</p>
     <p>lpSecurityAttributes — указывает на структуру SECURITY_ATTRIBUTES. На первых порах при вызовах функции CreateFile и всех остальных функций вам будет достаточно использовать значение NULL; вопросы безопасности файловой системы рассматриваются в главе 15.</p>
     <p>dwCreate — конкретизирует запрашиваемую операцию: создать новый файл, перезаписать существующий файл и тому подобное. Может принимать одно из приведенных ниже значений, которые могут объединяться при помощи операции поразрядного "или" языка С.</p>
     <p>• CREATE_NEW — создать новый файл; если указанный файл уже существует, выполнение функции завершается неудачей.</p>
     <p>• CREATE_ALWAYS — создать новый файл; если указанный файл уже существует, функция перезапишет его.</p>
     <p>• OPEN_EXISTING — открыть файл; если указанный файл не существует, выполнение функции завершается неудачей.</p>
     <p>• OPEN_ALWAYS — открыть файл; если указанный файл не существует, функция создаст его.</p>
     <p>• TRUNCATE_EXISTING — открыть файл; размер файла будет установлен равным нулю. Уровень доступа к файлу, установленный параметром dwAccess, должен быть не ниже GENERIC_WRITE. Если указанный файл существует, его содержимое будет уничтожено. В отличие от случая CREATENEW выполнение функции будет успешным даже в тех случаях, когда указанный файл не существует. </p>
     <p>dwAttrsAndFlags — позволяет указать атрибуты файла и флаги. Всего имеется 16 флагов и атрибутов. Атрибуты являются характеристиками файла, а не открытого дескриптора, и игнорируются, если открывается существующий файл. Некоторые из наиболее важных флаговых значений приводятся ниже.</p>
     <p>• FILE_ATTRIBUTE_NORMAL — этот атрибут можно использовать лишь при условии, что одновременно с ним не устанавливаются никакие другие атрибуты (тогда как для всех остальных флагов одновременная установка допускается).</p>
     <p>• FILE_ATTRIBUTE_READONLY — этот атрибут запрещает приложениям осуществлять запись в данный файл или удалять его.</p>
     <p>• FILE_FLAG_DELETE_ON_CLOSE — этот флаг полезно применять в случае временных файлов. Файл будет удален сразу же после закрытия последнего из его открытых дескрипторов.</p>
     <p>• FILE_FLAG_OVERLAPPED — этот флаг играет важную роль при выполнении операций асинхронного ввода/вывода, описанных в главе 14.</p>
     <p>Кроме того, существует несколько дополнительных флагов, позволяющих уточнить способ обработки файла и облегчить реализации Windows оптимизацию производительности и обеспечение целостности файлов.</p>
     <p>• FILE_FLAG_WRITE_THROUGH — устанавливает режим сквозной записи промежуточных данных непосредственно в файл на диске, минуя кэш.</p>
     <p>• FILE_FLAG_NO_BUFFERING — устанавливает режим отсутствия промежуточi ной буферизации или кэширования, при котором обмен данными происходит непосредственно с буферами данных программы, указанными при вызове функций ReadFile или WriteFile (описаны далее). Соответственно требуется, чтобы начала программных буферов совпадали с границами секторов, а их размеры были кратными размеру сектора тома. Чтобы определить размер сектора при указании этого флага, вы можете воспользоваться функцией GetDiskFreeSpace.</p>
     <p>• FILE_FLAG_RANDOM_ACCESS — предполагается открытие файла для произвольного доступа; Windows будет пытаться оптимизировать кэширование файла применительно к этому виду доступа.</p>
     <p>• FILE_FLAG_SEQUENTIAL_SCAN — предполагается открытие файла для последовательного доступа; Windows будет пытаться оптимизировать кэширование файла применительно к этому виду доступа. Оба последних режима реализуются системой лишь по мере возможностей.</p>
     <p>hTemplateFile — дескриптор с правами доступа GENERIC_READ к шаблону файла, предоставляющему расширенные атрибуты, которые будут применены к создаваемому файлу вместо атрибутов, указанных в параметре dwAttrsAndFlags. Обычно значение этого параметра устанавливается равным NULL. При открытии существующего файла параметр hTemplateFile игнорируется. Этот параметр используется в тех случаях, когда требуется, чтобы атрибуты вновь создаваемого файла совпадали с атрибутами уже существующего файла.</p>
     <p>Оба вызова функции CreateFile в программе 1.2 максимально упрощены за счет использования для параметров значений по умолчанию, и, тем не менее, они вполне справляются со своими задачами. В обоих случаях было бы целесообразно использовать флаг FILE_FLAG_SEQUENTIAL_SCAN. (Эта возможность исследуется в упражнении 2.3, а соответствующие результаты тестирования производительности приведены в приложении В.)</p>
     <p>Заметьте, что для данного файла могут быть одновременно открыты несколько дескрипторов, если только это разрешается атрибутами совместного доступа и защиты файла. Открытые дескрипторы могут принадлежать одному и тому же или различным процессам. (Управление процессами описано в главе 6).</p>
     <p>В Windows Server 2003 предоставляется функция ReOpenFile, которая возвращает новый дескриптор с иными флагами, правами доступа и прочим, нежели те, которые были указаны при первоначальном открытии файла, если только это не приводит к возникновению конфликта между новыми и прежними правами доступа.</p>
    </section>
    <section>
     <title>
      <p>Закрытие файла</p>
     </title>
     <p>Для закрытия объектов любого типа, объявления недействительными их дескрипторов и освобождения системных ресурсов почти во всех случаях используется одна и та же универсальная функция. Исключения из этого правила будут оговариваться отдельно. Закрытие дескриптора сопровождается уменьшением на единицу счетчика ссылок на объект, что делает возможным удаление таких не хранимых постоянно (nonpersistent) объектов, как временные файлы или события. При выходе из программы система автоматически закрывает все открытые дескрипторы, однако лучше все же, чтобы программа самостоятельно закрывала свои дескрипторы перед тем, как завершить работу.</p>
     <p>Попытки закрытия недействительных дескрипторов или повторного закрытия одного и того же дескриптора приводят к исключениям (исключения и обработка исключений обсуждаются в главе 4). Не только излишне, но и не следует закрывать дескрипторы стандартных устройств, которые обсуждаются в разделе "Стандартные устройства и консольный ввод/вывод" далее в этой главе. </p>
     <cite>
      <p><code>BOOL CloseHandle(HANDLE hObject)</code></p>
      <p><strong>Возвращаемое значение</strong>: в случае успешного выполнения функции — TRUE, иначе — FALSE. </p>
     </cite>
     <p>Функции UNIX, сопоставимые с рассмотренными выше, отличаются от них в нескольких отношениях. Функция (системный вызов) UNIX open возвращает целочисленный дескриптор (descriptor) файла, а не дескриптор типа HANDLE, причем для указания всех параметров доступа, разделения и создания файлов, а также атрибутов и флагов используется единственный целочисленный параметр oflag. Возможные варианты выбора, доступные в обеих системах, перекрываются, однако набор опций, предлагаемый Windows, отличается большим разнообразием.</p>
     <p>В UNIX отсутствует параметр, эквивалентный параметру dwShareMode. Файлы UNIX всегда являются разделяемыми.</p>
     <p>В обеих системах при создании файла используется информация, касающаяся его защиты. В UNIX для задания хорошо известных разрешений на доступ к файлу для владельца, членов группы и прочих пользователей используется аргумент mode.</p>
     <p>Функция close, хотя ее и можно сопоставить с функцией CloseHandle, отличается от последней меньшей универсальностью.</p>
     <p>Функции библиотеки С, описанные в заголовочном файле &lt;stdio.h&gt;, используют объекты FILE, которые можно поставить в соответствие дескрипторам (дисковые файлы, терминалы, ленточные устройства и тому подобные), связанным с потоками. Параметр mode функции fopen позволяет указать, должны ли содержащиеся в файле данные обрабатываться как двоичные или как текстовые. Имеются также опции открытия файла в режиме "только чтение", обновления файла, присоединения к другому файлу и так далее. Функция freopen обеспечивает возможность повторного использования объектов FILE без их предварительного закрытия. Средства для задания параметров защиты стандартной библиотекой С не предоставляются.</p>
     <p>Для закрытия объектов типа FILE предназначена функция fclose. Имена большинства функций стандартной библиотеки С, предназначенных для работы с объектами FILE, снабжены префиксом "f".</p>
    </section>
    <section>
     <title>
      <p>Чтение файла </p>
     </title>
     <cite>
      <p><code>BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)</code></p>
      <p><strong>Возвращаемое значение: </strong>в случае успешного выполнения (которое считается таковым, даже если не был считан ни один байт из-за попытки чтения с выходом за пределы файла) — TRUE, иначе — FALSE. </p>
     </cite>
     <p>Вплоть до главы 14 мы будем предполагать, что дескрипторы файлов создаются <emphasis>без </emphasis>указания флага перекрывающегося ввода/вывода FILE_FLAG_OVERLAPPED в параметре dwAttrsAndFlags. В этом случае функция ReadFile начинает чтение с текущей позиции указателя файла, и указатель файла сдвигается на число считанных байтов.</p>
     <p>Если значения дескриптора файла или иных параметров, используемых при вызове функции, оказались недействительными, возникает ошибка, и функция возвращает значение FALSE. Попытка выполнения чтения в ситуациях, когда указатель файла позиционирован в конце файла, не приводит к ошибке; вместо этого количество считанных байтов (*lpNumberOfBytesRead) устанавливается равным 0.</p>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>Описательные имена переменных и естественный порядок расположения параметров во многом говорят сами за себя. Тем не менее, ниже приводятся некоторые краткие пояснения.</p>
     <p>hFile — дескриптор считываемого файла, который должен быть создан с правами доступа GENERIC_READ. lpBuffer является указателем на буфер в памяти, куда помещаются считываемые данные. nNumberOfBytesToRead — количество байт, которые должны быть считаны из файла.</p>
     <p>lpNumberOfBytesRead — указатель на переменную, предназначенную для хранения числа байт, которые были фактически считаны в результате вызова функции ReadFile. Этот параметр может принимать нулевое значение, если перед выполнением чтения указатель файла был позиционирован в конце файла или если во время чтения возникли ошибки, а также после чтения из именованного канала, работающего в режиме обмена сообщениями (глава 11), если переданное сообщение имеет нулевую длину.</p>
     <p>lpOverlapped — указатель на структуру OVERLAPPED (главы 3 и 14). На данном этапе просто устанавливайте значение этого параметра равным NULL.</p>
    </section>
    <section>
     <title>
      <p>Запись в файл </p>
     </title>
     <cite>
      <p><code>BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)</code></p>
      <p><strong>Возвращаемое значение</strong>: в случае успешного выполнения — TRUE, иначе — FALSE.</p>
     </cite>
     <p>Все параметры этой функции вам уже знакомы. Заметьте, что успешное выполнение записи еще не говорит о том, что данные действительно оказались записанными на диск, если только при создании файла с помощью функции CreateFile не был использован флаг FILE_FLAG_WRITE_THROUGH. Если во время вызова функции указатель файла был позиционирован в конце файла, Windows увеличит длину существующего файла.</p>
     <p>Функции ReadFileGather и WriteFileGather позволяют выполнять операции чтения и записи с использованием набора буферов различного размера. </p>
     <cite>
      <p>Сопоставимыми функциями UNIX являются функции read и write, которым программист в качестве параметров должен предоставлять дескриптор файла, буфер и счетчик байтов. Возвращаемые значения этих функций указывают на количество фактически переданных байтов. Возврат функцией read значения 0 означает чтение конца файла, а значения –1 — возникновение ошибки. В противоположность этому в Windows для подсчета количества переданных байтов используется отдельный счетчик, а на успех или неудачу выполнения функции указывает возвращаемое ею булевское значение.</p>
      <p>В обеих системах функции имеют сходное назначение и могут выполнять соответствующие операции с использованием файлов, терминалов, ленточных устройств, каналов и так далее.</p>
      <p>Входящие в состав стандартной библиотеки С функции read и fwrite, выполняющие операции ввода/вывода в двоичном режиме, вместо счетчика одиночных байтов, как в UNIX и Windows, используют размер объекта и счетчик объектов. Преждевременное прекращение передачи данных может быть вызвано как достижением конца файла, так и возникновением ошибки; точная причина устанавливается с использованием функций feof или ferror. Библиотека предоставляет полный набор функций, ориентированных на работу с текстовыми файлами, таких как fgets или fputs, для которых в каждой из рассматриваемых ОС аналоги вне библиотеки С отсутствуют.</p>
     </cite>
    </section>
   </section>
   <section>
    <title>
     <p>Вступление: стандартные символы и символы Unicode</p>
    </title>
    <section>
     <p>Прежде чем двигаться дальше, необходимо кратко объяснить, как Windows обрабатывает символы и различает 8-битовые, 16-битовые и обобщенные символы. Эта тема весьма обширна и выходит за рамки данной книги, поэтому мы не будем выделять ее обсуждение в отдельную главу и ограничимся приведением лишь самых необходимых сведений в минимальном объеме.</p>
     <p>Windows поддерживает стандартные 8-битовые символы (типы char или CHAR) и (исключая Windows 9x) 16-битовые символы расширенной формы (тип WCHAR, определенный в библиотеке С как wchar_t). В документации Microsoft 8-битовый набор фигурирует как символьный набор ASCII, хотя фактически он является символьным набором Latin-1, однако в целях удобства изложения название "ASCII" будет использоваться и в нашем обсуждении. Обеспечиваемая Windows с использованием кодировки Unicode UTF-16 поддержка обобщенных символов расширенной формы позволяет представлять в стандарте Unicode символы и буквы, встречающиеся во всех основных языках, включая английский, французский, испанский, немецкий, русский, японский и китайский. </p>
     <p>Ниже описаны шаги, которые обычно предпринимаются при написании обобщенных (generic) Windows-приложений, то есть приложений, предусматривающих использование как символов Unicode (UTF-16, а не, например, UCS-4), так и 8-битовых ASCII-символов.</p>
     <p>1. Определите все символы и строки с использованием обобщенных типов TCHAR, LPTSTR и LPCTSTR.</p>
     <p>2. Чтобы иметь возможность работать с символами в расширенной форме Unicode (wchar_t в ANSI С), включите во все модули исходного кода определения #define UNICODE и #define _UNICODE; если этого не сделать, то тип TCHAR будет эквивалентен типу CHAR (char в ANSI С). Это определение должно помещаться перед директивой #include &lt;windows.h&gt;, и его часто задают в командной строке компилятора. Первая из указанных переменных препроцессора управляет определениями функций Windows, вторая — библиотекой С.</p>
     <p>3. Размеры буферов для хранения символов, указываемые, например, при вызове функций ReadFile, могут определяться с использованием функции sizeof(TCHAR).</p>
     <p>4. Используйте входящие в состав библиотеки С функции ввода/вывода обобщенных символов и строк, описанные в файле &lt;tchar.h&gt;. В качестве наиболее характерных из доступных функций можно назвать такие функции, как _fgettc, _itot (вместо itoa), _stprintf (вместо sprintf), _tstcpy (вместо strcpy), _ttoi, _totupper, _totlower и _tprintf.<a l:href="#n_12" type="note">[12]</a> Полный и исчерпывающий список таких функций можно найти в оперативной справочной системе. Все перечисленные определения зависят от определения символьной константы _UNICODE. Описанная коллекция функций не является полной. Примером функции, для которой еще не реализован аналог, позволяющий работать с символами расширенной формы, может служить функция memchr. Новые версии предоставляются по мере возникновения необходимости в них.</p>
     <p>5. Строковые константы могут принимать одну из трех допустимых форм. Эти же соглашения следует применять и к одиночным символам. Первые две формы предоставляются стандартом ANSI С, третья — макрос _Т (эквиваленты — TEXT и _ТЕХТ) — поставляется вместе с компилятором Microsoft С.</p>
     <p><code>"В этой строке используются 8-битовые символы"</code></p>
     <p><code>L"B этой строке используются 16-битовые символы"</code></p>
     <p><code>_Т("В этой строке используются обобщенные символы")</code></p>
     <p>6. Чтобы получить доступ к необходимым определениям текстовых макросов и обобщенным функциям библиотеки С, в модуль следует включить заголовочный файл &lt;tchar.h&gt;, объявление которого должно предшествовать объявлению файла &lt;windows.h&gt;.</p>
     <p>16-битовые символы Unicode (кодировка UTF-16) используются в Windows повсеместно; для внутреннего представления имен файлов и путей доступа в файловой системе NTFS также используется Unicode. Если определена символьная константа _UNICODE, то все вызовы функций Windows требуют использования строк, состоящих из расширенных символов; в противном случае строки 8-битовых символов преобразуются в расширенные строки. В случае программ, которые должны выполняться под управлением систем Windows 9x, не являющихся Unicode-системами, определять символические константы UNICODE и _UNICODE <emphasis>не следует.</emphasis> В средах NT или СЕ решение об использовании указанных определений вы принимаете по своему усмотрению, если только для программы не должна быть одновременно сохранена возможность выполнения под управлением Windows 9x.</p>
     <p>Во всех последующих примерах вместо обычного типа char для символов и символьных строк будет использоваться тип TCHAR, если только по каким-то вполне обоснованным причинам не возникнет необходимости в обработке отдельных 8-битовых символов. Точно так же, тип LPTSTR соответствует указателю на обобщенную строковую переменную, а тип LPCTSTR — указателю на обобщенную строковую константу. В результате принятия этих мер программа может стать более громоздкой, однако лишь своевременный учет различных возможных вариантов обеспечивает гибкость, необходимую для разработки и тестирования приложений, допускающих как кодировку Unicode, так и 8-битовую кодировку символов, что позволит легко преобразовать программу к использованию символов Unicode, если впоследствии в этом возникнет необходимость. Более того, предоставление возможности выбора между обеими разновидностями кодировок соответствует общепринятой, если не универсальной, практике, которая сложилась к настоящему времени.</p>
     <p>Немалую пользу может принести просмотр системных заголовочных файлов, изучив которые вы поймете, как определяются тип TCHAR и интерфейсы системных функций и как они зависят от того, определены или не определены символьные константы UNICODE и _UNICODE. Соответствующие строки обычно выглядят так:</p>
     <p><code>#ifdef UNICODE</code></p>
     <p><code>#define TCHAR WCHAR</code></p>
     <p><code>#else</code></p>
     <p><code>#define TCHAR CHAR</code></p>
     <p><code>#endif</code></p>
    </section>
    <section>
     <title>
      <p>Альтернативные функции для работы с обобщенными строками </p>
     </title>
     <p>В тех случаях, когда при сравнении строк необходим учет специфики языковых и региональных, или <emphasis>локальных, </emphasis>особенностей на стадии выполнения, или же когда требуется сравнивать не <emphasis>строки, </emphasis>а <emphasis>слова,<a l:href="#n_13" type="note">[13]</a> </emphasis>то вместо функций _tcscmp и _tcscmpi вам могут понадобиться функции lstrcmp и lstrcmpi. Сравнение строк осуществляется путем простого сравнения числовых значений символов, тогда как при сравнении слов принимаются во внимание специфические для конкретного языка особенности словообразования. Если применить указанные два метода сравнения к таким парам строк, как <emphasis>coop/co-op </emphasis>и <emphasis>were/we're, </emphasis>то они приведут к противоположным результатам.</p>
     <p>В Windows также существует группа функций, предназначенных для работы с символами и строками в представлении Unicode. Эти функции обеспечивают прозрачную обработку региональных особенностей. Типичными функциями этой группы являются функция CharUpper, которую можно применять как к строкам, так и к отдельным символам, и функция IsCharAlphaNumeric. К числу других функций для работы со строками принадлежат функция CompareString (учитывающая особенности локализации) и функция MultiByteToWideChar. Многобайтовые символы Windows 3.1 и 9х расширяют наборы 8-битовых символов, позволяя применять для представления наборов символов, используемых в языках дальневосточных стран, сдвоенные байты. Чтобы продемонстрировать использование функций обоих типов, будут рассмотрены примеры программ, в которых используются как обобщенные функции библиотеки С (_tprintf и подобные ей), так и функции Windows (CharUpper и подобные ей). Примеры в последующих главах в основном опираются на обобщенную библиотеку С.</p>
    </section>
    <section>
     <title>
      <p>Обобщенная функция Main</p>
     </title>
     <p>Обозначение С-функции main с ее списком аргументов (argv[]) следует заменить макросом _tmain. В зависимости от определения символической константы _UNICODE макрос разворачивается либо до main, либо до wmain. _tmain определяется в заголовочном файле &lt;tchar.h&gt;, который следует включать после файла &lt;windows.h&gt;. Тогда типичный заголовок основной программы будет иметь следующий вид:</p>
     <p><code>#include &lt;windows.h&gt;</code></p>
     <p><code>#include &lt;tchar.h&gt;</code></p>
     <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
     <p><code> …</code></p>
     <p><code>}</code></p>
     <p>В Microsoft С функция _tmain поддерживает дополнительный третий параметр, используемый для строк окружения. Такое нестандартное расширение является обычным в UNIX.</p>
    </section>
    <section>
     <title>
      <p>Определения функций</p>
     </title>
     <p>В качестве примера рассмотрим функцию CreateFile. Если символьная переменная UNICODE определена, то эта функция определяется как CreateFileA, а если не определена — то как CreateFileW. Строковые параметры в объявлениях также описываются как строки 8-битовых символов или символов в расширенной форме. Следовательно, если в исходном коде присутствуют такие, например, ошибки, как использование неподходящих параметров в функции CreateFile, то в сообщениях компилятора об этих ошибках будут указываться функции CreateFileA или CreateFileW.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Стратегии использования символов Unicode</p>
    </title>
    <p>Приступая к работе над проектом в Windows, либо для разработки нового программного кода, либо для переноса существующего, программист, в зависимости от требований проекта, может выбрать одну из четырех стратегий.</p>
    <p>1. <strong>Только 8-битовые символы. </strong>Игнорируйте Unicode и продолжайте использовать для таких функций, как printf, atoi и strcmp, типы данных char (или CHAR) и стандартную библиотеку С.</p>
    <p>2. <strong>8-битовые символы, но с возможностью использования символов Unicode. </strong>Следуйте ранее данным рекомендациям в отношении обобщенных приложений, но не определяйте константы UNICODE и _UNICODE директивами препроцессора. В приведенных в данной книге примерах программ используется именно эта стратегия.</p>
    <p>3.<strong> Только символы Unicode. </strong>Следуйте рекомендациям в отношении обобщенных приложений, но при этом определите директивами препроцессора обе константы UNICODE и _UNICODE. Другой возможный вариант состоит в том, чтобы использовать исключительно расширенную форму символов и функций для работы с символами. Результирующие программы не смогут правильно выполняться под управлением Windows 9x.</p>
    <p>4.<strong> Символы Unicode и 8-битовые символы. </strong>Программа ориентируется на работу как с символами Unicode, так и с ASCII-символами, причем решение относительно того, какие участки программного кода должны работать, принимается программой на стадии выполнения с использованием переключателей времени выполнения или других возможных средств.</p>
    <p>Как уже отмечалось ранее, несмотря на то что написание обобщенного кода требует дополнительных усилий, а результирующая программа становится менее удобочитаемой, эта мера позволяет программисту добиться максимальной гибкости приложения.</p>
    <p>Параметры локализации могут устанавливаться во время выполнения программы. В программе 2.2 показано, как определить язык, который должен использоваться в сообщениях об ошибках.</p>
    <cite>
     <p>Стандарт локализации приложений POSIX XPG4, предоставляемый многими поставщиками UNIX, существенно отличается от стандарта Unicode. Помимо всего прочего, символы в этом стандарте могут представляться 4, 3 или 1 байтами в зависимости от контекста, особенностей локализации и так далее.</p>
     <p>Microsoft С реализует функции стандартной библиотеки С, среди которых имеются также версии, рассчитанные на работу с символами в расширенной форме. Так, заголовочный файл &lt;wchar.h&gt; содержит описание функции _tsetlocale. В Windows NT используются символы Unicode, тогда как в Windows 9x используются те же многобайтовые символы (смесь 8– и 16-битовых символов), что и в Windows 3.1.</p>
    </cite>
   </section>
   <section>
    <title>
     <p>Стандартные устройства и консольный ввод/вывод</p>
    </title>
    <p>Как и в UNIX, в Windows предусмотрены три стандартных устройства, предназначенные, соответственно, для ввода данных (input), вывода данных (output) и вывода сообщений об ошибках (error). В UNIX для этих устройств используются известные системе значения дескрипторов файлов (0, 1 и 2), однако в Windows доступ к стандартным устройствам осуществляется с помощью дескрипторов типа HANDLE, для получения которых предоставляется специальная функция.</p>
    <p><code>HANDLE GetStdHandle(DWORD nStdHandle)</code></p>
    <p>Возвращаемое значение: в случае успешного выполнения — действительный дескриптор, иначе — значение INVALID_HANDLE_VALUE.</p>
    <subtitle><emphasis>Параметры</emphasis></subtitle>
    <p>Параметр nStdHandle должен принимать одно из следующих значений:</p>
    <p><code>• STD_INPUT_HANDLE</code></p>
    <p><code>• STD_OUTPUT_HANDLE</code></p>
    <p><code>• STD_ERROR_HANDLE</code></p>
    <p>В качестве стандартных устройств обычно назначаются консоль и клавиатура. Стандартный ввод/вывод можно перенаправлять на другие устройства.</p>
    <p>Вызов функции GetStdHandle не приводит к созданию новых или дублированию существующих дескрипторов стандартных устройств. Последовательные вызовы с указанием в качестве аргумента одного и того же устройства будут возвращать одно и то же значение дескриптора. Закрытие дескриптора стандартного устройства делает это устройство недоступным для дальнейшего использования. По этой причине в примерах ниже мы будем часто открывать дескриптор стандартного устройства, но не закрывать его. </p>
    <cite>
     <p><code>BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle)</code></p>
     <p><strong>Возвращаемое значение: </strong>в случае успешного выполнения — TRUE, иначе — FALSE. </p>
    </cite>
    <subtitle><emphasis>Параметры</emphasis></subtitle>
    <p>Допустимые значения параметра nStdHandle функции SetStdHandle являются теми же, что и в случае функции GetStdHandle. Параметр hHandle указывает открытый файл, который назначается в качестве стандартного устройства.</p>
    <p>Одним из методов перенаправления стандартного ввода/вывода является последовательный вызов функций SetStdHandle и GetStdHandle. Полученный в результате этого дескриптор используется в последующих операциях ввода/ вывода.</p>
    <p>Для указания путей доступа к консольному вводу (клавиатуре) и консольному выводу предусмотрены два зарезервированных имени: "CONIN$" и "CONOUT$". Роль стандартных устройств ввода, вывода и вывода ошибок первоначально отводится консоли. Однако консоль можно использовать даже после того, как операции ввода/вывода, требующие применения стандартных устройств, будут перенаправлены; для этого требуется лишь открыть дескрипторы для файлов "CONIN$" и "CONOUT$", вызвав функцию CreateFile. </p>
    <cite>
     <p>В UNIX стандартный ввод/вывод может быть перенаправлен одним из трех способов (см. [40], стр. 61—64).</p>
     <p>Первый метод является косвенным и основывается на том, что функция dup возвращает дескриптор файла с наименьшим доступным номером. Предположим, вы хотите переназначить стандартный ввод (файловый дескриптор 0) открытому файлу, описанному как fd_redirect. Тогда можно записать следующий код:</p>
     <p><code>close (STDIN_FILENO); </code></p>
     <p><code>dup (fd_redirect);</code></p>
     <p>Во втором методе используется функция dup2, а третий метод предполагает вызов замысловатой перегруженной функции fcntl с использованием в качестве параметра значения F_DUPFD.</p>
    </cite>
    <p>Операции консольного ввода/вывода могут выполняться с помощью функций ReadFile и WriteFile, но проще использовать предназначенные специально для этого функции консоли ReadConsole и WriteConsole. Основное преимущество этих функций заключается в том, что они манипулируют не байтами, а обобщенными символами (TCHAR), и, кроме того, обрабатывают символы в соответствии с текущими режимами консоли, которые устанавливаются функцией SetConsoleMode. </p>
    <cite>
     <p><code>BOOL SetConsoleMode(HANDLE hConsoleHandle, DWORD fdevMode)</code></p>
     <p><strong>Возвращаемое значение: </strong>тогда, и только тогда, когда функция завершается успешно — TRUE, иначе — FALSE. </p>
    </cite>
    <subtitle><emphasis>Параметры</emphasis></subtitle>
    <p>hConsoleHandle — дескриптор буфера ввода консоли или буфера дисплея, который должен быть создан с правами доступа GENERIC_WRITE, даже если устройство предназначено только для ввода информации.</p>
    <p>Параметр fdevMode задает способ обработки символов. В имени каждого из его флагов содержится компонент, указывающий, к чему относится данный флаг— к вводу (input) или выводу (output). Ниже перечислены пять обычно используемых флагов, причем все они устанавливаются по умолчанию.</p>
    <p>• ENABLE_LINE_INPUT — возврат из функции чтения (ReadConsole) происходит только после считывания символа возврата каретки.</p>
    <p>• ENABLE_ECHO_INPUT — эхо-отображение вводимых символов на экране.</p>
    <p>• ENABLE_PROCESSED_INPUT — установка этого флага приводит к обработке системой управляющих символов возврата на одну позицию, возврата каретки и перехода на новую строку.</p>
    <p>• ENABLE_PROCESSED_OUTPUT — установка этого флага приводит к обработке системой управляющих символов возврата на одну позицию, табуляции, подачи звукового сигнала, возврата каретки и перехода на новую строку.</p>
    <p>• ENABLE_WRAP_AT_EOL_OUTPUT — переход на следующую строку экрана как при обычном выводе символов, так и при их эхо-отображении в процессе ввода.</p>
    <p>В случае неудачного завершения функции SetConsoleMode текущий режим остается неизменным, и функция возвращает значение FALSE. Как обычно, для получения номера ошибки следует воспользоваться функцией GetLastError.</p>
    <p>Функции ReadConsole и WriteConsole аналогичны функциям ReadFile и WriteFile. </p>
    <cite>
     <p><code>BOOL ReadConsole(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD cchToRead, LPDWORD lpcchRead, LPVOID lpReserved)</code></p>
     <p><strong>Возвращаемое значение: </strong>тогда, и только тогда, когда функция завершается успешно — TRUE, иначе — FALSE.</p>
    </cite>
    <p>Параметры у этой функции почти те же, что и у функции ReadFile. Значения обоих параметров, связанных с количеством подлежащих считыванию (cchToRead) и фактически считанных (lpcchRead) символов, выражаются в терминах обобщенных символов, а не байтов, а значение параметра lpReserved должно быть равным NULL. Как и во всех остальных подобных случаях, никогда не используйте для собственных нужд зарезервированные поля, аналогичные lpReserved, которые встречаются в некоторых функциях. Параметры функции WriteConsole имеют тот же смысл и не нуждаются в дополнительных пояснениях. В очередном примере будет проиллюстрировано применение функций Read-Console и WriteConsole, и, кроме того, будет показано, как использовать возможности управления режимом консоли.</p>
    <p>Любому процессу в каждый момент времени может быть назначена только одна консоль. Приложениям того типа, с которым мы имели дело до сих пор, консоль передается обычно на стадии инициализации. Однако в целом ряде других случаев, например, в случае серверных или GUI-приложений, у вас может возникнуть необходимость в получении отдельной консоли, на которую можно было бы выводить информацию о состоянии программы или отладочную информацию. Для этих целей можно воспользоваться двумя простыми функциями, не имеющими параметров. </p>
    <cite>
     <p><code>BOOL FreeConsole(VOID)</code></p>
     <p><code><code>BOOL AllocConsole(VOID)</code> </code></p>
    </cite>
    <p>Функция FreeConsole отключает процесс от его консоли, тогда как функция AllocConsole создает новую консоль, ассоциированную с дескрипторами стандартного ввода информации, стандартного вывода информации и стандартного вывода сообщений об ошибках, принадлежащими данному процессу. Если консоль у процесса уже имеется, функция AllocConsole завершится с ошибкой; чтобы избежать этого, следует предварительно вызывать функцию FreeConsole.</p>
    <cite>
     <p><strong>Примечание</strong></p>
     <p>GUI-приложения Windows не имеют консоли по умолчанию и должны получить ее, прежде чем смогут воспользоваться функциями WriteConsole или printf для вывода на консоль. Процессы на стороне сервера также могут не иметь консоли. О том, как создать процесс без консоли, рассказано в главе 6. </p>
    </cite>
    <p>Имеется также множество других функций консольного ввода/вывода, предназначенных для установки позиции курсора, а также задания атрибутов выводимых символов (например, цвета) и так далее. Принятый в данной книге подход состоит в том, чтобы использовать лишь те функции, которые необходимы для создания примеров работоспособных программ, поэтому углубляться больше, чем это необходимо, в пользовательские интерфейсы мы не будем. После того как вы разберете примеры, для вас не составит большого труда изучить дополнительные функции, воспользовавшись справочными материалами. </p>
    <cite>
     <p>Исторически сложилось так, что ОС Windows ориентирована на использование терминалов или консолей в меньшей степени, чем UNIX, и не полностью воспроизводит функциональные средства UNIX, поддерживающие работу с терминалами. В книге [40] одна из глав посвящена рассмотрению обеспечиваемых UNIX возможностей терминального ввода/вывода (глава 11), а другая — псевдотерминалам (глава 19).</p>
     <p>Разумеется, работа в Windows почти всегда ведется с использованием мощных графических интерфейсов, поддерживающих мышь и ввод с клавиатуры. Несмотря на то что рассмотрение GUI выходит за рамки данной книги, все, что мы здесь обсуждаем, будет работать и в GUI-приложениях.</p>
    </cite>
   </section>
   <section>
    <title>
     <p>Пример: вывод на консоль сообщений и подсказок для пользователя</p>
    </title>
    <p>Функция ConsolePrompt, входящая в программу 2.1, является полезной утилитой, которая выводит на консоль заданное сообщение и возвращает ответ пользователя на него. Данная утилита предусматривает возможность подавления эхо-отображения ответной информации, полученной от пользователя. В указанной функции используются функции консольного ввода/вывода и обобщенные символы. Двумя другими точками входа в этом модуле являются функции Print-Strings и PrintMsg; эти функции допускают использование любого дескриптора, однако обычно они применяются совместно с дескрипторами устройств стандартного вывода информации и стандартного вывода сообщений об ошибках. В первой функции разрешается использовать список аргументов переменной длины, тогда как во второй в качестве аргумента можно задавать только одну строку, что в некоторых случаях может оказаться удобнее. Для обработки списка аргументов переменной длины функция PrintStrings использует функции va_start, va_arg и va_end стандартной библиотеки С.</p>
    <p>Описанные функции, а также функции из обобщенной библиотеки С будут привлекаться для использования в приводимых в данной книге примерах программ при всякой удобной возможности. </p>
    <cite>
     <p><strong>Примечание</strong></p>
     <p>Коды программ, находящиеся на Web-сайте книги, содержат подробные комментарии и тщательно документированы, тогда как в самой книге большинство комментариев с целью сокращения места были опущены, и основное внимание в ней уделяется использованию Windows.</p>
    </cite>
    <p>Следует также отметить, что в примере вводится заголовочный файл Envirmnt.h (его код приведен в приложении А и предоставлен на Web-сайте книги), который должен использоваться совместно со всеми приводимыми в книге программами. Этот файл содержит определения символических констант UNICODE и _UNICODE (сами определения "закомментированы"; при компоновке приложений, предназначенных для работы с символами стандарта Unicode, символы комментариев следует удалить), а также необходимых макропеременных, учитывающих особенности окружения. В заголовочных файлах, находящихся на Web-сайте, определены также дополнительные модификаторы, которые обеспечивают импортирование и экспортирование имен функций, а также гарантируют соблюдение соответствующих соглашений о вызове функций.</p>
    <subtitle>Программа 2.1. PrintMsg: вспомогательные функции вывода на консоль сообщений и ожидания ответа от пользователя </subtitle>
    <p><code>/* PrintMsg.с: ConsolePrompt, PrintStrings, PrintMsg */</code></p>
    <p><code>#include "Envirmnt.h" /* В этом файле устанавливаются директивы #define и #undef для UNICODE. */ </code></p>
    <p><code>#include &lt;windows.h&gt; </code></p>
    <p><code>#include &lt;stdarg.h&gt;</code></p>
    <empty-line/>
    <p><code>BOOL PrintStrings (HANDLE hOut, ...)</code></p>
    <p><code>/* Запись сообщений в буфер экрана консоли. */</code></p>
    <p><code>{</code></p>
    <p><code> DWORD MsgLen, Count;</code></p>
    <p><code> LPCTSTR pMsg;</code></p>
    <p><code> va_list pMsgList; /* Строка текущего сообщения. */</code></p>
    <p><code> va_start (pMsgList, hOut); /* Начать обработку сообщений. */</code></p>
    <p><code> while ((pMsg = va_arg(pMsgList, LPCTSTR)) != NULL) {</code></p>
    <p><code>  MsgLen = _tcslen(pMsg);</code></p>
    <p><code>  /* Функция WriteConsole может применяться только с дескриптором буфера экрана консоли. */</code></p>
    <p><code>  if (!WriteConsole(hOut, pMsg, MsgLen, &amp;Count, NULL) </code></p>
    <p><code>      /* Функция WriteFile вызывается только в случае неудачного завершения функции WriteConsole. */</code></p>
    <p><code>      &amp;&amp; !WriteFile(hOut, pMsg, MsgLen * sizeof (TCHAR), &amp;Count, NULL)) return FALSE;</code></p>
    <p><code> }</code></p>
    <p><code> va_end(pMsgList);</code></p>
    <p><code> return TRUE;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>BOOL PrintMsg(HANDLE hOut, LPCTSTR pMsg)</code></p>
    <p><code>/* Версия PrintStrings для вывода одиночного сообщения. */ </code></p>
    <p><code>{</code></p>
    <p><code> return PrintStrings(hOut, pMsg, NULL); </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>BOOL ConsolePrompt(LPCTSTR pPromptMsg, LPTSTR pResponse, DWORD MaxTchar, BOOL Echo)</code></p>
    <p><code>/* Вывести на консоль подсказку для пользователя и получить от него ответ. */ </code></p>
    <p><code>{</code></p>
    <p><code> HANDLE hStdIn, hStdOut;</code></p>
    <p><code> DWORD TcharIn, EchoFlag;</code></p>
    <p><code> BOOL Success;</code></p>
    <p><code> hStdIn = CreateFile(_T("CONIN$"), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);</code></p>
    <p><code> hStdOut = CreateFile(_T("CONOUT$"), GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);</code></p>
    <p><code> EchoFlag = Echo ? ENABLE_ECHO_INPUT : 0;</code></p>
    <p><code> Success = SetConsoleMode(hStdIn, ENABLE_LINE_INPUT | EchoFlag | ENABLE_PROCESSED_INPUT) &amp;&amp;</code></p>
    <p><code>           SetConsoleMode (hStdOut, ENABLE_WRAP_AT_EOL_OUTPUT | ENABLE_PROCESSED_OUTPUT) &amp;&amp;</code></p>
    <p><code>           PrintStrings (hStdOut, pPromptMsg, NULL) &amp;&amp;</code></p>
    <p><code>           ReadConsole (hStdIn, pResponse, MaxTchar, &amp;TcharIn, NULL);</code></p>
    <p><code> if (Success) pResponse [TcharIn – 2] = '\0';</code></p>
    <p><code> CloseHandle (hStdIn);</code></p>
    <p><code> CloseHandle (hStdOut);</code></p>
    <p><code> return Success; </code></p>
    <p><code>}</code></p>
    <p>Обратите внимание, что при вычислении возвращаемого функцией значения булевской переменной Success, которое служит индикатором успешности выполнения, в программе, с выгодой для логики ее работы, используется тот факт, что стандартом ANSI С гарантируется так называемое "сокращенное" вычисление логических выражений в направлении слева направо; поэтому, как только при вычислении части выражения, расположенной слева от любой из операций логического "и" (&amp;&amp;), в качестве результата будет получено значение FALSE, остальная часть выражения, расположенная справа от данной операции, вычисляться не будет, поскольку результат вычисления всего выражения в целом оказывается предопределенным. Данный стиль написания программ может показаться чересчур компактным, однако он обладает тем преимуществом, что позволяет организовать логически стройную и понятную последовательность системных вызовов, не загромождая программу многочисленными операторами условных переходов. Для получения более подробной информации о возможных ошибках можно воспользоваться функцией GetLastError. Распространенный в Windows возврат функциями логических значений поощряет подобную практику.</p>
    <p>В данной функции сообщения об ошибках не выводятся; их вывод, если это будет необходимо, можно предусмотреть в вызывающей программе.</p>
    <p>В программном коде используется тот документированный факт, что при использовании функции WriteConsole вместе с дескриптором, который не является дескриптором консоли, ее выполнение будет завершено с ошибкой. В связи с этим предварительный запрос свойств дескриптора не является обязательным. Функция воспользуется консольным режимом лишь в том случае, если указанный в ее вызове дескриптор действительно связан с консолью.</p>
    <p>Кроме того, функция ReadConsole возвращает управляющие символы возврата каретки и перехода на новую строку, что диктует необходимость вставки дополнительных нулевых символов после символов возврата каретки в соответствующих местах.</p>
   </section>
   <section>
    <title>
     <p>Пример: обработка ошибок</p>
    </title>
    <p>В программе 1.2 было продемонстрировано использование лишь самых примитивных средств обработки ошибок, а именно, получение номера ошибки в переменной типа DWORD с помощью функции GetLastError. Вызов функции, а не просто получение глобального номера ошибки, как это делается при помощи функции UNIX errno, гарантирует уникальную идентификацию системных ошибок для каждого из потоков (глава 7), использующих разделяемую область хранения данных.</p>
    <p>Функция FormatMessage превращает простой номер сообщения в описательное сообщение, представляющее собой фразу на английском или любом другом из множества возможных языков, и возвращает размер сообщения.</p>
    <p>В программе 2.2 представлена полезная универсальная функция ReportError, предназначенная для обработки ошибок и по своим возможностям аналогичная входящей в состав библиотеки С функции perror, а также описанным в [40] функциям err_sys и err_ret. Функция ReportError передает в выходной буфер сообщение в виде, определяемом первым аргументом, и либо прекращает выполнение с кодом выхода по ошибке, либо осуществляет обычный возврат управления, в зависимости от значения второго аргумента. Третий аргумент определяет, должны ли отображаться системные сообщения об ошибках.</p>
    <p>Обратите внимание на аргументы функции FormatMessage. В качестве одного из параметров используется значение, возвращаемое функцией GetLastError, a на необходимость генерации сообщения системой указывает флаг. Сгенерированное сообщение сохраняется в буфере, выделяемом функцией, а соответствующий адрес возвращается в параметре. Имеются также другие параметры, для которых указаны значения по умолчанию. Язык сообщений может быть задан как во время компиляции, так и во время выполнения. В этой книге функция Format-Message далее нигде не используется, поэтому никаких дополнительных пояснений относительно нее в тексте не дается. </p>
    <p>Функция ReportError упрощает обработку ошибок, и будет использоваться почти во всех последующих примерах. В главе 4 она будет модифицирована для генерации исключений.</p>
    <p>В программе 2.2 вводится заголовочный файл EvryThng.h. Как следует из самого его названия, этот файл включает в себя файлы &lt;windows.h&gt;, Envirmnt.h и все остальные заголовочные файлы, которые были явно указаны в программе 2.1. Кроме того, в нем описаны такие обычно используемые функции, как PrintMsg, PrintStrings и ReportError. Во всех остальных примерах будет использоваться только этот заголовочный файл, листинг которого приведен в приложении А.</p>
    <p>Обратите внимание на вызов функции HeapFree, находящийся почти в конце программы. Об этой функции будет рассказано в главе 5.</p>
    <subtitle>Программа 2.2. Функция Report Error, предназначенная для вывода сообщений об ошибках при выполнении системных вызовов </subtitle>
    <p><code>#include "EvryThng.h"</code></p>
    <empty-line/>
    <p><code>VOID ReportError(LPCTSTR UserMessage, DWORD ExitCode, BOOL PrintErrorMsg)</code></p>
    <p><code>/* Универсальная функция для вывода сообщений о системных ошибках. */ </code></p>
    <p><code>{</code></p>
    <p><code> DWORD eMsgLen, LastErr = GetLastError();</code></p>
    <p><code> LPTSTR lpvSysMsg;</code></p>
    <p><code> HANDLE hStdErr = GetStdHandle(STD_ERROR_HANDLE);</code></p>
    <p><code> PrintMsg(hStdErr, UserMessage);</code></p>
    <p><code> if (PrintErrorMsg) {</code></p>
    <p><code>  eMsgLen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, LastErr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&amp;lpvSysMsg, 0, NULL);</code></p>
    <p><code>  PrintStrings (hStdErr, _T("\n"), lpvSysMsg, _T("\n"), NULL);</code></p>
    <p><code>  /* Освободить блок памяти, содержащий сообщение об ошибке. */</code></p>
    <p><code>  HeapFree(GetProcessHeap(), 0, lpvSysMsg); /* См. гл. 5. */</code></p>
    <p><code> }</code></p>
    <p><code> if (ExitCode &gt; 0) ExitProcess (ExitCode);</code></p>
    <p><code> else return; </code></p>
    <p><code>}</code> </p>
   </section>
   <section>
    <title>
     <p>Пример: копирование нескольких файлов на стандартное устройство вывода</p>
    </title>
    <p>В программе 2.3 иллюстрируется использование стандартных устройств ввода/вывода, а также демонстрируется, как улучшить контроль ошибок и усовершенствовать взаимодействие с пользователем. Эта программа представляет собой вариант ограниченной реализации команды UNIX cat, которая копирует один или несколько заданных файлов (или содержимое буфера стандартного устройства ввода, если файлы не указаны) на стандартное устройства вывода.</p>
    <p>Программа 2.3 включает полную обработку ошибок. В большинстве других примеров проверка ошибок опущена или сведена к минимуму, но полностью включена в завершенные документированные варианты программ, находящиеся на Web-сайте. Обратите внимание на функцию Options (ее листинг приведен в приложении А), вызываемую в начале программы. Эта функция, которая включена в состав программ, находящихся на Web-сайте, и используется на протяжении всей книги, просматривает параметры в командной строке и возвращает индекс массива argv, соответствующий имени первого файла. Функция Options аналогична функции getopt, которая используется во многих программах в UNIX.</p>
    <subtitle>Программа 2.3. cat: вывод нескольких файлов на стандартное устройство вывода </subtitle>
    <p><code>/* Глава 2. cat. */</code></p>
    <p><code>/* cat [параметры] [файлы] Допускается только параметр –s, предназначенный для подавления вывода сообщений об ошибках в случае, если один из указанных файлов не существует. */</code></p>
    <p><code>#include "EvryThng.h" </code></p>
    <p><code>#define BUF_SIZE 0x200</code></p>
    <empty-line/>
    <p><code>static VOID CatFile(HANDLE, HANDLE); </code></p>
    <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> HANDLE hInFile, hStdIn = GetStdHandle(STD_INPUT_HANDLE);</code></p>
    <p><code> HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);</code></p>
    <p><code> BOOL DashS;</code></p>
    <p><code> int iArg, iFirstFile;</code></p>
    <p><code> /* Переменная DashS будет установлена только в случае задания параметра "-s" в командной строке. */</code></p>
    <p><code> /* iFirstFile — индекс первого входного файла в списке argv[]. */</code></p>
    <p><code> iFirstFile = Options(argc, argv, _T("s"), &amp;DashS, NULL);</code></p>
    <p><code> if (iFirstFile == argc) { /*Отсутствие входных файлов в списке аргументов.*/</code></p>
    <p><code>  /* Использовать стандартное устройство ввода. */</code></p>
    <p><code>  CatFile(hStdIn, hStdOut);</code></p>
    <p><code>  return 0;</code></p>
    <p><code> }</code></p>
    <p><code> /* Обработать каждый входной файл. */</code></p>
    <p><code> for (iArg = iFirstFile; iArg &lt; argc; iArg++) {</code></p>
    <p><code>  hInFile = CreateFile(argv [iArg], GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);</code></p>
    <p><code>  if (hInFile == INVALID_HANDLE_VALUE &amp;&amp; !DashS) ReportError (_T("Cat: ошибка при открытии файла"), 1, TRUE);</code></p>
    <p><code>  CatFile (hInFile, hStdOut);</code></p>
    <p><code>  CloseHandle (hInFile);</code></p>
    <p><code> }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* Функция, выполняющая всю работу:</code></p>
    <p><code>/* читает входные данные и копирует их на стандартное устройства вывода. */</code></p>
    <p><code>static VOID CatFile(HANDLE hInFile, HANDLE hOutFile) {</code></p>
    <p><code> DWORD nIn, nOut;</code></p>
    <p><code> BYTE Buffer [BUF_SIZE];</code></p>
    <p><code> while (ReadFile(hInFile, Buffer, BUF_SIZE, &amp;nIn, NULL) &amp;&amp; (nIn != 0) &amp;&amp; WriteFile(hOutFile, Buffer, nIn, &amp;nOut, NULL));</code></p>
    <p><code> return; </code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>Пример: преобразование символов из ASCII в Unicode</p>
    </title>
    <section>
     <p>Программа 2.4 достраивает программу 1.3, в которой использовалась вспомогательная функция CopyFile. С копированием файлов вы уже знакомы, поэтому в данном примере эта операция дополняется преобразованием файла к кодировке Unicode в предположении, что первоначальной кодировкой символов является ASCII, хотя проверка этого предположения не производится. В программе предусмотрены некоторые возможности вывода сообщений об ошибках и параметр, позволяющий подавить замену существующего файла; завершающий вызов функции CopyFile заменен в программе вызовом новой функции, которая Выполняет преобразование символьных строк файла из кодировки ASCII в кодировку Unicode.</p>
     <p>В данной программе основное внимание уделяется обеспечению возможности успешного завершения преобразования. Фактическое выполнение преобразования сосредоточено в единственной функции, вызываемой в самом конце программы. Этот фрагмент, как и аналогичный ему фрагмент предыдущей программы, послужит нам шаблоном и будет вновь использоваться в последующих программах без повторения его исходного кода.</p>
     <p>Обратите внимание на вызов функции _taccess, проверяющей существование файла. Эта функция является обобщенной версией функции access, которая имеется в библиотеке UNIX, но не входит в состав стандартной библиотеки С. Ее определение содержится в файле &lt;io.h&gt;. Если говорить точнее, функция _taccess осуществляет проверку прав доступа к файлу в соответствии с режимом, установленным значением второго параметра. Значение 0 задает проверку существования файла, 2 — проверку наличия разрешения на запись в файл, 4 — проверку наличия разрешения на чтение из файла, 6 — проверку наличия разрешения как на чтение из файла, так и на запись в файл (эти значения не связаны напрямую с такими параметрами доступа, используемыми в Windows, как GENERIC_READ). Альтернативой проверке существования файла могло бы быть открытие дескриптора при помощи функции CreateFile и его последующее закрытие после проверки действительности дескриптора. </p>
     <subtitle>Программа 2.4. atou: преобразование файла с выводом сообщений об ошибках </subtitle>
     <p><code>/* Глава 2. atou – копирование файлов с преобразованием из ASCII в Unicode. */</code></p>
     <p><code>#include "EvryThng.h"</code></p>
     <empty-line/>
     <p><code>BOOL Asc2Un(LPCTSTR, LPCTSTR, BOOL); </code></p>
     <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
     <p><code> DWORD LocFileIn, LocFileOut;</code></p>
     <p><code> BOOL DashI = FALSE;</code></p>
     <p><code> TCHAR YNResp[3] = _T("y");</code></p>
     <p><code> /* Получить параметры командной строки и индекс входного файла. */</code></p>
     <p><code> LocFileIn = Options(argc, argv, _T("i"), &amp;DashI, NULL);</code></p>
     <p><code> LocFileOut = LocFileIn + 1;</code></p>
     <p><code> if (DashI) { /* Существует ли выходной файл? */</code></p>
     <p><code>  /* Обобщенная версия функции access, осуществляющая проверку существования файла. */</code></p>
     <p><code>  if (_taccess(argv[LocFileOut], 0) == 0) {</code></p>
     <p><code>   _tprintf(_T("Перезаписать существующий файл? [y/n]"));</code></p>
     <p><code>   _tscanf(_T ("%s"), &amp;YNResp);</code></p>
     <p><code>   if (lstrcmp(CharLower(YNResp), YES) != 0) ReportError(_T("Отказ от перезаписи"), 4, FALSE);</code></p>
     <p><code>  }</code></p>
     <p><code> }</code></p>
     <p><code> /* Эта функция построена на основе функции CopyFile. */ </code></p>
     <p><code> Asc2Un(argv[LocFileIn], argv [LocFileOut], FALSE);</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <p>Программа 2.5 — это вызываемая в программе 2.4 функция Asc2Un, осуществляющая преобразование кодировки символов.</p>
     <subtitle>Программа 2.5. Функция Asc2Un</subtitle>
     <p><code>#include "EvryThng.h" </code></p>
     <p><code>#define BUF_SIZE 256</code></p>
     <empty-line/>
     <p><code>BOOL Asc2Un(LPCTSTR fIn, LPCTSTR fOut, BOOL bFailIfExists) </code></p>
     <p><code>/* Функция копирования файлов с преобразованием из ASCII в Unicode. Функция построена на основе функции CopyFile. */ </code></p>
     <p><code>{</code></p>
     <p><code> HANDLE hIn, hOut;</code></p>
     <p><code> DWORD dwOut, nIn, nOut, iCopy;</code></p>
     <p><code> CHAR aBuffer[BUF_SIZE];</code></p>
     <p><code> WCHAR uBuffer [BUF_SIZE];</code></p>
     <p><code> BOOL WriteOK = TRUE;</code></p>
     <p><code> hIn = CreateFile(fin, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); </code></p>
     <p><code> /* Определить поведение функции CreateFile, если выходной файл уже существует. */</code></p>
     <p><code> dwOut = bFailIfExists ? CREATE_NEW : CREATE_ALWAYS;</code></p>
     <p><code> hOut = CreateFile(fOut, GENERIC_WRITE, 0, NULL, dwOut, FILE_ATTRIBUTE_NORMAL, NULL);</code></p>
     <p><code> while (ReadFile(hIn, aBuffer, BUF_SIZE, &amp;nIn, NULL)  &amp;&amp; nIn &gt; 0 &amp;&amp; WriteOK) {</code></p>
     <p><code>  for (iCopy = 0; iCopy &lt; nIn; iCopy++)</code></p>
     <p><code>   /* Преобразовать каждый символ. */</code></p>
     <p><code>   uBuffer[iCopy] = (WCHAR)aBuffer [iCopy];</code></p>
     <p><code>  WriteOK = WriteFile(hOut, uBuffer, 2 * nIn, &amp;nOut, NULL);</code></p>
     <p><code> }</code></p>
     <p><code> CloseHandle(hIn);</code></p>
     <p><code> CloseHandle(hOut);</code></p>
     <p><code> return WriteOK;</code></p>
     <p><code>}</code></p>
    </section>
    <section>
     <title>
      <p>Производительность программы</p>
     </title>
     <p>Как показано в приложении В, производительность программы преобразования файлов можно повысить, предоставив буфер большего размера и задав флаг FILE_FLAG_SEQUENTIAL_SCAN при вызове функции CreateFile. В приложении В также сравниваются показатели производительности программы для файловых систем NTFS и распределенных файловых систем.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Управление файлами и каталогами</p>
    </title>
    <section>
     <p>В этом разделе вводятся основные функции, предназначенные для управления файлами и каталогами.</p>
    </section>
    <section>
     <title>
      <p>Управление файлами</p>
     </title>
     <p>Для управления файлами Windows предоставляет целый ряд функций, работа с которыми обычно не представляет сложности. Ниже описаны функции, с помощью которых можно удалять, копировать и переименовывать файлы. Существует также функция, предназначенная для создания имен временных файлов.</p>
     <p>При удалении файла достаточно указать его имя. Вспомните, что все полные имена файлов начинаются с буквы диска или имени сервера. Открытый файл, вообще говоря, удалить невозможно (это допускается в Windows 9x и UNIX); попытка выполнения подобной операции закончится неудачей. У такого ограничения есть свои положительные стороны, поскольку оно предотвращает случайное удаление открытых файлов. </p>
     <cite>
      <p><code>BOOL DeleteFile(LPCTSTR lpFileName)</code> </p>
     </cite>
     <p>Чтобы скопировать файл целиком, достаточно использовать одну функцию. </p>
     <cite>
      <p><code>BOOL CopyFile(LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, BOOL fFailIfExists)</code> </p>
     </cite>
     <p>Функция CopyFile копирует существующий файл с заданным именем и присваивает копии указанное новое имя. В случае существования файла с таким же именем он будет заменен новым файлом только в том случае, если значением параметра fFailIfExists является FALSE.</p>
     <p>Под управлением NT5 можно создать жесткую ссылку (hard link) для двух файлов, аналогичную жестким ссылкам в UNIX, используя для этого функцию CreateHardLink. Жесткие ссылки делают возможным существование файла под двумя различными именами. Заметьте, что в подобных случаях файл как таковой существует в единственном числе, и поэтому можно произвольно использовать любое из его имен, независимо от того, какое из них было использовано для открытия файла.</p>
     <cite>
      <p><code>BOOL CreateHardLink(LPCTSTR lpFileName, LPCTSTR lpExistingFileName, BOOL lpSecurityAttributes)</code> </p>
     </cite>
     <p>Два первых аргумента имеют тот же смысл, что и в функции CopyFile, хотя и расположены в обратном порядке. Оба имени файла, новое и существующее, должны относиться к одному и тому же тому файловой системы, но могут соответствовать различным каталогам. Атрибуты защиты файла, если таковые имеются, применимы и к новому имени файла.</p>
     <p>Если заглянуть в документацию Microsoft, то можно увидеть, что в структуре BY_HANDLE_FILE_INFO имеется поле "количество ссылок", и именно этот счетчик используется для определения того, может или не может быть удален данный файл. Функция DeleteFile удаляет имя из каталога файловой системы, но сам файл не может быть удален до тех пор, пока значение счетчика "количество ссылок" не станет равным 0.</p>
     <p>Гибких ссылок (soft link) в Windows не существует, хотя оболочки Windows (но не сама Windows), руководствующиеся при определении местоположения файла его содержимым, поддерживают ярлыки (shortcuts). Ярлыки предоставляют средства, подобные гибким ссылкам, но воспользоваться ими могут только пользователи оболочки.</p>
     <p>Доступны две функции, позволяющие переименовывать, или "перемещать", файл. Эти же функции применимы и к каталогам. (Функции DeleteFile и CopyFile могут применяться только к файлам.) </p>
     <cite>
      <p><code>BOOL MoveFile(LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName)</code></p>
      <p><code>BOOL MoveFileEx(LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, DWORD dwFlags)</code> </p>
     </cite>
     <p>Если новый файл уже существует, функция MoveFile завершается с ошибкой; в этом случае следует использовать функцию MoveFileEx. Заметьте, что суффикс "Ех" обычно применяется для обозначения усовершенствованных версий функций, обладающих расширенными (extended) функциональными возможностями.</p>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>lpExistingFileName — указатель на строку, содержащую имя существующего файла <emphasis>или</emphasis> каталога.</p>
     <p>lpNewFileName — указатель на строку, содержащую имя нового файла <emphasis>или</emphasis> каталога, которые, в случае функции MoveFile, до ее вызова существовать не должны. Новый файл может принадлежать другой файловой системе или находиться на другом диске, но новые каталоги обязательно должны находиться на одном и том же диске. Если значение этого параметра положить равным NULL, то существующий файл будет удален.</p>
     <p>dwFlags — позволяет задавать следующие опции:</p>
     <p>• MOVEFILE_REPLACE_EXISTING — разрешает замену существующего файла.</p>
     <p>• MOVEFILE_WRITETHROUGH — используйте этот флаг, если необходимо, чтобы функция выполнила возврат лишь после того, как файл будет фактически перемещен на диске.</p>
     <p>• MOVEFILE_COPY_ALLOWED — если новый файл находится на другом томе, перемещение осуществляется путем последовательного выполнения функций CopyFile и DeleteFile.</p>
     <p>• MOVEFILE_DELAY_UNTIL_REBOOT — установка этого флага, использование которого является прерогативой администратора системы и который не может применяться совместно с флагом MOVEFILE_COPY_ALLOWED, приводит к тому, что фактическое перемещение файла будет осуществлено только после перезагрузки системы.</p>
     <p>С перемещением (переименованием) файлов связаны некоторые ограничения.</p>
     <p>• В Windows 9x функция MoveFileEx не реализована; вместо нее вы должны использовать последовательные вызовы функций CopyFile и DeleteFile. Это делает возможным одновременное существование двух экземпляров файла, что порождает определенные проблемы в случае дисков, близких к заполнению, или файлов большого размера. При этом временные атрибуты файлов изменяются иначе, нежели при истинном перемещении.</p>
     <p>• Использование групповых символов в именах файлов или каталогов запрещено. Необходимо указывать фактические имена. </p>
     <cite>
      <p>Полные имена файлов в UNIX не включают имен дисков и серверов; корневой системный каталог обозначается обратной косой чертой. В то же время, функции для работы с файлами, входящие в библиотеку Microsoft С, поддерживают имена дисков, как того требуют соглашения Windows относительно именования файлов.</p>
      <p>В UNIX отсутствует функция непосредственного копирования файлов. Вместо этого, чтобы выполнить команду cp, вы должны написать небольшую программу или использовать системный вызов system ().</p>
      <p>В UNIX эквивалентом функции DeleteFile служит функция unlink, которая, к тому же, может удалять и каталоги.</p>
      <p>В библиотеку С входят функции rename и remove, однако функция remove не позволяет присваивать файлу имя уже существующего файла или присваивать каталогу имя существующего непустого каталога. Новое имя может совпадать с именем существующего каталога только в том случае, если этот каталог пустой.</p>
     </cite>
    </section>
    <section>
     <title>
      <p>Управление каталогами</p>
     </title>
     <p>Создание и удаление каталогов осуществляется при помощи двух простых функций. </p>
     <cite>
      <p><code>BOOL CreateDirectory(LPCTSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)</code></p>
      <p><code>BOOL RemoveDirectory(LPCTSTR lpPathName)</code></p>
     </cite>
     <p>lpPathName является указателем на завершающуюся нулевым символом строку, которая содержит путь к создаваемому или удаляемому каталогу. Как и в случае других функций, на данном этапе атрибуты защиты файла должны полагаться равными NULL; вопросы безопасности файлов и объектов рассматриваются в главе 15. Удалить можно только пустой каталог.</p>
     <p>Как и в UNIX, у каждого процесса имеется текущий, или рабочий, каталог. Кроме того, для каждого диска поддерживается свой рабочий каталог. Программист может как устанавливать рабочий каталог, так и получать информацию о том, какой каталог в данный момент является текущим. Первая функция предназначена для установки каталогов.</p>
     <cite>
      <p><code>BOOL SetCurrentDirectory(LPCTSTR lpPathName)</code> </p>
     </cite>
     <p>lpPathName определяет путь к новому текущему каталогу. Это может быть относительный путь или абсолютный полный путь, в начале которого указаны либо буква диска и двоеточие (например, D:), либо имя UNC (например, \\ACCTG_SERVER\PUBLIC).</p>
     <p>Если в качестве пути к каталогу указывается только имя диска (например, А: или С:), то рабочим каталогом становится рабочий каталог данного диска. Например, если рабочие каталоги устанавливались в последовательности:</p>
     <p><code>C:\MSDEV </code></p>
     <p><code>INCLUDE </code></p>
     <p><code>A:\MEMOS\TODO </code></p>
     <p><code>С:</code></p>
     <p>то результирующим рабочим каталогом будет:</p>
     <p><code>C:\MSDEV\INCLUDE</code></p>
     <p>Следующая функция возвращает абсолютный полный путь к текущему каталогу, помещая его в буфер, предоставляемый программистом: </p>
     <cite>
      <p><code>DWORD GetCurrentDirectory(DWORD cchCurDir, LPTSTR lpCurDir)</code></p>
      <p><strong>Возвращаемое значение</strong>: длина строки, содержащей путь доступа к текущему каталогу, или требуемый размер буфера, если буфер не достаточно велик; в случае ошибки — нуль.</p>
     </cite>
     <p>cchCurDir — размер буфера, содержащего имя каталога, который определяется количеством символов (а не байт). Размер буфера должен рассчитываться с учетом завершающего нулевого символа строки. lpCurDir является указателем на буфер, предназначенный для получения строки, содержащей путь.</p>
     <p>Заметьте, что в случае если размер буфера оказался недостаточным для того, чтобы в нем уместилась вся строка пути, функция возвратит значение, указывающее на требуемый размер буфера. Поэтому при тестировании успешности выполнения функции следует проверять два условия: равно ли возвращаемое значение нулю и не превышает ли оно значение, заданное аргументом cchCurDir.</p>
     <p>Подобный метод возврата строк и их длины широко распространен в Windows и требует внимательной обработки результатов. Программа 2.6 иллюстрирует типичный фрагмент кода, реализующего эту логику. Аналогичная логика реализуется и в других примерах. Вместе с тем, указанный метод применяется не всегда. Некоторые функции возвращают булевские значения, а параметр размера в них используется дважды: перед вызовом функции его значение устанавливается равным размеру буфера, а затем изменяется функцией. В качестве одного из многих возможных примеров можно привести функцию LookupAccountName, с которой вы встретитесь в главе 15. </p>
     <p>Альтернативный подход, демонстрируемый в программе 15.4 функцией GetFileSecurity, заключается в выделении буферной памяти в промежутке между двумя вызовами функций. Первый вызов обеспечивает получение длины строки, на основании чего и выделяется память, тогда как второй — получение самой строки. Самым простым подходом в данном случае является выделение памяти для строки, насчитывающей МАХ_РАТН символов.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: печать текущего каталога</p>
    </title>
    <p>Программа 2.6 реализует очередную версию команды UNIX pwd. Размер буфера определяется значением параметра МАХ_РАТН, однако проверка ошибок все равно предусмотрена, чтобы проиллюстрировать работу функции GetCurrent-Directory.</p>
    <subtitle>Программа 2.6. pwd: печать текущего каталога </subtitle>
    <p><code>/* Глава 2. pwd – вывод на печать содержимого рабочего каталога. */</code></p>
    <p><code>#include "EvryThng.h"</code></p>
    <p><code>#define DIRNAME_LEN MAX_PATH + 2</code></p>
    <empty-line/>
    <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> TCHAR pwdBuffer [DIRNAME_LEN];</code></p>
    <p><code> DWORD LenCurDir;</code></p>
    <p><code> LenCurDir = GetCurrentDirectory(DIRNAME_LEN, pwdBuffer);</code></p>
    <p><code> if (LenCurDir == 0) ReportError(_T("He удается получить путь."), 1, TRUE);</code></p>
    <p><code> if (LenCurDir &gt; DIRNAME_LEN) ReportError(_T("Слишком длинный путь."), 2, FALSE);</code></p>
    <p><code> PrintMsg(GetStdHandle(STD_OUTPUT_HANDLE), pwdBuffer);</code></p>
    <p><code> return 0; </code></p>
    <p><code>}</code> </p>
   </section>
   <section>
    <title>
     <p>Резюме</p>
    </title>
    <section>
     <p>Наряду с функциями, предназначенными для обработки символов, в Windows поддерживается полный набор функций, обеспечивающих управление файлами и каталогами. Кроме того, вы можете создавать переносимые, обобщенные приложения, которые могут быть рассчитаны на работу как с символами ASCII, так и с символами Unicode.</p>
     <p>Функции Windows во многом напоминают их аналоги в UNIX и библиотеке С, хотя различия между ними также очевидны. В приложении Б представлена таблица, в которой сведены функции Windows, UNIX и библиотеки С и показано, в чем они соответствуют друг другу, а в чем заметно отличаются. </p>
    </section>
    <section>
     <title>
      <p>В следующих главах</p>
     </title>
     <p>Нашим следующим шагом будет обсуждение в главе 3 прямого доступа к файлам и использования таких атрибутов файлов и каталогов, как размер файла и метки времени. Кроме того, в главе 3 показано, как управлять каталогами, а в завершение главы обсуждается работа с API реестра, аналогичного API управления каталогами.</p>
    </section>
    <section>
     <title>
      <p>Дополнительная литература</p>
     </title>
     <subtitle><emphasis>Организация хранения данных в Windows и NTFS</emphasis></subtitle>
     <p>В книге [22] содержится исчерпывающее обсуждение всего спектра возможных вариантов организации хранения данных в Windows как на непосредственно подключенных, так и на сетевых устройствах. Наряду с внутренними деталями реализации описаны все последние достижения и успехи в данной области, а также прогресс в отношении повышения быстродействия устройств хранения данных.</p>
     <p>Книга [10] — это небольшая монография, в которой описаны цели и особенности реализации NTFS. Содержащаяся в ней информация пригодится вам как для этой, так и для следующей глав.</p>
     <subtitle><emphasis>Unicode</emphasis></subtitle>
     <p>В книге [19] показано, как использовать Unicode на практике. Изложение сопровождается различными рекомендациями, а также рассмотрением международных стандартов и вопросов программирования, связанных с учетом региональных особенностей.</p>
     <p>На домашней странице компании Microsoft вы найдете несколько полезных статей о стандарте Unicode. Основной является статья "Unicode Support in Win32" ("Поддержка Unicode в Win32"), отталкиваясь от которой вы, используя средства поиска, сможете отыскать все остальные.</p>
     <subtitle><emphasis>UNIX</emphasis></subtitle>
     <p>В главах 3 и 4 книги [40] рассматриваются файлы и каталоги UNIX, а в главе 11 — терминальный ввод/вывод.</p>
     <p>Для быстрого ознакомления с командами UNIX можете обратиться к книге [15].</p>
    </section>
   </section>
   <section>
    <title>
     <p>Упражнения</p>
    </title>
    <p>2.1. Напишите небольшую программу для тестирования обобщенных версий функций printf и scanf.</p>
    <p>2.2. Модифицируйте функцию CatFile в программе 2.3 таким образом, чтобы при связывании дескриптора стандартного вывода с консолью в ней использовалась не функция WriteFile, а функция WriteConsole.</p>
    <p>2.3. Параметры вызова функции CreateFile позволяют задавать различные характеристики способа доступа к файлу, что может быть использовано для повышения производительности программ. В качестве примера можно привести параметр FILE_FLAG_SEQUENTIAL_SCAN. Используйте этот флаг в программе 2.5 и выясните, приведет ли это к улучшению показателей производительности при работе с файлами большого размера. Результаты для нескольких систем приведены в приложении В. Исследуйте также влияние флага FILE_FLAG_NO_BUFFERING.</p>
    <p>2.4. Исследуйте, насколько ощутимы различия в производительности для файловых систем FAT и NTFS при использовании функции atou в случае преобразования файлов большого размера.</p>
    <p>2.5. Выполните программу 2.4 с использованием и без использования определения символической константы UNICODE. Как это влияет на результаты, если таковое влияние вообще наблюдается? Если имеется такая возможность, выясните, способны ли программы правильно выполняться в системах Windows 9x.</p>
    <p>2.6. Сопоставьте информацию, предоставляемую функциями perror (библиотека С) и ReportError в случае таких распространенных ошибок, как попытка открытия несуществующего файла.</p>
    <p>2.7. Протестируйте подавление функцией ConsolePrompt (программа 2.1) эхо-отображения клавиатурного ввода, используя ее для вывода запроса на ввод и подтверждение пароля пользователем.</p>
    <p>2.8. Выясните, что происходит, когда для вывода на консоль используются смешанные вызовы функций обобщенной библиотеки С и функций Windows WriteFile и WriteConsole. Дайте происходящему свое объяснение.</p>
    <p>2.9. Напишите программу сортировки массива строк Unicode. Изучите различия между случаями сортировки слов и строк с помощью функций lstrcmp и _tcscmp. Приводит ли использование функции lstrlen к получению иных результатов по сравнению с функцией _tcslen? Вам могут пригодиться содержащиеся в оперативной справочной системе Microsoft замечания в описании функции CompareString. </p>
    <p>2.10. Расширьте реализацию функции Options таким образом, чтобы она выводила сообщение об ошибке, если в командной строке указаны опции, которые отсутствуют в списке разрешенных опций, заданных в параметре OptionString данной функции.</p>
    <p>2.11. В приложении В приводятся данные о показателях производительности для копирования файлов и их преобразования при помощи функции atou с использованием различных вариантов реализации программы и файловых систем. Исследуйте с помощью тестовых программ показатели производительности на доступных вам системах. Кроме того, если возможно, исследуйте показатели производительности для сетевых файловых систем, SAN и так далее, чтобы выяснить, каким образом проявляются различия в организации хранения данных при осуществлении последовательного доступа к файлам.</p>
   </section>
  </section>
  <section>
   <title>
    <p>ГЛАВА 3</p>
    <p>Усовершенствованные средства для работы с файлами и каталогами и знакомство с реестром</p>
   </title>
   <section>
    <p>Файловые системы обеспечивают не только простую последовательную обработку файлов; кроме этого, они должны предоставлять возможности прямого доступа к файлам и блокирования файлов, а также предлагать средства для управления каталогами и атрибутами файлов. В данной главе, которая начинается с обсуждения прямого доступа к файлам, требуемого для обслуживания баз данных, обработки файлов и решения целого ряда других задач, демонстрируются методы непосредственного доступа к данным, находящимся в произвольном месте файла, которые обеспечиваются файловыми указателями. Для этого, в частности, нам надо будет обсудить использование 64-битовых указателей Windows, поскольку файловая система NTFS способна поддерживать файлы гигантских размеров.</p>
    <p>Далее будут рассмотрены методы просмотра каталогов, рассказано о том, что такое атрибуты файлов, такие, например, как метки времени, атрибуты прав доступа или размер файла, и показано, как управлять атрибутами и интерпретировать их. Наконец, вы ознакомитесь с тем, как использовать блокирование файлов с целью предотвращения попыток изменения их содержимого одновременно несколькими процессами.</p>
    <p>Завершает данную главу рассмотрение реестра Windows — централизованной базы данных, хранящей информация о конфигурации системы, которой могут пользоваться как приложения, так и сама операционная система. Приведенный в конце главы пример программы показывает, что функции, с помощью которых осуществляется доступ к реестру, и структура соответствующих программ напоминают те, которые применяются для управления файлами и каталогами, что и послужило причиной включения этой темы в данную главу.</p>
   </section>
   <section>
    <title>
     <p>64-битовая файловая система</p>
    </title>
    <p>Win32 и Win64, работающие с NTFS, поддерживают 64-битовую адресацию в файлах, и поэтому допустимыми являются файлы размером до 2<emphasis>64</emphasis> байт.</p>
    <p>В 32-разрядных файловых системах, характеризующихся наличием 2<emphasis>32</emphasis> –байтового предела, допустимый размер файлов ограничивается величиной 4 Гбайт (4х10<emphasis>9</emphasis> байт). Для некоторых приложений, включая крупные базы данных и мультимедийные системы, это ограничение носит серьезный характер, что вынуждает современные ОС обеспечивать поддержку файлов гораздо больших размеров. Файлы, размеры которых превышают 4 Гбайт, иногда называют <emphasis>гигантскими</emphasis> (huge).</p>
    <p>Вполне очевидно, что многим приложения гигантские файлы никогда не понадобятся, так что большинству программистов на протяжении ближайших нескольких лет возможностей 32-битовой файловой адресации будет вполне достаточно. Однако, с учетом темпов технической модернизации и увеличения емкости дисков<a l:href="#n_14" type="note">[14]</a>, улучшения их стоимостных показателей и повышения уровня требований со стороны приложений, целесообразно уже с самого начала работы над новым проектом предусмотреть возможность использования 64-битовых адресов.</p>
    <p>Несмотря на возможность использования 64-битовой адресации файлов и поддержку гигантских файлов, интерфейс Win32, в силу его привязки к 32-битовой адресации памяти, о чем говорится в главе 5, остается API 32-битовой ОС, так что для работы с 64-битовыми адресами памяти нам потребуется интерфейс Win64.</p>
   </section>
   <section>
    <title>
     <p>Указатели файлов</p>
    </title>
    <section>
     <p>В Windows аналогично тому, как это предусмотрено в UNIX, библиотеке С и почти любой другой ОС, для каждого дескриптора открытого файла поддерживается <emphasis>указатель файла</emphasis> (file pointer), отмечающий позицию текущего байта в данном файле. Именно эта позиция служит отправной точкой для последующей передачи данных при выполнении очередной операции WriteFile или ReadFile, что сопровождается увеличением значения указателя файла на соответствующее количество переданных байт. При открытии файла путем вызова функции CreateFile указатель файла принимает нулевое значение, отмечающее начало файла, которое изменяется по мере чтения или записи каждого очередного байта. Ключевую роль в обеспечении возможности прямого доступа к данным, хранящимся в файле, играет функция SetFilePointer, позволяющая устанавливать значения указателя файла.</p>
     <p>Функция SetFilePointer является первой из функций, на примере которых мы познакомимся с обработкой 64-битовых указателей файлов NTFS. Методы, основанные на этой функции, не всегда удобны в применении, и поэтому функцию SetFilePointer проще всего использовать в случае небольших файлов.</p>
     <cite>
      <p><code>DWORD SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)</code></p>
      <p><strong>Возвращаемое значение: </strong>младшее двойное слово (DWORD, беззнаковое) нового значения указателя файла. Старшая часть значения этого указателя помещается в двойное слово, на которое указывает указатель lpDistanceToMoveHigh (если он отличен от NULL). В случае неудачного завершения функция возвращает значение 0xFFFFFFFF.</p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>hFile — дескриптор файла, который должен быть создан с правами доступа по чтению или по записи (или с правами доступа одновременно обоих типов).</p>
     <p>IDistanceToMove — 32-битовое число типа LONG <emphasis>со знаком,</emphasis> указывающее величину смещения, на которое должен быть перемещен указатель файла, или число типа LONG <emphasis>без знака,</emphasis> указывающее позицию, в которую должен быть перемещен указатель файла, в зависимости от значения параметра dwMoveMethod.</p>
     <p>lpDistanceToMoveHigh — указатель на старшую часть 64-битового смещения, на которое должен быть перемещен указатель файла. Если значение этого параметра задано равным NULL, то функция может применяться только к файлам, размер которых не превышает 2&#179;&#178;–2 (в байтах). Этот же параметр используется для получения старшей части возвращаемого функцией значения указателя файла.<a l:href="#n_15" type="note">[15]</a> Младшую часть указателя файла возвращает сама функция.</p>
     <p>dwMoveMethod — этот параметр устанавливает один из трех возможных режимов перемещения указателя файла.</p>
     <p>• FILE_BEGIN — указатель файла позиционируется относительно начала файла, причем параметр DistanceToMove интерпретируется как беззнаковое число.</p>
     <p>• FILE_CURRENT — указатель файла перемещается в сторону больших или меньших значений относительно текущей позиции, причем параметр DistanceToMove интерпретируется как число со знаком. Положительным значениям соответствует перемещение указателя файла в сторону больших значений. </p>
     <p>• FILE_END — указатель файла перемещается в сторону больших или меньших значений относительно позиции конца файла.</p>
     <p>Эту функцию можно использовать для получения размера файла, задав нулевое смещение указателя от позиции конца файла.</p>
     <p>Описанный метод представления 64-битовых указателей файлов становится причиной некоторых затруднений, поскольку возвращенное функцией значение может представлять как действительную позицию указателя файла, так и код ошибки. Рассмотрите, например, случай, когда фактической позиции указателя соответствует значение 2&#179;&#178;–1 (то есть, 0xFFFFFFFF), а при вызове функции указывается ненулевое значение старшей части перемещения указателя файла. Чтобы определить, представляет ли значение, возвращенное функцией SetFile-Pointer, действительную позицию указателя файла или же код ошибки, следует вызвать функцию GetLastError, возвращаемым значением которой в случае неудачного завершения не может быть NO_ERROR. Из этих рассуждений становится ясно, почему размеры файлов не могут превышать значения 2&#179;&#178;–2, если при вызове функции SetFilePointer старшая часть указателя файла опускается.</p>
     <p>Дополнительную неразбериху привносит тот факт, что старшая и младшая компоненты указателя файла отделены друг от друга и обрабатываются по-разному. Младшая часть определяется через передачу параметра по значению и равна возвращаемому значению функции, тогда как для старшей части применяется передача параметра по ссылке, и этот параметр используется как в качестве входного, так и выходного.</p>
     <p>К счастью, 32-битовой адресации вам будет вполне достаточно для большинства задач программирования. Тем не менее, приведенные в книге примеры программ рассчитаны на далекую перспективу и используют, "как и положено", 64-битовую арифметику.</p>
    </section>
    <section>
     <title>
      <p>64-битовая арифметика</p>
     </title>
     <p>Арифметика 64-битовых указателей файлов не так уж сложна, и для ее реализации в примерах программ используется принятый в Microsoft С 64-битовый тип данных LARGE_INTEGER, объединяющий в одном типе данных union величину типа LONGLONG (носящую название QuadPart) и две 32-битовые величины (LowPart типа DWORD и, HighPart типа LONG). Тип данных LONGLONG поддерживает все арифметические операции. Существует также соответствующий тип данных без знака ULONGLONG. </p>
     <cite>
      <p>Аналогами функции SetFilePointer являются функции lseek (UNIX) и fseek (библиотека С). В обеих упомянутых системах выполнение операций чтения или записи также сопровождается перемещением указателя файла. </p>
     </cite>
    </section>
    <section>
     <title>
      <p>Указание позиции файла с помощью структуры OVERLAPPED</p>
     </title>
     <p>Для указания позиции в файле Windows предоставляет еще один способ, не требующий использования функции SetFilePointer. Вспомните, что последним параметром в обеих функциях ReadFile и WriteFile является адрес структуры перекрытия OVERLAPPED, который в предыдущих примерах всегда полагался равным NULL. В структуру перекрытия входят элементы Offset и OffsetHigh. Устанавливая соответствующие значения элементов структуры OVERLAPPED, вы можете добиться того, чтобы выполнение операций ввода/вывода начиналось с указанной позиции. В отличие от указателя файла, значение которого изменяется, соответствуя позиции, следующей за последним переданным байтом, значения элементов структуры OVERLAPPED остаются неизменными. Элементом этой структуры является также дескриптор hEvent, значение которого должно устанавливаться равным NULL.</p>
     <cite>
      <p><strong>Примечание</strong></p>
      <p>Под управлением Windows 9x описанный метод работать не будет, поскольку в этом случае указатель структуры OVERLAPPED при обработке файлов должен устанавливаться равным NULL.</p>
     </cite>
     <cite>
      <p><strong>Предостережение</strong></p>
      <p>Хотя в рассмотренном примере и используется структура OVERLAPPED, здесь не идет речь о перекрывающемся вводе/выводе, который обсуждается в главе 14.</p>
     </cite>
     <p>Использование структуры OVERLAPPED оказывается особенно удобным в тех случаях, когда требуется обновить запись в файле, что иллюстрирует приведенный ниже фрагмент программного кода; в противном случае вы должны были бы перед каждым вызовом функций ReadFile и WriteFile отдельно вызывать функцию SetFilePointer. Последним из пяти полей структуры OVERLAPPED является поле hEvent, как это видно из оператора инициализации. Для хранения вычисленного значения позиции в файле используется переменная FilePos типа LARGE_INTEGER.</p>
     <p><code>OVERLAPPED ov = { 0, 0, 0, 0, NULL };</code></p>
     <p><code>RECORD r; /* Хотя определение этой структуры не приведено, в ней имеется поле RefCount. */ </code></p>
     <p><code>LONGLONG n;</code></p>
     <p><code>LARGE_INTEGER FilePos; </code></p>
     <p><code>DWORD nRead, nWrite;</code></p>
     <p><code>…</code></p>
     <p><code>/* Обновить счетчик, чтобы он соответствовал n-й записи. */</code></p>
     <p><code>FilePos.QuadPart = n * sizeof(RECORD);</code></p>
     <p><code>ov.Offset = FilePos.LowPart;</code></p>
     <p><code>ov.OffsetHigh = FilePos.HighPart;</code></p>
     <p><code>ReadFile(hFile, r, sizeof(RECORD), &amp;nRead, &amp;ov);</code></p>
     <p><code>r.RefCount++; /* Обновить запись. */</code></p>
     <p><code>WriteFile(hFile, r, sizeof(RECORD), &amp;nWrite, &amp;ov); </code></p>
     <p>Если дескриптор файла был создан за счет вызова функции CreateFile с установленным флагом FILE_FLAG_NO_BUFFERING, то как смещение позиции в файле, так и размер записи (количество байт) должны быть кратными размеру сектора диска. Соответствующую информацию относительно физического диска, включая информацию о размере сектора, возвращает функция GetDiskFreeSpace.</p>
     <p>Структуры OVERLAPPED будут вновь использованы далее в этой главе для указания областей блокирования файлов и в главе 14 для выполнения операций асинхронного ввода/вывода и прямого доступа к файлам.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Определение размера файла</p>
    </title>
    <section>
     <p>Размер файла можно получить, используя значение указателя файла, возвращаемое функцией SetFilePointer, если при вызове этой функции задать количество байтов, на которое должен быть перемещен указатель файла, равным 0. Для этой же цели можно воспользоваться также функцией GetFileSize. </p>
     <cite>
      <p><code>DWORD GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)</code></p>
      <p><strong>Возвращаемое значение: </strong>младшая компонента размера файла. Значение 0xFFFFFFFF указывает на возможную ошибку; для проверки наличия ошибок следует использовать функцию GetLastError.</p>
     </cite>
     <p>Обратите внимание, что для возвращения размера файла используется, по сути, тот же способ, что и для возвращения фактического указателя файла функцией SetFilePointer.</p>
     <p>Функции GetFileSize и GetFileSizeEx (возвращающая 64-битовое значение размера файла в одном элементе данных) требуют указания дескриптора, открытого для файла. Для определения размера файла можно применять также имя файла. Функция GetCompressedFileSize возвращает размер сжатого файла, тогда как функция FindFirstFile, которая обсуждается в разделе "Атрибуты файлов и управление каталогами" далее в этой главе, предоставляет точный размер именованного файла.</p>
    </section>
    <section>
     <title>
      <p>Установка размера файла, инициализация файла и разреженные файлы</p>
     </title>
     <p>Функция SetEndOfFile позволяет переустановить размер файла, используя текущее значение указателя файла для определения его размера. Возможно как расширение, так и усечение файла. В случае расширения файла содержимое области расширения не определено. Файл будет фактически потреблять выделенные квоты дискового и пользовательского пространств, если только не является разреженным. Файлы можно сжимать с целью уменьшения объема занимаемого ими пространства. Этот вопрос исследуется в упражнении 3.1.</p>
     <p>Функция SetEndOfFile устанавливает физический конец файла. Прежде чем выполнять эту операцию, на которую может уйти довольно длительное время, необходимое для записи данных файл с целью его заполнения, можно установить также логический конец файла, используя для этого функцию SetValidFileData. Эта функция определяет ту часть файла, которая, в соответствии с вашими предположениями, в настоящий момент содержит достоверные данные, благодаря чему вы сможете сэкономить время при установке физического конца файла. Часть файла, заключенная между его логическим и физическим концами, называется <emphasis>хвостовиком</emphasis> (tail) и может быть сокращена путем записи оставшихся данных после логического конца файла или в результате дополнительного вызова функции SetValidFileData.</p>
     <p>В случае разреженных файлов (sparse files), появившихся в Windows 2000, дисковое пространство расходуется лишь по мере записи данных. Администратор может назначать, какие файлы, каталоги или тома должны быть разреженными. Кроме того, можно назначить существующий файл в качестве разреженного с помощью функции DeviceIoControl, если установить при ее вызове флаг FSCTL_SET_SPARSE. Ситуацию, в которой удобно использовать разреженные файлы, иллюстрирует программа 3.1. К разреженным файлам функция SetValidFileData неприменима.</p>
     <p>Файлы FAT нулями автоматически <emphasis>не</emphasis> инициализируются. Согласно документации Microsoft содержимое вновь созданных файлов не определено, что подтверждается экспериментами. Поэтому, если для корректной работы требуется инициализация файлов, приложения должны это делать самостоятельно путем вызова функции WriteFile. Файлы NTFS будут инициализированы, поскольку уровень безопасности С2, обеспечиваемый Windows, требует, чтобы чтение содержимого удаленных файлов было невозможным.</p>
     <p>Обратите внимание, что кроме функции SetEndOfFile существуют и другие способы расширения размера файла. Так, можно расширить файл, используя ряд последовательных операций записи, хотя при этом существует риск увеличения степени фрагментации файла; размещение на диске файлов в виде непрерывных блоков большого размера функция SetEndOfFile отдает на откуп операционной системе.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: обновление записей, находящихся в произвольном месте файла</p>
    </title>
    <p>Программа RecordAccess (программа 3.1) обеспечивает поддержку файлов фиксированного размера, состоящих из записей фиксированного размера. В заголовке файла хранится количество непустых записей, содержащихся в файле, а также емкость файла. Пользователю предоставляется возможность выполнять в интерактивном режиме чтение, запись (обновление) и удаление записей, каждая из которых содержит метки времени, текстовую строку и счетчик, показывающий, сколько раз запись изменялась. В качестве несложного и реалистичного расширения возможностей программы можно было бы добавить в структуру записи ключ и определять местоположение записей в файле путем применения хэш-функции к значениям ключа.</p>
    <p>Программа демонстрирует позиционирование указателя файла перед заданной записью, а также выполнение 64-битовых арифметических операций с использованием данных типа LARGE_INTEGER Microsoft С. Чтобы проиллюстрировать логику работы указателей файла, в программу включен код, проверяющий наличие ошибок. Программа в целом иллюстрирует применение файловых указателей и множественных структур OVERLAPPED, а также обновление файлов с использованием 64-битовых файловых указателей.</p>
    <p>Общее количество записей в файле указывается в командной строке; при большом количестве записей размеры создаваемых файлов могут быть очень большими и даже гигантскими, поскольку длина одной записи составляет примерно 300 байт. После выполнения нескольких экспериментов вы убедитесь, что большие файлы должны быть разреженным; в противном случае необходимо размещать и инициализировать на диске весь файл целиком, в результате чего может существенно увеличиться время обработки файла и занимаемое им место на диске. Хотя в листинге программы 3.1 это и не отражено, в программе предусмотрен участок кода, обеспечивающий создание разреженных файлов, если в этом возникает необходимость; в некоторых системах, например Windows XP Home, этот код правильно работать не сможет.</p>
    <p>На Web-сайте книги предоставляются три дополнительные программы, родственные этой: tail.с — другой пример реализации произвольного доступа к файлу, getn.c — упрощенная версия программы RecordAccess, обеспечивающая лишь чтение записей, и atouMT (включена в программы для главы 14, находящиеся на Web-сайте, однако не включена в программы, приведенные в книге), также иллюстрирующая прямой доступ к файлам.</p>
    <subtitle>Программа 3.1. RecordAccess </subtitle>
    <p><code>/* Глава 3. RecordAccess. */</code></p>
    <p><code>/* Использование: RecordAccess имя файла [количество записей]</code></p>
    <p><code>Количество записей (nrec) можно не указывать, если файл с указанным именем уже существует. Если количество записей (nrec) задано, создается файл с указанным именем (если файл с таким именем существует, он уничтожается). При большом количестве записей (nrec) файлы рекомендуется создавать как разреженные. */</code></p>
    <p><code>/* Программа иллюстрирует:</code></p>
    <p><code>1. Произвольный доступ к файлам.</code></p>
    <p><code>2. Арифметику данных типа LARGE_INTEGER и использование 64-битовых указателей файла.</code></p>
    <p><code>3. Обновление записей на месте.</code></p>
    <p><code>4. Запись в файл нулей во время инициализации (требует использования файловой системы NTFS).</code></p>
    <p><code>*/</code></p>
    <empty-line/>
    <p><code>#include "EvryThng.h" </code></p>
    <p><code>#define STRING_SIZE 256</code></p>
    <p><code>typedef struct _RECORD { /* Структура записи в файле */</code></p>
    <p><code> DWORD ReferenceCount; /* 0 означает пустую запись. */</code></p>
    <p><code> SYSTEMTIME RecordCreationTime;</code></p>
    <p><code> SYSTEMTIME RecordLastReferenceTime;</code></p>
    <p><code> SYSTEMTIME RecordUpdateTime;</code></p>
    <p><code> TCHAR DataString[STRING_SIZE]; </code></p>
    <p><code>} RECORD;</code></p>
    <p><code>typedef struct _HEADER { /* Дескриптор заголовка файла */</code></p>
    <p><code> DWORD NumRecords;</code></p>
    <p><code> DWORD NumNonEmptyRecords; </code></p>
    <p><code>} HEADER;</code></p>
    <empty-line/>
    <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> HANDLE hFile;</code></p>
    <p><code> LARGE_INTEGER CurPtr;</code></p>
    <p><code> DWORD FPos, OpenOption, nXfer, RecNo;</code></p>
    <p><code> RECORD Record;</code></p>
    <p><code> TCHAR String[STRING_SIZE], Command, Extra;</code></p>
    <p><code> OVERLAPPED ov = {0, 0, 0, 0, NULL}, ovZero = {0, 0, 0, 0, NULL};</code></p>
    <p><code> HEADER Header = {0, 0};</code></p>
    <p><code> SYSTEMTIME CurrentTime;</code></p>
    <p><code> BOOLEAN HeaderChange, RecordChange;</code></p>
    <p><code> OpenOption = (argc == 2) ? OPEN_EXISTING : CREATE_ALWAYS;</code></p>
    <p><code> hFile = CreateFile(argv[1], GENERIC_READ | GENERIC_WRITE, 0, NULL, OpenOption, FILE_ATTRIBUTE_NORMAL, NULL);</code></p>
    <p><code> if (argc &gt;= 3) { /* Записать заголовок и заранее установить размер нового файла */</code></p>
    <p><code>  Header.NumRecords = atoi(argv[2]);</code></p>
    <p><code>  WriteFile(hFile, &amp;Header, sizeof(Header), &amp;nXfer, &amp;ovZero);</code></p>
    <p><code>  CurPtr.QuadPart = sizeof(RECORD)*atoi(argv[2])+sizeof(HEADER);</code></p>
    <p><code>  FPos = SetFilePointer(hFile, CurPtr.LowPart, &amp;CurPtr.HighPart, FILE_BEGIN);</code></p>
    <p><code>  if (FPos == 0xFFFFFFFF &amp;&amp; GetLastError() != NO_ERROR) ReportError(_T("Ошибка указателя."), 4, TRUE);</code></p>
    <p><code>  SetEndOfFile(hFile);</code></p>
    <p><code> }</code></p>
    <p><code> /* Считать заголовок файла: определить количество записей и количество непустых записей. */</code></p>
    <p><code> ReadFile(hFile, &amp;Header, sizeof(HEADER), &amp;nXfer, &amp;ovZero);</code></p>
    <p><code> /* Предложить пользователю считать или записать запись с определенным номером. */</code></p>
    <p><code> while(TRUE) {</code></p>
    <p><code>  HeaderChange = FALSE;</code></p>
    <p><code>  RecordChange = FALSE;</code></p>
    <p><code>  _tprintf(_Т("Введите r(ead)/w(rite)/d(elete)/q Запись#\n"));</code></p>
    <p><code>  _tscanf(_T("%c" "%d" "%c"), &amp;Command, &amp;RecNo, &amp;Extra );</code></p>
    <p><code>  if (Command == 'q') break;</code></p>
    <p><code>  CurPtr.QuadPart = RecNo * sizeof(RECORD) + sizeof(HEADER);</code></p>
    <p><code>  ov.Offset = CurPtr.LowPart;</code></p>
    <p><code>  ov.OffsetHigh = CurPtr.HighPart;</code></p>
    <p><code>  ReadFile(hFile, &amp;Record, sizeof(RECORD), &amp;nXfer, &amp;ov);</code></p>
    <p><code>  GetSystemTime(&amp;CurrentTime); /* Обновить поля даты и времени в записи. */</code></p>
    <p><code>  Record.RecordLastRefernceTime = CurrentTime;</code></p>
    <p><code>  if (Command == 'r' || Command == 'd') { /*Вывести содержимое записи.*/</code></p>
    <p><code>   if (Record.ReferenceCount == 0) {</code></p>
    <p><code>    _tprintf(_T("Запись номер %d – пустая.\n"), RecNo);</code></p>
    <p><code>    continue;</code></p>
    <p><code>   } else {</code></p>
    <p><code>    _tprintf(_Т("Запись номер %d. Значение счетчика: %d \n"), RecNo, Record.ReferenceCount);</code></p>
    <p><code>    _tprintf(_Т("Данные: %s\n"), Record.DataString);</code></p>
    <p><code>    /* Упражнение: вывести метки времени. См. следующий пример. */</code></p>
    <p><code>    RecordChange = TRUE;</code></p>
    <p><code>   }</code></p>
    <p><code>   if (Command == 'd') { /* Удалить запись. */</code></p>
    <p><code>    Record.ReferenceCount = 0;</code></p>
    <p><code>    Header.NumNonEmptyRecords--;</code></p>
    <p><code>    HeaderChange = TRUE;</code></p>
    <p><code>    RecordChange = TRUE;</code></p>
    <p><code>   }</code></p>
    <p><code>  } else if (Command == 'w') { /* Записать данные. Впервые? */</code></p>
    <p><code>   _tprintf(_Т("Введите новую строку для записи.\n"));</code></p>
    <p><code>   _getts(String);</code></p>
    <p><code>   if (Record.ReferenceCount == 0) {</code></p>
    <p><code>    Record.RecordCreationTime = CurrentTime;</code></p>
    <p><code>    Header.NumNonEmptyRecords++;</code></p>
    <p><code>    HeaderChange = TRUE;</code></p>
    <p><code>   }</code></p>
    <p><code>   Record.RecordUpdateTime = CurrentTime;</code></p>
    <p><code>   Record.ReferenceCount++;</code></p>
    <p><code>   _tcsncpy(Record.DataString, String, STRING_SIZE-1);</code></p>
    <p><code>   RecordChange = TRUE;</code></p>
    <p><code>  } else {</code></p>
    <p><code>   _tprintf(_T("Допустимые команды: r, w и d. Повторите ввод.\n"));</code></p>
    <p><code>  }</code></p>
    <p><code>  /* Обновить запись на месте, если ее содержимое изменилось. */</code></p>
    <p><code>  if (RecordChange) WriteFile(hFile, &amp;Record, sizeof(RECORD), &amp;nXfer, &amp;ov);</code></p>
    <p><code>  /* При необходимости обновить количество непустых записей. */</code></p>
    <p><code>  if (HeaderChange) WriteFile(hFile, &amp;Header, sizeof(Header), &amp;nXfer, &amp;ovZero);</code></p>
    <p><code> }</code></p>
    <p><code> _tprintf(_T("Вычисленное количество непустых записей: %d\n"), Header.NumNonEmptyRecords);</code></p>
    <p><code> CloseHandle(hFile);</code></p>
    <p><code> return 0; </code></p>
    <p><code>}</code> </p>
   </section>
   <section>
    <title>
     <p>Атрибуты файлов и управление каталогами</p>
    </title>
    <section>
     <p>Существует возможность просмотра указанного каталога с целью поиска файлов и других каталогов, имена которых соответствуют заданному шаблону, одновременно с получением атрибутов файлов. Для выполнения поиска требуется дескриптор поиска (search handle), получаемый с помощью функции FindFirstFile. Для нахождения файлов, имена которых удовлетворяют заданным условиям, используется функция FindNextFile, а для прекращения поиска — функция FindClose. </p>
     <cite>
      <p><code>HANDLE FindFirstFile(LPCTSTR lpFileName, LPWIN32_FIND_DATA lpffd)</code></p>
      <p><strong>Возвращаемое значение: </strong>дескриптор поиска. Значение INVALID_HANDLE_VALUE указывает на неудачное завершение функции.</p>
     </cite>
     <p>В процессе поиска имен, соответствующих искомому, функция FindFirstFile проверяет имена не только файлов, но и подкаталогов. Возвращенное функцией значение дескриптора типа HANDLE используется для продолжения поиска.</p>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>lpFileName — указатель на строку, содержащую имя каталога или полное имя файла, при указании которых можно использовать метасимволы (? и *). Если необходимо осуществить поиск конкретного файла, метасимволы опускаются.</p>
     <p>lpffd — указатель на структуру WIN32_FIND_DATA, которая принимает информацию о первом найденном файле или каталоге, который удовлетворяет критерию поиска, если таковой был найден.</p>
     <p>Структура WIN32_FIND_DATA определяется следующим образом: </p>
     <cite>
      <p><code>typedef struct_WIN32_FIND_DATA {</code></p>
      <p><code> DWORD dwFileAttributes;</code></p>
      <p><code> FILETIME ftCreationTime;</code></p>
      <p><code> FILETIME ftLastAccessTime;</code></p>
      <p><code> FILETIME ftLastWriteTime;</code></p>
      <p><code> DWORD nFileSizeHigh;</code></p>
      <p><code> DWORD nFileSizeLow;</code></p>
      <p><code> DWORD dwReserved0;</code></p>
      <p><code> DWORD dwReserved1;</code></p>
      <p><code> TCHAR cFileName[MAX_PATH];</code></p>
      <p><code> TCHAR cAlternateFileName[14];</code></p>
      <p><code> } WIN32_FIND_DATA;</code> </p>
     </cite>
     <p>Параметр dwFileAttributes можно тестировать на присутствие значений, описанных при рассмотрении функции CreateFile, а также некоторых других значений, например, FILE_ATTRIBUTE_SPARSE_FILE или FILE_ATTRIBUTE_ENCRYTPED, которые не устанавливаются функцией CreateFile. Описание меток времени трех типов (время создания, время последнего обращения и время последнего изменения) приведено в одном из следующих разделов. Названия полей размера файла (nFileSizeHigh и nFileSizeLow) говорят сами за себя. cFileName — это не полное имя файла, содержащее путь доступа, а само имя файла. cAlternateFileName — имя файла в формате DOS 8.3 (включая точку); эта информация редко используется и может понадобиться лишь для того, чтобы определить, каким будет имя файла в файловой системе FAT16.</p>
     <p>Во многих случаях требуется просматривать каталог с целью поиска файлов, имена которых соответствуют некоторому шаблону, содержащему метасимволы ? и *. Для этого следует использовать дескриптор поиска, полученный из функции FindFirstFile, в котором содержится информация об искомом имени, и вызвать функцию FindNextFile. </p>
     <cite>
      <p><code>BOOL FindNextFile(HANDLE hFindFile, LPWIN32_FIND_DATA lpffd)</code> </p>
     </cite>
     <p>Функция FindNextFile возвращает значение FALSE, если аргументы недействительны или если не удается найти файл, удовлетворяющий критерию поиска, причем последнему случаю соответствует возвращаемое значение функции GetLastError, равное ERROR_NO_MORE_FILES.</p>
     <p>После того как поиск завершен, дескриптор поиска должен быть закрыт. Функцию CloseHandle для этой цели использовать нельзя. Это редкий пример нарушения правила, согласно которому функция CloseHandle применима к дескрипторам любого типа; в данном случае закрытие дескриптора поиска подобным способом приведет к генерации исключения. Вместо этого необходимо использовать следующую функцию: </p>
     <cite>
      <p><code>BOOL FindClose(HANDLE hFindFile) </code></p>
     </cite>
     <p>Функция GetFileInformationByHandle позволяет получить информацию о конкретном файле, на который указывает открытый дескриптор файла. Она также возвращает поле nNumberOfLinks, в котором содержится количество жестких ссылок на файл, установленных функцией CreateHardLink.</p>
     <p>Описанный метод расширения метасимволов необходим даже в программах, запускаемых на выполнение из командной строки DOS, поскольку оболочка DOS не расширяет метасимволы. </p>
    </section>
    <section>
     <title>
      <p>Полные имена файлов</p>
     </title>
     <p>Полное имя файла можно получить, используя функцию GetFullPathName. Функция GetShortPathName возвращает имя файла в формате DOS 8.3, в предположении, что данный том поддерживает короткие имена файлов.</p>
     <p>В NT 5.1 была введена функция SetFileShortName, позволяющая изменить существующее сокращенное имя файла или каталога. Иногда это оказывается удобным, поскольку интерпретация сокращенных имен файлов часто вызывает затруднения.</p>
    </section>
    <section>
     <title>
      <p>Другие методы определения атрибутов файлов и каталогов</p>
     </title>
     <p>Функции FindFirstFile и FindNextFile позволяют получить следующую информацию, связанную с атрибутами файла: флаги атрибутов, метки времени трех типов и размер файла. Существуют также другие аналогичные функции, одна из которых предназначена для задания атрибутов, причем эти функции могут работать непосредственно с открытыми дескрипторами файлов, не требуя просмотра каталогов или указания имен файлов. Три из этих функций, а именно, GetFileSize, GetFileSizeEx и SetEndOfFile, были описаны ранее в этой главе.</p>
     <p>Для получения других атрибутов используются отдельные функции. Например, чтобы получить метки времени открытого файла, следует вызвать функцию GetFileTime.</p>
     <cite>
      <p><code>BOOL GetFileTime(HANDLE hFile, LPFILETIME lpftCreation, LPFILETIME lpftLastAccess, LPFILETIME lpftLastWrite) </code></p>
     </cite>
     <p>Указанные здесь и в структуре WIN32_FIND_DATA метки времени представляют собой 64-битовые целые числа без знака, которые выражают величину временного интервала, вычисленную относительно условного начала отсчета (1 января 1601 года) и преобразованную во время UTC (Universal Coordinated Time — всеобщее скоординированное время)<a l:href="#n_16" type="note">[16]</a>, в 100-наносекундных единицах времени (10<sup>7 </sup>единиц в 1 секунде). Для работы с этими временными параметрами предусмотрено несколько удобных функций.</p>
     <p>• Функция FileTimeToSystemTime (здесь не описывается; см. справочную систему Windows и программу 3.2) разбивает метки времени файла на отдельные блоки, соответствующие естественным единицам измерения, от годов до секунд и миллисекунд. Эти блоки удобно, например, использовать при выводе временных атрибутов файлов на экран или принтер.</p>
     <p>• Функция SystemTimeToFileTime обращает этот процесс, преобразуя время, выраженное в естественных единицах, в метки времени файла.</p>
     <p>• Функция CompareFileTime сравнивает метки времени двух файлов и в случае успешного завершения возвращает значение, зависящее от того, меньше (-1), равно (0) или больше (+1) значение метки времени первого файла по сравнению со значением метки времени второго файла.</p>
     <p>• Для изменения меток времени служит функция SetFileTime; метки времени, не подлежащие изменению, при вызове функции указываются равными 0. NTFS поддерживает все три типа меток времени файлов, но FAT дает точные результаты только для меток времени последнего обращения.</p>
     <p>• Функции FileTimeToLocalFileTime и LocalFileTimeToFileTime преобразуют значения меток времени, соответственно, от всеобщего скоординированного времени UTC к местному времени и наоборот.</p>
     <p>Функция GetFileType, которая здесь подробно не описывается, позволяет различать файлы трех типов: дисковые, символьные (к ним, по сути, относятся такие устройства, как принтеры и консоли) и каналы (см. главу 11). Как и в большинстве других случаев, файл, характеристику которого необходимо определить, задается дескриптором.</p>
     <p>Функция GetFileAttributes принимает в качестве аргумента имя файла или каталога, а всю информацию об атрибутах передает через свое возвращаемое значение dwFileAttributes. </p>
     <cite>
      <p><code>DWORD GetFileAttributes(LPCTSTR lpFileName) </code></p>
      <p><strong>Возвращаемое значение: </strong>в случае успешного завершения — атрибуты файла, иначе — 0xFFFFFFFF.</p>
     </cite>
     <p>Для определения атрибутов можно воспользоваться логическим сравнением возвращаемого значения функции с соответствующими масками значений атрибутов. Некоторые атрибуты, например атрибут временного файла, изначально устанавливаются функцией CreateFile. В качестве примера можно привести следующие атрибуты:</p>
     <p>• FILE_ATTRIBUTE_DIRECTORY</p>
     <p>• FILE_ATTRIBUTE_NORMAL</p>
     <p>• FILE_ATTRIBUTE_READONLY</p>
     <p>• FILE_ATTRIBUTE_TEMPORARY</p>
     <p>Для изменения атрибутов именованных файлов служит функция SetFileAttributes. </p>
     <cite>
      <p>В UNIX трем вышеописанным функциям Find соответствуют функции opendir, readdir и closedir. Функция stat предоставляет размер файла и значения меток времени, а также информацию о его индивидуальном или групповом владельце, необходимую для защиты файлов в UNIX. Разновидностями этой функции являются функции fstat и lstat. Эти функции позволяют также получать информацию о типе файла. Метки времени файла в UNIX устанавливаются с помощью функции utime. Эквивалента атрибута временного файла в UNIX не существует.</p>
     </cite>
    </section>
    <section>
     <title>
      <p>Именование временных файлов</p>
     </title>
     <p>Следующая функция создает имена для временных файлов. Файл может находиться в любом заданном каталоге, и его имя должно быть уникальным.</p>
     <p>Функция GetTempFileName предоставляет уникальное имя файла с расширением .tmp, используя указанный путь доступа, и при необходимости создает файл. Эта функция широко используется в ряде следующих примеров (программа 6.1, программа 7.1 и другие). </p>
     <cite>
      <p><code>UINT GetTempFileName(LPCTSTR lpPathName, LPCTSTR lpPrefixString, UINT uUnique, LPTSTR lpTempFileName)</code></p>
      <p><strong>Возвращаемое значение: </strong>уникальное числовое значение, используемое для создания имени файла. Этим значением будет значение параметра uUnique, если при вызове функции оно было задано ненулевым. В случае неудачного завершения функции возвращаемое значение равно нулю. </p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>lpPathName — каталог, в котором размещается временный файл. Типичным значением этого параметра является строка ".", указывающая на текущий каталог. В других случаях можно воспользоваться функцией Windows GetTempPath, которая предоставляет имя каталога, используемого для хранения временных файлов, но нами здесь не рассматривается.</p>
     <p>lpPrefixString — префикс, используемый в имени временного файла. Допускаются лишь 8-битовые символы ASCII. Значение параметра uUnique обычно устанавливается равным нулю, чтобы функция самостоятельно сгенерировала уникальный четырехразрядный префикс и использовала его в имени создаваемого файла. При ненулевом значении этого параметра файл не создается, так что это необходимо сделать отдельно при помощи функции CreateFile, возможно — с использованием флага FILE_FLAG_DELETE_ON_CLOSE. </p>
     <p>lpTempFileName — указатель на буфер, предназначенный для хранения имени временного файла. Размер буфера, выраженный в байтах, должен быть не менее МАХРАТН. Результирующее полное имя файла получается объединением строк, соответствующих пути доступа к файлу, префикса, четырехразрядного шестнадцатеричного числа и суффикса .tmp.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Точки монтирования</p>
    </title>
    <p>NT 5.0 разрешает монтирование (или подключение) одной файловой системы в точке монтирования, находящейся в другой файловой системе. Обычно управление точками монтирования является прерогативой администратора системы, но эти же задачи можно решать и программным путем.</p>
    <p>Функция SetVolumeMountPoint монтирует диск (второй аргумент) в точке монтирования, указанной первым аргументом. Например, вызов </p>
    <p><code>SetVolumeMountPoint("С:\\mycd\\, "D:\\");</code></p>
    <p>монтирует диск D: (которому в персональных системах часто соответствует привод компакт-диска) в каталоге mycd (точка монтирования), находящемуся на диске С:. Обратите внимание на то, что обозначения всех путей доступа заканчиваются символами обратной косой черты. Тогда после применения этой функции пути доступа C:\mycd\memos\book.doc будет соответствовать путь доступа D:\memos\book.doc.</p>
    <p>Одну и ту же точку монтирования можно использовать для подключения нескольких файловых систем. Для размонтирования файловых систем служит функция DeleteMountPoint.</p>
    <p>Функция GetVolumePathName возвращает корневую точку монтирования абсолютного или относительного пути доступа или имени файла. В свою очередь, функция GetVolumeNameForVolumeMountPoint предоставляет имя тома, например, C:\, соответствующего точке монтирования.</p>
   </section>
   <section>
    <title>
     <p>Пример: вывод списка атрибутов файла</p>
    </title>
    <p>Настало время увидеть функции управления файлами и каталогами в действии. Программа 3.2 представляет собой ограниченную версию команды UNIX ls, предназначенной для вывода содержимого каталогов, которая позволяет вывести дату и время последнего изменения файла и размер файла, хотя данная версия отображает лишь младшую часть размера файла.</p>
    <p>Программа просматривает каталог для поиска файлов, соответствующих шаблону поиска. Для каждого найденного файла программа отображает имя файла и, если был задан параметр –1, то и его атрибуты. Данная программа иллюстрирует принцип построения многих, хотя и далеко не всех, функций Windows, предназначенных для работы с каталогами. </p>
    <p>Значительная часть кода программы 3.2 отвечает за обход дерева каталогов. Заметьте, что каждый каталог проходится дважды: при первом проходе обрабатываются файлы, а при втором — подкаталоги, чем обеспечивается поддержка параметра рекурсивного обхода каталогов (-R).</p>
    <p>В том виде, как она представлена ниже, программа 3.2 будет корректно выполняться в том случае, если при ее вызове используются относительные полные имена файлов, например:</p>
    <p><code>lsW –R include\*.h</code></p>
    <p>Вместе с тем, в результате указания абсолютного полного имени файла, например:</p>
    <p><code>lsW –R C:\Projects\ls\Debug\*.obj</code></p>
    <p>правильная работа программы будет нарушена, поскольку в ней самым существенным образом используется привязка каталогов к текущему каталогу. Завершенное решение (доступное на Web-сайте) анализирует абсолютные полные пути доступа к файлам и поэтому обеспечивает правильное выполнение программы и для второй команды.</p>
    <subtitle>Программа 3.2. lsw: вывод списка файлов и обход дерева каталогов </subtitle>
    <p><code>/* Глава 3. lsW — команда вывода списка файлов */ </code></p>
    <p><code>/* lsW [параметры] [файлы] */</code></p>
    <p><code>#include "EvryThng.h"</code></p>
    <p><code>BOOL TraverseDirectory(LPCTSTR, DWORD, LPBOOL);</code></p>
    <p><code>DWORD FileType(LPWIN32_FIND_DATA);</code></p>
    <p><code>BOOL ProcessItem(LPWIN32_FIND_DATA, DWORD, LPBOOL);</code></p>
    <empty-line/>
    <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> BOOL Flags [MAX_OPTIONS], ok = TRUE;</code></p>
    <p><code> TCHAR PathName [MAX_PATH +1], CurrPath [MAX_PATH + 1];</code></p>
    <p><code> LPTSTR pSlash, pFileName;</code></p>
    <p><code> int i, FileIndex;</code></p>
    <p><code> FileIndex = Options(argc, argv, _T("R1"), &amp;Flags[0], &amp;Flags[1], NULL);</code></p>
    <p><code> <emphasis>I*</emphasis> "Разобрать" шаблон поиска на "родительскую часть" и имя файла. */</code></p>
    <p><code> GetCurrentDirectory(MAX_PATH, CurrPath); /* Сохранить текущий путь доступа. */</code></p>
    <p><code> if (argc &lt; FileIndex +1) /* Путь доступа не указан. Использовать текущий каталог. */</code></p>
    <p><code>  ok = TraverseDirectory(_T("*"), MAX_OPTIONS, Flags);</code></p>
    <p><code> else for (i = FileIndex; i &lt; argc; i++) {</code></p>
    <p><code>  /* Обработать все пути, указанные в командной строке. */</code></p>
    <p><code>  ok = TraverseDirectory(pFileName, MAX_OPTIONS, Flags) &amp;&amp; ok;</code></p>
    <p><code>  SetCurrentDirectory(CurrPath);</code></p>
    <p><code>  /* Восстановить каталог. */</code></p>
    <p><code> }</code></p>
    <p><code> return ok ? 0 : 1;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>static BOOL TraverseDirectory(LPCTSTR PathName, DWORD NumFlags, LPBOOL Flags)</code></p>
    <p><code>/* Обход дерева каталогов; выполнить функцию ProcessItem для каждого случая совпадения. */</code></p>
    <p><code>/* PathName: относительное или абсолютное имя просматриваемого каталога.*/</code></p>
    <p><code>{</code></p>
    <p><code> HANDLE SearchHandle;</code></p>
    <p><code> WIN32_FIND_DATA FindData;</code></p>
    <p><code> BOOL Recursive = Flags[0];</code></p>
    <p><code> DWORD FType, iPass;</code></p>
    <p><code> TCHAR CurrPath[MAX_PATH + 1];</code></p>
    <p><code> GetCurrentDirectory(MAX_PATH, CurrPath);</code></p>
    <p><code> for (iPass = 1; iPass &lt;= 2; iPass++) {</code></p>
    <p><code>  /* Проход 1: вывод списка файлов. */</code></p>
    <p><code>  /* Проход 2: обход дерева каталогов (если задана опция –R). */</code></p>
    <p><code>  SearchHandle = FindFirstFile(PathName, &amp;FindData);</code></p>
    <p><code>  do {</code></p>
    <p><code>   FType = FileType(&amp;FindData);</code></p>
    <p><code>   /* Файл или каталог? */</code></p>
    <p><code>   if (iPass == 1) /* Вывести имя и атрибуты файла. */</code></p>
    <p><code>    ProcessItem(&amp;FindData, MAX_OPTIONS, Flags);</code></p>
    <p><code>   if (FType == TYPE_DIR &amp;&amp; iPass == 2 &amp;&amp; Recursive) {</code></p>
    <p><code>    /* Обработать подкаталог. */</code></p>
    <p><code>    _tprintf(_T ("\n%s\\%s:"), CurrPath, FindData.cFileName);</code></p>
    <p><code>    /* Подготовка к обходу каталога. */</code></p>
    <p><code>    SetCurrentDirectory(FindData.cFileName);</code></p>
    <p><code>    TraverseDirectory(_T("*"), NumFlags, Flags);</code></p>
    <p><code>    /* Рекурсивный вызов. */</code></p>
    <p><code>    SetCurrentDirectory(_T(".."));</code></p>
    <p><code>   }</code></p>
    <p><code>  } while (FindNextFile(SearchHandle, &amp;FindData));</code></p>
    <p><code>  FindClose (SearchHandle);</code></p>
    <p><code> }</code></p>
    <p><code> return TRUE; </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>static BOOL ProcessItem(LPWIN32_FIND_DATA pFileData, DWORD NumFlags, LPBOOL Flags)</code></p>
    <p><code>/* Выводит список атрибутов файла или каталога. */ </code></p>
    <p><code>{</code></p>
    <p><code> const TCHAR FileTypeChar[] = {' ', 'd'};</code></p>
    <p><code> DWORD FType = FileType(pFileData);</code></p>
    <p><code> BOOL Long = Flags[1];</code></p>
    <p><code> SYSTEMTIME LastWrite;</code></p>
    <p><code> if (FType != TYPE_FILE &amp;&amp; FType != TYPE_DIR) return FALSE;</code></p>
    <p><code> _tprintf(_T ("\n"));</code></p>
    <p><code> if (Long) { /* Указан ли в командной строке параметр "-1"? */</code></p>
    <p><code>  _tprintf(_T("%c"), FileTypeChar[FType – 1]);</code></p>
    <p><code>  _tprintf(_T("%10d"), pFileData-&gt;nFileSizeLow); </code></p>
    <p><code>  FileTimeToSystemTime(&amp;(pFileData-&gt;ftLastWriteTime), &amp;LastWrite);</code></p>
    <p><code>  _tprintf(_T(" %02d/%02d/%04d %02d:%02d:%02d"), LastWrite.wMonth, LastWrite.wDay, LastWrite.wYear, LastWrite.wHour, LastWrite.wMinute, LastWrite.wSecond);</code></p>
    <p><code> }</code></p>
    <p><code> _tprintf(_T(" %s"), pFileData-&gt;cFileName);</code></p>
    <p><code> return TRUE; </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>static DWORD FileType(LPWIN32_FIND_DATA pFileData)</code></p>
    <p><code>/* Поддерживаемые типы файлов – TYPE_FILE: файл; TYPE_DIR: каталог; TYPE_DOT: каталоги . или .. */ </code></p>
    <p><code>{</code></p>
    <p><code> BOOL IsDir;</code></p>
    <p><code> DWORD FType;</code></p>
    <p><code> FType = TYPE_FILE;</code></p>
    <p><code> IsDir = (pFileData-&gt;dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) != 0;</code></p>
    <p><code> if (IsDir) if (lstrcmp(pFileData-&gt;cFileName, _T(".")) == 0 || lstrcmp(pFileData-&gt;cFileName, _T("..")) == 0) FType = TYPE_DOT;</code></p>
    <p><code> else FType = TYPE_DIR;</code></p>
    <p><code> return FType;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>Пример: установка меток времени файла</p>
    </title>
    <p>Программа 3.3 реализует UNIX-команду touch, предназначенную для изменения кода защиты файлов и обновления меток времени до текущих значений системного времени. В упражнении 3.11 от вас требуется расширить возможности функции touch таким образом, чтобы новые значения меток времени можно было указывать в параметрах командной строки.</p>
    <subtitle>Программа 3.3. touch: установка меток даты и времени файла</subtitle>
    <p><code>/* Глава 3. команда touch. */ </code></p>
    <p><code>/* touch [параметры] [файлы] */ </code></p>
    <p><code>#include "EvryThng.h"</code></p>
    <empty-line/>
    <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> SYSTEMTIME SysTime;</code></p>
    <p><code> FILETIME NewFileTime;</code></p>
    <p><code> LPFILETIME pAccessTime = NULL, pModifyTime = NULL;</code></p>
    <p><code> HANDLE hFile;</code></p>
    <p><code> BOOL Flags[MAX_OPTIONS], SetAccessTime, SetModTime, CreateNew;</code></p>
    <p><code> DWORD CreateFlag;</code></p>
    <p><code> int i, FileIndex;</code></p>
    <p><code> FileIndex = Options(argc, argv, _T("amc"), &amp;Flags[0], &amp;Flags[1], &amp;Flags[2], NULL);</code></p>
    <p><code> SetAccessTime = !Flags[0];</code></p>
    <p><code> SetModTime = !Flags[1];</code></p>
    <p><code> CreateNew = !Flags[2];</code></p>
    <p><code> CreateFlag = CreateNew ? OPEN_ALWAYS : OPEN_EXISTING;</code></p>
    <p><code> for (i = FileIndex; i &lt; argc; i++) {</code></p>
    <p><code>  hFile = CreateFile(argv[i], GENERIC_READ | GENERIC_WRITE, 0, NULL, CreateFlag, FILE_ATTRIBUTE_NORMAL, NULL);</code></p>
    <p><code>  GetSystemTime(&amp;SysTime);</code></p>
    <p><code>  SystemTimeToFileTime(&amp;SysTime, &amp;NewFileTime);</code></p>
    <p><code>  if (SetAccessTime) pAccessTime = &amp;NewFileTime;</code></p>
    <p><code>  if (SetModTime) pModifyTime = &amp;NewFileTime;</code></p>
    <p><code>  SetFileTime(hFile, NULL, pAccessTime, pModifyTime);</code></p>
    <p><code>  CloseHandle(hFile);</code></p>
    <p><code> }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>Стратегии обработки файлов</p>
    </title>
    <p>Уже на ранних стадиях любого проекта разработки приложения или подготовки его к переносу на другую платформу приходится принимать решение относительно того, должна ли осуществляться обработка файлов с использованием функций библиотеки С или функций Windows. Характер этого решения не относится к категории "или-или", поскольку при соблюдении определенных мер предосторожности смешанное применение функций возможно даже по отношению к одному и тому же файлу.</p>
    <p>Библиотека С обладает рядом явных преимуществ, среди которых можно выделить следующие:</p>
    <p>• Полученный программный код легко переносится на другие системы.</p>
    <p>• Наличие удобных функций для работы с символами и строками, не имеющих прямых аналогов среди функций Windows, упрощает обработку строк.</p>
    <p>• Функции библиотеки С обычно проще в использовании по сравнению с функциями Windows.</p>
    <p>• Функции, ориентированные на обработку символьных строк и потоков, легко преобразовать к форме, допускающей указание обобщенных символов при их вызове, хотя преимущества переносимости при этом будут утеряны.</p>
    <p>• Как показано в главе 7, функции библиотеки С способны работать и в средах с многопоточной поддержкой.</p>
    <p>Тем не менее, использование библиотеки С налагает некоторые ограничения. В пользу этого утверждения можно привести перечисленные ниже соображения: </p>
    <p>• Средства библиотеки С не обеспечивают управление каталогами и обход дерева каталогов и в большинстве случаев не позволяют получать или устанавливать атрибутов файлов.</p>
    <p>• В функции fseek, входящей в библиотеку С, используются 32-битовые указатели файла, и поэтому, несмотря на возможность последовательного считывания гигантских файлов, установка произвольной позиции в таком файле, как это требуется, например, в программе 3.1, оказывается невозможной.</p>
    <p>• Библиотека С не предоставляет такие развитые возможности, как защита файлов, отображение файлов, блокирование файлов, асинхронный ввод/вывод и взаимодействие между процессами. Вместе с тем, как показано в приложении В, использование некоторых из этих возможностей в ряде случаев может обеспечивать существенное улучшение показателей производительности программ.</p>
    <p>Альтернативным вариантом является перенос существующего UNIX-кода с привлечением библиотеки совместимости (compatibility library). Microsoft С предоставляет ограниченную библиотеку совместимости, включающую многие, хотя и далеко не все, функции UNIX. К числу функций UNIX, входящих в состав библиотеки Microsoft, относятся функции ввода/вывода, однако большинство функций управления процессами, не говоря о многих других функциях, в ней отсутствуют. В именах функций-аналогов присутствует префикс в виде символа подчеркивания, например, _read, _write, _stat и так далее.</p>
    <p>Решения относительно смешанного использования функций библиотеки С, библиотеки совместимости и Win32/64 API должны приниматься на основании требований проекта. Многие из преимуществ функций Windows будут продемонстрированы в следующих главах, а для ознакомления с количественными данными, характеризующими производительность, которые пригодятся вам в тех случаях, когда этот фактор становится решающим, вы можете обратиться к приложению В.</p>
   </section>
   <section>
    <title>
     <p>Блокирование файлов</p>
    </title>
    <section>
     <p>В системах, допускающих одновременное выполнение нескольких процессов, особую актуальность приобретает проблема координации и синхронизации доступа к разделяемым (совместно используемым) объектам, например файлам.</p>
     <p>В Windows имеется возможность блокировать файлы (целиком или частично) таким образом, что никакой другой процесс (выполняющаяся программа) не сможет получить доступ к заблокированному участку файла. Блокирование файла может оставлять другим приложениям возможность доступа только для чтения (разделяемый доступ) или же закрывать им доступ к файлу как для записи, так и для чтения (монопольный доступ). Что немаловажно, владельцем блокировки является блокирующий процесс. Любая попытка получения доступа к части файла (с помощью функций ReadFile или WriteFile) в нарушение существующей блокировки закончится неудачей, поскольку блокировки носят обязательный характер на уровне процесса. Любая попытка получения несовместимой блокировки также завершится неудачей, даже если процесс уже владеет данной блокировкой. Блокирование файлов является ограниченной разновидностью синхронизации параллельно выполняющихся процессов и потоков; обсуждение синхронизации с использованием гораздо более общей терминологии начнется в главе 8.</p>
     <p>Для блокирования файлов предусмотрены две функции. Более общей из них является функция LockFileEx, менее общей — LockFile, которую можно использовать и в Windows 9x.</p>
     <p>Функция LockFileEx относится к классу функций расширенного (extended) ввода/вывода, поэтому для указания 64-битовой позиции в файле и границ области файла, подлежащей блокированию, необходимо использовать структуру OVERLAPPED, которая ранее уже применялась при указании позиции в файле для функций ReadFile и WriteFile. </p>
     <p><code>BOOL LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped)</code> </p>
     <p>Функция LockFileEx блокирует участок открытого файла либо для разделяемого доступа (разрешающего доступ одновременно нескольким приложениям в режиме чтения), либо для монопольного доступа (разрешающего доступ только одному приложению в режиме чтения/записи).</p>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>hFile — дескриптор открытого файла. Дескриптор должен быть создан либо с правами доступа GENERIC_READ, либо с правами доступа GENERIC_READ и GENERIC_WRITE.</p>
     <p>dwFlags — определяет вид блокировки файла, а также режим ожидания доступности затребованной блокировки. Этот параметр определяется комбинацией следующих значений:</p>
     <p>LOCKFILE_EXCLUSIVE_LOCK — запрос монопольной блокировки в режиме чтения/записи. Если это значение не задано, запрашивается разделяемая блокировка (только чтение).</p>
     <p>LOCKFILE_FAIL_IMMEDIATELY — задает режим немедленного возврата функции с возвращаемым значением равным FALSE, если приобрести блокировку не удается. Если это значение не задано, функция переходит в режим ожидания. </p>
     <p>dwReserved — значение этого параметра должно устанавливаться равным 0. Следующие два параметра определяют соответственно младшие и старшие 32-битовые значения размера блокируемого участка файла (в байтах).</p>
     <p>lpOverlapped — указатель на структуру данных OVERLAPPED, содержащую информацию о начале блокируемого участка. В этой структуре необходимо устанавливать значения трех элементов (остальные элементы игнорируются), первые два из которых определяют смещение начала блокируемого участка от начала файла.</p>
     <p>• DWORD Offset (используется именно такое имя параметра, а не OffsetLow).</p>
     <p>• DWORD OffsetHigh.</p>
     <p>• HANDLE hEvent должен задаваться равным 0.</p>
     <p>Чтобы разблокировать файл, следует вызвать функцию UnlockFileEx, все параметры которой, за исключением dwFlags, совпадают с параметрами предыдущей функции: </p>
     <p><code>BOOL UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped)</code> </p>
     <p>Используя блокирование файлов, вы должны принимать во внимание следующие обстоятельства:</p>
     <p>• Границы области разблокирования должны в точности совпадать с границами ранее заблокированной области. Не допускается, например, объединение двух ранее заблокированных областей или разблокирование части заблокированной области. Любая попытка разблокирования области, не совпадающей в точности с одной из существующих заблокированных областей, будет неудачной. В этом случае функция вернет значение FALSE, а в выведенном системой сообщении об ошибке будет указано, что данная область блокирования не существует.</p>
     <p>• Вновь создаваемая и существующие области блокирования в файле не могут перекрываться, если это приводит к возникновению конфликтной ситуации.</p>
     <p>• Возможно блокирование участка, границы которого выходят за пределы файла. Такая операция может оказаться полезной в случае расширения файла процессом или потоком.</p>
     <p>• Блокировки не наследуются вновь создаваемыми процессами.</p>
     <p>Логику процедуры блокирования, когда вся область <emphasis>или</emphasis> только некоторая ее часть уже содержат заблокированные участки, иллюстрирует табл. 3.1.</p>
     <empty-line/>
     <p><strong>Таблица 3.1. Логика предоставления блокировки</strong> </p>
     <table>
      <tr align="left">
       <th align="left" valign="top"/>
       <th colspan="2" align="left" valign="top">Тип запрашиваемой блокировки </th>
      </tr>
      <tr align="left">
       <th align="left" valign="top">Существующая блокировка </th>
       <th align="left" valign="top">Разделяемая блокировка </th>
       <th align="left" valign="top">Монопольная блокировка</th>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Отсутствует </td>
       <td align="left" valign="top">Предоставляется </td>
       <td align="left" valign="top">Предоставляется</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Разделяемая блокировка (одна или несколько) </td>
       <td align="left" valign="top">Предоставляется </td>
       <td align="left" valign="top">Отказ</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Монопольная блокировка</td>
       <td align="left" valign="top">Отказ</td>
       <td align="left" valign="top">Отказ</td>
      </tr>
     </table>
     <p>Логику предоставления возможности выполнения операций чтения/записи во всей или части области файла, содержащей участки с одной или несколькими блокировками, владельцами которых являются другие процессы, иллюстрирует табл. 3.2.</p>
     <empty-line/>
     <p><strong>Таблица 3.2. Блокировки и выполнение операций ввода/вывода</strong></p>
     <table>
      <tr align="left">
       <th align="left" valign="top"/>
       <th colspan="2" align="left" valign="top">Операция ввода/вывода</th>
      </tr>
      <tr align="left">
       <th align="left" valign="top">Существующая блокировка </th>
       <th align="left" valign="top">Чтение </th>
       <th align="left" valign="top">Запись</th>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Отсутствует </td>
       <td align="left" valign="top">Успешно выполняется </td>
       <td align="left" valign="top">Успешно выполняется</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Разделяемая блокировка (одна или несколько) </td>
       <td align="left" valign="top">Выполняется. Вызывающий процесс не обязан быть владельцем блокировки данной области файла.</td>
       <td align="left" valign="top">Не выполняется</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Монопольная блокировка</td>
       <td align="left" valign="top">Выполняется, если вызывающий процесс является владельцем блокировки, в противном случае — неудачное завершение.</td>
       <td align="left" valign="top">Выполняется, если вызывающий процесс является владельцем блокировки, в противном случае — неудачное завершение.</td>
      </tr>
     </table>
     <p>Обычно операции чтения и записи выполняются путем вызова функций Read-File и WriteFile или их расширенных версий ReadFileEx и WriteFileEx. Для диагностики ошибок, возникающих в процессе выполнения операций ввода/вывода, следует вызывать функцию GetLastError.</p>
     <p>Одна из разновидностей операций ввода/вывода с участием файлов предполагает использование отображения файлов, которое обсуждается в главе 5. Обнаружение конфликтов блокировки на этапе обращения к памяти не производится; такая проверка осуществляется во время вызова функции MapViewOfFile. Указанная функция делает часть файла доступной для процесса, вследствие чего проверка наличия блокировок на этом этапе является необходимой.</p>
     <p>Разновидностью функции LockFileEx с ограниченной сферой применимости является функция LockFile, вызов которой, скорее, лишь уведомляет о намерении осуществить блокировку. Эту функцию можно использовать в системах Windows 9x, которые не поддерживают функцию LockFileEx. Функция LockFile предоставляет блокирующему процессу только монопольный доступ, а возврат из функции происходит сразу же. Таким образом, функция LockFile не блокируется. Проверить, предоставлена блокировка или нет, можно путем тестирования возвращаемого функцией значения.</p>
     <subtitle><emphasis>Снятие блокировок</emphasis></subtitle>
     <p>Каждый успешный вызов функции LockFileEx должен сопровождаться последующим вызовом функции UnlockFileEx (то же самое касается и пары функций LockFile и UnlockFile). Если программа не позаботится о снятии блокировки или будет удерживать ее в течение большего, чем это необходимо, времени, другие программы либо вовсе не смогут работать, либо будут вынуждены простаивать. Поэтому уже на стадии проектирования и реализации программ необходимо очень тщательно следить за тем, чтобы снятие блокировки осуществлялось сразу же после того, как необходимость в ней отпала, а логика работы программ не позволяла оставлять невыполненными необходимые операции разблокирования файлов.</p>
     <p>Одним из способов, гарантирующих своевременное разблокирования файлов, является использование дескрипторов завершения (termination handlers), которые описаны в главе 4.</p>
    </section>
    <section>
     <title>
      <p>Следствия принятой логики блокирования файлов</p>
     </title>
     <p>Несмотря на всю естественность логики блокирования файлов, представленной в таблицах 3.1 и 3.2, последствия ее применения могут оказаться для вас неожиданными и вызвать на первый взгляд необъяснимые изменения в поведении программы. Некоторые возможные примеры этого приводятся ниже.</p>
     <p>• Предположим, что процессы А и В периодически приобретают разделяемые блокировки файла, а процесс С блокируется при попытке получения монопольной блокировки того же файла после того, как процесс А стал владельцем собственной разделяемой блокировки. В этих условиях процесс В может получить свою разделяемую блокировку, но процесс С будет оставаться блокированным даже после того, как процесс А снимет свою блокировку файла. Процесс С будет оставаться блокированным до тех пор, пока все процессы не снимут свои блокировки, даже если они были получены уже тогда, когда процесс С пребывал в блокированном состоянии. Согласно этому сценарию процесс С может оставаться блокированным сколь угодно долго, тогда как другие процессы сохраняют возможность управления своими разделяемыми блокировками.</p>
     <p>• Предположим, что процесс А стал владельцем разделяемой блокировки файла, а процесс В пытается осуществить считывание файла без предварительного приобретения разделяемой блокировки. В этой ситуации чтение может быть успешно осуществлено даже несмотря на то, что процесс, выполняющий чтение, не владеет ни одной блокировкой данного файла, поскольку операция чтения не вступает в конфликт с существующей разделяемой блокировкой.</p>
     <p>• Все, о чем говорилось выше, относится не только к блокировке файла в целом, но и к блокировке отдельного его участка.</p>
     <p>• Процессы чтения и записи вполне могут успешно завершить часть своего запроса, прежде чем возникнет конфликт с существующей блокировкой. В этом случае функции чтения и записи возвратят значения FALSE, а значение счетчика переданных байтов окажется меньше затребованного.</p>
     <subtitle><emphasis>Использование блокирования файлов</emphasis></subtitle>
     <p>Рассмотрение примеров блокирования файлов мы отложим до главы 6, в которой обсуждается управление процессами. В программах 4.2, 6.4, 6.5 и 6.6 блокирование файлов используется для обеспечения того, чтобы в каждый момент времени изменять файл мог только один процесс.</p>
     <cite>
      <p>В UNIX блокирование файлов является <emphasis>уведомляющим </emphasis>(advisory); выполнение процесса ввода/вывода может продолжаться даже в том случае, если попытка получения блокировки оказалась неудачной (логика, отраженная в табл. 3.1, действует и в этом случае). Это обеспечивает в UNIX возможность блокирования файлов взаимодействующими процессами, но любой другой процесс может нарушить описанный протокол.</p>
      <p>Для получения уведомляющей блокировки используются параметры, указываемые при вызове функции fcntl. Допустимыми командами (второй параметр) являются F_SETLK, F_SETLKW и F_GETLK. Информация о типе блокировки (F_RDLCK, F_WRLCK или F_UNLCK) и блокируемой области содержится в дополнительной структуре данных.</p>
      <p>Помимо этого, в некоторых UNIX-системах доступна <emphasis>обязательная</emphasis> (mandatory) блокировка, обеспечиваемая путем определения групповых полномочий для файла с помощью команды chmode.</p>
      <p>Блокирование файлов в UNIX имеет много особенностей. Например, блокировки наследуются при выполнении вызова функции exec.</p>
      <p>Блокирование файлов библиотекой С не поддерживается, но в Visual C++ обеспечивается поддержка нестандартных расширений механизма блокирования.</p>
     </cite>
    </section>
   </section>
   <section>
    <title>
     <p>Реестр</p>
    </title>
    <section>
     <p>Реестр — это централизованная иерархическая база данных, хранящая информацию о параметрах конфигурации операционной системы и установленных приложений. Доступ к реестру осуществляется через <emphasis>разделы,</emphasis> или <emphasis>ключи, реестра</emphasis> (registry keys), играющие ту же роль, что и каталоги в файловой системе. Раздел может содержать подразделы или пары "имя-значение", в которых между именем и значением существует примерно та же взаимосвязь, что и между именами файлов и их содержимым. </p>
     <p>Пользователь или системный администратор может просматривать и изменять содержимое реестра, пользуясь редактором реестра, для запуска которого необходимо выполнить команду REGEDIT. Реестром можно управлять также из программ, используя функции API реестра, описанные в данном разделе.</p>
     <cite>
      <p><strong>Примечание</strong></p>
      <p>Программирование реестра обсуждается в данной главе по той причине, что решаемая при этом задача весьма напоминает обработку файлов, а также потому, что оно играет важную роль в некоторых, хотя и не во всех, приложениях. Соответствующий пример будет получен путем несложного изменения программы lsW. Вместе с тем, данный раздел вполне мог бы стать небольшой отдельной главой. Поэтому читатели, для которых программирование реестра не представляет непосредственного интереса, могут пропустить этот раздел, чтобы вернуться к нему впоследствии, если это окажется необходимым.</p>
     </cite>
     <p>В парах "имя-значение" реестра хранится следующая информация:</p>
     <p>• Номер версии операционной системы, номер сборки и информация о зарегистрированном пользователе.</p>
     <p>• Аналогичная информация обо всех приложения, которые были надлежащим образом установлены в системе.</p>
     <p>• Информация о типе процессоров в системе и их количестве, системной памяти и тому подобное.</p>
     <p>• Специфическая для каждого отдельного пользователя системы информация, включая данные относительно основного каталога пользователя и предпочтительных пользовательских настройках приложений.</p>
     <p>• Информация, необходимая для системы безопасности, включая имена учетных записей пользователей.</p>
     <p>• Информация об установленных службах (глава 13).</p>
     <p>• Список соответствий между расширениями имен файлов и ассоциированными с ними исполняемыми программами. Именно эти соответствия используются системой после того, как пользователь щелкнет на пиктограмме какого-либо файла. Например, щелчок на файле с расширением .doc может приводить к запуску текстового редактора Microsoft Word.</p>
     <p>• Отображения сетевых адресов на имена, используемые локальным компьютером.</p>
     <p>В операционной системе UNIX аналогичная информация хранится в каталоге /etc и файлах, находящихся в основном каталоге пользователя. В Windows 3.1 для этих целей использовались .INI-файлы. Реестр обеспечивает единообразное централизованное хранение всей информации подобного рода. Кроме того, используя средства защиты, описанные в главе 15, можно обеспечить безопасность реестра. </p>
     <p>API управления реестром описывается ниже, однако подробное рассмотрение содержимого и смысла различных записей, образующих реестр, выходит за рамки данной книги. Тем не менее, общее представление о структуре и содержимом этого хранилища данных можно получить на рис. 3.1, на котором изображен типичный вид окна открытого редактора реестра. </p>
     <image l:href="#Any2FbImgLoader48"/>
     <p><strong>Рис. 3.1.</strong> Окно редактора реестра</p>
     <empty-line/>
     <p>Справа на этом рисунке можно видеть специфическая информация, относящаяся к установленному на данном локальном компьютере процессору. В нижней левой части рисунка показаны различные разделы, содержащие информацию об установленном в локальной системе программном обеспечении. Обратите внимание, что каждый ключ обязательно имеет значение по умолчанию, которое указывается в списке самым первым, предшествуя любым другим парам "имя-значение".</p>
     <p>Рассмотрение принципов реализации реестра, включая организацию хранения и извлечения хранящихся в реестре данных, выходит за рамки данной книги; для более глубокого изучения этих вопросов обратитесь к списку дополнительной литературы, приведенному в конце главы.</p>
    </section>
    <section>
     <title>
      <p>Ключи реестра</p>
     </title>
     <p>На рис. 3.1 показана аналогия между разделами реестра и каталогами файловой системы. Каждый раздел может содержать другие разделы или последовательности пар "имя-значение". В то время как доступ к файловой системе реализуется посредством указания путей доступа, доступ к реестру осуществляется через его разделы. Существует несколько предопределенных разделов, которые играют роль точек входа в реестр.</p>
     <p>• HKEY_LOCAL_MACHINE. В этом разделе хранится информация об оборудовании локального компьютера и установленном на нем программном обеспечении. Информация об установленном программном обеспечении обычно создается в подразделах (subkeys) в виде: SOFTWARE\НазваниеКомпании\НазваниеПродукта\Версия.</p>
     <p>• HKEY_USERS. В этом разделе хранится информация о настройке пользовательских конфигураций.</p>
     <p>• HKEY_CURRENT_CONFIG. В этом разделе хранятся текущие настройки таких параметров, как разрешение дисплея или гарнитура шрифта.</p>
     <p>• HKEY_CLASSES_ROOT. В этом разделе содержатся подчиненные записи, устанавливающие соответствие между именами файлов и классами, а также приложениями, используемыми оболочкой для доступа к объектам, имена которых имеют определенные расширения. В этот раздел также входят все подразделы, необходимые для функционирования модели компонентных объектов (Component Object Model — СОМ), разработанной компанией Microsoft.</p>
     <p>• HKEY_CURRENT_USER. В этом разделе хранится информация, определяемая пользователем, в том числе информация о переменных среды, принтерах и предпочтительных для вошедшего в систему пользователя конфигурационных параметрах приложений.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Управление системным реестром</p>
    </title>
    <section>
     <p>Функции управления реестром позволяют запрашивать и изменять данные, относящиеся к парам "имя-значение", а также создавать новые подразделы и новые пары "имя-значение". Как для указания существующих разделов, так и для создания новых используются дескрипторы типа HKEY.<a l:href="#n_17" type="note">[17]</a> Нужные значения необходимо вводить; тип значения можно выбрать из нескольких готовых вариантов, соответствующих, например, строкам, двойным словам или расширяемым (expandable) строкам, параметры которых могут быть заменены переменными окружения.</p>
    </section>
    <section>
     <title>
      <p>Управление подразделами реестра</p>
     </title>
     <p>Первая из рассматриваемых нами функций, RegOpenKeyEx, предназначена для открытия подразделов системного реестра. Начав с одного из предопределенных зарезервированных дескрипторов, вы можете получить дескриптор любого из его подразделов, совершая обход дерева разделов. </p>
     <cite>
      <p><code>LONG RegOpenKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)</code> </p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>hKey — указатель на текущий открытый раздел реестра или значение дескриптора одного из предопределенных зарезервированных разделов. pHkResult — указатель на переменную типа HKEY, получающую значение дескриптора вновь открываемого раздела.</p>
     <p>lpSubKey — указатель на строку с именем подраздела. Именем подраздела может быть путь, например: Microsoft\WindowsNT\CurrentVersion. Значению NULL соответствует открытие новой копии раздела для hKey. Значение параметра ulOptions должно быть равным 0.</p>
     <p>samDesired — маска доступа, описывающая уровень защиты нового раздела. К числу возможных значений относятся значения KEY_ALL_ACCESS, KEY_WRITE, KEY_QUERY_VALUE и KEY_ENUMARATE_SUBKEYS.</p>
     <p>В случае успешного завершения функции возвращается значение ERROR_SUCCESS. Возврат любого другого значения указывает на ошибку. Для закрытия дескриптора открытого раздела используется функция RegCloseKey, которая в качестве своего единственного параметра принимает дескриптор.</p>
     <p>Для получения имен подразделов любого заданного раздела следует воспользоваться функцией RegEnumKeyEx.</p>
     <p>Для получения пар "имя-значение" используются две взаимно дополняющих функции: RegEnumValue и RegQueryValueEx.<a l:href="#n_18" type="note">[18]</a> Функция RegSetValueEx сохраняет данные различного типа в поле значения открытого раздела реестра. Описания перечисленных функций, применение которых будет проиллюстрировано примером, содержатся в этом и следующем разделах книги.</p>
     <p>Функция RegEnumKeyEx перечисляет подразделы открытого раздела системного реестра во многом аналогично тому, как функции FindFirstFile и FindNextFile перечисляют содержимое каталогов. Эта функция извлекает имя подраздела, строку с именем класса подраздела, а также дату и время последнего изменения.</p>
     <cite>
      <p><code>LONG RegEnumValue(HKEY hKey, DWORD dwIndex, LPTSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)</code> </p>
     </cite>
     <p>Значение параметра dwIndex должно устанавливаться равным 0 при первом вызове функции и увеличиваться на единицу при каждом последующем вызове. Название раздела и его размер, а также строка с именем класса и ее размер, возвращаются обычным способом. В случае успешного завершения функция возвращает значение ERROR_SUCCESS, иначе — код ошибки.</p>
     <p>Можно также создавать новые разделы, используя для этого функцию RegCreateKeyEx. Разделам системного реестра можно присваивать атрибуты защиты точно так же, как каталогам и файлам (глава 15). </p>
     <cite>
      <p><code>LONG RegCreateKeyEx(HKEY hKey, LPCTSTR lpSubKey, DWORD Reserved, LPTSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)</code> </p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>lpSubKey — указатель на строку, содержащую имя нового подраздела, создаваемого в разделе, на который указывает дескриптор hKey.</p>
     <p>lpClass — указатель на строку, содержащую имя класса, или объектный тип, раздела, описывающее данные, представляемые разделом. Одними из многочисленных возможных значений являются REG_SZ (строка, завершающаяся нулевым символом) и REG_DWORD (двойное слово).</p>
     <p>Параметр dwOptions может иметь значение 0 или одно из двух взаимоисключающих значений — REG_OPTION_VOLATILE или REG_OPTION_NON_VOLATILE. Постоянно хранимая (nonvolatile) информация системного реестра сохраняется в файле на диске и не теряется после перезапуска системы. При этом временные (volatile) разделы системного реестра, хранящиеся в оперативной памяти, не будут восстановлены. </p>
     <p>Параметр samDesired имеет тот же смысл, что и в случае функции RegOpenKeyEx.</p>
     <p>Параметр lpSecurityAttributes может принимать значение NULL или указывать атрибуты защиты. Опции прав доступа к разделу могут выбираться из того же набора значений, что и в случае параметра samDesired.</p>
     <p>lpdwDisposition — указатель на переменную типа DWORD, значение которой говорит о том, существовал ли раздел ранее (REG_OPENED_EXISTING_KEY) или он только создается (REG_CREATED_NEW_KEY).</p>
     <p>Для удаления раздела используется функция RegDeleteKey. Двумя ее параметрами являются дескриптор открытого раздела и имя подраздела.</p>
    </section>
    <section>
     <title>
      <p>Управление значениями</p>
     </title>
     <p>Для перечисления значений параметров открытого раздела реестра используется функция RegEnumValue. Значение параметра dwIndex должно устанавливаться равным 0 при первом вызове функции и увеличиваться на единицу при каждом последующем вызове. После возврата из функции вы получаете строку, содержащую имя перечисляемого параметра, а также размер данных. Кроме того, вы получаете значение перечисляемого параметра и его тип. </p>
     <cite>
      <p><code>LONG RegEnumValue(HKEY hKey, DWORD dwIndex, LPTSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)</code> </p>
     </cite>
     <p>Фактическое значение параметра возвращается в буфере, на который указывает указатель lpData. Размер результата содержится в переменной, на которую указывает указатель lpcbData. Тип данных, содержащийся в переменной, на которую указывает указатель lpType, может быть самым различным, включая REG_BINARY, REG_DWORD, REG_SZ (строка) и REG_EXPAND_SZ (расширяемая строка с параметрами, которые заменяются переменными окружения). Полный список типов данных системного реестра можно найти в оперативной справочной системе.</p>
     <p>Чтобы определить, все ли параметры перечислены, следует проверить возвращаемое значение функции. После успешного нахождения действительного параметра оно должно быть равным ERROR_SUCCESS.</p>
     <p>Функция RegQueryValueEx ведет себя аналогичным образом, за исключением того, что требует указания имени перечисляемого параметра, а не его индекса. Эту функцию можно использовать в тех случаях, когда известны имена параметров. Если же имена параметров неизвестны, следует использовать функцию RegEnumValueEx.</p>
     <p>Для установки значения параметра в открытом разделе служит функция RegSetValueEx, которой необходимо предоставить имя параметра, тип значения и фактические данные, образующие значение.</p>
     <cite>
      <p><code>LONG RegSetValueEx(HKEY hKey, LPCTSTR lpValueName, DWORD Reserved, DWORD dwType, CONST BYTE * lpData, CONST cbData)</code> </p>
     </cite>
     <p>Наконец, для удаления именованных значений используется функция RegDeleteValue.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: вывод списка разделов и содержимого реестра</p>
    </title>
    <p>Программа lsReq (программа 3.4), является видоизменением lsW (программа 3.2, предназначенная для вывода списка файлов и каталогов) и обрабатывает не каталоги и файлы, а разделы и пары "имя-значение" системного реестра.</p>
    <subtitle>Программа 3.4. lsReq: вывод списка разделов и содержимого системного реестра</subtitle>
    <p><code>/* Глава 3. lsReg: Команда вывода содержимого реестра. Адаптированная версия программы 3.2. */</code></p>
    <p><code>/* lsReg [параметры] подраздел */</code></p>
    <p><code>#include "EvryThng.h"</code></p>
    <p><code>BOOL TraverseRegistry(HKEY, LPTSTR, LPTSTR, LPBOOL); </code></p>
    <p><code>BOOL DisplayPair(LPTSTR, DWORD, LPBYTE, DWORD, LPBOOL);</code></p>
    <p><code>BOOL DisplaySubKey (LPTSTR, LPTSTR, PFILETIME, LPBOOL);</code></p>
    <empty-line/>
    <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> BOOL Flags[2], ok = TRUE;</code></p>
    <p><code> TCHAR KeyName[MAX_PATH + 1];</code></p>
    <p><code> LPTSTR pScan;</code></p>
    <p><code> DWORD i, KeyIndex;</code></p>
    <p><code> HKEY hKey, hNextKey;</code></p>
    <p><code> /* Таблица предопределенных имен и дескрипторов разделов. */</code></p>
    <p><code> LPTSTR PreDefKeyNames[] = {</code></p>
    <p><code>  _Т("HKEY_LOCAL_MACHINE"), _T("HKEY_CLASSES_ROOT"),</code></p>
    <p><code>  _Т("HKEY CURRENT USER"), _T ("HKEY CURRENT CONFIG"), NULL </code></p>
    <p><code> };</code></p>
    <p><code> HKEY PreDefKeys[] = {</code></p>
    <p><code>  HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_CURRENT_CONFIG</code></p>
    <p><code> };</code></p>
    <p><code> KeyIndex = Options(argc, argv, _T("Rl"), &amp;Flags[0], &amp;Flags[1], NULL);</code></p>
    <p><code> /* "Разобрать" шаблон поиска на "раздел" и "подраздел". */</code></p>
    <p><code> /* Воссоздать раздел. */</code></p>
    <p><code> pScan = argv[KeyIndex];</code></p>
    <p><code> for (i = 0; *pScan != _T('\\') &amp;&amp; *pScan != _T('\0'); pScan++, i++) KeyName [i] = *pScan;</code></p>
    <p><code> KeyName[i] = _T('\0');</code></p>
    <p><code> if (*pScan == _T('\\')) pScan++;</code></p>
    <p><code> /* Преобразовать предопределенное имя раздела в соответствующий HKEY.*/</code></p>
    <p><code> for (i = 0; PreDefKeyNames [i] != NULL &amp;&amp; _tcscmp(PreDefKeyNames[i], KeyName) != 0; i++);</code></p>
    <p><code> hKey = PreDefKeys[i];</code></p>
    <p><code> RegOpenKeyEx(hKey, pScan, 0, KEY_READ, &amp;hNextKey);</code></p>
    <p><code> hKey = hNextKey;</code></p>
    <p><code> ok = TraverseRegistry(hKey, argv[KeyIndex], NULL, Flags);</code></p>
    <p><code> return ok ? 0 : 1; </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>BOOL TraverseRegistry(HKEY hKey, LPTSTR FullKeyName, LPTSTR SubKey, LPBOOL Flags) </code></p>
    <p><code>/*Совершить обход разделов и подразделов реестра, если задан параметр –R.*/ </code></p>
    <p><code>{</code></p>
    <p><code> HKEY hSubK;</code></p>
    <p><code> BOOL Recursive = Flags[0];</code></p>
    <p><code> LONG Result;</code></p>
    <p><code> DWORD ValType, Index, NumSubKs, SubKNameLen, ValNameLen, ValLen;</code></p>
    <p><code> DWORD MaxSubKLen, NumVals, MaxValNameLen, MaxValLen;</code></p>
    <p><code> FILETIME LastWriteTime;</code></p>
    <p><code> LPTSTR SubKName, ValName;</code></p>
    <p><code> LPBYTE Val;</code></p>
    <p><code> TCHAR FullSubKName[MAX_PATH + 1];</code></p>
    <p><code> /* Открыть дескриптор раздела. */</code></p>
    <p><code> RegOpenKeyEx(hKey, SubKey, 0, KEY_READ, &amp;hSubK);</code></p>
    <p><code> /* Определить максимальный размер информации относительно раздела и распределить память. */</code></p>
    <p><code> RegQueryInfoKey(hSubK, NULL, NULL, NULL, &amp;NumSubKs, &amp;MaxSubKLen, NULL, &amp;NumVals, &amp;MaxValNameLen, &amp;MaxValLen, NULL, &amp;LastWriteTime);</code></p>
    <p><code> SubKName = malloc (MaxSubKLen+1); /* Размер без учета завершающего нулевого символа. */</code></p>
    <p><code> ValName = malloc(MaxValNameLen+1); /* Учесть нулевой символ. */</code></p>
    <p><code> Val = malloc(MaxValLen); /* Размер в байтах. */</code></p>
    <p><code> /* Первый проход: пары "имя-значение". */</code></p>
    <p><code> for (Index = 0; Index &lt; NumVals; Index++) {</code></p>
    <p><code>  ValNameLen = MaxValNameLen + 1; /* Устанавливается каждый раз! */</code></p>
    <p><code>  ValLen = MaxValLen + 1;</code></p>
    <p><code>  RegEnumValue(hSubK, Index, ValName, &amp;ValNameLen, NULL, &amp;ValType, Val, &amp;ValLen);</code></p>
    <p><code>  DisplayPair(ValName, ValType, Val, ValLen, Flags);</code></p>
    <p><code> }</code></p>
    <p><code> /* Второй проход: подразделы. */</code></p>
    <p><code> for (Index = 0; Index &lt; NumSubKs; Index++) {</code></p>
    <p><code>  SubKNameLen = MaxSubKLen + 1;</code></p>
    <p><code>  RegEnumKeyEx(hSubK, Index, SubKName, &amp;SubKNameLen, NULL, NULL, NULL, &amp;LastWriteTime);</code></p>
    <p><code>  DisplaySubKey(FullKName, SubKName, &amp;LastWriteTime, Flags);</code></p>
    <p><code>  if (Recursive) {</code></p>
    <p><code>   _stprintf(FullSubKName, _T("%s\\%s"), FullKName, SubKName);</code></p>
    <p><code>   TraverseRegistry(hSubK, FullSubKName, SubKName, Flags);</code></p>
    <p><code>  }</code></p>
    <p><code> }</code></p>
    <p><code> _tprintf(_T("\n"));</code></p>
    <p><code> free(SubKName);</code></p>
    <p><code> free(ValName);</code></p>
    <p><code> free(Val);</code></p>
    <p><code> RegCloseKey(hSubK);</code></p>
    <p><code> return TRUE; </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>BOOL DisplayPair(LPTSTR ValueName, DWORD ValueType, LPBYTE Value, DWORD ValueLen, LPBOOL Flags)</code></p>
    <p><code>/* Функция, отображающая пары "имя-значение". */ </code></p>
    <p><code>{</code></p>
    <p><code> LPBYTE pV = Value;</code></p>
    <p><code> DWORD i;</code></p>
    <p><code> _tprintf(_T("\nValue: %s = "), ValueName);</code></p>
    <p><code> switch (ValueType) {</code></p>
    <p><code> case REG_FULL_RESOURCE_DESCRIPTOR: /* 9: описание оборудования. */</code></p>
    <p><code> case REG_BINARY: /* 3: Любые двоичные данные. */</code></p>
    <p><code>  for (i = 0; i &lt; ValueLen; i++, pV++) _tprintf (_T (" %x"), *pV);</code></p>
    <p><code>  break;</code></p>
    <p><code> case REG_DWORD: /* 4: 32-битовое число. */</code></p>
    <p><code>  _tprintf(_T ("%x"), (DWORD)*Value);</code></p>
    <p><code>  break;</code></p>
    <p><code> case REG_MULTI SZ: /*7: массив строк, завершающихся нулевым символом.*/</code></p>
    <p><code> case REG_SZ: /* 1: строка, завершающаяся нулевым символом. */</code></p>
    <p><code>  _tprintf(_T("%s"), (LPTSTR)Value);</code></p>
    <p><code>  break;</code></p>
    <p><code> /* … Несколько других типов … */</code></p>
    <p><code> }</code></p>
    <p><code> return TRUE; </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>BOOL DisplaySubKey(LPTSTR KeyName, LPTSTR SubKeyName, PFILETIME pLastWrite, LPBOOL Flags) {</code></p>
    <p><code> BOOL Long = Flags[1];</code></p>
    <p><code> SYSTEMTIME SysLastWrite;</code></p>
    <p><code> _tprintf(_T("\nSubkey: %s"), KeyName);</code></p>
    <p><code> if (_tcslen(SubKeyName) &gt; 0) _tprintf (_T ("\\%s "), SubKeyName);</code></p>
    <p><code> if (Long) {</code></p>
    <p><code>  FileTimeToSystemTime(pLastWrite, &amp;SysLastWrite);</code></p>
    <p><code>  _tprintf(_T("%02d/%02d/%04d %02d:%02d:%02d"), SysLastWrite.wMonth, SysLastWrite.wDay, SysLastWrite.wYear, SysLastWrite.wHour, SysLastWrite.wMinute, SysLastWrite.wSecond);</code></p>
    <p><code> }</code></p>
    <p><code> return TRUE; </code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>Резюме</p>
    </title>
    <section>
     <p>В главах 2 и 3 описаны все наиболее важные базовые функции, необходимые для работы с файлами, каталогами и консольным вводом/выводом. Использование этих функций для построения типичных приложений иллюстрировали многочисленные примеры. Как показывает последний из примеров, между управлением системным реестром и управлением файловой системой имеется много общего.</p>
     <p>В последующих главах будут рассмотрены такие усовершенствованные методы ввода/вывода, как асинхронные операции ввода/вывода и отображение файлов. Этих средств будет достаточно для того, чтобы воспроизвести в Windows почти любой из обычных видов обработки файлов, доступных при использовании UNIX или библиотечных функций С.</p>
     <p>В приложении Б приведены сравнительные таблицы функций Windows, UNIX и библиотеки С, в которых наглядно показано, в чем указанные группы функций соответствуют друг другу, а в чем заметно отличаются.</p>
    </section>
    <section>
     <title>
      <p>В следующих главах</p>
     </title>
     <p>Глава 4 рассказывает о том, как упростить обработку ошибок и исключений, и распространяет применение функции ReportError на случаи обработки любых исключительных ситуаций.</p>
    </section>
    <section>
     <title>
      <p>Дополнительная литература</p>
     </title>
     <p>Для получения более подробной информации относительно программирования и использования системного реестра Windows, обратитесь к книге [17]. </p>
    </section>
   </section>
   <section>
    <title>
     <p>Упражнения</p>
    </title>
    <p>3.1. Используя функции GetDiskFreeSpace и GetDiskFreeSpaceEx, определите, насколько разреженным оказывается файловое пространство, распределяемое различными версиями операционной системы Windows. Например, создайте новый файл, установите для указателя файла большое значение, задайте размер файла и исследуйте наличие свободного пространства на жестком диске при помощи функции GetDiskFreeSpace. Эту же функцию Windows можно использовать для определения того, чтобы определить, каким образом сконфигурирован диск в терминах секторов и кластеров. Определите, инициализируется ли выделенное для вновь созданного файла дисковое пространство. Решение в виде исходного текста функции FreeSpace.с доступно на Web-сайте книги. Сравните результаты, полученные для столь различных систем, как Windows NT и Windows 9x. Представляет интерес также исследование вопроса о том, как сделать файл разреженным.</p>
    <p>3.2. Что произойдет, если длину файла задать такой, чтобы его размер превышал объем диска? Обеспечивает ли Windows изящный выход из функции в случае ее неудачного завершения?</p>
    <p>3.3. Измените предоставляемую на Web-сайте программу tail.с таким образом, чтобы в ней можно было обойтись без применения функции SetFilePointer; воспользуйтесь для этого структурой OVERLAPPED.</p>
    <p>3.4. Исследуйте значение поля "количество ссылок" (nNumberOfLinks), полученное с использованием функции GetFileInformationByHandle. Всегда ли оно равно 1? Различаются ли ответы на этот вопрос для файловых систем NTFS и FAT? He включают ли значения счетчиков ссылок жесткие ссылки и ссылки из родительских каталогов и подкаталогов, как это имеет место в UNIX? Открывает ли Windows каталог как файл для получения дескриптора, прежде чем использовать эту функцию? Что можно сказать о ярлыках, поддерживаемых пользовательским интерфейсом?</p>
    <p>3.5. В программе 3.2 поиск текущего и родительских каталогов осуществляется с использованием имен "." и "..". Что произойдет в случае, если файлы с такими именами действительно существуют? Могут ли файлы иметь такие имена?</p>
    <p>3.6. Значения какого времени выводятся в программе 3.2 — местного или UCT? При необходимости измените программу таким образом, чтобы выводимые значения соответствовали местному времени.</p>
    <p>3.7. Усовершенствуйте программу 3.2 таким образом, чтобы в выводимый список включались также текущий (".") и родительский ("..") каталоги (завершенная программа находится на Web-сайте). Кроме того, добавьте опции, позволяющие наряду с датой и временем последнего изменения отображать дату и время создания файла, а также дату и время последнего доступа к нему. </p>
    <p>3.8. Напишите программу, которая реализует команду rm, позволяющую удалять файлы, изменив для этого функцию ProcessItem в программе 3.2. Решение доступно на Web-сайте.</p>
    <p>3.9. Усовершенствуйте команду cp из главы 2, предназначенную для копирования файлов, таким образом, чтобы она позволяла копировать файлы в указанный каталог. Дополнительно предусмотрите опцию рекурсивного копирования файлов (параметр –r) и опцию сохранения вместе с копией также времени последнего изменения файла (параметр –р). Для реализации опции рекурсивного копирования файлов вам потребуется создать новые каталоги. </p>
    <p>3.10. Напишите программу mv, которая реализует одноименную команду UNIX, позволяющую переместить целиком любой каталог. При этом имеет существенное значение, осуществляется ли перемещение файла или каталога на другой диск или они остаются на прежнем диске. В случае смены диска используйте операцию копирования файлов, в противном случае используйте команды MoveFile или MoveFileEx.</p>
    <p>3.11. Усовершенствуйте программу 3.3 (touch) таким образом, чтобы новое время создания файла можно было указывать в командной строке. Команда UNIX допускает (по выбору) указание метки времени после обычных параметров, но перед именами файлов. Метки даты и времени имеют формат MMddhhmm [уу], где ММ — месяцы, dd — дни, hh — часы, mm — минуты, уу — года. Двух цифр для обозначения года нам будет недостаточно, поэтому предусмотрите для указания года четыре разряда.</p>
    <p>3.12. Программа 3.1 рассчитана на работу с большими файловыми системами NTFS. Если на вашем жестком диске имеется достаточно много свободного места, протестируйте работу этой программы на файлах гигантских размеров (свыше 4 Гбайт). Проверьте, насколько корректно работает 64-битовая арифметика. Выполнять это упражнение на сетевом диске без предварительного разрешения администратора сети не рекомендуется. Завершив работу над этим упражнением, не забудьте удалить тестовый файл.</p>
    <p>3.13. Напишите программу, которая блокирует заданный файл и удерживает его в блокированном состоянии в течение длительного времени (вероятно, вызахотите воспользоваться функцией Sleep). Воспользовавшись любым текстовым редактором, попытайтесь получить доступ к файлу (используйте текстовый файл) в период действия блокировки. Что при этом происходит? Заблокирован ли файл должным образом? Вы также можете написать программу, предлагающую пользователю задать блокировку для тестового файла. Чтобы проверить, срабатывает ли блокировка описанным образом, запустите на выполнение два экземпляра программы в разных окнах. Решение этого упражнения содержится в файле TestLock.c, находящемся на Web-сайте. </p>
    <p>3.14. Исследуйте представление временных характеристик файла Windows в формате данных FILETIME. В этом формате используются 64-битовые счетчики, выражающие в 100-наносекундных единицах длительность истекшего периода времени, отсчитываемого от 1 января 1601 года. Когда исчерпаются показания этого счетчика? Какова максимально допустимая дата для временных характеристик файлов UNIX?</p>
    <p>3.15. Напишите интерактивную утилиту, в которой пользователю предлагается ввести имя раздела реестра и имя значения реестра. Отобразите текущее значение и предложите пользователю указать новое.</p>
    <p>3.16. В этой главе, как и в большинстве других глав книги, описываются наиболее важные функции. Однако во многих случаях вам могут оказаться полезными и другие функции. На страницах оперативного справочного руководства для каждой функции приведены ссылки на родственные функции. Ознакомьтесь с некоторыми из них, такими, например, как FindFirstFileEx, ReplaceFile, SearchPath или WriteFileGather. Некоторые функции доступны не во всех версиях NT5. </p>
   </section>
  </section>
  <section>
   <title>
    <p>ГЛАВА 4</p>
    <p>Обработка исключений</p>
   </title>
   <section>
    <p>Основное внимание в данной главе сфокусировано на структурной обработке исключений (Structured Exception Handling, SEH), но наряду с этим обсуждены также обработчики управляющих сигналов консоли и векторная обработка исключений (Vectored Exception Handling, VEH).</p>
    <p>SEH предоставляет механизм обеспечения надежности программ, благодаря которому приложения получают возможность реагировать на такие непредсказуемые события, как исключения адресации, арифметические сбои и системные ошибки. Использование SEH позволяет программам осуществлять корректный выход из любой точки программного блока и автоматически выполнять предусмотренную программистом обработку ошибок для восстановления своей работоспособности. SEH гарантирует своевременное освобождение ресурсов и выполнение любых других операций очистки, прежде чем блок, поток или процесс закончат работу либо под управлением программы, либо в ответ на возникновение исключительной ситуации. Кроме того, SEH легко добавляется в существующие программные коды, во многих случаях обеспечивая упрощение логики работы программы.</p>
    <p>Мы используем SEH в приведенных ниже примерах программ и расширим посредством этого механизма возможности функции обработки ошибок ReportError, которая была введена в главе 2. Обычно сфера применимости SEH ограничивается программами, написанными на языке на С. Вместе с тем, представленные ниже возможности SEH воспроизводятся в C++, С# и других языках программирования с использованием весьма похожих механизмов.</p>
    <p>В настоящей главе описаны также обработчики управляющих сигналов консоли, благодаря которым программы могут воспринимать внешние сигналы, вырабатываемые, например, при нажатии сочетания клавиш &lt;Ctrl+C&gt;, выходе пользователя из системы или завершении работы системы. Кроме того, использование подобных сигналов обеспечивает реализацию ограниченных форм межпроцессного взаимодействия.</p>
    <p>Глава завершается рассмотрением векторной обработки исключений, которая потребует от вас использования операционных систем Windows XP или Windows Server 2003. Благодаря VEH пользователь получает возможность определить функции, которые должны вызываться сразу же после возникновения исключения, не дожидаясь активизации SEH.</p>
   </section>
   <section>
    <title>
     <p>Исключения и обработчики исключений</p>
    </title>
    <section>
     <p>В отсутствие обработки исключений возникновение любой нестандартной ситуации, например, попытки разыменования нулевого указателя или деления на ноль, приведет к немедленному прекращению выполнения программы. В качестве примера, иллюстрирующего проблемы, которые могут при этом возникать, можно назвать создаваемые программой временные файлы, подлежащие удалению до того, как программа завершит свою работу. SEH предоставляет возможность определить блок программного кода, или <emphasis>обработчик исключений</emphasis> (exception handler), который в случае возникновения исключения удалит временные файлы.</p>
     <p>Поддержка SEH обеспечивается за счет совместного использования функций Windows, средств поддержки языков программирования, предоставляемых компилятором, и средств поддержки времени выполнения. Какой именно язык программирования поддерживается, зависит от конкретной системы; наши примеры ориентированы на Microsoft С.</p>
    </section>
    <section>
     <title>
      <p>Блоки try и except</p>
     </title>
     <p>Все начинается с выяснения того, в каких именно блоках программного кода вы намерены контролировать возникновение нестандартных ситуаций, после чего этим блокам должны быть предоставлены обработчики исключений в соответствии с приведенным ниже описанием. Можно контролировать как функцию в целом, так и ее отдельные программные блоки или подфункции, предусмотрев для них независимые обработчики исключений.</p>
     <p>Ниже перечислены характерные признаки участков программного кода, для которых целесообразно предусматривать отдельные обработчики исключений.</p>
     <p>• Возможность возникновения регистрируемых ошибок, включая ошибки системных вызовов, в условиях, когда необходимо организовать устранение последствий ошибки, а не предоставлять программе возможность прекращения выполнения.</p>
     <p>• Интенсивное использование указателей, повышающее вероятность попыток разыменования указателей, инициализация которых не была выполнена должным образом.</p>
     <p>• Интенсивное использование данных в виде массивов, что может сопровождаться выходом значений индексов элементов массива за границы допустимого диапазона.</p>
     <p>• В программе выполняются арифметические операции с участием вещественных чисел (чисел с плавающей точкой), и существует риск того, что могут возникать исключения, связанные с попытками деления на ноль, потерей точности при вычислениях и переполнением.</p>
     <p>• Наличие вызовов функций, которые могут генерировать исключения либо программным путем, либо в силу того, что их работоспособность не была достаточно тщательно проверена.</p>
     <p>Если при изучении примеров, приведенных в этой главе или книге в целом, вы решите отслеживать исключения, которые могут возникать на том или ином участке программы, создайте для него блоки try и except, как показано ниже:</p>
     <p><code>__try {</code></p>
     <p><code> /* Блок контролируемого кода */ </code></p>
     <p><code>} __ except<emphasis>(выражение_фильтра)</emphasis> {</code></p>
     <p><code> /* Блок обработки исключений */ </code></p>
     <p><code>}</code></p>
     <p>Имейте в виду, что __try и __except — это ключевые слова, распознаваемые компилятором.</p>
     <p>Блоки try являются частью обычного кода приложения. Если на данном участке кода возникает исключение, ОС передает управление обработчику исключений, который представляет собой блок программного кода, следующий за ключевым словом_ except. Характер последующих действий определяется значением параметра выражение_фильтра.</p>
     <p>Обратите внимание, что исключение может возникнуть также в пределах блока, находящегося внутри try-блока; в этом случае средства поддержки времени исполнения "разворачивают" стек, чтобы отыскать в нем информацию об обработчике исключений, после чего передают управление этому обработчику. То же самое происходит и в тех случаях, когда исключения возникают внутри функций, вызванных в пределах try-блока.</p>
     <p>На рис. 4.1 показано, как располагается в стеке информация об обработчике исключений во время возникновения исключения. Как только обработчик исключений завершит свою работу, управление передается оператору, который следует за блоком except, если только в самом обработчике исключений не предусмотрены иные операторы ветвления, изменяющие ход выполнения программы.</p>
    </section>
    <section>
     <title>
      <p>Выражения фильтров и их значения</p>
     </title>
     <p>Параметр выражение_фильтра в операторе except вычисляется сразу же после того, как возникает исключение. В качестве выражения может выступать литеральная константа, вызов <emphasis>функции фильтра</emphasis> (filter function) или условное выражение. В любом случае выражение должно возвращать одно из следующих трех значений:</p>
     <p>1. EXCEPTION_EXECUTE_HANDLER — система выполняет операторы блока обработки исключений, как показано на рис. 4.1 (см. программу 4.1). Это соответствует обычному случаю.</p>
     <p>2. EXCEPTION_CONTINUE_SEARCH — система игнорирует данный обработчик исключений и пытается найти обработчик исключений в охватывающем блоке, продолжая этот процесс аналогичным образом до тех пор, пока не будет найден обработчик исключений.</p>
     <p>3. EXCEPTION_CONTINUE_EXECUTION — система немедленно возвращает управление в точку, в которой возникло исключение. В случае некоторых исключений дальнейшее выполнение программы невозможно, но если такие попытки делаются, то генерируется повторное исключение.</p>
     <image l:href="#Any2FbImgLoader53"/>
     <p><strong>Рис. 4.1.</strong> SEH, блоки и функции</p>
     <p>Ниже приведен простой пример, в котором обработчик исключений используется для удаления временного файла в тех случаях, когда исключение возникает в теле цикла. Заметьте, что ключевое слово __try может быть применено к любому блоку, включая блоки, связанные с операторами while, if или любым другим оператором ветвления. В данном примере возникновение любого исключения приводит к удалению временного файла и закрытию дескриптора, после чего выполнение цикла возобновляется.</p>
     <p><code>GetTempFileName(TempFile, …);</code></p>
     <p><code>while (…) __try {</code></p>
     <p><code> hFile = CreateFile(TempFile, …, OPEN_ALWAYS, …);</code></p>
     <p><code> SetFilePointer(hFile, 0, NULL, FILE_END);</code></p>
     <p><code> WriteFile(hFile, …);</code></p>
     <p><code> i = *p; /* В этом месте программы возможно возникновение исключения адресации. */</code></p>
     <p><code> CloseHandle (hFile);</code></p>
     <p><code> …</code></p>
     <p><code>} __except (EXCEPTION_EXECUTE_HANDLER) {</code></p>
     <p><code> CloseHandle(hFile);</code></p>
     <p><code> DeleteFile(TempFile);</code></p>
     <p><code> /* Переход к выполнению очередной итерации цикла. */ </code></p>
     <p><code>} </code></p>
     <p><code>/* Сюда передается управление после нормального завершения цикла.</code></p>
     <p><code> Каждый раз при возникновении исключения дескриптор временного файла  закрывается, а сам файл удаляется. */</code></p>
     <p>Ниже описана логика приведенного выше фрагмента кода.</p>
     <p>• На каждой итерации цикла в конце файла добавляются новые данные.</p>
     <p>• В случае возникновения исключения во время выполнения итерации цикла все данные, накопленные во временном файле, будут уничтожены, и если еще остались невыполненные итерации, то во временном файле начнут накапливаться новые данные.</p>
     <p>• В случае возникновения исключения на последней итерации файл прекращает существование. В любом случае файл будет содержать все данные, сгенерированные после предыдущего исключения.</p>
     <p>• В примере отмечена лишь одна точка программы, в которой возможно возникновение исключения, хотя исключения могут возникнуть в любой точке тела цикла.</p>
     <p>• Чтобы гарантировать закрытие дескриптора файла, это делается как при выходе из цикла, так и перед началом очередной итерации цикла.</p>
    </section>
    <section>
     <title>
      <p>Коды исключений</p>
     </title>
     <p>Для точной идентификации типа возникшего исключения блок исключения или выражение фильтра могут использовать следующую функцию:</p>
     <cite>
      <p><code>DWORD GetExceptionCode(VOID)</code></p>
     </cite>
     <p>Код исключения должен быть получен сразу же после возникновения исключения. Поэтому функция фильтра не может просто вызвать функцию GetExceptionCode (это ограничение налагается компилятором). Обычный способ решения этой проблемы состоит в том, чтобы осуществить этот вызов в выражении фильтра, как показано в следующем примере, в котором код исключения является аргументом функции фильтра, предоставляемой пользователем:</p>
     <p><code>__except(MyFilter(GetExceptionCode())) {</code></p>
     <p><code>}</code> </p>
     <p>В данном случае значение выражения фильтра, которое должно быть одним из трех указанных ранее значений, определяется и возвращается функцией фильтра. В свою очередь, для определения возвращаемого этой функцией значения используется код исключения; например, можно сделать так, чтобы фильтр передавал обработку исключений, возникающих при выполнении операций с плавающей точкой (FP-исключений, от <emphasis>FloatingPoint —</emphasis> плавающая точка), внешнему обработчику (возвращая значение EXCEPTION_CONTINUE_SEARCH), а обработку нарушений доступа к памяти — текущему обработчику (возвращая значение EXCEPTION_EXECUTE_HANDLER).</p>
     <p>Число возможных кодов исключений, возвращаемых функцией GetExceptionCode, очень велико, однако их можно разделить на несколько категорий.</p>
     <p>• Выполнение программой некорректных действий, например:</p>
     <p>EXCEPTION_ACCESS_VIOLATION — попытка чтения или записи по адресу виртуальной памяти, к которой процесс не имеет доступа.</p>
     <p>EXCEPTION_DATATYPE_MISALIGNMENT — многие процессоры, например, требуют чтобы данные типа DWORD выравнивались по четырехбайтовым границам.</p>
     <p>EXCEPTION_NONCONTINUABLE_EXECUTION — значением выражения фильтра было EXCEPTION_CONTINUE_EXECUTION, но выполнения программы после возникновения исключения не может быть продолжено.</p>
     <p>• Исключения, сгенерированные функциями распределения памяти НеарAlloc и HeapCreate, если они используют флаг HEAP_GENERATE_EXCEPTIONS (см. главу 5). Соответствующими значениями кода исключения являются STATUS_NO_MEMORY или EXCEPTION_ACCESS_VIOLATION.</p>
     <p>• Коды определенных пользователем исключений, генерируемых путем вызова функции RaiseException, о чем говорится в подразделе "Исключения, генерируемые приложением".</p>
     <p>• Коды различных арифметических исключений (особенно FP-исключений), например, EXCEPTION_INT_DIVIDE_BY_ZERO или EXCEPTION_FLT_OVERFLOW.</p>
     <p>• Исключения, используемые отладчиками, например, EXCEPTION_BREAKPOINT или EXCEPTION_SINGLE_STEP.</p>
     <p>Вам пригодится также функция GetExceptionInformation, которая может быть вызвана только из выражения фильтра и возвращает дополнительную информацию, включая информацию, специфическую для используемого процессора. </p>
     <cite>
      <p><code>LPEXCEPTION_POINTERS GetExceptionINFORMATION(VOID)</code> </p>
     </cite>
     <p>Вся информация, как относящаяся, так и не относящаяся к процессору, содержится в структуре EXCEPTION_POINTERS, состоящей из двух других структур.  </p>
     <cite>
      <p><code>typedef struct _EXCEPTION_POINTERS {</code></p>
      <p><code> PEXCEPTION_RECORD ExceptionRecord;</code></p>
      <p><code> PCONTEXT ContextRecord;</code></p>
      <p><code>} EXCEPTION POINTERS;</code> </p>
     </cite>
     <p>В структуру EXCEPTION_RECORD входит элемент ExceptionCode, набор возможных значений которого совпадает с набором значений, возвращаемых функцией GetExceptionCode. Элемент ExceptionFlags структуры EXCEPTION_RECORD может принимать значения 0 или EXCEPTION_NONCONTINUABLE, причем последнее значение указывает функции фильтра на то, что она не должна предпринимать попыток продолжения выполнения. К числу других элементов данных этой структуры относятся адрес виртуальной памяти ExceptionAddress и массив параметров ExceptionInformation. В случае исключения EXCEPTION_ACCESS_VIOLATION значение первого элемента этого массива указывает на то, какая именно из операций пыталась получить доступ по недоступному адресу — записи (1) или чтения (0). Второй элемент содержит адрес виртуальный памяти.</p>
     <p>Во втором элементе структуры EXCEPTION_POINTERS, а именно, элементе ContextRecord, содержится информация, относящаяся к процессору. Для каждого типа процессоров предусмотрены свои структуры, определения которых содержатся в файле &lt;winnt.h&gt;.</p>
    </section>
    <section>
     <title>
      <p>Резюме: последовательность обработки исключений</p>
     </title>
     <p>На рис. 4.2 в схематическом виде представлена последовательность событий, происходящих после возникновении исключения. Слева приведен программный код, а обведенные кружками цифры справа обозначают операции, выполняемые языковыми средствами поддержки времени выполнения. Отдельные элементы приведенной схемы имеют следующий смысл:</p>
     <p>1. Возникло исключение; в данном случае это деление на ноль.</p>
     <p>2. Управление передается обработчику исключений, в котором вычисляется выражение фильтра. Сначала вызывается функция GetExceptionCode, а затем ее возвращаемое значение используется в качестве аргумента функции Filter.</p>
     <p>3. Функция фильтра выполняет действия, определяемые значением кода исключения.</p>
     <p>4. В данном случае значением кода исключения является EXCEPTION_INT_DIVIDE_BY_ZERO.</p>
     <p>5. Функция фильтра устанавливает, что должен быть выполнен код обработчика исключений, и поэтому возвращает значение EXCEPTION_EXECUTE_HANDLER.</p>
     <p>6. Выполняется код обработчика исключений, связанного с оператором _except.</p>
     <p>7. Управление передается за пределы блоков try и except. </p>
     <image l:href="#Any2FbImgLoader57"/>
     <p><strong>Рис. 4.2.</strong> Последовательность операций при обработке исключений</p>
    </section>
   </section>
   <section>
    <title>
     <p>Исключения, возникающие при выполнении операций над числами с плавающей точкой</p>
    </title>
    <p>Существует семь различных кодов исключений, которые могут возникать при выполнении операций с использованием данных вещественного типа. Первоначально эти исключения отключены и не могут возникать до тех пор, пока с помощью функции _controlfp для них не будет предварительно задана специальная маска, не зависящая от типа процессора. Предусмотрены отдельные исключения для ситуаций антипереполнения, переполнения, деления на ноль, неточного результата и так далее, что иллюстрируется приведенным ниже фрагментом кода. Для активизации исключений определенного типа следует <emphasis>отключить</emphasis> соответствующий бит маски. </p>
    <cite>
     <p><code>DWORD _controlfp(DWORD new, DWORD mask)</code> </p>
    </cite>
    <p>Фактическое значение маски определяется ее текущим значением (current_mask) и двумя аргументами следующим образом:</p>
    <p><code>(current_mask &amp; ~mask) | (new &amp; mask)</code></p>
    <p>Данная функция устанавливает лишь те из битов, указанных в аргументе new, которые разрешены аргументом mask. Биты, не активизированные аргументом mask, не изменяются. Маска FP-исключений управляет также точностью, округлением и обработкой значений, соответствующих бесконечности, поэтому при активизации перечисленных исключений необходимо тщательно следить за тем, чтобы случайно не изменить эти установки.</p>
    <p>Возвращаемым значением является фактическое значение маски. Так, при нулевых значениях обоих аргументов возвращаемым значением будет текущее значение маски (current_mask), что может быть использовано для восстановления маски, если впоследствии в этом возникнет необходимость. С другой стороны, если задать аргумент mask равным 0xFFFFFFFF, то регистр установится в new, что, например, может быть использовано для восстановления прежнего значения маски.</p>
    <p>Обычно для того, чтобы разрешить исключения, связанные с выполнением операций над числами с плавающей точкой, в качестве аргумента mask используют константу MCW_EM, как продемонстрировано в следующем примере. Также заметьте, что при обработке FP-исключения оно должно быть сброшено путем использования функции _clearfp.</p>
    <p><code>#include &lt;float.h&gt;</code></p>
    <p><code>DWORD FPOld, FPNew; /* Старое и новое значения маски. */</code></p>
    <p><code>…</code></p>
    <p><code>FPOld = _controlfp(0, 0); /* Сохранить старую маску. */</code></p>
    <p><code>/* Указать в качестве разрешенных шесть типов исключений. */</code></p>
    <p><code>FPNew = FPOld &amp; ~(EM_OVERFLOW | EM_UNDERFLOW | EM_INEXACT | EM_ZERODIVIDE | EM_DENORMAL | EM_INVALID); </code></p>
    <p><code>/* Установить новую управляющую маску. Параметр MCW_EM объединяет шесть исключений, указанных в предыдущем операторе. */ </code></p>
    <p><code>_controlfp(FPNew, MCW_EM);</code></p>
    <p><code>while(…) __try { /* Выполнить вычисления над числами с плавающей точкой. */</code></p>
    <p><code> … /* На этом участке кода может возникнуть FP-исключение. */</code></p>
    <p><code>} __except(EXCEPTION_EXECUTE_HANDLER) {</code></p>
    <p><code> … /* Обработать FP-исключение. */</code></p>
    <p><code> _clearfp(); /* Сбросить исключение. */</code></p>
    <p><code> _controlfp(FPOld, 0xFFFFFFFF); /* Восстановить маску. */</code></p>
    <p><code>}</code></p>
    <p>В этом примере разрешены все возможные FP-исключения, кроме одного — EXCEPTION_FLT_STACK_CHECK, которое соответствует переполнению стека при выполнении операций над числами с плавающей точкой. Можно поступить и по-другому, разрешая отдельные исключения путем использования только выбранных масок исключений, например EM_OVERFLOW. Аналогичный код используется в программе 4.3 в контексте примера программного кода большего объема.</p>
   </section>
   <section>
    <title>
     <p>Ошибки и исключения</p>
    </title>
    <section>
     <p>Под ошибками понимаются исключительные ситуации, которые время от времени могут возникать в известных местах программы. Так, обнаружение ошибок, возникающих во время выполнения системных вызовов, и немедленный вывод сообщений о них должны предусматриваться логикой работы самой программы. Поэтому программисты, как правило, явно включают в программный код участки, ответственные, например, за тестирование успешности завершения операции чтения данных из файла. В главе 2 для диагностики ошибок и принятия соответствующих мер была разработана функция ReportError.</p>
     <p>С другой стороны, исключения могут возникать практически в любом месте программы, и поэтому организация явной проверки всех исключений невозможна или практически нецелесообразна. Примерами подобных ситуаций могут служить попытки деления на ноль или обращения к недоступным областям памяти.</p>
     <p>Вместе с тем, указанные различия между ошибками и исключениями являются довольно условными. Windows позволяет управлять генерацией исключений, возникающих в случае нехватки памяти при ее распределении с использованием функций НеарАllос и HeapCreate. Этот процесс описан в главе 5. Помимо этого, программы могут генерировать собственные исключения с кодами, определяемыми программистом, используя для этого функцию RaiseException, о чем далее будет говориться.</p>
     <p>Обработчики исключений обеспечивают удобный механизм выхода из внутренних блоков или функций под управлением программы без использования операторов перехода goto или longjmp. Такая возможность оказывается особенно полезной, если блок получил доступ к таким, например, ресурсам, как открытые файлы, память или объекты синхронизации, поскольку обработчик может взять на себя задачу освобождения этих ресурсов. Возможно также продолжение работы программы после выполнения кода обработчика исключений, а не ее обязательное завершение. Кроме того, после выхода из блока программа может восстанавливать прежнее состояние системы, например маску FP-исключений. Именно в этом ключе обработчики используются во многих наших примерах.</p>
    </section>
    <section>
     <title>
      <p>Исключения, генерируемые приложением</p>
     </title>
     <p>Существует возможность формирования исключений в любой точке программы в процессе ее выполнения с помощью функции RaiseException. Это позволяет программе обнаруживать и обрабатывать возникающие ошибки как исключения.</p>
     <p><code>VOID RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD cArguments, CONST DWORD *lpArguments)</code></p>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>dwExceptionCode — код исключения, определяемый пользователем. Бит 28 использовать нельзя, так как он зарезервирован системой. Для кода ошибки отводятся биты 27—0 (то есть все слово, кроме самого старшего шестнадцатеричного разряда). Бит 29 должен быть установлен, чтобы показать, что данное исключение имеет "пользовательскую" природу (а не относится к числу тех, которые предусмотрела Microsoft). В битах 31—30 содержится код серьезности ошибки, принимающий приведенные ниже значения, в которых результирующая старшая шестнадцатеричная цифра кода исключения представлена с установленным битом 29.</p>
     <p>• 0 — успешное выполнение (старшая шестнадцатеричная цифра кода исключения равна 2).</p>
     <p>• 1 — информационный код (старшая шестнадцатеричная цифра кода исключения равна 6).</p>
     <p>• 2 — предупреждение (старшая шестнадцатеричная цифра кода исключения равна А).</p>
     <p>• 3 — ошибка (старшая шестнадцатеричная цифра кода исключения равна Е).</p>
     <p>dwExceptionFlags — обычно устанавливается равным 0, тогда как установка значения EXCEPTION_NONCONTINUABLE будет указывать на то, что выражение фильтра не должно возвращать значение EXCEPTION_CONTINUE_EXECUTION; при попытке это сделать будет немедленно сгенерировано исключение ЕХСЕРTION_NONCONTINUABLE_EXCEPTION.</p>
     <p>lpArguments — этот указатель, если он не равен NULL, указывает на массив размера cArguments (третий параметр), содержащий 32-битовые значения, которые должны быть переданы выражению фильтра. Максимально возможное число этих значений ограничивается значением EXCEPTION_MAXIMUM_PARAMETERS, которое в настоящее время установлено равным 15. Для доступа к этой структуре следует использовать функцию GetExceptionInformation.</p>
     <p>Заметьте, что невозможно сгенерировать исключение в другом процессе. В то же время, при весьма ограниченных условиях для этой цели могут быть использованы обработчики управляющих сигналов консоли, о чем говорится в конце этой главы и в главе 6. </p>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: обработка ошибок как исключений</p>
    </title>
    <p>В предыдущих примерах для обработки ошибок при выполнении системных вызовов и других ошибок используется функция ReportError. Эта функция прекращает выполнение процесса, если программист указал, что данная ошибка является критической. Вместе с тем, такой подход препятствует нормальному выходу из программы и не обеспечивает возможность продолжения работы программы после устранения последствий ошибки. Так, после отказа от задачи, которая привела к возникновению сбоя, может потребоваться уничтожение временных файлов, созданных в процессе работы программы, или переход программы к выполнению других задач. Функции ReportError присущи и другие ограничения, перечень которых приводится ниже.</p>
    <p>• Даже в тех случаях, когда было бы достаточно прекратить выполнения только одного потока, критическая ошибка приводит к остановке всего процесса (главу 7).</p>
    <p>• Вместо завершения процесса может оказаться желательным продолжение выполнения программы.</p>
    <p>• Во многих случаях становится невозможным освобождение ресурсов синхронизации (глава 8), например мьютексов.</p>
    <p>При прекращении выполнения процесса (но не потоки) открытые дескрипторы будут закрываться, однако при этом необходимо учитывать другие отрицательные факторы.</p>
    <p>Решение заключается в написании новой функции — ReportException. Если ошибка не является критической, эта функция вызывает функцию ReportError (разработанную в главе 2), которая выводит сообщение об ошибке. В случае же возникновения критической ошибки будет сгенерировано исключение. Система будет использовать обработчик исключений из вызывающего try-блока, и поэтому в действительности характер исключения может быть некритическим, если обработчик предоставляет программе возможность восстановиться после сбоя. По существу, функция ReportException дополняет обычные программные методы защиты от ошибок, ранее ограниченные функцией ReportError. В случае обнаружения ошибки обработчик позволяет программе продолжить свою работу после выполнения необходимых восстановительных действий. Эти возможности иллюстрирует программа 4.2.</p>
    <p>Функция ReportException представлена в программе 4.1. Необходимые определения и заголовочные файлы не указаны, поскольку эта функция находится в том же модуле исходного кода, что и функция ReportError. </p>
    <subtitle>Программа 4.1. ReportException: функция вывода сообщений об исключениях </subtitle>
    <p><code>/* Расширение функции ReportError для генерации формируемого приложением кода исключения вместо прекращения выполнения процесса. */ </code></p>
    <p><code>VOID ReportException(LPCTSTR UserMessage, DWORD ExceptionCode) </code></p>
    <p><code>/* Вывести сообщение о некритической ошибке. */</code></p>
    <p><code>{</code></p>
    <p><code> ReportError(UserMessage, 0, TRUE);</code></p>
    <p><code> /* Если ошибка критическая, сгенерировать исключение. */</code></p>
    <p><code> if (ExceptionCode != 0) RaiseException((0x0FFFFFFF &amp; ExceptionCode) | 0xE0000000, 0, 0, NULL);</code></p>
    <p><code> return; </code></p>
    <p><code>}</code></p>
    <p>Функция ReportException используется в нескольких последующих примерах. </p>
    <cite>
     <p>Модель сигналов, используемая в UNIX, значительно отличается от SEH. Сигналы могут быть пропущены или игнорированы, и логика их работы иная. Тем не менее, у этих моделей имеются и общие черты.</p>
     <p>Значительная часть поддержки обработки сигналов в UNIX обеспечивается библиотекой С, ограниченная версия которой доступна также под управлением Windows. Во многих случаях в программах Windows вместо сигналов можно воспользоваться обработчиками управляющих сигналов консоли, описанными в конце данной главы.</p>
     <p>Некоторые сигналы соответствуют исключениямWindows.</p>
     <p>Перечень в некоторой мере ограниченных соответствий "сигнал-исключение" представлен ниже:</p>
     <p>• SIGILL — EXCEPTION_PRIV_INSTRUCTION</p>
     <p>• SIGSEGV — EXCEPTION_ACCESS_VIOLATION</p>
     <p>• SIGFPE — семь различных исключений, связанных с выполнением операций над числами с плавающей точкой, например EXCEPTION_FLT_DIVIDE_BY_ZERO</p>
     <p>• SIGUSR1 и SIGUSR2 — исключения, определяемые приложением </p>
     <p>Функции RaiseException соответствует функция библиотеки С raise.</p>
     <p>В Windows сигналы SIGILL, SIGSEGV и SIGFPE не генерируются, хотя функция raise может генерировать один из них. Сигнал SIGINT в Windows не поддерживается.</p>
     <p>Функция UNIX kill (kill не входит в состав стандартной библиотеки С), которая посылает сигнал другому процессу, может быть сопоставлена функции Windows GenerateConsoleCtrlEvent (глава 6). Для ограниченного варианта SIGKILL в Windows имеются аналоги в виде функций TerminateProcess и TerminateThread, с помощью которых один процесс (или поток) может уничтожить другой, хотя при использовании этих функций необходимо соблюдать осторожность (см. главы 6 и 7).</p>
    </cite>
   </section>
   <section>
    <title>
     <p>Обработчики завершения</p>
    </title>
    <section>
     <p>Обработчики завершения служат в основном тем же целям, что и обработчики исключений, но выполняются, когда поток покидает блок в результате нормального выполнения программы, а также когда возникает исключение. С другой стороны, обработчик завершения не может распознавать исключения.</p>
     <p>Обработчик завершения строится с использования ключевого слова __finally в операторе try…finally. Структура этого оператора аналогична структуре оператора try…finally, но в ней отсутствует выражение фильтра. Как и обработчики исключений, обработчики завершения предоставляют удобные возможности для закрытия дескрипторов, освобождения ресурсов, восстановления масок и выполнения иных действий, направленных на восстановление известного состояния системы после выхода из блока. Например, программа может выполнять операторы return внутри блока, оставляя всю работу по "уборке мусора" обработчику завершения. Благодаря этому отпадает необходимость во включении кода очистки в код самого блока или переходе к коду очистки при помощи оператора goto.</p>
     <p><code>__try {</code></p>
     <p><code> /* Блок кода. */ </code></p>
     <p><code>} _finally {</code></p>
     <p><code> /* Обработчик завершения (блок finally). */ </code></p>
     <p><code>}</code></p>
    </section>
    <section>
     <title>
      <p>Выход из try-блока</p>
     </title>
     <p>Обработчик завершения выполняется всякий раз, когда в соответствии с логикой программы осуществляется выход из try-блока по одной из следующих причин:</p>
     <p>• Достижение конца try-блока и "проваливание" в обработчик завершения.</p>
     <p>• Выполнение одного из следующих операторов таким образом, что происходит выход за пределы блока:</p>
     <p><code>return </code></p>
     <p><code>break </code></p>
     <p><code>goto<a l:href="#n_19" type="note">[19]</a> </code></p>
     <p><code>longjmp</code> </p>
     <p><code>continue</code></p>
     <p><code>__leave<a l:href="#n_20" type="note">[20]</a></code></p>
     <p>• Исключение.</p>
    </section>
    <section>
     <title>
      <p>Аварийное завершение</p>
     </title>
     <p>Любое завершение выполнения программы по причинам, отличным от достижения конца try-блока и "проваливания вниз" или выполнения оператора __leave, считается аварийным завершением. Результатом выполнения оператора __leave является переход в конец блока __try и передача управления вниз по тексту программы, что намного эффективнее простого использования оператора goto, поскольку не требует разворачивания стека. Для определения того, каким образом завершилось выполнение try-блока, в обработчике завершения используется следующая функция: </p>
     <cite>
      <p><code>BOOL AbnormalTermination(VOID)</code> </p>
     </cite>
     <p>При аварийном завершении выполнения блока эта функция возвращает значение TRUE, при нормальном — FALSE.</p>
     <cite>
      <p><strong>Примечание</strong></p>
      <p>Завершение будет считаться аварийным, даже если, например, последним оператором try-блока был оператор return.</p>
     </cite>
    </section>
    <section>
     <title>
      <p>Выполнение обработчика завершения и выход из него</p>
     </title>
     <p>Обработчик завершения, или блок __finally, выполняется в контексте блока или функции, работу которых он отслеживает. Управление может переходить от оператора завершения к следующему оператору. Существует и другая возможность, когда обработчик завершения выполняет оператор передачи управления (return, break, continue, goto, longjmp или __leave). Еще одной возможностью является выход из обработчика по причине возникновения исключения.</p>
    </section>
    <section>
     <title>
      <p>Сочетание блоков finally и except</p>
     </title>
     <p>Один try-блок может иметь только один блок finally или только один блок except, но не может иметь оба указанных блока одновременно. Поэтому нижеприведенный код вызовет появление ошибок на стадии компиляции. </p>
     <p><code>__try {</code></p>
     <p><code> /* Блок контролируемого кода. */</code></p>
     <p><code>} __except (filter_expression) {</code></p>
     <p><code> /* Блок обработчика исключений. */ </code></p>
     <p><code>} __finally {</code></p>
     <p><code> /* Так делать нельзя! Это приведет к ошибке на стадии компиляции. */ </code></p>
     <p><code>}</code></p>
     <p>Вместе с тем, допускается вложение одного блока в другой, что используется довольно часто. Нижеприведенный код является вполне работоспособным и обеспечивает гарантированное удаление временных файлов при выходе из цикла под управлением программы или в результате возникновения исключения. Эта методика оказывается удобной и в тех случаях, когда требуется обеспечить гарантированную отмену блокирования файлов, что будет использовано в программе 4.2. Кроме того, в коде имеется внутренний блок try…except, размещенный в том месте программы, где выполняются вычисления, в которых участвуют вещественные числа.</p>
     <p><code> __try { /* Внешний блок try-except. */</code></p>
     <p><code>  while (…) __try { /* Внутренний блок try-finally. */</code></p>
     <p><code>   hFile = CreateFile(TempFile, …);</code></p>
     <p><code>   if(…) __try { /* Внутренний блок try-except. */</code></p>
     <p><code>    /* Разрешить FP-исключения. Выполнить вычисления. */</code></p>
     <p><code>    …</code></p>
     <p><code>   } __except(EXCEPTION_EXECUTE_HANDLER) {</code></p>
     <p><code>    … /* Обработать FP-исключение. */</code></p>
     <p><code>    _clearfp();</code></p>
     <p><code>   }</code></p>
     <p><code>   … /* Обработка исключений, не являющихся FP-исключениями. /*</code></p>
     <p><code>  } __finally { /* Конец цикла while. */</code></p>
     <p><code>   /* Выполняется на КАЖДОЙ итерации цикла. */</code></p>
     <p><code>   CloseHandle(hFile);</code></p>
     <p><code>   DeleteFile(TempFile);</code></p>
     <p><code>  } </code></p>
     <p><code> } __except (<emphasis>filter-expression)</emphasis> {</code></p>
     <p><code> /* Обработчик исключений. */</code></p>
     <p><code>}</code></p>
    </section>
    <section>
     <title>
      <p>Глобальное и локальное разворачивание стека</p>
     </title>
     <p>Исключения и аварийные завершения вызывают <emphasis>глобальное разворачивание стека</emphasis> (global stack unwind) в поиске обработчика, как было показано на рис. 4.1. Предположим, например, что в отслеживаемом блоке примера, приведенного в конце предыдущего раздела, исключение возникает прежде, чем активизируются FP-исключения. Тогда перед обработчиком исключения в стеке могут находиться многочисленные обработчики завершения.</p>
     <p>Вспомните, что структура стека является динамической, как показано на рис. 4.1, и что в стеке, наряду с другими данными, хранятся данные обработчиков исключений и завершения. Фактическое содержимое стека в любой момент времени зависит от следующих факторов:</p>
     <p>• <emphasis>Статической</emphasis> структуры программных блоков.</p>
     <p>•  <emphasis>Динамической</emphasis> структуры программы, отражаемой в последовательности открытых вызовов функций.</p>
    </section>
    <section>
     <title>
      <p>Обработчики завершения: завершение процессов и потоков</p>
     </title>
     <p>Обработчики завершения не выполняются, если выполнение процесса или потока было прекращено независимо от того, было ли это инициировано самим процессом путем использования функций ExitProcess или ExitThread, или вызвано извне, например, инициировано вызовом функций TerminateProcess или TerminateThread из другого места в программе. Поэтому ни одна из этих функций не должна вызываться процессом или потоком внутри блоков try…except или try…finally.</p>
     <p>Обратите также внимание, что выполнение функции библиотеки С exit или возврат из функции main приводят к выходу из процесса.</p>
    </section>
    <section>
     <title>
      <p>SEH и обработка исключений в C++</p>
     </title>
     <p>При обработке исключений в C++ используются ключевые слова catch и throw, а сам механизм исключений реализован с использованием SEH. Тем не менее, обработка исключений в C++ и SEH — это разные вещи. Их совместное применение требует внимательного обращения, поскольку обработчики исключений, написанные пользователем и сгенерированные C++, могут взаимодействовать между собой и приводить к нежелательным последствиям. Например, находящийся в стеке обработчик __except может перехватить исключение C++, в результате чего данное исключение так и не дойдет до обработчика C++.</p>
     <p>Возможно и обратное, когда, например, обработчик C++ перехватит SEH-исключение, сгенерированное функцией RaiseException. Документация Microsoft рекомендует полностью отказаться от использования обработчиков Windows в программах на C++ и ограничиться применением в них только обработчиков исключений C++.</p>
     <p>Кроме того, обработчики исключений или завершения Windows не осуществляют вызов деструкторов, что в ряде случаев необходимо для уничтожения экземпляров объектов C++.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: использование обработчиков завершения для повышения качества программ</p>
    </title>
    <p>Обработчики исключений и завершения позволяют повысить надежность программ как за счет упрощения процедуры восстановления программы после возникновения ошибок и исключений, так и за счет гарантированного освобождения ресурсов и отмены блокирования файлов в критических ситуациях.</p>
    <p>В программе toupper (программа 4.2) эти моменты иллюстрируются с привлечением идей, почерпнутых в программном коде предшествующих примеров. toupper обрабатывает несколько файлов, имена которых указываются в командной строке, переписывая их с преобразованием всех букв в верхний регистр. Имена преобразованных файлов получаются путем добавления префикса UC_ к исходным именам, и согласно "спецификации" программы запись поверх существующих файлов не производится. Преобразование файлов осуществляется в памяти машины, поэтому для каждого файла выделяется большая буферная область (достаточная для размещения всего файла). Кроме того, чтобы исключить любую возможность изменения файлов другими процессами, а также для того, чтобы вновь создаваемые выходные файлы строго соответствовали преобразованным входным файлам, оба вида файлов блокируются во время обработки. Понятно, что на каждой стадии обработки существует вероятность возникновения самых различных сбойных ситуаций, но в программе должна быть предусмотрена защита от подобных ошибок, и она должна располагать средствами, позволяющими ей восстановить свое нормальное состояние и попытаться обработать все остальные файлы, имена которых были указаны в командной строке. Программа 4.2 решает все эти задачи, обеспечивая разблокирование файлов во всех необходимых случаях без применения громоздкой логики операторов ветвления, к которым пришлось бы прибегнуть, если бы не были использованы средства SEH. Более подробные комментарии к программе содержатся в программном коде, находящемся на Web-сайте книги.</p>
    <subtitle>Программа 4.2. toupper: обработка файлов с восстановлением нормального состояния программы после сбоев</subtitle>
    <p><code>/* Глава 4. Команда toupper. */</code></p>
    <p><code>/* Преобразование содержимое одного и более файлов с заменой всех букв на прописные. Имя выходного файла получается из имени входного файла добавлением к нему префикса UC_. */</code></p>
    <p><code>#include "EvryThng.h"</code></p>
    <empty-line/>
    <p><code>int _tmain(DWORD argc, LPTSTR argv[]) {</code></p>
    <p><code> HANDLE hIn = INVALID_HANDLE_VALUE, hOut = INVALID_HANDLE_VALUE;</code></p>
    <p><code> DWORD FileSize, nXfer, iFile, j;</code></p>
    <p><code> CHAR OutFileName [256] = "", *pBuffer = NULL;</code></p>
    <p><code> OVERLAPPED ov = {0, 0, 0, 0, NULL}; /* Используется для блокирования файлов. */</code></p>
    <p><code> if (argc &lt;= 1) ReportError(_T("Использование: toupper файлы"), 1, FALSE);</code></p>
    <p><code> /* Обработать все файлы, указанные в командной строке. */</code></p>
    <p><code> for (iFile = 1; iFile &lt; argc; iFile++) __try { /* Блок исключений. */</code></p>
    <p><code>  /* Все дескрипторы файлов недействительны, pBuffer == NULL, а файл OutFileName пуст. Выполнение этих условий обеспечивается обработчиками. */</code></p>
    <p><code>  _stprintf(OutFileName, "UC_%s", argv[iFile]);</code></p>
    <p><code>  __try { /* Внутренний блок try-finally. */</code></p>
    <p><code>   /* Ошибка на любом шаге сгенерирует исключение, и следующий */</code></p>
    <p><code>   /* файл будет обрабатываться только после "уборки мусора". */</code></p>
    <p><code>   /* Объем работы по очистке зависит от того, в каком месте */</code></p>
    <p><code>   /* программы возникла ошибка. */</code></p>
    <p><code>   /* Создать выходной файл (завершается с ошибкой, если файл уже существует). */</code></p>
    <p><code>   hIn = CreateFile(argv[iFile], GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);</code></p>
    <p><code>   if (hIn == INVALID_HANDLE_VALUE) ReportException(argv[iFile], 1);</code></p>
    <p><code>   FileSize = GetFileSize(hIn, NULL);</code></p>
    <p><code>   hOut = CreateFile(OutFileName, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_NEW, 0, NULL);</code></p>
    <p><code>   if (hOut == INVALID_HANDLE_VALUE) ReportException(OutFileName, 1);</code></p>
    <p><code>   /* Распределить память под содержимое файла. */</code></p>
    <p><code>   pBuffer = malloc(FileSize);</code></p>
    <p><code>   if (pBuffer == NULL) ReportException(_T("Ошибка при распределении памяти"), 1);</code></p>
    <p><code>   /* Блокировать оба файла для обеспечения целостности копии. */</code></p>
    <p><code>   if (!LockFileEx(hIn, LOCKFILE_FAIL_IMMEDIATELY, 0, FileSize, 0, &amp;ov) ReportException(_T("Ошибка при блокировании входного файла"), 1);</code></p>
    <p><code>   if (!LockFileEx(hOut, LOCKFILE_EXCLUSIVE_LOCK | LOCKFILE_FAIL_IMMEDIATELY, 0, FileSize, 0, &amp;ov) ReportException(_T("Ошибка при блокировании выходного файла "), 1);</code></p>
    <p><code>   /* Считать данные, преобразовать их и записать в выходной файл. */</code></p>
    <p><code>   /* Освободить ресурсы при завершении обработки или возникновении */</code></p>
    <p><code>   /* ошибки; обработать следующий файл. */</code></p>
    <p><code>   if (!ReadFile(hIn, pBuffer, FileSize, &amp;nXfer, NULL)) ReportException(_T("Ошибка при чтении файла"), 1);</code></p>
    <p><code>   for (j = 0; j &lt; FileSize; j++) /* Преобразовать данные. */</code></p>
    <p><code>    if (isalpha(pBuffer [j])) pBuffer[j] = toupper(pBuffer [j]);</code></p>
    <p><code>   if(WriteFile(hOut, pBuffer, FileSize, &amp;nXfer, NULL)) ReportException(T("Ошибка при записи в файл"), 1);</code></p>
    <p><code>  } __finally {</code></p>
    <p><code>   /*Освобождение блокировок, закрытие дескрипторов файлов,*/</code></p>
    <p><code>   /*освобождение памяти и повторная инициализация */</code></p>
    <p><code>   /*дескрипторов и указателя. */</code></p>
    <p><code>   if (pBuffer != NULL) free (pBuffer);</code></p>
    <p><code>   pBuffer = NULL;</code></p>
    <p><code>   if (hIn != INVALID_HANDLE_VALUE) {</code></p>
    <p><code>    UnlockFileEx(hIn, 0, FileSize, 0, &amp;ov);</code></p>
    <p><code>    CloseHandle(hIn);</code></p>
    <p><code>    hIn = INVALID_HANDLE_VALUE;</code></p>
    <p><code>   }</code></p>
    <p><code>   if (hOut != INVALID_HANDLE_VALUE) {</code></p>
    <p><code>    UnlockFileEx(hOut, 0, FileSize, 0, &amp;ov);</code></p>
    <p><code>    CloseHandle(hOut);</code></p>
    <p><code>    hOut = INVALID_HANDLE_VALUE;</code></p>
    <p><code>   }</code></p>
    <p><code>   _tcscpy(OutFileName, _T(""));</code></p>
    <p><code>  }</code></p>
    <p><code> }</code></p>
    <p><code> /* Конец основного цикла обработки файлов и блока try. */</code></p>
    <p><code> /* Обработчик исключений для тела цикла. */</code></p>
    <p><code> __except(EXCEPTION_EXECUTE_HANDLER) {</code></p>
    <p><code>  _tprintf(_T("Ошибка при обработке файла %s\n"), argv[iFile]);</code></p>
    <p><code>  DeleteFile (OutFileName);</code></p>
    <p><code> }</code></p>
    <p><code> _tprintf(_T("Обработаны все файлы, кроме указанных выше \n"));</code></p>
    <p><code> return 0; </code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>Пример: использование функции фильтра</p>
    </title>
    <p>Программа 4.3 представляет собой каркас программы, иллюстрирующей обработку исключений и завершения выполнения, в которой используется функция фильтра. Программа предлагает пользователю указать тип исключения, после чего продолжает работу для генерации исключения. Функция фильтра обрабатывает различные типы исключений по-разному; выбор вариантов, предусмотренных в программе, был совершенно произвольным и определялся исключительно целями демонстрации. В частности, программа обнаруживает попытки обращения к недоступным областям памяти, предоставляя адреса виртуальной памяти, по которым производилось такое обращение.</p>
    <p>Блок __finally восстанавливает состояние маски FP-исключений. Совершенно очевидно, что восстановление состояния маски в данном случае, когда процесс уже должен завершаться, особого значения не имеет, но эта методика пригодится нам впоследствии, когда мы будем использовать ее на стадии завершения выполнения потока. Вообще говоря, процесс должен восстанавливать и системные ресурсы, например, удалять временные файлы, освобождать ресурсы синхронизации (глава 8) и отменять блокирование файлов (главы 3 и 6). Функция фильтра представлена в программе 4.4.</p>
    <p>Данный пример не иллюстрирует обработку исключений, которые могут возникать при распределении памяти; эти исключения мы начнем интенсивно использовать в главе 5.</p>
    <subtitle>Программа 4.3. Exception: обработка исключений и завершения выполнения</subtitle>
    <p><code>#include "EvryThng.h" </code></p>
    <p><code>#include &lt;float.h&gt;</code></p>
    <empty-line/>
    <p><code>DWORD Filter(LPEXCEPTION_POINTERS, LPDWORD); </code></p>
    <p><code>double x = 1.0, у = 0.0;</code></p>
    <empty-line/>
    <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> DWORD ECatgry, i = 0, ix, iy = 0;</code></p>
    <p><code> LPDWORD pNull = NULL;</code></p>
    <p><code> BOOL Done = FALSE;</code></p>
    <p><code> DWORD FPOld, FPNew;</code></p>
    <p><code> FPOld = _controlfp(0, 0); /* Сохранить старую управляющую маску. */</code></p>
    <p><code> /* Разрешить FP-исключения. */</code></p>
    <p><code> FPNew = FPOld &amp; ~(EM_OVERFLOW | EM_UNDERFLOW | EM_INEXACT | EM_ZERODIVIDE | EM_DENORMAL | EM_INVALID);</code></p>
    <p><code> _controlfp(FPNew, MCW_EM);</code></p>
    <p><code> while (!Done) _try { /* Блок try-finally. */</code></p>
    <p><code>  _tprintf(_T("Введите тип исключения: "));</code></p>
    <p><code>  _tprintf(_T(" 1: Mem, 2: Int, 3: Flt 4: User 5: __leave "));</code></p>
    <p><code>  _tscanf(_T("%d"), &amp;i);</code></p>
    <p><code>  __try { /* Блок try-except. */</code></p>
    <p><code>   switch (i) {</code></p>
    <p><code>   case 1: /* Исключение при обращении к памяти. */</code></p>
    <p><code>    ix = *pNull;</code></p>
    <p><code>    *pNull = 5;</code></p>
    <p><code>    break;</code></p>
    <p><code>   case 2: /* Исключение при выполнении арифметических операций над целыми числами. */</code></p>
    <p><code>    ix = ix / iy;</code></p>
    <p><code>    break;</code></p>
    <p><code>   case 3: /* FP-исключение. */</code></p>
    <p><code>    x = x / у;</code></p>
    <p><code>    _tprintf(_T("x = %20e\n"), x);</code></p>
    <p><code>    break;</code></p>
    <p><code>   case 4: /* Пользовательское исключение. */</code></p>
    <p><code>    ReportException(_T("Пользовательское исключение"), 1);</code></p>
    <p><code>    break;</code></p>
    <p><code>   case 5: /* Использовать оператор _leave для завершения выполнения.*/</code></p>
    <p><code>    __leave;</code></p>
    <p><code>   default:</code></p>
    <p><code>    Done = TRUE;</code></p>
    <p><code>   }</code></p>
    <p><code>  } /* Конец внутреннего блока __try. */</code></p>
    <p><code>  __except(Filter(GetExceptionInformation(), &amp;ECatgry)) {</code></p>
    <p><code>   switch(ECatgry) {</code></p>
    <p><code>   case 0:</code></p>
    <p><code>    _tprintf(_T("Неизвестное исключение\n"));</code></p>
    <p><code>    break;</code></p>
    <p><code>   case 1:</code></p>
    <p><code>    _tprintf(_T("Исключение при обращении к памяти\n"));</code></p>
    <p><code>    continue;</code></p>
    <p><code>   case 2:</code></p>
    <p><code>    _tprintf(_T("Исключение при выполнении арифметических операций над целыми числами \n"));</code></p>
    <p><code>    break;</code></p>
    <p><code>   case 3:</code></p>
    <p><code>    _tprintf(_Т("FР-исключение\n"));</code></p>
    <p><code>    _clearfp();</code></p>
    <p><code>    break;</code></p>
    <p><code>   case 10:</code></p>
    <p><code>    _tprintf(_T("Пользовательское исключение\n"));</code></p>
    <p><code>    break;</code></p>
    <p><code>   default:</code></p>
    <p><code>    _tprintf(_T("Неизвестное исключение\n"));</code></p>
    <p><code>    break;</code></p>
    <p><code>   } /* Конец оператора switch. */</code></p>
    <p><code>   _tprintf(_Т("Конец обработчика\n"));</code></p>
    <p><code>  }</code></p>
    <p><code>  /* Конец блока try-except. */</code></p>
    <p><code> } /* Конец цикла while – ниже находится обработчик завершения. */</code></p>
    <p><code> __finally { /* Это часть цикла while. */</code></p>
    <p><code>  _tprintf(_T("Аварийное завершение?: %d\n"),</code></p>
    <p><code>  AbnormalTermination());</code></p>
    <p><code> }</code></p>
    <p><code> _controlfp(FPOld, 0xFFFFFFFF); /* Восстановить старую FP-маску.*/</code></p>
    <p><code> return 0; </code></p>
    <p><code>}</code></p>
    <p>Программа 4.4 представляет функцию фильтра, используемую в программе 4.3. Эта функция просто проверяет и классифицирует различные возможные значения кодов исключений. В программном коде, размещенном на Web-сайте книги, проверяется каждое из возможных значений, в то время как приведенная ниже функция осуществляет проверку лишь тех из них, которые нужны для тестовой программы.</p>
    <subtitle>Программа 4.4. Функция Filter</subtitle>
    <p><code>static DWORD Filter(LPEXCEPTION_POINTERS pExP, LPDWORD ECatgry)</code></p>
    <p><code>/* Классификация исключений и выбор соответствующего действия. */ </code></p>
    <p><code>{</code></p>
    <p><code> DWORD ExCode, ReadWrite, VirtAddr;</code></p>
    <p><code> ExCode = pExP-&gt;ExceptionRecord-&gt;ExceptionCode;</code></p>
    <p><code> _tprintf(_T("Filter. ExCode:. %x\n"), ExCode);</code></p>
    <p><code> if ((0x20000000 &amp; ExCode) != 0) { /* Пользовательское исключение. */</code></p>
    <p><code>  *ECatgry =10;</code></p>
    <p><code>  return EXCEPTION_EXECUTE_HANDLER;</code></p>
    <p><code> }</code></p>
    <p><code> switch (ExCode) {</code></p>
    <p><code> case EXCEPTION_ACCESS_VIOLATION:</code></p>
    <p><code>  ReadWrite = /* Операция чтения или записи? */</code></p>
    <p><code>   pExP-&gt;ExceptionRecord-&gt;ExceptionInformation[0];</code></p>
    <p><code>  VirtAddr = /* Адрес сбоя в виртуальный памяти. */</code></p>
    <p><code>   pExP-&gt;ExceptionRecord-&gt;ExceptionInformation [1];</code></p>
    <p><code>  _tprintf(_T("Нарушение доступа. Чтение/запись: %d. Адрес: %х\n"), ReadWrite, VirtAddr);</code></p>
    <p><code>  *ECatgry = 1;</code></p>
    <p><code>  return EXCEPTION_EXECUTE_HANDLER;</code></p>
    <p><code> case EXCEPTION_INT_DIVIDE_BY_ZERO:</code></p>
    <p><code> case EXCEPTION_INT_OVERFLOW:</code></p>
    <p><code>  *ECatgry = 2;</code></p>
    <p><code>  return EXCEPTION_EXECUTE_HANDLER;</code></p>
    <p><code> case EXCEPTION_FLT_DIVIDE_BY_ZERO:</code></p>
    <p><code> case EXCEPTION_FLT_OVERFLOW:</code></p>
    <p><code>  _tprintf(_T("FP-исключение — слишком большое значение.\n"));</code></p>
    <p><code>  *ECatgry = 3;</code></p>
    <p><code>  _clearfp();</code></p>
    <p><code>  return (DWORD)EXCEPTION_EXECUTE_HANDLER;</code></p>
    <p><code> default:</code></p>
    <p><code>  *ECatgry = 0;</code></p>
    <p><code>  return EXCEPTION_CONTINUE_SEARCH;</code></p>
    <p><code> }</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>Обработчики управляющих сигналов консоли</p>
    </title>
    <p>Обработчики исключений могут реагировать на самые разнообразные события, но они не в состоянии обнаруживать такие ситуации, как выход пользователя из системы или нажатие комбинации клавиш &lt;Ctrl+C&gt; на клавиатуре с целью прекращения выполнения программы. Для обработки таких событий требуются обработчики управляющих сигналов консоли.</p>
    <p>Функция SetConsoleCtrlHandler позволяет одной или нескольким указанным функциям выполняться в ответ на получение сигналов Ctrl-c, Ctrl-break или одного из трех других сигналов, связанных с консолью. Функция GenerateConsoleCtrlEvent, описанная в главе 6, также генерирует эти сигналы, а, кроме того, все эти сигналы могут посылаться другим процессам, совместно использующим ту же консоль. Обработчиками сигналов являются указанные пользователем функции, которые возвращают булевские значения и принимают единственный аргумент типа DWORD, идентифицирующий фактический сигнал.</p>
    <p>С одним сигналом могут быть ассоциированы несколько обработчиков, причем обработчики можно добавлять и удалять. Функция, которая используется для добавления и удаления обработчиков, имеет следующий вид:</p>
    <cite>
     <p><code>BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add)</code> </p>
    </cite>
    <p>Значению флага Add, равному TRUE, соответствует добавление процедуры обработчика, в противном случае происходит удаление процедуры из списка процедур обработки управляющих сигналов консоли. Заметьте, что тип сигнала при вызове функции не конкретизируется. Тестирование с целью проверки того, какой именно сигнал получен, должен выполнять сам обработчик.</p>
    <p>Процедура обработчика возвращает булевское значение и принимает единственный параметр типа DWORD, идентифицирующий фактический сигнал. Использованное в объявлении имя обработчика (HandlerRoutine) является заменителем, и программист может выбирать его по своему усмотрению.</p>
    <p>Ниже приводятся дополнительные полезные сведения, касающиеся использования обработчиков управляющих сигналов консоли.</p>
    <p>• Если значение параметра HandlerRoutine равно NULL, а параметра Add — TRUE, то сигналы Ctrl-c будут игнорироваться.</p>
    <p>• Если при вызове функции SetConsoleMode был задан параметр ENABLE_PROCESSED_INPUT (глава 2), то комбинация &lt;Ctrl+C&gt; будет обрабатываться не как сигнал, а как клавиатурный ввод.</p>
    <p>• Процедура обработчика фактически выполняется как независимый поток (см. главу 7) внутри процесса. При этом выполнение основной программы, как показано в следующем примере, не приостанавливается.</p>
    <p>• Формирование исключения в обработчике <emphasis>не вызовет</emphasis> исключения в потоки, выполнение которого было прервано, поскольку исключения применяются только к потокам, а не к процессу в целом. Если вы хотите организовать связь с прерванным потоком, используйте переменную, как в следующем примере, или метод синхронизации (глава 8).</p>
    <p>Между исключениями и сигналами существует важное отличие. Сигналы применяются к процессу в целом, тогда как исключения — только к потоку, выполняющему код, в котором возникло исключение. </p>
    <cite>
     <p><code>BOOL <emphasis>HandlerRoutine</emphasis>(DWORD dwCtrlType)</code></p>
    </cite>
    <p>dwCtrlType идентифицирует фактический сигнал (или <emphasis>событие)</emphasis> и может принимать одно из следующих пяти значений:</p>
    <p>1. CTRL_C_EVENT указывает на то, что комбинация &lt;Ctrl+C&gt; должна восприниматься как клавиатурный ввод.</p>
    <p>2. CTRL_CLOSE_EVENT указывает на закрытие окна консоли.</p>
    <p>3. CTRL_BREAK_EVENT указывает на сигнал Ctrl-break.</p>
    <p>4. CTRL_LOGOFF_EVENT указывает на выход пользователя из системы.</p>
    <p>5. CTRL_SHUTDOWN_EVENT указывает на завершение работы системы. </p>
    <p>Обработчик сигналов может выполнять операции по "уборке мусора" точно так же, как это делают обработчики исключений и завершения. В случае успешной обработки сигнала обработчик должен вернуть значение TRUE. Если обработчик возвращает значение FALSE, выполняется следующая функция обработчика из числа тех, что указаны в списке. Обработчики сигналов выполняются в порядке, обратном порядку их установки, так что первым будет выполняться самый последний из установленных обработчиков, а системный обработчик будет выполняться самым последним.</p>
   </section>
   <section>
    <title>
     <p>Пример: обработчик управляющих сигналов консоли</p>
    </title>
    <p>В программе 4.5 организован бесконечный цикл, в котором каждые 5 секунд вызывается функция Веер, подающая звуковой сигнал. Пользователь может завершить выполнение программы, нажав комбинацию клавиш &lt;Ctrl+C&gt; или закрыв консоль. Процедура обработчика выводит на экран сообщение, выжидает 10 секунд, после чего, казалось бы, выполнение программы должно завершиться с возвратом значения TRUE. Однако в действительности основная программа обнаруживает флаг Exit и останавливает процесс. Это демонстрирует параллельную природу выполнения процедуры обработчика; заметьте, что объем выходной информации обработчика сигналов зависит от временных характеристик сигнала. Обработчики управляющих сигналов консоли будут использоваться также в примерах, приводимых в следующих главах.</p>
    <p>Обратите внимание на использование макроса WINAPI; он применяется к пользовательским функциям, передаваемым в качестве аргументов функциям Windows, чтобы гарантировать выполнение соответствующих соглашений о вызовах. Этот макрос определен в заголовочном файле Microsoft С WTYPES.Н.</p>
    <subtitle>Программа 4.5. Ctrlc: программа обработки сигналов </subtitle>
    <p><code>/* Глава 4. Ctrlc.с */</code></p>
    <p><code>/* Перехватчик событий консоли. */</code></p>
    <p><code>#include "EvryThng.h"</code></p>
    <empty-line/>
    <p><code>static BOOL WINAPI Handler(DWORD CtrlEvent); /* См. WTYPES.H. */ </code></p>
    <p><code>volatile static BOOL Exit = FALSE;</code></p>
    <empty-line/>
    <p><code>int _tmain(int argc, LPTSTR argv[])</code></p>
    <p><code> /* Периодическая подача звукового сигнала до поступления сигнала о прекращении выполнения. */ </code></p>
    <p><code>{</code></p>
    <p><code> /* Добавить обработчик событий. */</code></p>
    <p><code> if (!SetConsoleCtrlHandler(Handler, TRUE)) ReportError(_T("Ошибка при установке обработчика событий."), 1, TRUE);</code></p>
    <p><code> while (!Exit) {</code></p>
    <p><code>  Sleep (5000); /* Подача звукового сигнала каждые 5 секунд. */</code></p>
    <p><code>  Веер(1000 /* Частота. */, 250 /* Длительность. */); </code></p>
    <p><code> }</code></p>
    <p><code> _tprintf(_T("Прекращение выполнения программы по требованию.\n"));</code></p>
    <p><code> return 0; </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>BOOL WINAPI Handler (DWORD CtrlEvent) {</code></p>
    <p><code> Exit = TRUE;</code></p>
    <p><code> switch (CntrlEvent) {</code></p>
    <p><code> /* Увидите ли вы второе сообщения обработчика, зависит от соотношения временных параметров. */</code></p>
    <p><code> case CTRL_C_EVENT:</code></p>
    <p><code>  _tprintf(_T("Получен сигнал Ctrl-c. Выход из обработчика через 10 секунд.\n"));</code></p>
    <p><code>  Sleep(4000); /* Уменьшите это значение, чтобы получить другой эффект. */</code></p>
    <p><code>  _tprintf(_T("Выход из обработчика через 6 секунд.\n"));</code></p>
    <p><code>  Sleep(6000); /* Попробуйте уменьшить и это значение. */</code></p>
    <p><code>  return TRUE; /* TRUE указывает на успешную обработку сигнала. */</code></p>
    <p><code> case CTRL_CLOSE_EVENT:</code></p>
    <p><code>  _tprintf(_T("Выход из обработчика через 10 секунд.\n"));</code></p>
    <p><code>  Sleep(4000);</code></p>
    <p><code>  _tprintf(_Т ("Выход из обработчика через 6 секунд.\n"));</code></p>
    <p><code>  Sleep (6000); /* Попробуйте уменьшить и это значение. */</code></p>
    <p><code>  return TRUE; /* Попробуйте возвратить FALSE. Приводит ли это к изменению поведения программы? */</code></p>
    <p><code> default:</code></p>
    <p><code>  _tprintf(_T("Событие: %d. Выход из обработчика через 10 секунд.\n"), CntrlEvent);</code></p>
    <p><code>  Sleep(4000);</code></p>
    <p><code>  _tprintf(_T("Выход из обработчика через 6 секунд.\n"));</code></p>
    <p><code>  Sleep(6000);</code></p>
    <p><code>  return TRUE;</code></p>
    <p><code> }</code></p>
    <p><code>}</code> </p>
   </section>
   <section>
    <title>
     <p>Векторная обработка исключений</p>
    </title>
    <p>Функции обработки исключений можно непосредственно связывать с исключениями, точно так же, как обработчики управляющих сигналов консоли можно связывать с управляющими событиями консоли. В этом случае, если возникает исключение, то первыми, еще до того, как система начнет разворачивать стек в поиске структурных обработчиков исключений, будут вызываться <emphasis>векторные обработчики исключений</emphasis> (vectored exception handlers). При этом никакие ключевые слова, аналогичные __try или __catch, не требуются. Такая возможность предоставляется только в Windows XP и Windows Server 2003. </p>
    <p>Работа с векторными обработчиками исключений (Vectored Exception Handling, VEH) напоминает работу с обработчиками управляющих сигналов консоли, хотя детали и отличаются. Для добавления, или регистрации, обработчика служит функция AddVectoredExceptionHandler. </p>
    <cite>
     <p><code>PVOID AddVectoredExceptionHandler(ULONG FirstHandler, PVECTORED_EXCEPTION_HANDLER VectoredHandler)</code> </p>
    </cite>
    <p>Обработчики можно связывать в цепочки, поэтому первый параметр First-Handler указывает, что при возникновении исключения обработчик должен вызываться либо первым (ненулевое значение), либо последним (нулевое значение). Последующие вызовы функции AddVectoredExceptionHandler могут изменить этот порядок. Например, если добавляются два обработчика, причем для каждого из них задаются нулевые значения параметра FirstHandler, то они будут вызываться в том порядке, в котором добавлялись.</p>
    <p>Функция RemoveVectoredExceptionHandler, прекращающая регистрацию векторного обработчика исключений, требует задания единственного параметра, адреса обработчика, и в случае успешного выполнения возвращает ненулевое значение.</p>
    <p>Функция AddVectoredExceptionHandler в случае успешного выполнения возвращает адрес обработчика исключений, т.е. VectoredHandler. Возвращаемое значение NULL указывает на неудачное завершение выполнения функции.</p>
    <p>VectorHandler — это указатель на функцию обработчика, которая имеет следующий прототип: </p>
    <cite>
     <p><code>LONG WINAPI VectoredHandler(PEXCEPTION_POINTERS ExceptionInfo)</code></p>
    </cite>
    <p>PEXCEPTION_POINTERS — адрес структуры EXCEPTION_POINTERS, которая содержит как информацию, зависящую от типа процессора, так и информацию общего характера. Это та же структура, которую возвращает функция GetExceptionInformation и которая уже использовалась нами в программе 4.4.</p>
    <p>От функции VEH-обработчика требуется, чтобы она выполнялась быстро и никогда не получала доступа к объектам синхронизации, таким как мьютекс (см. главу 8). В большинстве случаев VEH-обработчики просто обращаются к структуре исключения, выполняют некоторую минимальную обработку (например, устанавливают флаг) и осуществляют возврат. Возможны два возвращаемых значения, с которыми мы уже встречались при обсуждении SEH-обработчиков.</p>
    <p>1. EXCEPTION_CONTINUE_EXECUTION — обработчики далее не выполняются, обработка средствами SEH не производится, и управление передается в ту точку программы, в которой возникло исключение. Как и в случае SEH, это оказывается возможным не всегда.</p>
    <p>2. EXCEPTION_CONTINUE_SEARCH — выполняется следующий VEH-обработчик, если таковой имеется. Если обработчиков больше нет, разворачивается стек для поиска SEH-обработчиков.</p>
    <p>В упражнении 4.9 вам предлагается добавить VEH в программы 4.3 и 4.4.</p>
   </section>
   <section>
    <title>
     <p>Резюме</p>
    </title>
    <section>
     <p>Структурная обработка исключений в Windows предоставляет в распоряжение разработчиков механизм повышения надежности, благодаря которому С-программы могут адекватно реагировать на ошибки и исключения и восстанавливаться после возникновения сбоев в процессе выполнения. Методы обработки исключений отличаются высокой эффективностью, и их применение делает структуру программ более понятной, что облегчает их сопровождение и улучшает их качественные характеристики. В большинстве других языков и ОС также реализованы аналогичные подходы, однако решение Windows обеспечивает возможность точного анализа природы возникающих исключений.</p>
     <p>Обработчики управляющих сигналов консоли позволяют реагировать на внешние события, наступление которых не сопровождается генерацией исключений. Векторная обработка исключений является новейшим средством, обеспечивающим выполнение соответствующих функций еще до того, как начнется выполнение SEH-процедур. Механизм VEH аналогичен обычному механизму векторных прерываний.</p>
    </section>
    <section>
     <title>
      <p>В следующих главах</p>
     </title>
     <p>Функция ReportException, a также обработчики исключений и завершения будут неоднократно использоваться в последующих примерах, когда в этом возникнет необходимость. Глава 5 посвящена вопросам управления памятью, а в приведенных в ней в качестве примера программах для обнаружения ошибок, которые могут возникать в процессе распределения памяти, используется механизм SEH.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Упражнения</p>
    </title>
    <p>4.1. Расширьте возможности программы 4.2 путем предоставления при каждом вызове функции ReportException достаточно большого объема информации, чтобы обработчик исключений в своих сообщениях указывал точную природу возникающих ошибок и удалял выходные файлы, если их содержимое оказывается незначащим. </p>
    <p>4.2.  Расширьте возможности программы 4.3 за счет генерации таких исключений, связанных с нарушениями доступа к памяти, как выход индекса за пределы допустимого диапазона, а также исключений, обусловленных сбоями при выполнении арифметических операций, и других FP-исключений, не предусмотренных в программе 4.3.</p>
    <p>4.3.  Дополните программу 4.3 таким образом, чтобы она выводила на печать фактическое значение FP-маски после разрешения исключений. Все ли исключения оказались действительно разрешенными? Объясните результаты.</p>
    <p>4.4.  Какие значения вы в действительности получаете после возникновения таких FP-исключений, как деление на ноль? Можете ли вы установить результат в функции фильтра, как это пытается делать программа 4.3?</p>
    <p>4.5. Что произойдет при выполнении программы 4.3, если не сбросить FP-исключение? Объясните результат. <emphasis>Подсказка.</emphasis> Запросите дополнительное исключение после возникновения FP-исключения.</p>
    <p>4.6. Расширьте возможности программы 4.5 таким образом, чтобы процедура обработчика формировала исключение, а не возврат из функции. Объясните полученные результаты.</p>
    <p>4.7. Расширьте возможности программы 4.5 таким образом, чтобы она могла обрабатывать сигналы, указывающие на выход пользователя из системы и завершение работы системы.</p>
    <p>4.8. Экспериментальным путем убедитесь в том, что процедура обработчика в программе 4.5 выполняется параллельно с основной программой.</p>
    <p>4.9. Усовершенствуйте программы 4.3 и 4.4. В частности, организуйте обработку арифметических и FP-исключений до активизации SEH.</p>
   </section>
  </section>
  <section>
   <title>
    <p>ГЛАВА 5</p>
    <p>Управление памятью, отображение файлов и библиотеки DLL</p>
   </title>
   <section>
    <p>Управление динамической памятью в той или иной форме требуется в большинстве программ. Необходимость в этом возникает всякий раз, когда требуется создавать структуры данных, размер которых не может быть определен заранее на стадии создания программы. Типичными примерами динамических структур данных могут служить деревья поиска, таблицы имен и связанные списки.</p>
    <p>В Windows предусмотрены гибкие механизмы управления динамической памятью программы. Кроме того, Windows предоставляет средства отображения файлов, которые позволяют ассоциировать файл непосредственно с виртуальным адресным пространством процесса, благодаря чему ОС может управлять любыми перемещениями данных между файлом и памятью, так что программисту вообще не приходится иметь дело с функциями ReadFile, WriteFile, SetFilePointer и другими функциями ввода/вывода.</p>
    <p>В случае использования отображения файлов программе удобно сохранять внутренние динамические структуры данных в виде постоянно существующих файлов, а все алгоритмы обработки применять к создаваемой в памяти копии файла. Более того, отображение файлов может значительно ускорить последовательную обработку файлов и предоставляет механизм, обеспечивающий совместное использование областей памяти одновременно несколькими процессами.</p>
    <p>Важным специальным случаем отображения файлов и разделения памяти являются динамически компонуемые библиотеки (dynamic linked libraries, DLL), обеспечивающие возможность отображения файлов (обычно, когда они используются только для чтения) на адресное пространство процесса для их выполнения.</p>
    <p>В этой главе описывается система управления памятью и функции отображения файлов Windows, что иллюстрируется целым рядом примеров их использования, а также обсуждаются явно и неявно связанные библиотеки DLL.</p>
   </section>
   <section>
    <title>
     <p>Архитектура системы управления памятью в Win32 и Win64</p>
    </title>
    <section>
     <p>Win32 (в данном случае различия между Win32 и Win64 становятся существенными) — это API 32-разрядных ОС семейства Windows. "32-разрядность" проявляет себя при адресации памяти тем, что указатели (LPSTR, LPDWORD и так далее) являются 4-байтовыми (32-битовыми) объектами. Win64 API предоставляет виртуальное адресное пространство гораздо большего объема, и 64-битовые указатели являются естественным результатом эволюции Win32. Тем не менее, о переносимости приложений на платформу Win64 необходимо заботиться отдельно. Настоящее обсуждение будет относиться только к Win32; вопросы миграции приложений на платформу Win64 обсуждаются в главе 16, где также приводятся ссылки на соответствующие источники информации.</p>
     <p>Далее, в рамках Win32 у каждого процесса имеется собственное виртуальное адресное пространство объемом 4 Гбайт (2<emphasis>32</emphasis> байт). Разумеется, объем виртуального адресного пространства в Win64 гораздо больше. По крайней мере, половину указанного пространства (2-3 Гбайт; расширение до 3 Гбайт должно производиться во время загрузки) Win32 делает доступной для процесса. Оставшаяся часть виртуального адресного пространства выделяется для совместно используемых данных и кода, системного кода, драйверов и так далее.</p>
     <p>Хотя детали описанного распределения памяти и заслуживают интереса, здесь они обсуждаться не будут; прикладные программы используют абстрактные модели памяти, предоставляемые API. С точки зрения программиста ОС просто предоставляет адресное пространство большого объема для размещения кода, данных и других ресурсов. В этой главе мы сосредоточим свое внимание на использовании средств управления памятью в Windows, не заботясь о том, как все это реализуется в ОС. Тем не менее, ниже приводится соответствующий краткий обзор.</p>
    </section>
    <section>
     <title>
      <p>Обзор методов управления памятью</p>
     </title>
     <p>Обо всех деталях отображения виртуальных адресов на физические адреса (virtual to physical memory mapping), механизмах страничной подкачки (page swapping) и замещения страниц по запросу (demand paging) и прочих моментах заботится ОС. Эти вопросы подробно обсуждаются в документации по ОС, а также в книге Соломона (Solomon) и Руссиновича (Russinovich) <emphasis>Inside Windows2000.</emphasis> Краткое изложение наиболее существенных сведений приводится ниже:</p>
     <p>• Система может располагать сравнительно небольшим объемом физической памяти; на практике для всех систем, кроме Windows XP, необходимый минимум составляет 128 Мбайт, однако в типичных случаях доступные объемы физической памяти оказываются намного большими.<a l:href="#n_21" type="note">[21]</a></p>
     <p>• Каждый отдельный процесс — а таких процессов, как пользовательских, так и системных, может выполняться одновременно несколько — имеет собственное виртуальное адресное пространство, объем которого может значительно превосходить объем доступного физического адресного пространства. Например, емкость виртуального адресного пространства объемом 1 Гбайт, относящегося к одному процессу, в восемь раз превышает емкость физической памяти объемом 128 Мбайт, и таких процессов может быть множество.</p>
     <p>• ОС преобразует виртуальные адреса в физические адреса.</p>
     <p>• Для большинства виртуальных страниц в физической памяти места не хватит, поэтому ОС имеет возможность реагировать на страничные ошибки (page faults), возникающие при попытках обращения к страницам, которые отсутствуют в памяти, и загружать данные с жесткого диска — из системного файла подкачки (swap file) или из обычного файла. Будучи прозрачными для программиста, страничные ошибки отрицательно влияют на производительность, поэтому программы должны проектироваться таким образом, чтобы вероятность возникновения подобных ошибок была сведена к минимуму. Более подробное освещение этой темы, рассмотрение которой выходит за рамки данной книги, вы найдете в справочной документации по ОС.</p>
     <p>На рис. 5.1 проиллюстрировано расположение уровней API управления памятью Windows поверх диспетчера виртуальной памяти (Virtual Memory Manager, VMM). API виртуальной памяти Windows (VirtualAlloc, VirtualFree, Virtual-Lock, VirtualUnlock и так далее) работает с целыми страницами. API кучи Windows управляет блоками памяти, размер которых определяется пользователем.</p>
     <p>Мы не будем останавливаться на топологии адресного пространства виртуальной памяти, поскольку она не имеет непосредственного отношения к API, различна в Windows 9x и Windows NT и в будущем может измениться. Соответствующая информация содержится в документации Microsoft.</p>
     <p>Тем не менее, многим программистам хотелось бы знать больше о своей среде разработки. Начните исследование структуры памяти в вашей системе с вызова следующей функции:</p>
     <cite>
      <p><code>VOID GetSystemInfo(LPSYSTEM_INFO lpSystemInfo)</code> </p>
     </cite>
     <p>Параметром этой функции служит адрес структуры PSYSTEM_INFO, в которой содержится информация относительно размера системной страницы, а также адресах физической памяти, доступных для приложений.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Куча</p>
    </title>
    <p>Windows поддерживает пулы памяти, называемые <emphasis>кучами</emphasis> (heaps). Процесс может иметь несколько куч, которые используются для распределения памяти. </p>
    <image l:href="#Any2FbImgLoader66"/>
    <p><strong>Рис. 5.1.</strong> Архитектура системы управления памятью Windows</p>
    <empty-line/>
    <p>Во многих случаях одной кучи вполне достаточно, но в силу ряда причин, о которых будет сказано ниже, иногда целесообразно иметь в своем распоряжении несколько куч. Если одной кучи вам хватает, можно обойтись использованием функций управления памятью, предоставляемых библиотекой С (malloc, free, calloc, realloc).</p>
    <p>Кучи являются объектами Windows и, следовательно, имеют дескрипторы. Дескриптор кучи используется при распределении памяти. У каждого процесса имеется куча, заданная по умолчанию, которую использует функция malloc и для получения дескриптора которой используется следующая функция: </p>
    <cite>
     <p><code>HANDLE GetProcessHeap(VOID)</code></p>
     <p><strong>Возвращаемое значение:</strong> дескриптор кучи процесса; в случае неуспешного завершения — NULL. </p>
    </cite>
    <p>Заметьте, что для индикации неудачного завершения функции используется возвращаемое значение NULL, а не INVALID_HANDLE_VALUE, как в случае функции CreateFile. </p>
    <p>Программа также может создать несколько различных куч. Иногда для размещения в памяти отдельных структур данных оказывается удобным, чтобы для каждой из них была предусмотрена своя куча. Использование независимых куч обеспечивает ряд преимуществ.</p>
    <p>• <strong>Отсутствие взаимной дискриминации между потоками. </strong>Ни один из потоков не сможет получить больше памяти, чем распределено для ее кучи. В частности, так называемая утечка памяти (memory leak), возникающая в тех случаях, когда программа "забывает" своевременно освободить память, занятую элементами данных, необходимости в которых больше нет, будет влиять лишь на один поток процесса.<a l:href="#n_22" type="note">[22]</a></p>
    <p>• <strong>Повышение производительности. </strong>Предоставление собственной кучи каждого потока уменьшает состязательность между ними, в результате чего общая производительность программы может значительно повыситься. См. главу 9.</p>
    <p>• <strong>Эффективность размещения данных. </strong>Размещение элементов данных фиксированного размера в небольшой куче может оказаться гораздо более эффективным, чем размещение множества элементов самых различных размеров в одной большой куче. При этом также уменьшается фрагментация памяти. Кроме того, предоставление каждого потока собственной кучи существенно упрощает синхронизацию потоков, что приводит к дополнительному повышению производительности.</p>
    <p>• <strong>Эффективность освобождения памяти. </strong>Области памяти, распределенные для кучи в целом и всех структур данных, которые она содержит, могут быть освобождены с помощью единственного вызова функции. Этот вызов также устранит отрицательные последствия утечки памяти, связанной с данной кучей.</p>
    <p>• <strong>Эффективность локализации обращений к памяти. </strong>Сохранение структуры данных в небольшой куче гарантирует, что для всех элементов данных потребуется сравнительно небольшое количество страниц, а это может уменьшить вероятность возникновения ошибок страниц в процессе обработки элементов структур данных.</p>
    <p>Ценность указанных преимуществ может варьироваться в зависимости от приложения, и многие программисты ограничиваются использованием только кучи процесса, для управления которой используют функции библиотеки С. Однако такой выбор лишает программу возможности воспользоваться способностью функций управления памятью Windows генерировать исключения (обсуждается при рассмотрении функций). В любом случае для создания и уничтожения куч применяются две функции, описания которых приводятся ниже.<a l:href="#n_23" type="note">[23]</a> </p>
    <p>Начальный размер кучи, устанавливаемый параметром dwInitialSize (который может быть нулевым), всегда округляется до величины, кратной размеру страницы, и определяет объем физической памяти (в <emphasis>файле подкачки),</emphasis> который <emphasis>передается</emphasis> (commit) в распоряжение кучи (для последующего распределения памяти по запросам) первоначально, а не в ответ на запросы распределения (allocation) памяти из кучи. Когда программа исчерпывает первоначальный размер кучи, куче автоматически передаются дополнительные страницы памяти вплоть до пор, пока она не достигнет установленного для нее максимального размера. Поскольку файл подкачки является ограниченным ресурсом, рекомендуется откладывать передачу памяти куче на более поздний срок, если только заранее не известно, какой размер кучи потребуется. Максимально допустимый размер кучи при ее увеличении в результате динамического расширения определяется значением параметра dwMaximumSize (если оно ненулевое). Рост куч процессов, заданных по умолчанию, также осуществляется динамическим путем. </p>
    <cite>
     <p><code>HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)</code> </p>
    </cite>
    <p>Возвращаемое значение: дескриптор кучи; в случае неудачного завершения — NULL.</p>
    <p>Типом данных обоих упомянутых полей, связанных с размерами кучи, является не DWORD, a SIZE_T. Тип данных SIZE_T определяется как 32– или 64-битовое целое число без знака, в зависимости от флагов компилятора (_WIN32 или _WIN64). Этот тип данных был введен специально для того, чтобы обеспечить возможность миграции приложений Win64 (см. главу 16), и охватывает весь диапазон 32– и 64-битовых указателей. Вариантом этого типа данных для чисел со знаком является тип SSIZE_T).</p>
    <p>flOptions — этот параметр может объединять следующие два флага:</p>
    <p>• HEAP_GENERATE_EXCEPTIONS: в случае ошибки при распределении памяти вместо возврата значения NULL генерируется исключение, которое должно быть обработано средствами SEH (см. главу 4). Если установлен этот флаг, то такие исключения при сбоях будет возбуждаться не самой функцией HeapCreate, а такими функциями, как HeapAlloc, к рассмотрению которых мы вскоре перейдем.</p>
    <p>• HEAP_NO SERIALIZE: при определенных обстоятельствах, о которых сказано ниже, установка этого флага может привести к незначительному повышению производительности.</p>
    <p>Существуют другие важные моменты, связанные с параметром dwMaximumSize.</p>
    <p>• Если параметр dwMaximumSize имеет ненулевое значение, то виртуальное адресное пространство резервируется в соответствии с этим значением, даже если первоначально не все оно передается в распоряжение кучи. Это значение определяет максимальный размер кучи, о котором в этом случае говорят как о <emphasis>нерастущем</emphasis> (nongrowable). Данный параметр ограничивает размер кучи, чтобы, например, обеспечить отсутствие дискриминации между потоками, о чем говорилось выше.</p>
    <p>• Если же значение dwMaximumSize равно 0, то куча может <emphasis>расти</emphasis> (grow), превышая предел, установленный начальным размером, и в этом случае максимальный размер кучи ограничивается лишь объемом доступного виртуального адресного пространства, не распределенного в данный момент для других куч и файла подкачки.</p>
    <p>Заметьте, что кучи не имеют атрибутов защиты, поскольку доступ к ним извне процесса невозможен. В то же время, для объектов отображения файлов, описанных далее в этой главе, защита предусмотрена (глава 15), так как они могут совместно использоваться несколькими процессами.</p>
    <p>Для уничтожения объекта кучи используется функция HeapDestroy. Она также может служить примером исключения из общих правил, в данном случае — правила, согласно которому для удаления ненужных дескрипторов любого типа используется функция CloseHandle. </p>
    <cite>
     <p><code>BOOL HeapDestroy(HANDLE hHeap)</code> </p>
    </cite>
    <p>Параметр hHeap должен указывать на кучу, созданную посредством вызова функции HeapCreate. Будьте внимательны и следите за тем, чтобы случайно не уничтожить кучу процесса, заданную по умолчанию (дескриптор которой получают с помощью функции GetProcessHeap). В результате уничтожения кучи освобождается область виртуального адресного пространства и физическая область сохранения файла подкачки. Разумеется, правильно спроектированная программа должна уничтожать кучи, необходимости в которых больше нет.</p>
    <p>Помимо всего прочего, уничтожение кучи позволяет быстро освободить память, занимаемую структурами данных, избавляя вас от необходимости отдельного уничтожения каждой из структур, однако экземпляры объектов C++ уничтожены не будут, поскольку их деструкторы при этом не вызываются. Применение операции уничтожения кучи имеет следующие положительные стороны:</p>
    <p>1. Отпадает необходимость в написании программного кода, обеспечивающего обход структур данных.</p>
    <p>2. Отпадает необходимость в освобождении памяти, занимаемой каждым из элементов, по отдельности.</p>
    <p>3. Система не затрачивает время на обслуживание кучи, поскольку отмена распределения памяти для всех элементов структуры данных осуществляется посредством единственного вызова функции. </p>
    <cite>
     <p>Функции библиотеки С используют только одну кучу. В силу этого иметь дело с чем-либо, напоминающим дескрипторы куч Windows, в данном случае не приходится.</p>
     <p>В UNIX адресное пространство процесса может быть увеличено с помощью функции sbrk, однако эта функция не является диспетчером памяти общего назначения.</p>
     <p>При неудачных попытках распределения памяти в UNIX сигналы не генерируются, поэтому в программах должна быть предусмотрена явная проверка значений возвращаемых указателей.</p>
    </cite>
   </section>
   <section>
    <title>
     <p>Управление памятью кучи</p>
    </title>
    <section>
     <p>Для получения блока памяти из кучи следует указать дескриптор области памяти кучи, размер блока и некоторые флаги. </p>
     <cite>
      <p><code>LPVOID НеарАllос(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)</code></p>
      <p><strong>Возвращаемое значение: </strong>в случае успешного выполнения — указатель на распределенный блок памяти, иначе — NULL (если только не была указана генерация исключения). </p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>hHeap — дескриптор кучи, из которой должен быть распределен блок памяти. Этот дескриптор должен быть предоставлен либо функцией GetProcessHeap, либо функцией HeapCreate.</p>
     <p>dwFlags — может объединять следующие флаги:</p>
     <p>• HEAP_GENERATE_EXCEPTIONS и HEAP_NO_SERIALIZE: эти флаги имеют тот же смысл, что и в случае функции HeapCreate. Первый флаг игнорируется, если он был установлен функцией кучи HeapCreate, но активизирует исключения для каждого отдельного вызова функции НеарАllос, даже если функцией HeapCreate флаг HEAP_GENERATE_EXCEPTIONS и не был задан. При распределении памяти из кучи процесса второй флаг использовать не следует.</p>
     <p>• HEAP_ZERO_MEMORY: этот флаг указывает, что распределенная память будет инициализирована значениями 0; если этот флаг не установлен, содержимое памяти является неопределенным.</p>
     <p>dwBytes — размер блока памяти, который должен быть распределен. Для нерастущих куч значение этого параметра не должно превышать 0x7FFF8 (приблизительно 0,5 Мбайт). </p>
     <cite>
      <p><strong>Примечание</strong></p>
      <p>Как только функция HeapAlloc вернула указатель, вы можете использовать его самым обычным способом; ссылаться после этого на его кучу нет никакой необходимости. Заметьте, что тип данных LPVOID может представлять либо 32-битовый, либо 64-битовый указатель.</p>
     </cite>
     <p>Для освобождения блока памяти, распределенного из кучи достаточно вызвать следующую функцию: </p>
     <cite>
      <p><code>BOOL HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)</code> </p>
     </cite>
     <p>dwFlags — значениями этого параметра должны быть 0 или HEAP_NO_SERIALIZE. Значением параметра lpMem должно быть значение, возвращенное функциями HeapAlloc или HeapReAlloc (описана ниже), а дескриптор hHeap должен быть дескриптором кучи, которой принадлежит освобождаемый блок памяти, указываемый lpMem.</p>
     <p>Для повторного распределения блоков памяти с целью изменения их размера используется следующая функция: </p>
     <cite>
      <p><code>LPVOID HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes)</code></p>
      <p><strong>Возвращаемое значение: </strong>в случае успешного выполнения — указатель на перераспределенный блок памяти; в противном случае функция возвращает NULL или вызывает исключение. </p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>• HEAP_GENERATE_EXCEPTIONS и HEAP_NO_SERIALIZE: это те же флаги, которые были описаны при рассмотрении функции HeapAlloc.</p>
     <p>• HEAP_ZERO_MEMORY: нулями инициализируется лишь вновь распределенная память (когда значение параметра dwBytes превышает первоначальный размер блока). Содержимое исходного блока не изменяется.</p>
     <p>• HEAP_REALLOC_IN_PLACE_ONLY: установка этого флага запрещает перемещение блока при перераспределении памяти. Если вы увеличиваете размер блока, адреса добавляемой памяти будут располагаться непосредственно вслед за адресами памяти, занимаемой существующим блоком.</p>
     <p>lpMem — указывает на блок памяти, перераспределяемый из кучи hHeap. </p>
     <p>dwBytes — размер нового блока памяти, который может быть как меньше, так и больше размера существующего блока.</p>
     <p>Обычно возвращенный указатель имеет то же значение, что и указатель lpMem. В то же время, если блок перемещается (чтобы такое перемещение было разрешено, следует при вызове функции опустить флаг HEAP_REALLOC_IN_PLACE_ONLY), то возвращенное значение будет другим. Следите за своевременным изменением любых ссылок на блок. Независимо от того, перемещается блок или не перемещается, содержащиеся в нем данные остаются неизменными; в то же время, при уменьшении блока часть данных может теряться.</p>
     <p>Размер распределенного блока памяти можно определить, вызвав функцию HeapSize (эту функцию следовало бы назвать BlockSize, поскольку о размере кучи она ничего не сообщает), используя в качестве параметров дескриптор кучи и указатель на блок. </p>
     <cite>
      <p><code>DWORD HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)</code></p>
      <p><strong>Возвращаемое значение: </strong>в случае успешного выполнения — размер блока; иначе — ноль.</p>
     </cite>
     <subtitle><emphasis>Флаг HEAP_NO_SERIALIZE</emphasis></subtitle>
     <p>При вызове функций HeapCreate, HeapAlloc и HeapReAlloc можно указывать флаг HEAP_NO_SERIALIZE. Использование этого флага иногда обеспечивает незначительный выигрыш в производительности, поскольку во время обращения функции к куче взаимоисключающая блокировка к потокам в этом случае применяться не будет. Результаты простых тестов, в которых не делалось ничего, кроме распределения блоков памяти, показали повышение производительности примерно на 16 процентов. Этот флаг без какого бы то ни было риска можно использовать в следующих ситуациях:</p>
     <p>• Программа не использует потоки (глава 7), или, точнее, процесс (глава 6) имеет только один поток. В данной главе этот флаг используется во всех примерах.</p>
     <p>• Каждый поток имеет собственную кучу или набор куч, и никакой другой поток не имеет доступа к этой куче.</p>
     <p>• Программа располагает собственным механизмом взаимоисключающей блокировки, который предотвращает одновременный доступ к куче сразу нескольких потоков, использующих функции HeapAlloc и HeapAlloc. Для этой цели также могут применяться функции HeapLock и HeapUnlock. </p>
     <subtitle><emphasis>Флаг HEAP_GENERATE_EXCEPTIONS</emphasis></subtitle>
     <p>Разрешение исключений вместо возврата значений NULL в случае сбоев при распределении памяти позволяет избавиться от утомительной необходимости тестирования результатов каждой попытки такого распределения. К тому же, обработчики исключений или завершения могут производить очистку памяти, которая к этому моменту была частично распределена. Эта методика применена в нескольких примерах.</p>
     <p>Возможны два кода исключения:</p>
     <p>1. STATUS_NO_MEMORY: это значение указывает на то, что системе не удалось создать блок запрошенного объема. Причинами этого могут быть фрагментация памяти, достижение нерастущей кучей максимально допустимого размера или исчерпание всей доступной памяти растущими кучами.</p>
     <p>2. STATUS_ACCESS_VIOLATION: это значение указывает на повреждение кучи.</p>
     <p>Одной из возможных причин этого может быть выполнение программой записи в память с выходом за границы распределенного блока.</p>
    </section>
    <section>
     <title>
      <p>Другие функции кучи</p>
     </title>
     <p>Функция HeapCompact пытается уплотнить, или <emphasis>дефрагментировать,</emphasis> смежные блоки в куче. Функция HeapValidate пытается обнаруживать повреждения кучи. Функция HeapWalk перечисляет блоки в куче, а функция GetProcessHeaps получает все действительные дескрипторы куч.</p>
     <p>Функции HeapLock и HeapUnlock позволяют потоки сериализовать доступ к куче, о чем говорится в главе 8.</p>
     <p>Имейте в виду, что эти функции не работают под управлением Windows 9x или Windows СЕ. Кроме того, имеются некоторые вышедшие из употребления функции, которые использовались ранее для совместимости с 16-битовыми системами. Мы упомянули об этих функциях лишь для того, чтобы лишний раз подчеркнуть тот факт, что многие функции продолжают поддерживаться, хотя никакой необходимости в них больше нет.</p>
    </section>
    <section>
     <title>
      <p>Резюме: управление кучами</p>
     </title>
     <p>Обычная процедура использования куч не представляет никаких сложностей:</p>
     <p>1. Получите дескриптор кучи, воспользовавшись одной из функций CreateНеар или GetProcessHeap.</p>
     <p>2. Распределите блоки из кучи, используя функцию HeapAlloc.</p>
     <p>3. В случае необходимости освободите все или только некоторые блоки при помощи функции HeapFree.</p>
     <p>4. Уничтожьте кучу и закройте ее дескриптор при помощи функции HeapDestroy.</p>
     <p>Этот процесс иллюстрируют рис. 5.2 и программа 5.2. </p>
     <cite>
      <p>В отсутствие необходимости создания отдельных куч или генерации исключений программисты, которые привыкли использовать функции управления памятью из библиотеки С, могут использовать их и далее. При этом, если речь идет о куче процесса, функция malloc эквивалентна функции HeapAlloc, функция realloc — функции HeapReAlloc, а функция free — функции HeapFree. Функция calloc распределяет память и инициализирует объекты, и ее поведение легко эмулируется функцией HeapAlloc. Эквивалент функции HeapSize в библиотеке С отсутствует.</p>
     </cite>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: сортировка файлов с использованием бинарного дерева поиска</p>
    </title>
    <p>Распространенными динамическими структурами данных, требующими управления памятью, являются деревья поиска. Деревья поиска предоставляют удобный способ сопровождения коллекций записей, дополнительным преимуществом которого является возможность применения чрезвычайно эффективных алгоритмов обхода узлов.</p>
    <p>Программа sortBT (программа 5.1) реализует ограниченную версию UNIX-команды sort за счет создания бинарного дерева поиска с использованием двух куч. Ключи размещаются в <emphasis>куче узлов</emphasis> (node heap), представляющей дерево поиска. Каждый узел содержит левый и правый указатели, ключ и указатель на запись в <emphasis>куче данных</emphasis> (data heap). Заметьте, что куча узлов состоит из блоков фиксированного размера, тогда как куча данных содержит строки переменной длины. Наконец, отсортированный файл выводится путем обхода дерева.</p>
    <p>В данном примере для использования в качестве ключа произвольно выбраны первые 8 байтов строки, а не целая строка. В двух других вариантах реализации сортировки, приведенных в настоящей главе (программы 5.4 и 5.5), выполняется сортировка индексированных файлов, а показатели производительности всех трех программ сравниваются в приложении В.</p>
    <p>Последовательность операций по созданию куч и размещению блоков в памяти представлена на рис. 5.2. Программный код, приведенный справа, является <emphasis>псевдокодом,</emphasis> который отражает лишь наиболее существенные вызовы функций и аргументы. В виртуальном адресном пространстве, схематически изображенном слева, выделена память для трех куч, в каждой из которых имеются распределенные блоки. Программа 5.1 незначительно отличается от рисунка в том, что на рисунке, в отличие от программы, корень дерева размещен в куче процесса.</p>
    <cite>
     <p><strong>Примечание</strong></p>
     <p>Фактическое расположение куч и блоков в пределах куч зависит от варианта реализации Windows, а также от предыстории использования памяти процессом, включая рост кучи сверх ее начального размера. Кроме того, после увеличения размера растущей кучи с выходом за границы начальной области она может уже не занимать непрерывное адресное пространство. Наиболее оптимальная практика программирования состоит в том, чтобы не делать относительно фактической топологии распределения памяти никаких предположений; просто используйте функции управления памятью так, как это определяют правила работы с ними.</p>
    </cite>
    <image l:href="#Any2FbImgLoader73"/>
    <image l:href="#Any2FbImgLoader74"/>
    <p><strong>Рис. 5.2.</strong> Управление памятью при наличии нескольких куч</p>
    <empty-line/>
    <p>Программа 5.1 иллюстрирует некоторые методики, которые упрощают программу, но были бы невозможны при использовании одной только библиотеки С или же только кучи процесса.</p>
    <p>• Элементы узлов имеют фиксированный размер и размещаются в собственной куче, тогда как элементы данных переменной длины размещаются в отдельной куче.</p>
    <p>• Готовясь к сортировке очередного файла, программа уничтожает две кучи, а не освобождает память, занимаемую отдельными элементами.</p>
    <p>• Ошибки при распределении памяти обрабатываются как исключения, вследствие чего отпадает необходимость в тестировании возвращаемых значений функциями для отслеживания нулевых указателей.</p>
    <p>Если используется Windows, то сфера применимости таких программ, как программа 5.1, ограничивается файлами небольшого размера, поскольку в виртуальной памяти должны находиться целиком весь файл и копии ключей. Абсолютный верхний предел размера файла определяется объемом доступного виртуального адресного пространства (максимум 3 Гбайт); фактически достижимый предел оказывается еще меньшим. В случае Win64 ограничения подобного рода практически отсутствуют.</p>
    <p>В программе 5.1 вызываются некоторые функции управления деревом: FillTree, InsertTree, Scan и TreeCompare. Все они представлены в программе 5.2.</p>
    <p>В этой программе используются исключения кучи. Можно было бы поступить иначе, отказавшись от использования флага HEAP_GENERATE_EXCEPTIONS и отслеживая ошибки, возникающие при распределении памяти, явным образом.</p>
    <subtitle>Программа 5.1. sortBT: сортировка с использованием бинарного дерева поиска </subtitle>
    <p><code>/* Глава 5. Команда sortBT. Версия, использующая бинарное дерево поиска.*/</code></p>
    <p><code>#include "EvryThng.h" </code></p>
    <p><code>#define KEY_SIZE 8</code></p>
    <empty-line/>
    <p><code>typedef struct _TreeNode {/* Описание структуры узла. */</code></p>
    <p><code> struct _TreeNode *Left, *Right;</code></p>
    <p><code> TCHAR Key[KEY_SIZE];</code></p>
    <p><code> LPTSTR pData;</code></p>
    <p><code>} TREENODE, *LPTNODE, **LPPTNODE; </code></p>
    <p><code>#define NODE_SIZE sizeof(TREENODE) </code></p>
    <p><code>#define NODE_HEAP_ISIZE 0x8000 </code></p>
    <p><code>#define DATA_HEAP_ISIZE 0x8000 </code></p>
    <p><code>#define MAX_DATA_LEN 0x1000 </code></p>
    <p><code>#define TKEY_SIZE KEY_SIZE * sizeof(TCHAR)</code></p>
    <empty-line/>
    <p><code>LPTNODE FillTree(HANDLE, HANDLE, HANDLE);</code></p>
    <p><code>BOOL Scan(LPTNODE);</code></p>
    <p><code>int KeyCompare (LPCTSTR, LPCTSTR); iFile;</code></p>
    <empty-line/>
    <p><code>BOOL InsertTree (LPPTNODE, LPTNODE);</code></p>
    <empty-line/>
    <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> HANDLE hIn, hNode = NULL, hData = NULL;</code></p>
    <p><code> LPTNODE pRoot;</code></p>
    <p><code> CHAR ErrorMessage[256];</code></p>
    <p><code> int iFirstFile = Options(argc, argv, _T("n"), &amp;NoPrint, NULL);</code></p>
    <p><code> /* Обработать все файлы, указанные в командной строке. */</code></p>
    <p><code> for (iFile = iFirstFile; iFile &lt; argc; iFile++) __try {</code></p>
    <p><code>  /* Открыть входной файл. */</code></p>
    <p><code>  hIn = CreateFile(argv[iFile], GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);</code></p>
    <p><code>  if (hIn == INVALID_HANDLE_VALUE) RaiseException(0, 0, 0, NULL);</code></p>
    <p><code>  __try { /* Распределить две кучи. */</code></p>
    <p><code>   hNode = HeapCreate(HEAP_GENERATE_EXCEPTIONS | HEAP_NO_SERIALIZE, NODE_HEAP_ISIZE, 0);</code></p>
    <p><code>   hData = HeapCreate(HEAP_GENERATE_EXCEPTIONS | HEAP_NO_SERIALIZE, DATA_HEAP_ISIZE, 0); </code></p>
    <p><code>   /* Обработать входной файл, создавая дерево. */</code></p>
    <p><code>   pRoot = FillTree(hIn, hNode, hData);</code></p>
    <p><code>   /* Отобразить дерево в порядке следования ключей. */</code></p>
    <p><code>   _tprintf(_T("Сортируемый файл: %s\n"), argv [iFile]);</code></p>
    <p><code>   Scan(pRoot);</code></p>
    <p><code>  } _ finally { /* Кучи и дескрипторы файлов всегда закрываются.</code></p>
    <p><code>   /* Уничтожить обе кучи и структуры данных. */</code></p>
    <p><code>   if (hNode !=NULL) HeapDestroy (hNode);</code></p>
    <p><code>   if (hNode != NULL) HeapDestroy (hData);</code></p>
    <p><code>   hNode = NULL;</code></p>
    <p><code>   hData = NULL;</code></p>
    <p><code>   if (hIn != INVALID_HANDLE_VALUE) CloseHandle (hIn);</code></p>
    <p><code>  }</code></p>
    <p><code> } /* Конец основного цикла обработки файлов и try-блока. */</code></p>
    <p><code> __except(EXCEPTION_EXECUTE_HANDLER) {</code></p>
    <p><code>  _stprintf(ErrorMessage, _T("\n%s %s"), _T("sortBT, ошибка при обработке файла:"), argv [iFile]);</code></p>
    <p><code>  ReportError(ErrorMessage, 0, TRUE); </code></p>
    <p><code> }</code></p>
    <p><code> return 0; </code></p>
    <p><code>}</code></p>
    <p>В программе 5.2 представлены функции, которые фактически реализуют алгоритмы поиска с использованием бинарного дерева. Первая из этих функций, FillTree, распределяет память в обеих кучах. Вторая функция, KeyCompare, используется также в нескольких других программах в данной главе. Заметьте, что функции FillTree и KeyCompare используют обработчики завершения и исключений программы 5.1, которая вызывает эти функции. Таким образом, ошибки распределения памяти будут обрабатываться основной программой, которая после этого продолжит свое выполнение, переходя к обработке следующего файла.</p>
    <subtitle>Программа 5.2. FillTree и другие функции управления деревом поиска </subtitle>
    <p><code>LPTNODE FillTree(HANDLE hIn, HANDLE hNode, HANDLE hData) </code></p>
    <p><code>/* Заполнение дерева записями из входного файла. Используется обработчик исключений вызывающей программы. */</code></p>
    <p><code>{</code></p>
    <p><code> LPTNODE pRoot = NULL, pNode;</code></p>
    <p><code> DWORD nRead, i;</code></p>
    <p><code> BOOL AtCR;</code></p>
    <p><code> TCHAR DataHold [MAX_DATA_LEN] ;</code></p>
    <p><code> LPTSTR pString;</code></p>
    <p><code> while (TRUE) {</code></p>
    <p><code>  /* Разместить и инициализировать новый узел дерева. */</code></p>
    <p><code>  pNode = HeapAlloc(hNode, HEAP_ZERO_MEMORY, NODE_SIZE);</code></p>
    <p><code>  /* Считать ключ из следующей записи файла. */</code></p>
    <p><code>  if (!ReadFile(hIn, pNode-&gt;Key, TKEY_SIZE, &amp;nRead, NULL) || nRead != TKEY_SIZE) return pRoot; </code></p>
    <p><code>  AtCR = FALSE; /* Считать данные до конца строки. */</code></p>
    <p><code>  for (i = 0; i &lt; MAX_DATA_LEN; i++) {</code></p>
    <p><code>   ReadFile(hIn, &amp;DataHold [i], TSIZE, &amp;nRead, NULL);</code></p>
    <p><code>   if (AtCR &amp;&amp; DataHold [i] == LF) break;</code></p>
    <p><code>   AtCR = (DataHold [i] == CR);</code></p>
    <p><code>  }</code></p>
    <p><code>  DataHold[i – 1] = '\0';</code></p>
    <p><code>  /* Объединить ключ и данные — вставить в дерево. */</code></p>
    <p><code>  pString = HeapAlloc(hData, HEAP_ZERO_MEMORY, (SIZE_T)(KEY_SIZE + _tcslen (DataHold) + 1) * TSIZE);</code></p>
    <p><code>  memcpy(pString, pNode-&gt;Key, TKEY_SIZE);</code></p>
    <p><code>  pString [KEY_SIZE] = '\0';</code></p>
    <p><code>  _tcscat (pString, DataHold);</code></p>
    <p><code>  pNode-&gt;pData = pString;</code></p>
    <p><code>  InsertTree(&amp;pRoot, pNode);</code></p>
    <p><code> } /* Конец цикла while (TRUE). */</code></p>
    <p><code> return NULL; /* Ошибка */ </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>BOOL InsertTree(LPPTNODE ppRoot, LPTNODE pNode)</code></p>
    <p><code>/* Добавить в дерево одиночный узел, содержащий данные. */</code></p>
    <p><code>{</code></p>
    <p><code> if (*ppRoot == NULL) {</code></p>
    <p><code>  *ppRoot = pNode;</code></p>
    <p><code>  return TRUE;</code></p>
    <p><code> }</code></p>
    <p><code> /* Обратите внимание на рекурсивные вызовы InsertTree. */</code></p>
    <p><code> if (KeyCompare(pNode-&gt;Key, (*ppRoot)-&gt;Key) &lt; 0) InsertTree(&amp;((*ppRoot)-&gt;Left), pNode);</code></p>
    <p><code> else InsertTree(&amp;((*ppRoot)-&gt;Right), pNode); </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>static int KeyCompare(LPCTSTR pKey1, LPCTSTR pKey2) </code></p>
    <p><code>/* Сравнить две записи, состоящие из обобщенных символов. */ </code></p>
    <p><code>{</code></p>
    <p><code> return _tcsncmp(pKey1, pKey2, KEY_SIZE); </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>static BOOL Scan(LPTNODE pNode) </code></p>
    <p><code>/* Рекурсивный просмотр и отображение содержимого бинарного дерева. */ </code></p>
    <p><code>{</code></p>
    <p><code> if (pNode == NULL) return TRUE;</code></p>
    <p><code> Scan(pNode-&gt;Left);</code></p>
    <p><code> _tprintf(_T ("%s\n"), pNode-&gt;pData);</code></p>
    <p><code> Scan(pNode-&gt;Right);</code></p>
    <p><code> return TRUE; </code></p>
    <p><code>}</code> </p>
    <cite>
     <p><strong>Примечание</strong></p>
     <p>Очевидно, что данную реализацию дерева поиска нельзя назвать самой эффективной, поскольку дереву поиска ничто не мешает стать несбалансированным. Разумеется, о балансировке дерева поиска следовало бы позаботиться, однако на организацию управления памятью в программе это никак не повлияет.</p>
    </cite>
   </section>
   <section>
    <title>
     <p>Отображение файлов</p>
    </title>
    <section>
     <p>Динамическая память, распределенная в кучах, должна физически размещаться в файле подкачки. Управление перемещением страниц между физической памятью и файлом подкачки, а также отображением файла подкачки на виртуальное адресное пространство процесса осуществляется средствами ОС, ответственными за управление памятью. По завершении выполнения процесса физическое пространство в этом файле освобождается.</p>
     <p>Те же функциональные возможности Windows, которые обеспечивают отображение файла подкачки, позволяют отображать и обычные файлы. Отображение файлов дает следующие преимущества:</p>
     <p>• Отпадает необходимость в выполнении операций непосредственного файлового ввода/вывода (чтения и записи).</p>
     <p>• Структуры данных, созданные в памяти, будут сохраняться в файле для последующего использования этой же или другими программами. Необходимо тщательно следить за правильностью использования указателей, что иллюстрируется в программе 5.5.</p>
     <p>• Становится возможным применение удобных и эффективных алгоритмов, ориентированных на работу с файлами "в памяти" (in-memory files) (сортировка, деревья поиска, обработка строк и тому подобное), которые позволяют обрабатывать хранящиеся в файлах данные даже в тех случаях, когда размеры файлов значительно превышают доступный объем физической памяти. При больших размерах файлов особенности организации страничного обмена могут оказывать заметное влияние на производительность.</p>
     <p>• В некоторых случаях значительно повышается эффективность обработки файлов.</p>
     <p>• Исчезает необходимость в управлении буферами и манипулировании содержащимися в них данными файлов. Всю эту тяжелую работу выполняет ОС, причем делает она это в высшей степени эффективно и надежно.</p>
     <p>• Обеспечивается возможность разделения памяти несколькими параллельно выполняющимися процессами (глава 6) за счет отображения на их виртуальные адресные пространства одного и того же обычного файла или файла подкачки (разделение памяти несколькими процессами является одной из основных причин использования объекта отображения файла подкачки).</p>
     <p>• Отпадает необходимость в расходовании излишнего пространства файла подкачки. </p>
     <p>ОС сама использует методы отображения файлов для реализации DLL, а также для загрузки и выполнения исполняемых (.EXE) файлов. Библиотеки DLL описаны в конце настоящей главы.</p>
    </section>
    <section>
     <title>
      <p>Объекты отображения файлов</p>
     </title>
     <p>Сначала необходимо создать для открытого файла <emphasis>объект отображения файла</emphasis> (file mapping object), у которого имеется дескриптор, а затем отобразить этот файл или только некоторую его часть на виртуальное адресное пространство процесса. Объектам отображения можно присваивать имена, по которым к ним смогут обращаться другие процессы, разделяющие память совместно с данным процессом. Кроме того, объекты отображения файлов имеют параметры размера и атрибуты защиты. </p>
     <cite>
      <p><code>HANDLE CreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpsa, DWORD dwProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCTSTR lpMapName)</code></p>
      <p><strong>Возвращаемое значение: </strong>в случае успешного выполнения — дескриптор объекта отображения файла, иначе — NULL. </p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>hFile — дескриптор открытого файла, атрибуты защиты которого совместимы с флагами защиты, указанными параметром dwProtect. Значение этого дескриптора (тип данных HANDLE), равное 0xFFFFFFFF (его эквивалент — символическая константа INVALID_HANDLE_VALUE), соответствует системному файлу подкачки, и его можно использовать для организации разделения памяти несколькими процессами без создания отдельного файла.</p>
     <p>LPSECURITY_ATTRIBUTES — позволяет указать атрибуты защиты объекта отображения.</p>
     <p>dwProtect — с помощью флагов, которые приводятся ниже, определяет возможности доступа к представлению файла при его отображении. Помимо упомянутых флагов предусмотрены дополнительные флаги, имеющие специальное назначение. Так, флаг SEC_IMAGE указывает на то, что открытый файл, на основе которого создается объект отображения, является исполняемым загрузочным модулем; для получения более подробной информации обратитесь к оперативной справочной документации.</p>
     <p>• PAGE_READONLY: страницы в указанной области отображения доступны программе только для чтения; программа не может осуществлять в них запись или запускать на выполнение. Файл с дескриптором hFile должен быть открыт с правами доступа GENERIC_READ.</p>
     <p>• PAGE_READWRITE: предоставляет полный доступ к объекту, если файл с дескриптором hFile был открыт с правами доступа GENERIC_READ и GENERIC_WRITE.</p>
     <p>• PAGE_WRITECOPY: при изменении отображения файла его приватная (для данного процесса) копия записывается в файл подкачки, а не в исходный файл. Отладчики могут использовать этот флаг для установки точек прерывания в разделяемом коде.</p>
     <p>dwMaximumSizeHigh и dwMaximumSizeLow — соответственно, старшая и младшая 32-битовые части значения максимального размера объекта отображения файла. Если оба эти параметры равны 0, используется текущий размер файла; в случае работы с файлом подкачки указание размера является обязательным. Если предполагается, что впоследствии файл может увеличиться, укажите его предполагаемый конечный размер, и, если это необходимо, этот размер будет сразу же установлен для файла. Не пытайтесь отображать область файла, лежащую за пределами указанного размера, поскольку размер объекта отображения расти не может.</p>
     <p>lpMapName — указатель на строку, содержащую имя объекта отображения, которое другие процессы могут использовать для разделения объекта; имя объекта чувствительно к регистру. Если не предполагается разделение памяти, используйте для этого параметра значение NULL.</p>
     <p>На возникновение ошибок указывает возвращение функцией значения NULL (а не INVALID_HANDLE_VALUE).</p>
     <p>Дескриптор объекта отображения файла можно получить, указав имя существующего объекта отображения. Это имя должно совпадать с тем, которое было задано во время создания открываемого объекта отображения с помощью функции CreateFileMapping. Два процесса могут разделять память, разделяя отображение файла. При этом первый процесс создает именованный объект отображения, а второй открывает этот объект, используя его имя. Если объекта отображения с указанным именем не существует, попытка его открытия будет неудачной. </p>
     <cite>
      <p><code>HANDLE OpenFileMapping(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpMapName)</code></p>
      <p><strong>Возвращаемое значение: </strong>в случае успешного выполнения — дескриптор объекта отображения файла, иначе — NULL. </p>
     </cite>
     <p>Параметр dwDesiredAccess использует тот же набор флагов, что и параметр dwProtect в функции CreateFileMapping. Указатель lpMapName должен указывать на строку с именем, совпадающим с тем, которое было задано при вызове функции CreateFileMapping. Дескриптор наследования (bInheritTable) рассматривается в главе 6.</p>
     <p>Как несложно догадаться, для закрытия дескрипторов объектов отображения используется функция CloseHandle.</p>
    </section>
    <section>
     <title>
      <p>Отображение файла на адресное пространство процесса</p>
     </title>
     <p>Следующим шагом является распределение виртуального адресного пространства и отображение на него файла с использованием объекта отображения. С точки зрения программиста этот процесс распределения памяти аналогичен тому, который обсуждался при рассмотрении функции HeapAlloc, хотя и делает это намного грубее, оперируя более крупными блоками. В результате этого распределения возвращается указатель на распределенный блок, или представление файла (file view); различие состоит в том, что этот распределенный блок является отображением пользовательского файла, а не файла подкачки. Объект отображения файла играет ту же роль, что и куча в случае использования функции HeapAlloc.</p>
     <cite>
      <p><code>LPVOID MapViewOfFile(HANDLE hMapObject, DWORD dwAccess, DWORD dwOffsetHigh, DWORD dwOffsetLow, SIZE_T cbMap)</code></p>
      <p><strong>Возвращаемое значение: </strong>В случае успешного выполнения — начальный адрес блока (представления файла), иначе — NULL. </p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>hMapObject — дескриптор объекта отображения файла, возвращенный функцией CreateFileMapping или OpenFileMapping.</p>
     <p>dwAccess — этот параметр должен быть совместимым с разрешенными типами доступа к объекту отображения. Тремя возможными флаговыми значениями являются FILE_MAP_WRITE, FILE_MAP_READ и FILE_MAP_ALL_ACCESS. (Последний флаг является результатом применения поразрядной операции "или" к двум предыдущим флагам).</p>
     <p>dwOffsetHigh и dwOffsetLow — соответственно, старшая и младшая 32-битовые части смещения начала отображаемого участка в файле. Значение этого начального адреса должно быть кратным 64 Кбайт. Чтобы начало отображаемого участка совпадало с началом файла, оба параметра следует задать равными 0. </p>
     <p>cbMap — размер отображаемого участка файла в байтах. Если значение этого параметра установлено равным 0, то отображаться будет весь файл, существующий в момент вызова функции MapViewOfFile.</p>
     <p>Функция MapViewOfFileEx аналогична функции MapViewOfFile, но дополнительно позволяет указать при вызове начальный адрес памяти для отображенного представления. Например, в качестве такого адреса может быть указан адрес массива в пространстве данных программы. В Windows, если затребованная область памяти уже используется для отображения, выполнение этой функции завершится с ошибкой.</p>
     <p>Точно так же как память, распределенная из кучи, должна освобождаться при помощи функции HeapFree, необходимо отменять и отображение представления файла, которое больше не используется. </p>
     <cite>
      <p><code>BOOL UnmapViewOfFile(LPVOID lpBaseAddress)</code> </p>
     </cite>
     <p>Взаимосвязь между адресным пространством процесса и отображаемым файлом проиллюстрирована на рис. 5.3. </p>
     <image l:href="#Any2FbImgLoader77"/>
     <p><strong>Рис. 5.З.</strong> Отображение представления файла на адресное пространство процесса</p>
     <empty-line/>
     <p>Вызов функции FlushViewOfFile вынуждает систему записать измененные страницы на диск. Как правило, процесс, получающий доступ к файлу через его отображение в памяти, и процесс, получающий доступ к файлу посредством обычных файловых операций ввода/вывода, будут "видеть" разные представления файла. Не решает эту проблему и выполнение файловых операций ввода/вывода без буферизации, так как представление отображаемого файла в памяти не записывается немедленно на диск. </p>
     <p>В силу этого идея получения доступа к отображаемому файлу с помощью функций ReadFile и WriteFile не сулит ничего хорошего, поскольку согласованность данных при этом не гарантируется. С другой стороны, представления файла для процессов, получающих совместный доступ к нему через разделяемую память, будут согласованными. Если один процесс изменяет какой-либо участок памяти в области отображения файла, то другой процесс при получении доступа к соответствующему участку в своей области отображения файла получит измененные данные. Этот механизм проиллюстрирован на рис. 5.4, из которого следует, что согласованность отображенных представлений файла в двух процессах (РА и РВ) действительно обеспечивается, поскольку виртуальным адресам данных в обоих процессах, несмотря на то, что эти адреса различны, соответствуют одни и те же участки физической памяти; Естественным образом связанная с этим тема синхронизации процессов обсуждается в главах 8—10.<a l:href="#n_24" type="note">[24]</a></p>
     <empty-line/>
     <image l:href="#Any2FbImgLoader78"/>
     <p><strong>Рис. 5.4.</strong> Разделяемая память</p>
     <empty-line/>
     <cite>
      <p>В UNIX (выпуски SVR4 и 4.3+BSD) поддерживается функция mmap, аналогичная функции MapViewOfFile. В ее параметрах указывается та же информация, за исключением того, что объект отображения отсутствует.</p>
      <p>Эквивалентом функции UnMapViewOfFile является функция munmap. </p>
      <p>Для функций CreateFileMapping и OpenFileMapping эквиваленты отсутствуют. Любой обычный файл может непосредственно отображаться. В UNIX отображение файлов для разделения памяти не используется, и для этих целей предусмотрены специальные функции API, а именно, shmctl, shmat и shmdt.</p>
     </cite>
    </section>
    <section>
     <title>
      <p>Ограничения метода отображения файлов</p>
     </title>
     <p>Как уже отмечалось ранее, отображение файлов является весьма мощным и полезным средством. Существующая в Windows диспропорция между 64-битовой файловой системой и 32-битовой адресацией снижает ценность обеспечиваемых этим средством преимуществ; Win64 свободен от этих ограничений.</p>
     <p>Основная проблема заключается в том, что при больших размерах файлов (в данном случае, свыше 2—3 Гбайт) отображение всего файла на пространство виртуальной памяти становится невозможным. Более того, не будут доступны даже все 3 Гбайт, поскольку часть виртуального адресного пространства распределяется для других целей, а суммарный объем доступных смежных блоков будет гораздо меньше теоретического максимума. Win64 в значительной степени снимает это ограничение.</p>
     <p>При работе с большими файлами, для которых объект отображения не может быть создан целиком, необходимо предусматривать отдельный программный код, осуществляющий отображение и отмену отображения соответствующих участков файла по мере необходимости. По сложности реализации такая методика сопоставима с организацией управления буферами в памяти, хотя необходимость в выполнении явных операций чтения и записи в данном случае отсутствует.</p>
     <p>Двумя другими существенными недостатками метода отображения файлов являются следующие:</p>
     <p>• Размер объекта отображения не может увеличиваться. Создавая объект отображения, вы должны заранее определить, какой максимальный размер вам может понадобиться, но во многих случаях сделать это трудно или вообще невозможно.</p>
     <p>• Невозможно распределить память в пределах области, занимаемой представлением объекта отображения, не создав для этого собственные функции управления памятью. Было бы очень удобно, если бы существовал способ задавать объект отображения файла и указатель, возвращаемый функцией MapViewOfFile, с последующим получением дескриптора кучи. </p>
    </section>
    <section>
     <title>
      <p>Резюме: отображение файлов</p>
     </title>
     <p>Ниже приведена стандартная последовательность действий, которые необходимо выполнять, если используется отображение файлов:</p>
     <p>1. Откройте файл. Убедитесь в том, что он имеет права доступа GENERIC_READ.</p>
     <p>2. В случае создания нового файла укажите его размер, используя для этого либо функцию CreateFileMapping (шаг 3), либо функцию SetFilePointer с последующим вызовом функции SetEndOfFile.</p>
     <p>3. Отобразите файл при помощи функций CreateFileMapping или OpenFileMapping.</p>
     <p>4. Создайте одно или несколько представлений объекта отображения файла с помощью функции MapViewOfFile.</p>
     <p>5. Осуществляйте доступ к файлу через обращения к памяти. Для перехода к другим участкам отображаемого файла используйте функции UnmapViewOfFile и MapViewOfFile.</p>
     <p>6. Завершив работу, вызовите последовательно функции UnmapViewOfFile, CloseHandle для закрытия дескриптора объекта отображения и CloseHandle для закрытия дескриптора файла.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: последовательная обработка файлов с использованием метода отображения</p>
    </title>
    <p>Программа atou (программа 2.4) иллюстрирует последовательную обработку файлов на примере преобразования ASCII-файлов к кодировке Unicode, приводящего к удвоению размера файла. Этот случай является идеальным для применения отображения файлов, поскольку наиболее естественным способом указанного преобразования является посимвольная обработка данных без обращения к операциям файлового ввода/вывода. Программа 5.3 сначала просто отображает входной и выходной файлы в память, предварительно вычисляя размер выходного файла путем удвоения размера входного файла, а затем осуществляет требуемое посимвольное преобразование.</p>
    <p>Этот пример отчетливо демонстрирует, как сложность процесса отображения файлов, выполнение которого необходимо для инициализации программы, компенсируется простотой результирующей обработки. Принимая во внимание, насколько просто выполняются обычные операции файлового ввода/вывода, применение более сложного метода могло бы показаться излишним, однако это с лихвой окупается выигрышем в производительности. В приложении В показано, что версия, использующая отображение файлов, в файловых системах NTFS работает значительно быстрее по сравнению с версиями, использующими обычные способы доступа к файлам, так что некоторое усложнение программы себя полностью оправдывает. Дополнительные результаты анализа производительности приведены на Web-сайте книги, поэтому ниже мы ограничимся лишь краткими выводами.</p>
    <p>• Повышение производительности программ за счет использования отображения файлов наблюдается только в случае Windows NT и файловых систем NTFS.</p>
    <p>• По сравнению с наилучшими из методик последовательной обработки файлов обеспечивается, по крайней мере, трехкратное повышение производительности .</p>
    <p>• При работе с файлами большого размера преимущества в отношении производительности теряются. В нашем примере обычный последовательный просмотр файлов оказывается более предпочтительным, так как размер входного файла составляет около одной трети объема физической памяти. Снижение производительности метода отображения файлов в данном случае объясняется тем, что для входного файла требуется одна треть памяти, а для выходного файла, размер которого в два раза больше, — оставшиеся две трети, что заставляет нас сбрасывать отдельные части выходного файла на диск. Таким образом, в системе с объемом оперативной памяти 192 Мбайт ухудшение производительности метода отображения файлов будет наступать после достижения входными файлами размера 60 Мбайт. В большинстве случаев приходится иметь дело с файлами меньшего размера, в результате чего применение метода отображения файлов становится целесообразным.</p>
    <p>В программе 5.3 представлена лишь функция Asc2UnMM. Основная программа совпадает с той, которая приведена в программе 2.4.</p>
    <subtitle>Программа 5.3. Asc2UnMM: преобразование файла с использованием метода отображения файлов </subtitle>
    <p><code>/* Глава 5. Asc2UnMM.c: Реализация, использующая отображение файлов. */ </code></p>
    <p><code>#include "EvryThng.h"</code></p>
    <empty-line/>
    <p><code>BOOL Asc2Un(LPCTSTR fin, LPCTSTR fOut, BOOL bFaillfExists) {</code></p>
    <p><code> HANDLE hIn, hOut, hInMap, hOutMap;</code></p>
    <p><code> LPSTR pIn, pInFile;</code></p>
    <p><code> LPWSTR pOut, pOutFile;</code></p>
    <p><code> DWORD FsLow, dwOut;</code></p>
    <p><code> /* Открыть и отобразить входной и выходной файлы. */ </code></p>
    <p><code> hIn = CreateFile(fIn, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);</code></p>
    <p><code> hInMap = CreateFileMapping(hIn, NULL, PAGE_READONLY, 0, 0, NULL);</code></p>
    <p><code> pInFile = MapViewOfFile(hInMap, FILE_MAP_READ, 0, 0, 0);</code></p>
    <p><code> dwOut = bFailIfExists ? CREATE NEW : CREATE ALWAYS; </code></p>
    <p><code> hOut = CreateFile(fOut, GENERIC_READ | GENERIC_WRITE, 0, NULL, dwOut, FILE_ATTRIBUTE_NORMAL, NULL);</code></p>
    <p><code> FsLow = GetFileSize (hIn, NULL); /* Установить размер отображения. */ </code></p>
    <p><code> hOutMap = CreateFileMapping(hOut, NULL, PAGE_READWRITE, 0, 2* FsLow, NULL);</code></p>
    <p><code> pOutFile = MapViewOfFile(hOutMap, FILE_MAP_WRITE, 0, 0, (SIZE_T)(2 * FsLow));</code></p>
    <p><code> /* Преобразовать данные отображенного файла из ASCII в Unicode. */</code></p>
    <p><code> pIn = pInFile;</code></p>
    <p><code> pOut = pOutFile;</code></p>
    <p><code> while (pIn &lt; pInFile + FsLow) {</code></p>
    <p><code>  *pOut = (WCHAR) *pIn;</code></p>
    <p><code>  pIn++;</code></p>
    <p><code>  pOut++;</code></p>
    <p><code> }</code></p>
    <p><code> UnmapViewOfFile(pOutFile);</code></p>
    <p><code> UnmapViewOfFile(pInFile);</code></p>
    <p><code> CloseHandle(hOutMap);</code></p>
    <p><code> CloseHandle(hInMap);</code></p>
    <p><code> CloseHandle(hIn);</code></p>
    <p><code> CloseHandle(hOut);</code></p>
    <p><code> return TRUE; </code></p>
    <p><code>}</code> </p>
   </section>
   <section>
    <title>
     <p>Пример: сортировка отображенных файлов</p>
    </title>
    <p>Дополнительным преимуществом метода отображения файлов является то, что он допускает применение обычных алгоритмов обработки файлов в памяти компьютера. Так, сортировку данных в памяти осуществить гораздо легче, чем сортировку записей в файле.</p>
    <p>Программа 5.4 предназначена для сортировки файлов с записями фиксированной длины. Данная программа, sortFL, аналогична программе 5.1 в том отношении, что предполагает наличие 8-байтового ключа сортировки в начале записи, но ограничивается записями фиксированной длины. В программе 5.5 этот недостаток будет устранен за счет некоторого усложнения программы.</p>
    <p>Сортировку выполняет описанная в файле &lt;stdlib.h&gt; функция qsort, входящая в состав библиотеки С. Заметьте, что эта функции требует от программиста предоставления функции, осуществляющей сравнение записей, в качестве которой нами будет использована функция KeyCompare из программы 5.2.</p>
    <p>Структура программы достаточно проста. Сначала на основе временной копии входного файла создается объект отображения файла, затем создается единое представление объекта отображения файла в памяти, и, наконец, вызывается функция qsort. При этом какие-либо операции файлового ввода/вывода отсутствуют. Отсортированный файл направляется далее на стандартный вывод, причем в конце отображения файла добавляется нулевой символ. </p>
    <subtitle>Программа 5.4. sortFL: сортировка файла с использованием его отображения в памяти </subtitle>
    <p><code>/* Глава 5. sortFL. Сортировка файлов. Записи имеют фиксированную длину.*/ </code></p>
    <p><code>/* Использование: sortFL файл */</code></p>
    <p><code>#include "EvryThng.h"</code></p>
    <empty-line/>
    <p><code>typedef struct _RECORD {</code></p>
    <p><code> TCHAR Key[KEY_SIZE];</code></p>
    <p><code> TCHAR Data[DATALEN]; </code></p>
    <p><code>} RECORD;</code></p>
    <empty-line/>
    <p><code>#define RECSIZE sizeof(RECORD)</code></p>
    <empty-line/>
    <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> HANDLE hFile = INVALID_HANDLE_VALUE, hMap = NULL;</code></p>
    <p><code> LPVOID pFile = NULL;</code></p>
    <p><code> DWORD FsLow, Result = 2;</code></p>
    <p><code> TCHAR TempFile[MAX_PATH];</code></p>
    <p><code> LPTSTR pTFile;</code></p>
    <p><code> /* Создать имя временного файла, предназначенного для хранения копии сортируемого файла, которая и подвергается сортировке. */</code></p>
    <p><code> /* Можно действовать и по-другому, оставив файл в качестве постоянно хранимой сортируемой версии. */</code></p>
    <p><code> _stprintf(TempFile, _T("%s%s"), argv[1], _Т(".tmp"));</code></p>
    <p><code> CopyFile(argv[1], TempFile, TRUE);</code></p>
    <p><code> Result = 1; /* Временный файл является вновь созданным и должен быть удален. */</code></p>
    <p><code> /* Отобразить временный файл и выполнить его сортировку в памяти. */</code></p>
    <p><code> hFile = CreateFile(TempFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);</code></p>
    <p><code> FsLow = GetFileSize(hFile, NULL);</code></p>
    <p><code> hMap = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, FsLow + TSIZE, NULL);</code></p>
    <p><code> pFile = MapViewOfFile(hMap, FILE_MAP_ALL_ACCESS, 0, 0 /* FsLow + TSIZE */, 0);</code></p>
    <p><code> qsort(pFile, FsLow / RECSIZE, RECSIZE, KeyCompare);</code></p>
    <p><code> /* KeyCompare – как в программе 5.2. */</code></p>
    <p><code> /* Отобразить отсортированный файл. */</code></p>
    <p><code> pTFile = (LPTSTR)pFile;</code></p>
    <p><code> pTFile[FsLow/TSIZE] = '\0';</code></p>
    <p><code> _tprintf(_T("%s"), pFile);</code></p>
    <p><code> UnmapViewOfFile(pFile);</code></p>
    <p><code> CloseHandle(hMap);</code></p>
    <p><code> CloseHandle(hFile);</code></p>
    <p><code> DeleteFile(TempFile);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code> </p>
    <p>Описанный вариант реализации довольно прост, однако возможен и другой вариант, не требующий использования отображения файлов. Для этого достаточно распределить память, считать весь файл, выполнить его сортировку в памяти и записать на диск. По своей эффективности это решение, которое приведено на Web-сайте книги, не уступает программе 5.4, а нередко и превосходит ее, как показано в приложении В.</p>
   </section>
   <section>
    <title>
     <p>Базовые указатели</p>
    </title>
    <p>Как показали предыдущие примеры, во многих случаях метод отображения файлов является весьма удобным. Однако предположим, что в программе создается структура данных с указателями, ссылающимися на область отображения файла, и ожидается, что впоследствии к этому файлу будет производиться обращение. В этом случае указатели оказываются установленными относительно виртуального адреса, возвращенного функцией MapViewOfFile, и не будут иметь смысла при использовании представления объекта отображения в следующий раз. Решение состоит в том, чтобы использовать базовые указатели (based pointers), являющиеся фактически смещениями относительно другого указателя. Соответствующий синтаксис Microsoft С, доступный в Visual C++ и некоторых других системах, выглядит следующим образом:</p>
    <p><code><emphasis>тип</emphasis> _based (база) <emphasis>объявление</emphasis></code></p>
    <p>Ниже показаны два примера таких указателей.</p>
    <p><code>LPTSTR pInFile = NULL;</code></p>
    <p><code>DWORD _based (pInFile) *pSize;</code></p>
    <p><code>TCHAR _based (pInFile) *pIn;</code></p>
    <p>Обратите внимание на тот факт, что синтаксис требует использования символа *, хотя такая практика противоречит соглашениям Windows.</p>
   </section>
   <section>
    <title>
     <p>Пример: использование базовых указателей</p>
    </title>
    <p>Рассмотренные выше примеры относились к сортировке файлов в различных ситуациях. Вместе с тем, должно быть очевидным, что наша цель состояла не в обсуждении методик сортировки, а в демонстрации применения различных методов управления памятью. В программе 5.1 используется бинарное дерево поиска, которое уничтожается при переходе к сортировке очередного файла, тогда как в программе 5.4 сортируется массив фиксированных записей, отображенный в памяти компьютера. В приложении В представлены показатели производительности для различных вариантов реализации, включая и тот, который реализует программа 5.5. </p>
    <p>Предположим, что необходимо обеспечить сопровождение постоянно существующего индексного файла, предоставляющего отсортированный ключ исходного файла. Могло бы показаться, что очевидным решением является отображение в памяти файла, содержащего постоянно хранимые индексы в виде дерева поиска, или его формы с отсортированным ключом. Однако это решение страдает серьезным недостатком. Все указатели дерева, сохраняемые в файле, являются заданными относительно адреса, возвращенного функцией MapViewOfFile. Когда программа будет запущена в следующий раз и создаст отображение файла, эти указатели окажутся бесполезными.</p>
    <p>Программа 5.5, которая должна применяться совместно с программой 5.6, решает эту проблему, которая проявляется всякий раз, когда отображаются структуры данных, использующие указатели. В предлагаемом решении используется ключевое слово _based, предоставляемое Microsoft С. Альтернативным вариантом было бы отображение файла в массив и обеспечение доступа к записям в представлении объекта отображения файла с помощью индекса.</p>
    <p>Программа написана в виде еще одной версии команды sort, которой в данном случае присвоено имя sortMM. Данная версия программы отличается следующими особенностями, заслуживающими внимания:</p>
    <p>• Записи могут иметь переменную длину.</p>
    <p>• Программа использует первое поле в качестве ключа, но определяет его длину.</p>
    <p>• Строятся два представления файла. Одно из них представляет исходный файл, а второе — файл, содержащий отсортированные ключи. Второй файл является <emphasis>индексным файлом</emphasis> (index file), каждая из записей которого содержит ключ и указатель (базовый адрес), относящийся к исходному файлу. Для сортировки индексного файла, во многом по аналогии с программой 5.4, применяется функция qsort.</p>
    <p>• Индексный файл сохраняется и впоследствии может быть использован, причем предусмотрена возможность (параметр командной строки –I) отказаться от сортировки и использовать существующий индексный файл. Кроме того, индексный файл может быть использован для быстрого поиска ключей путем проведения бинарного поиска (возможно, с использованием входящей в библиотеку C функции bsearch) в индексном файле.</p>
    <p>Взаимосвязь между индексным файлом и сортируемым файлом иллюстрирует рис. 5.5. Главной программой является программа 5.5, которая обеспечивает создание представлений файлов в памяти компьютера, осуществляет сортировку индексного файла и отображает результаты. Эта программа вызывает функцию CreateIndexFile, представленную программой 5.6. </p>
    <image l:href="#Any2FbImgLoader80"/>
    <p><strong>Рис. 5.5.</strong> Сортировка с использованием отображения индексного файла</p>
    <empty-line/>
    <subtitle>Программа 5.5. sortMM: использование базовых указателей в индексном файле </subtitle>
    <p><code>/* Глава 5. Команда sortMM.</code></p>
    <p><code> Сортировка отображенного в памяти файла – только один файл. Опции:</code></p>
    <p><code> -r Сортировать в обратном порядке.</code></p>
    <p><code> -I Использовать индексный файл для получения отсортированного файла. */ </code></p>
    <p><code>#include "EvryThng.h"</code></p>
    <empty-line/>
    <p><code>int KeyCompare(LPCTSTR , LPCTSTR);</code></p>
    <p><code>DWORD CreateIndexFile (DWORD, LPCTSTR, LPTSTR);</code></p>
    <p><code>DWORD KStart, KSize; /* Начальная позиция и размер ключа (TCHAR) . */</code></p>
    <p><code>BOOL Revrs;</code></p>
    <empty-line/>
    <p><code>int _tmain(int argc, LPTSTR argv []) {</code></p>
    <p><code> HANDLE hInFile, hInMap; /* Дескрипторы входного файла. */</code></p>
    <p><code> HANDLE hXFile, hXMap; /* Дескрипторы индексного файла. */</code></p>
    <p><code> HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);</code></p>
    <p><code> BOOL IdxExists;</code></p>
    <p><code> DWORD FsIn, FsX, RSize, iKey, nWrite, *pSizes;</code></p>
    <p><code> LPTSTR pInFile = NULL;</code></p>
    <p><code> LPBYTE pXFile = NULL, pX;</code></p>
    <p><code> TCHAR _based(pInFile) *pIn; </code></p>
    <p><code> TCHAR IdxFlNam [MAX_PATH], ChNewLine = TNEWLINE;</code></p>
    <p><code> int FlIdx = Options(argc, argv, _T("rI"), &amp;Revrs, &amp;IdxExists, NULL);</code></p>
    <p><code> /* Шаг 1: открыть и отобразить входной файл. */</code></p>
    <p><code> hInFile = CreateFile(argv [FlIdx], GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);</code></p>
    <p><code> hInMap = CreateFileMapping(hInFile, NULL, PAGE_READWRITE, 0, 0, NULL);</code></p>
    <p><code> pInFile = MapViewOfFile(hInMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);</code></p>
    <p><code> FsIn = GetFileSize(hInFile, NULL);</code></p>
    <p><code> /* Шаги 2 и З: создать имя индексного файла. */</code></p>
    <p><code> _stprintf(IdxFlNam, _T("%s%s"), argv[FlIdx], _T(".idx"));</code></p>
    <p><code> if (!IdxExists) RSize = CreateIndexFile(FsIn, IdxFlNam, pInFile);</code></p>
    <p><code> /* Шаг 4: отобразить индексный файл. */</code></p>
    <p><code> hXFile = CreateFile(IdxFlNam, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);</code></p>
    <p><code> hXMap = CreateFileMapping(hXFile, NULL, PAGE_READWRITE, 0, 0, NULL);</code></p>
    <p><code> pXFile = MapViewOfFile(hXMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);</code></p>
    <p><code> FsX = GetFileSize(hXFile, NULL);</code></p>
    <p><code> pSizes = (LPDWORD)pXFile; /* Поля размера в .idx-файле. */</code></p>
    <p><code> KSize = *pSizes; /* Размер ключа */</code></p>
    <p><code> KStart = *(pSizes + 1); /* Начальная позиция ключа в записи. */</code></p>
    <p><code> FsX –= 2 * sizeof(DWORD);</code></p>
    <p><code> /* Шаг 5: сортировать индексный файл при помощи qsort. */</code></p>
    <p><code> if (!IdxExists) qsort(pXFile + 2 * sizeof(DWORD), FsX / RSize, RSize, KeyCompare);</code></p>
    <p><code> /* Шаг 6: отобразить входной файл в отсортированном виде. */</code></p>
    <p><code> рХ = pXFile + 2 * sizeof(DWORD) + RSize – sizeof(LPTSTR);</code></p>
    <p><code> for (iKey = 0; iKey &lt; FsX / RSize; iKey++) {</code></p>
    <p><code>  WriteFile(hStdOut, &amp;ChNewLine, TSIZE, &amp;nWrite, NULL);</code></p>
    <p><code>  /* Приведение типа рХ, если это необходимо! */</code></p>
    <p><code>  pIn = (TCHAR _based (pInFile)*) *(LPDWORD)pX;</code></p>
    <p><code>  while ((*pIn != CR || * (pIn + 1) != LF) &amp;&amp; (DWORD) pIn &lt; FsIn) {</code></p>
    <p><code>   WriteFile(hStdOut, pIn, TSIZE, &amp;nWrite, NULL); pIn++;</code></p>
    <p><code>  }</code></p>
    <p><code>  рХ += RSize;</code></p>
    <p><code> }</code></p>
    <p><code> UnmapViewOfFile(pInFile);</code></p>
    <p><code> CloseHandle(hInMap);</code></p>
    <p><code> CloseHandle(hInFile);</code></p>
    <p><code> UnmapViewOfFile(pXFile);</code></p>
    <p><code> CloseHandle(hXMap);</code></p>
    <p><code> CloseHandle(hXFile);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <p>Программа 5.6 представляет собой функцию CreateIndexFile,  с помощью которой создается индексный файл. Сначала она просматривает входной файл для определения размера ключа по первой записи. После этого она должна просматривать входной файл для нахождения границ каждой из записей переменной длины для организации структуры, представленной на рис. 5.5.</p>
    <subtitle>Программа 5.6. sortMM: создание индексного файла </subtitle>
    <p><code>DWORD CreateIndexFile(DWORD FsIn, LPCTSTR IdxFlNam, LPTSTR pInFile) {</code></p>
    <p><code> HANDLE hXFile;</code></p>
    <p><code> TCHAR _based (pInFile) *pInScan = 0;</code></p>
    <p><code> DWORD nWrite;</code></p>
    <p><code> /* Шаг 2а: создать индексный файл. Не отображать его на данной стадии. */</code></p>
    <p><code> hXFile = CreateFile(IdxFlNam, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);</code></p>
    <p><code> /* Шаг 2b: получить первый ключ и определить его размер и начальную позицию. Пропустить пробел и получить длину ключа. */</code></p>
    <p><code> KStart = (DWORD) pInScan;</code></p>
    <p><code> while (*pInScan != TSPACE &amp;&amp; *pInScan != TAB) pInScan++; /* Найти поле первого ключа. */</code></p>
    <p><code> KSize = ((DWORD)pInScan – KStart) / TSIZE;</code></p>
    <p><code> /* Шаг 3: просмотреть весь файл, записывая ключи и указатели записей в индексный файл. */</code></p>
    <p><code> WriteFile(hXFile, &amp;KSize, sizeof(DWORD) , &amp;nWrite, NULL);</code></p>
    <p><code> WriteFile(hXFile, &amp;KStart, sizeof(DWORD), &amp;nWrite, NULL);</code></p>
    <p><code> pInScan = 0;</code></p>
    <p><code> while ((DWORD)pInScan &lt; FsIn) {</code></p>
    <p><code>  WriteFile(hXFile, pInScan + KStart, KSize * TSIZE, &amp;nWrite, NULL);</code></p>
    <p><code>  WriteFile(hXFile, &amp;pInScan, sizeof(LPTSTR), &amp;nWrite, NULL);</code></p>
    <p><code>  while ((DWORD)pInScan &lt; FsIn &amp;&amp; ((*pInScan != CR) || (*(pInScan + 1) != LF))) {</code></p>
    <p><code>   pInScan++; /* Пропустить до конца строки. */</code></p>
    <p><code>  }</code></p>
    <p><code>  pInScan += 2; /* Пропустить CR, LF. */</code></p>
    <p><code> }</code></p>
    <p><code> CloseHandle(hXFile);</code></p>
    <p><code> /* Размер отдельной записи. */</code></p>
    <p><code> return KSize * TSIZE + sizeof(LPTSTR); </code></p>
    <p><code>}</code> </p>
   </section>
   <section>
    <title>
     <p>Динамически компонуемые библиотеки</p>
    </title>
    <section>
     <p>Как вы имели возможность убедиться, средства управления памятью и отображения файлов оказываются важными и полезными для широкого класса программ. Системы управления памятью используются также самими ОС, и наиболее важной и заслуживающей внимания сферой применения отображения файлов являются библиотеки DLL. DLL широко используются приложениями Windows, являясь существенным элементом таких высокоуровневых технологий, как СОМ, а многие компоненты программного обеспечения поставляются в виде DLL.</p>
     <p>Нашим первым шагом будет рассмотрение различных методов построения библиотек наиболее часто используемых функций.</p>
    </section>
    <section>
     <title>
      <p>Статические и динамические библиотеки</p>
     </title>
     <p>Самый непосредственный способ построения любой программы — это объединение исходных кодов всех функций, их компиляция и компоновка всех необходимых элементов в один исполняемый модуль. Чтобы упростить процесс сборки, такие функции общего назначения, как ReportError, можно поместить в библиотеку. Этот подход применялся во всех представленных до сих пор примерах программ, хотя и касался всего лишь нескольких функций, большинство из которых предназначались для вывода сообщений об ошибках.</p>
     <p>Эта монолитная, одномодульная модель отличается простотой, однако обладает и рядом недостатков.</p>
     <p>• Исполняемый модуль может разрастаться до больших размеров, занимая большие объемы дискового пространства и физической памяти во время выполнения и требуя дополнительных усилий для организации управления модулем и передачи его пользователям.</p>
     <p>• При каждом обновлении потребуется повторная сборка всей программы, даже если необходимые изменения незначительны или носят локальный характер.</p>
     <p>• Каждый исполняемый модуль тех программ в системе, которые используют эти функции, будет иметь свои экземпляры функций, версии которых могут различаться. Подобная схема компоновки приводит к тому, что при одновременном выполнении нескольких таких программ будет напрасно расходоваться дисковое пространство и, что намного существеннее, физическая память.</p>
     <p>• Для достижения наилучшей производительности в различных средах может потребоваться использование различных версий программы, в которых применяются различные методики. Так, функция Asc2Un в программе 2.4 (atou) и программе 5.3 (Asc2UnMM) реализована по-разному. Единственный способ выполнения программ, имеющих несколько различных реализаций, — это заранее принять решение относительно того, какую из двух версий запускать, исходя из свойств окружения.</p>
     <p>Библиотеки DLL обеспечивают возможность элегантного решения этих и других проблем. </p>
     <p>• Библиотечные функции не связываются во время компоновки. Вместо этого их связывание осуществляется во время загрузки программы (<emphasis>неявное связывание</emphasis>) или во время ее выполнения <emphasis>(явное связывание).</emphasis> Это позволяет существенно уменьшить размер модуля программы, поскольку библиотечные функции в него не включаются.</p>
     <p>• DLL могут использоваться для создания <emphasis>общих библиотек</emphasis> (shared libraries). Одну и ту же библиотеку DLL могут совместно использовать несколько одновременно выполняющихся программ, но в память будет загружена только одна ее копия. Все программы отображают код DLL на адресные пространства своих процессов, хотя каждый поток будет иметь собственный экземпляр неразделяемого хранилища в стеке. Например, функция ReportError использовалась почти в каждом из приведенных ранее примеров программ, тогда как для всех программ было бы вполне достаточно ее единственной DLL-реализации.</p>
     <p>• Новые версии программ или другие возможные варианты их реализации могут поддерживаться путем простого предоставления новой версии DLL, а все программы, использующие эту библиотеку, могут выполняться как новая версия без внесения каких бы то ни было дополнительных изменений.</p>
     <p>• В случае явного связывания решение о том, какую версию библиотеки использовать, программа может принимать во время выполнения. Разные библиотеки могут быть альтернативными вариантами реализации одной и той же функции или решать совершенно иные задачи, как если бы они были независимыми программами. Библиотека выполняется в том же процессе и том же потоке, что и вызывающая программа.</p>
     <p>Библиотеки DLL, иногда в ограниченном виде, используются практически в любой ОС. Так, в UNIX аналогичные библиотеки фигурируют под названием "разделяемых библиотек" (shared libraries). В Windows библиотеки DLL используются, помимо прочего, для создания интерфейсов ОС. Весь Windows API поддерживается одной DLL, которая для предоставления дополнительных услуг вызывает ядро Windows.</p>
     <p>Один код DLL может совместно использоваться несколькими процессами Windows, но после его вызова он выполняется как часть вызывающего процесса или потока, Поэтому библиотека может использовать ресурсы вызывающего процесса, например дескрипторы файлов, и стек потока. Следовательно, DLL должны создаваться таким образом, чтобы обеспечивалась безопасная многопоточная поддержка (thread safety). (Более подробная информация относительно DLL и безопасной многопоточной поддержки содержится в главах 8, 9 и 10. Методы создания DLL, предоставляющих многопоточную поддержку, иллюстрируются программами 12.4 и 12.5.) Кроме того, DLL могут экспортировать переменные, а также точки входа функций. </p>
    </section>
    <section>
     <title>
      <p>Неявное связывание</p>
     </title>
     <p><emphasis>Неявное связывание,</emphasis> или <emphasis>связывание во время загрузки</emphasis> (load-time linking) является простейшей из двух методик связывания. Порядок действий в случае использования Microsoft C++ следующий:</p>
     <p>1. После того как собраны все необходимые для новой DLL функции, осуществляется сборка DLL, а не, например, консольного приложения.</p>
     <p>2. В процессе сборки создается библиотечный .LIB-файл, играющий роль <emphasis>заглушки</emphasis> (stub) для фактического кода. Этот файл должен помещаться в каталог библиотек общего пользования, указанный в проекте.</p>
     <p>3. В процессе сборки создается также .DLL-файл, содержащий исполняемый модуль. В типичных случаях этот файл размещается в том же каталоге, что и приложение, которое будет его использовать, и приложение загружает DLL в процессе своей инициализации. Вторым возможным местом расположения DLL является рабочий каталог, а далее ОС будет осуществлять поиск .DLL-файла в системном каталоге, каталоге Windows, а также в путях доступа, указанных в переменной окружения PATH.</p>
     <p>4. В исходном коде DLL следует предусмотреть экспортирование интерфейсов функций, о чем рассказано ниже.</p>
     <subtitle><emphasis>Экспортирование и импортирование интерфейсов</emphasis></subtitle>
     <p>Самое значительное изменение, которое требуется внести в функцию, прежде чем ее можно будет поместить в DLL, — это объявить ее экспортируемой (UNIX и некоторые другие системы не требуют явного выполнения этого шага). Это достигается либо за счет использования .DEF-файла, либо, что проще и возможно в Microsoft С, за счет использования в объявлениях модификатора _declspec (dllexport) следующим образом:</p>
     <p><code>_declspec(dllexport) DWORD MyFunction (…);</code></p>
     <p>Далее в процессе сборки создаются .DLL-файл и .LIB-файл. .LIB-файл — это библиотека-заглушка, которая должна быть скомпонована с вызывающей программой для разрешения внешних ссылок и создания актуальных связей с . DLL-файлом во время загрузки.</p>
     <p>Вызывающая, или <emphasis>клиентская,</emphasis> программа должна объявить о том, что функцию следует импортировать, используя для этого модификатор _declspec (dllexport). Стандартный метод заключается в создании включаемого файла, использующего переменную препроцессора, имя которой формируется на основе имени проекта Microsoft Visual C++, набранного в верхнем регистре и дополненного суффиксом _EXPORTS.</p>
     <p>Вам также может потребоваться еще одно объявление. Если вызывающая (клиентская) программа написана на C++, то для нее будет определена переменная препроцессора __cplusplus, и вы должны будете указать на необходимость использования системы соглашений о вызовах, принятой в С, с помощью следующего выражения:</p>
     <p><code>extern "С"</code></p>
     <p>Если, например, в качестве части сборки DLL в проекте MyLibrary определена функция MyLibrary, то содержимое заголовочного файла должно быть таким:</p>
     <p><code>#if defined(MYLIBRARY_EXPORTS)</code></p>
     <p><code>#define LIBSPEC _declspec(dllexport)</code></p>
     <p><code>#elif defined(__cplusplus)</code></p>
     <p><code>#define LIBSPEC extern "C" _declspec(dllimport)</code></p>
     <p><code>#else</code></p>
     <p><code>#define LIBSPEC _declspec(dllimport)</code></p>
     <p><code>#endif</code></p>
     <p><code>LIBSPEC DWORD MyFunction (…);</code></p>
     <p>Visual C++ автоматически определяет MYLIBRARY_EXPORTS при вызове компилятора, если проект предназначен для создания DLL MyLibrary. Клиентский проект, который использует DLL, переменную MYLIBRARYEXPORTS не определяет, и поэтому имя функции импортируется из библиотеки.</p>
     <p>При построении вызывающей программы укажите соответствующий .DLL-файл. Когда будете запускать вызывающую программу на выполнение, убедитесь в наличии доступа к этому файлу; часто это обеспечивается размещением .DLL-файла в одном каталоге с исполняемым файлом. Как ранее уже отмечалось, существует ряд правил поиска DLL, определяющих последовательность просмотра каталогов, в которых Windows будет осуществлять поиск указанного .DLL-файла, <emphasis>а также</emphasis> других DLL и исполняемых файлов, необходимых указанному файлу, прекращая этот поиск, как только будет найден первый подходящий экземпляр. Ниже приведена <emphasis>стандартная последовательность просмотра каталогов при поиске,</emphasis> используемая как в случае явного, так и в случае неявного связывания.</p>
     <p>• Каталог, в котором находится загружаемое приложение.</p>
     <p>• Текущий каталог, если он отличен от каталога, содержащего исполняемый модуль.</p>
     <p>• Системный каталог Windows. Вы можете определить этот путь, вызвав функцию GetSystemDirectory; таковым обычно является каталог с:\WINDOWS\SYSTEM32.</p>
     <p>• Системный каталог 16-разрядной Windows, который отсутствует в системах Windows 9x. Функция, позволяющая получить путь доступа к этому каталогу, отсутствует, и для наших целей он оказывается ненужным.</p>
     <p>• Каталог Windows (используйте функцию GetWindowsDirectory).</p>
     <p>• Каталоги, перечисленные в переменной окружения PATH, которые будут просматриваться в той последовательности, в какой они указаны. </p>
     <p>Заметьте, что этот стандартный порядок просмотра каталогов при поиске можно изменить, о чем говорится в разделе "Явное связывание". Для получения более подробной информации относительно стратегии поиска посетите Web-сайт по адресу http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/loadlibrary.asp, а также ознакомьтесь с описанием функции SetDllDirectory, введенной в Windows NT 5.1 (то есть Windows XP). Изменить стратегию поиска позволяет также функция LoadLibraryEx, описанная в следующем разделе.</p>
     <p>Применение стандартной стратегии поиска иллюстрируется в проекте Utilities, доступном на Web-сайте книги, а такие вспомогательные функции, как ReportError, используются почти в каждом примере проектов.</p>
     <p>Возможно также экспортирование и импортирование переменных, а также точек входа функций, хотя эти возможности в примерах не иллюстрируются.</p>
    </section>
    <section>
     <title>
      <p>Явное связывание</p>
     </title>
     <p><emphasis>Явное связывание,</emphasis> или <emphasis>связывание во время выполнения</emphasis> (run-time linking), требует, чтобы в программе содержались конкретные указания относительно того, когда именно необходимо загрузить или освободить библиотеку DLL. Далее программа получает адрес запрошенной точки входа и использует этот адрес в качестве указателя при вызове функции. В вызывающей программе функция не объявляется; вместо этого в качестве указателя на функцию объявляется переменная. Поэтому во время компоновки программы присутствие библиотеки не является обязательным. Для выполнения необходимых операций требуются три функции: LoadLibrary (или LoadLibraryEx), GetProcAddress и FreeLibrary. На 16-битовое происхождение определений функций указывает присутствие в них дальних (far) указателей и дескрипторов различных типов.</p>
     <p>Для загрузки библиотеки служат две функции: LoadLibrary и LoadLibraryEx. </p>
     <cite>
      <p><code>HINSTANCE LoadLibrary(LPCTSTR lpLibFileName)</code> </p>
     </cite>
     <cite>
      <p><code>HINSTANCE LoadLibraryEx(LPCTSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)</code> </p>
     </cite>
     <p>В обоих случаях значением возвращаемого дескриптора (типа HINSTANCE, а не HANDLE) в случае ошибки будет NULL. Суффикс .DLL в имени файла указывать не обязательно. С помощью функций LoadLibrary можно загружать также .ЕХЕ-файлы. При указании путей доступа должны использоваться символы обратной косой черты (\); символы прямой косой черты (/) в данном случае работать не будут. </p>
     <p>Поскольку библиотеки DLL являются совместно используемым ресурсом, системой поддерживается счетчик ссылок на каждую DLL (который увеличивается на единицу при каждом вызове любой из указанных выше функций загрузки), так что повторное отображение фактического файла библиотеки не требуется. Функция LoadLibrary завершится с ошибкой даже в случае успешного нахождения .DLL-файла, если данная библиотека DLL неявно связана с другой DLL, найти которую программе не удалось.</p>
     <p>Функция LoadLibraryEx аналогична функции LoadLibrary, однако имеет несколько флагов, которые оказываются полезными для указания альтернативных путей поиска и загрузки библиотек в виде файла данных. Параметр hFile зарезервирован для использования в будущем. Параметр dwFlags позволяет определять различные варианты поведения системы путем указания одного из трех значений:</p>
     <p>1. LOAD_WITH_ALTERED_SEARCH_PATH: отменяет ранее описанный стандартный порядок просмотра каталогов при поиске, изменяя лишь первый из шагов стратегии поиска. Вместо каталога, из которого загружалось приложение, используется путь поиска, указанный в имени lpLibFileName.</p>
     <p>2. LOAD_LIBRARY_AS_DATAFILE: файл воспринимается как файл данных и не требует выполнения каких-либо действий по его подготовке к запуску, на пример вызова функции DllMain (см. раздел "Точки входа библиотеки DLL" далее в этой главе).</p>
     <p>3. DONT_RESOLVE_DLL_REFERENCE: функция DllMain для инициализаций процессов и потоков не вызывается; загрузка дополнительных модулей, на которые имеются ссылки в указанной DLL, также не производится.</p>
     <p>Закончив работать с экземпляром DLL — возможно, с намерением загрузить другую ее версию — вы должны освободить дескриптор библиотеки, тем самым освобождая ресурсы, в том числе распределенное для библиотеки виртуальное адресное пространство. Однако DLL продолжает оставаться загруженной, если счетчик ссылок указывает на то, что она все еще используется другими процессами. </p>
     <cite>
      <p><code>BOOL FreeLibrary(HINSTANCE hLibModule)</code> </p>
     </cite>
     <p>После загрузки библиотеки, но до ее освобождения, вы можете получить адрес любой точки входа, используя функцию GetProcAddress. </p>
     <cite>
      <p><code>FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName)</code> </p>
     </cite>
     <p>Параметр hModule, несмотря на другой тип имени (HINSTANCE определен как HMODULE), является экземпляром (instance) библиотеки, получаемым посредством вызова функции LoadLibrary или GetModuleHandle (см. следующий абзац). lpProcName — указатель на строку, содержащую имя точки входа; это имя не может задаваться в кодировке Unicode. В случае неуспешного выполнения функция возвращает значение NULL. Слово FARPROC, означающее "длинный указатель на процедуру", является анахронизмом.</p>
     <p>Имя файла, связанного с дескриптором hHandle, можно получить с помощью функции GetModuleFileName. Возможно и обратное: для заданного имени файла (.DLL или .EXE) функция GetModuleHandle в случае успешного выполнения возвратит дескриптор, связанный с этим файлом, если текущий процесс загрузил его.</p>
     <p>В следующем примере показано, как использовать адрес точки входа для вызова функции.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: явное связывание функци и преобразования файлов</p>
    </title>
    <section>
     <p>Программа 2.4, предназначенная для преобразования кодировки текстовых файлов из ASCII в Unicode, вызывает функцию Asc2Un (программа 2.5), выполняющую обработку файла с использованием операций файлового ввода/вывода. Программа 5.3 (Asc2UnMM) представляет альтернативную функцию, которая для выполнения той же операции использует отображение файлов. Обстоятельства, при которых функция Asc2UnMM обеспечивает выигрыш в скорости выполнения преобразования, ранее уже обсуждались; в основном они сводятся к тому, что файловой системой должна быть NTFS, а размер файла не должен быть слишком большим.</p>
     <p>Программа 5.7 является модифицированным вариантом вызывающей программы, обеспечивающим возможность принятия решения относительно того, какой вариант реализации функции преобразования должен быть загружен, во время выполнения. Программа загружает DLL, получает адрес точки входа Asc2Un и вызывает функцию. В данном случае существует только одна точка входа, но реализовать вариант с несколькими точками входа не составляет особого труда. Основная программа является, по существу, той же, что и прежде, за исключением того, что библиотека DLL, которую необходимо использовать, указывается в виде параметра командной строки. В упражнении 5.9 вам предлагается написать вариант программы, в котором нужная DLL определяется на основе свойств системы и файла. Обратите внимание на то, каким образом осуществляется приведение типа адреса FARPROC к типу соответствующей функции с использованием необходимого в этом случае, но довольно сложного, синтаксиса С.</p>
     <subtitle>Программа 5.7. atouEL: преобразование файлов с использованием явного связывания</subtitle>
     <p><code>/* Глава 5. Версия atou, использующая явное связывание. */</code></p>
     <p><code>#include "EvryThng.h"</code></p>
     <empty-line/>
     <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
     <p><code> /* Объявить переменную Asc2Un как функцию. */</code></p>
     <p><code> BOOL (*Asc2Un)(LPCTSTR, LPCTSTR, BOOL);</code></p>
     <p><code> DWORD LocFileIn, LocFileOut, LocDLL, DashI;</code></p>
     <p><code> HINSTANCE hDLL;</code></p>
     <p><code> FARPROC pA2U;</code></p>
     <p><code> LocFileIn = Options(argc, argv, _T("i"), &amp;DashI, NULL);</code></p>
     <p><code> LocFileOut = LocFileIn + 1;</code></p>
     <p><code> LocDLL = LocFileOut + 1;</code></p>
     <p><code> /* Проверить существование файла, а также опущен ли параметр DashI. */</code></p>
     <p><code> /* Загрузить функцию преобразования из ASCII в Unicode. */</code></p>
     <p><code> hDLL = LoadLibrary(argv[LocDLL]);</code></p>
     <p><code> if (hDLL == NULL) ReportError(_T("He удается загрузить DLL."), 1, TRUE);</code></p>
     <p><code> /* Получить адрес точки входа. */</code></p>
     <p><code> pA2U = GetProcAddress(hDLL, "Asc2Un");</code></p>
     <p><code> if (pA2U == NULL) ReportError(_T("He найдена точка входа."), 2, TRUE);</code></p>
     <p><code> /* Привести тип указателя. Здесь можно использовать typedef. */</code></p>
     <p><code> Asc2Un = (BOOL(*)(LPCTSTR, LPCTSTR, BOOL))pA2U;</code></p>
     <p><code> /* Вызвать функцию. */</code></p>
     <p><code> Asc2Un(argv[LocFileIn], argv[LocFileOut], FALSE);</code></p>
     <p><code> FreeLibrary(hDLL);</code></p>
     <p><code> return 0;</code></p>
     <p><code>}</code> </p>
    </section>
    <section>
     <title>
      <p>Создание библиотек DLL на основе функции Asc2Un</p>
     </title>
     <p>Программа тестировалась с двумя функциями преобразования файлов, которые должны были создаваться в виде библиотек DLL, имеющих различные имена, но идентичные точки входа. В данном случае существует только одна точка входа. Единственным существенным изменением в исходном коде является добавление модификатора _declspec(dllexport) для экспортирования функции.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Точки входа библиотеки DLL</p>
    </title>
    <p>Для каждой создаваемой DLL вы можете указать точку входа запуска библиотеки, которая обычно автоматически вызывается при каждом подключении или отключении процесса. В то же время, в функции LoadLibraryEx предусмотрена опция, позволяющая подавить вызов точки входа. В случае неявно связываемых (связываемых во время выполнения) библиотек DLL подключение и отключение процесса происходит, соответственно, при его запуске и завершении. В случае же явно связываемых DLL это осуществляется при вызове функций LoadLibrary, LoadLibraryEx и FreeLibrary. </p>
    <p>Кроме того, точка входа вызывается всякий раз, когда процесс создает новый поток (глава 7) или прекращает его выполнение.</p>
    <p>Точкой входа с именем DllMain, прототип которой приводится ниже, мы воспользуемся в полной мере только в главе 12 (программа 12.4), где она предоставит потокам удобный способ управления ресурсами и так называемыми локальными областями хранения потоков (Thread Local Storage, SLT) в DLL с многопоточной поддержкой. </p>
    <cite>
     <p><code>BOOL DllMain(HINSTANCE hDll, DWORD Reason, LPVOID Reserved) </code></p>
    </cite>
    <p>Параметр hDll является дескриптором экземпляра DLL, возвращенным функцией LoadLibrary. Значение NULL параметра Reserved указывает на то, что подключение процесса к библиотеке произошло в результате вызова функции Load-Library; иные значения этого параметра свидетельствуют о подключении к библиотеке в результате неявного связывания во время загрузки. Подобным образом, к значению NULL параметра Reserved приводит и отключение процесса от библиотеки в результате вызова функции FreeLibrary.</p>
    <p>Параметр Reason может иметь одно из четырех значений: DLL_PROCESS_ATTACH, DLL_THREAD_ATTACH, DLL_THREAD_DETACH и DLL_PROCESS_DETACH. Функции точки входа DLL обычно используют операторы switch и в качестве индикатора успешного выполнения возвращают значение TRUE.</p>
    <p>Система сериализует вызовы DllMain таким образом, что в каждый момент времени выполнять ее может только один поток (к подробному обсуждению потоков мы приступим в главе 7). Эта сериализация весьма существенна, поскольку операции инициализации, которые должна выполнять DllMain, не должны прерываться до их завершения. По этой же причине внутри точки входа не рекомендуется использовать блокирующие вызовы функций, например, функций ввода/вывода или функций ожидания (см. главу 8), поскольку они будут препятствовать запуску точки входа другими потоками. В частности, не следует вызывать внутри точки входа DLL функции LoadLibrary и LoadLibraryEx, поскольку это будет порождать дополнительные вызовы точек входа DLL.</p>
    <p>Функция DisableThreadLibraryCalls отменяет отправку указанному экземпляру DLL уведомлений о подключении и отключении потоков. Запрет отправки уведомлений может пригодиться в тех случаях, когда потоки не нуждаются в каких-либо уникальных ресурсах во время инициализации.</p>
   </section>
   <section>
    <title>
     <p>Управление версиями DLL</p>
    </title>
    <p>При использовании DLL обычно проявляются трудности, обусловленные обновлением библиотек за счет введения новых символов и добавления новых средств. Основное преимущество DLL заключается в том, что несколько приложений могут совместно использовать одну и ту же библиотеку, находящуюся в памяти. Вместе с тем, это порождает целый ряд осложнений, связанных с совместимостью версий, что иллюстрируется приведенными ниже примерами.</p>
    <p>• В результате добавления новых функций в случае неявного связывания могут стать недействительными смещения, определенные для приложений во время компоновки с .lib-файлами. От этой проблемы можно избавиться, применив явное связывание.</p>
    <p>• Поведение новых версий функций может быть иным, в результате чего существующие приложения могут испытывать проблемы, если не будут своевременно обновлены.</p>
    <p>• Для приложений, использующих обновленную функциональность DLL, возможны случая связывания с прежними версиями DLL.</p>
    <p>Проблемы совместимости различных версий DLL, носящие жаргонное название "кошмара DLL", не являются столь острыми, если в одном каталоге поддерживать только одну версию DLL. Однако предоставить отдельный каталог для каждой из различных версий вовсе не так просто, как может показаться. Существует несколько других вариантов решения этой проблемы.</p>
    <p>• Можно использовать номер версии DLL в именах .DLL– и .LIB-файлов, обычно в виде суффикса. Так, чтобы соответствовать номеру версии, используемой в данной книге, в примерах, приведенных на Web-сайте книги, и во всех проектах используются файлы Utility_3_0.LIB и Utility_3_0.DLL. Применяя явное или неявное связывание, приложения могут формулировать свои требования к версиям и получать доступ к файлам с различными именами. Такое решение характерно для UNIX-приложений.</p>
    <p>• Компания Microsoft ввела понятие параллельных DLL (side-by-side DLL), или сборок (assemblies) и компонентов (components). При таком подходе в приложение необходимо включать объявление на языке XML, в котором определяются требования к DLL. Рассмотрение этой темы выходит за рамки данной книги, однако дополнительную информацию вы можете получить на Web-сайте компании Microsoft, в разделе, посвященном вопросам разработки приложений.</p>
    <p>• Платформа .NET Framework предоставляет дополнительные средства поддержки выполнения приложений в условиях сосуществования различных версий DLL.</p>
    <p>В примерах проектов, используемых в данной книге, используется первый из отмеченных подходов, предусматривающий включение номеров версий в имена файлов. С целью предоставления дополнительной поддержки, обеспечивающей возможность получения приложениями информации о DLL, во всех DLL реализована функция DllGetVersion. Кроме того, Microsoft предоставляет эту косвенно вызываемую функцию в качестве стандартного средства получения информации о версии в динамическом режиме. Указанная функция имеет следующий прототип: </p>
    <cite>
     <p><code>HRESULT CALLBACK DllGetVersion(DLLVERSIONINFO *pdvi )</code> </p>
    </cite>
    <p>Информация о DLL возвращается в структуре DLLVERSIONINFO, в которой имеются поля типа DWORD для параметров cbSize (размер структуры), dwMajorVersion, dwMinorVersion, dwBuildNumber и dwPlatformID. В последнем поле, dwPlatformID, может быть установлено значение DLLVER_PLATFORM_NT, если библиотека не выполняется под управлением Windows 9x, или DLLVER_PLATFORM_WINDOWS, если это ограничение отсутствует. В поле cbSize должно находиться значение sizeof (DLLVERSIONINFO). В случае успешного выполнения функция возвращает значение NOERROR. Функция DllGetVersion реализована в проекте Utility_3_0.</p>
   </section>
   <section>
    <title>
     <p>Резюме</p>
    </title>
    <section>
     <p>Система управления памятью Windows предоставляет следующие возможности:</p>
     <p>• Использование средств Windows, осуществляющих управление кучей, а также обработчиков исключений для обнаружения и обработки ошибок, возникающих при распределении памяти, значительно упрощает логическую организацию.</p>
     <p>• Использование нескольких независимых куч обладает рядом преимуществ по сравнению с распределением памяти из одной кучи.</p>
     <p>• Методы отображения файлов, доступные в UNIX, но не предоставляемые библиотекой С, обеспечивают обработку файлов в памяти, что было проиллюстрировано несколькими примерами. Отображение файлов в памяти осуществляется независимо от управления кучей и упрощает решение многих задач программирования. Преимущества использования отображения файлов подтверждаются данными о достигаемом за счет этого повышении производительности, приведенными в приложении В.</p>
     <p>• DLL являются важным специальным случаем отображения файлов и могут загружаться либо явным, либо неявным образом. DLL, предназначенные для использования многими приложениями, должны предоставлять информацию о версии библиотеки.</p>
    </section>
    <section>
     <title>
      <p>В следующих главах</p>
     </title>
     <p>Мы завершили обзор задач, решаемых в рамках одного процесса. Далее мы переходим к изучению методов параллельной обработки, сначала на уровне процессов (глава 6), а затем — потоков (глава 7). В последующих главах показано, как организовать синхронизацию и взаимодействие параллельно выполняющихся операций по обработке данных. </p>
    </section>
    <section>
     <title>
      <p>Дополнительная литература</p>
     </title>
     <subtitle><emphasis>Отображение файлов, виртуальная память и ошибки страниц</emphasis></subtitle>
     <p>Описание этих важных понятий содержится в книге [38], а их углубленное обсуждение вы можете найти в документации, поставляемой вместе с большинством ОС.</p>
     <subtitle><emphasis>Структуры данных и алгоритмы</emphasis></subtitle>
     <p>Деревьям поиска и алгоритмам сортировки посвящено множество работ, включая [39] и [34].</p>
     <subtitle><emphasis>Использование явного связывания</emphasis></subtitle>
     <p>DLL и явное связывание имеют фундаментальное значение для использования модели СОМ, которая широко применяется при разработке программного обеспечения Windows. Важность функций LoadLibrary и GetProcAddress продемонстрирована в главе 1 книги [3].</p>
    </section>
   </section>
   <section>
    <title>
     <p>Упражнения</p>
    </title>
    <p>5.1. Спроектируйте и проведите эксперименты для оценки выигрыша в производительности, достигаемого за счет использования флага HEAP_NO_SERIALIZE при вызове функций HeapCreate и HeapAlloc. Как зависит этот показатель от размера кучи и размера блока? Заметна ли разница в результатах для различных версий Windows? На Web-сайте книги находится программа HeapNoSr.c, которая поможет вам приступить к выполнению этого и следующего упражнений.</p>
    <p>5.2. Измените тестовую программу из предыдущего упражнения таким образом, чтобы она позволяла определить, генерирует ли функция malloc исключения или возвращает нулевой указатель в случае нехватки памяти. Является ли обнаруженное поведение функции корректным? Сравните также производительность, обеспечиваемую функцией malloc, с результатами предыдущего упражнения.</p>
    <p>5.3. Доля накладных издержек при распределении памяти из кучи колеблется в зависимости от используемой версии Windows, что особенно заметно в случае выходящих из употребления версий Windows 9x. Спроектируйте и проведите эксперимент для определения количества блоков памяти фиксированного размера, которые каждая из систем предоставляет в одной куче. Используя SEH для определения того момента, когда распределенными оказываются все блоки, вы значительно упростите программу. Подобным образом ведет себя программа clear.с, находящаяся на Web-сайте книги, если игнорировать часть ее кода, ответственную за явное тестирование ОС. Между прочим, эта программа используется в некоторых тестах по измерению временных характеристик для гарантии того, что данные, полученные в процессе выполнении предыдущего теста, не остались в памяти.</p>
    <p>5.4. Путем изменения программы sortFL (программа 5.4) создайте программу sortHP, распределяющую память для буфера, размер которого достаточно велик, чтобы в нем уместился весь файл, и выполните считывание файла в этот буфер. Отображение файла использовать не следует. Сравните производительность обеих программ.</p>
    <p>5.5. В программе 5.5 применены указатели типа _base, специфические для Microsoft С. Если ваш компилятор не поддерживает это средство (но в любом случае — просто в качестве упражнения) переделайте программу 5.5, используя для генерации значений базового указателя макрос, массив или иной механизм.</p>
    <p>5.6. Напишите программу поиска записей по указанному ключу в файле, проиндексированном с применением программы 5.5. Для этой цели удобно воспользоваться функцией bsearch, входящей в состав библиотеки С.</p>
    <p>5.7. Реализуйте программу tail из главы 3, используя отображение файлов.</p>
    <p>5.8. Поместите вспомогательные функции ReportError, PrintStrings, PrintMsg и ConsolePrompt в DLL и перекомпонуйте некоторые из программ, с которыми мы работали раньше. Проделайте то же самое с функциями Options и GetArgs, предназначенными, соответственно, для обработки параметров командной строки и аргументов. Важно, чтобы как вспомогательная DLL, так и вызывающая программа использовали также и библиотеку С в виде DLL. Например, в Visual C++ и Visual Studio 6.0 выберите, начав со строки главного меню, следующие команды: Project (Проект), Settings (Параметры), вкладку C/C++, Category (Code Generation) (Категория (Генерация кода)), Use Run-Time Library (Multithreaded DLL) (Использовать библиотеку времени выполнения (многопоточная DLL)). Заметьте, что библиотеки DLL, вообще говоря, должны обеспечивать многопоточную поддержку, поскольку они будут использоваться потоками нескольких процессов. Пример возможного решения содержится в проекте Utilities_3_0, доступном на Web-сайте книги.</p>
    <p>5.9. Измените программу 5.7 таким образом, чтобы решение относительно того, какую DLL следует использовать, базировалось на размере файла и конфигурации системы. .LIB-файл здесь не требуется, поэтому продумайте, как отменить его генерацию. Для определения типа файловой системы используйте функцию GetVolumeInformation.</p>
    <p>5.10. Создайте дополнительные DLL для функции преобразования из предыдущего упражнения, каждая версия которых использует иную методику обработки файлов, и расширьте вызывающую программу таким образом, чтобы она сама решала, когда и какую версию использовать. </p>
   </section>
  </section>
  <section>
   <title>
    <p>ГЛАВА 6</p>
    <p>Управление процессами</p>
   </title>
   <section>
    <p><emphasis>Процесс</emphasis> (process) представляет собой объект, обладающий собственным независимым виртуальным адресным пространством, в котором могут размещаться код и данные, защищенные от других процессов. В свою очередь, внутри каждого процесса могут независимо выполняться одна или несколько <emphasis>потоков</emphasis> (threads). Поток, выполняющийся внутри процесса, может сама создавать новые потоки и новые независимые процессы, а также управлять взаимодействием объектов между собой и их синхронизацией.</p>
    <p>Создавая процессы и управляя ими, приложения могут организовывать параллельное выполнение нескольких задач, обеспечивающих обработку файлов, проведение вычислений или связь с другими системами в сети. Допускается даже использование нескольких процессоров с целью ускорения обработки данных.</p>
    <p>В этой главе объясняются основы управления процессами и вводятся; простейшие операции синхронизации, которые будут использоваться на протяжении оставшейся части книги.</p>
   </section>
   <section>
    <title>
     <p>Процессы и потоки Windows</p>
    </title>
    <p>Внутри каждого процесса могут выполняться одна или несколько потоков, и именно поток является базовой единицей выполнения в Windows. Выполнение потоков планируется системой на основе обычных факторов: наличие таких ресурсов, как CPU и физическая память, приоритеты, равнодоступность ресурсов и так далее. Начиная с версии NT4, в Windows поддерживается симметричная многопроцессорная обработка (Symmetric Multiprocessing, SMP), позволяющая распределять выполнение потоков между отдельными процессорами, установленными в системе.</p>
    <p>С точки зрения программиста каждому процессу принадлежат ресурсы, представленные следующими компонентами:</p>
    <p>• Одна или несколько потоков.</p>
    <p>• Виртуальное адресное пространство, отличное от адресных пространств других процессов, если не считать областей памяти, распределенных явным образом для совместного использования (разделения) несколькими процессами. Заметьте, что разделяемые отображенные файлы совместно используют физическую память, тогда как разделяющие их процессы используют различные виртуальные адресные пространства.</p>
    <p>• Один или несколько сегментов кода, включая код DLL.</p>
    <p>• Один или несколько сегментов данных, содержащих глобальные переменные.</p>
    <p>• Строки, содержащие информацию об окружении, например, информацию о текущем пути доступа к файлам.</p>
    <p>• Куча процесса.</p>
    <p>• Различного рода ресурсы, например, дескрипторы открытых файлов и другие кучи.</p>
    <p>Поток разделяет вместе с процессом код, глобальные переменные, строки окружения и другие ресурсы. Каждый поток планируется независимо от других и располагает следующими элементами:</p>
    <p>• Стек, используемый для вызова процедур, прерываний и обработчиков исключений, а также хранения автоматических переменных.</p>
    <p>• Локальные области хранения потока (Thread Local Storage, SLT) — массивы указателей, используя которые каждый поток может создавать собственную уникальную информационную среду.</p>
    <p>• Аргумент в стеке, получаемый от создающего потока, который обычно является уникальным для каждого потока.</p>
    <p>• Структура контекста, поддерживаемая ядром системы и содержащая значения машинных регистров.</p>
    <p>На рис. 6.1 показан процесс с несколькими потоками. Рисунок является схематическим, поэтому на нем не указаны фактические адреса памяти и не соблюдены масштабы.</p>
    <p>В данной главе показано, как работать с процессами, состоящими из единственного потока. О том, как использовать несколько потоков, рассказывается в главе 7.</p>
    <cite>
     <p><strong>Примечание</strong></p>
     <p>Рисунок 6.1 является высокоуровневым с точки зрения программиста представлением процесса. В действительности эта картина должна быть дополнена множеством технических деталей и особенностями реализации. Более подробную информацию заинтересованные читатели могут найти в книге Соломона (Solomon) и Руссиновича (Russinovich) <emphasis>Inside Windows 2000.</emphasis> </p>
    </cite>
    <cite>
     <p>Процессы UNIX сопоставимы с процессами Windows, имеющими единственный поток.</p>
     <p>Реализации UNIX недавно пополнились потоками POSIX Pthreads, которые в настоящее время используются почти повсеместно. В [40] потоки не обсуждаются; все рассмотрение основано на процессах.</p>
     <p>Наверное, можно было бы даже не напоминать о том, что понятие потоков не является новым, и их различные реализации предлагаются поставщиками уже на протяжении целого ряда лет. Однако потоки Pthreads являются самым распространенным стандартом, в то время как коммерческие реализации потоков являются устаревшими.</p>
    </cite>
    <image l:href="#Any2FbImgLoader84"/>
    <p><strong>Рис. 6.1.</strong> Процесс и его потоки</p>
   </section>
   <section>
    <title>
     <p>Создание процесса</p>
    </title>
    <section>
     <p>Одной из важнейших функций Windows, обеспечивающих управление процессами, является функция CreateProcess, которая создает новый процесс с единственным потоком. При вызове этой функции требуется указать имя файла исполняемой программы.</p>
     <p>Обычно принято говорить о <emphasis>процессах-предках,</emphasis> или <emphasis>родительских процессах</emphasis> (parent processes), и <emphasis>процессах-потомках,</emphasis> или <emphasis>дочерних процессах</emphasis> (child processes), однако между процессами Windows эти отношения фактически не поддерживаются. Использование данной терминология является просто удобным способом выражения того факта, что один процесс порождается другим.</p>
     <p>Гибкие и мощные возможности функции CreateProcess обеспечиваются ее десятью параметрами. На первых порах для упрощения работы целесообразно использовать значения параметров, заданные по умолчанию. Точно так же, как и в случае функции CreateFile, имеет смысл подробно рассмотреть каждый из параметров функции CreateProcess. Благодаря этому изучить другие аналогичные функции вам будет гораздо легче.</p>
     <p>Прежде всего, заметьте, что возвращаемое значение функции не является дескриптором типа HANDLE; вместо этого функция возвращает два отдельных дескриптора, по одному для процесса и потока, передавая их в структуре, которая указывается при вызове функции. Эти дескрипторы относятся к создаваемому функцией CreateProcess новому процессу и его <emphasis>основного</emphasis> (primary) потока. Во избежание утечки ресурсов в процессе работы с примерами программ тщательно следите за своевременным закрытием обоих дескрипторов, когда они вам больше не нужны; забывчивость в отношении закрытия дескрипторов потоков является одной из самых распространенных ошибок. Закрытие дескриптора потока не приводит к прекращению ее выполнения; функция CloseHandle лишь удаляет ссылку на поток внутри процесса, вызвавшего функцию CreateProcess. </p>
     <cite>
      <p><code>BOOL CreateProcess(lpApplicationName, LPTSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpsaProcess, LPSECURITY_ATTRIBUTES lpsaThread, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCTSTR lpCurDir, LPSTARTUPINFO lpStartupInfo, LPPROCESS_INFORMATION lpProcInfo)</code></p>
      <p><strong>Возвращаемое значение:</strong> в случае успешного создания процесса и потока — TRUE, иначе — FALSE. </p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>Некоторые параметры потребуют дальнейшего подробного обсуждения в следующих разделах, тогда как смысл многих других станет для вас более понятным при рассмотрении примеров программ.</p>
     <p>lpApplicationName и lpCommandLine (последний указатель имеет тип LPTSTR, а не LPCTSTR) — используются вместе для указания исполняемой программы и аргументов командной строки, о чем говорится в следующем разделе.</p>
     <p>lpsaProcess и lpsaThread — указатели на структуры атрибутов защиты процесса и потока. Значениям NULL соответствует использование атрибутов защиты, заданных по умолчанию, и именно эти значения будут использоваться нами вплоть до главы 15, посвященной рассмотрению средств безопасности Windows.</p>
     <p>bInheritHandles — показывает, наследует ли новый процесс наследуемые открытые дескрипторы (файлов, отображений файлов и так далее) из вызывающего процесса. Наследуемые дескрипторы имеют те же атрибуты, что и исходные, и их обсуждение будет продолжено в одном из следующих разделов.</p>
     <p>dwCreationFlags — может объединять в себе несколько флаговых значений, включая следующие:</p>
     <p>• CREATE_SUSPENDED — указывает на то, что основной поток будет создан в приостановленном состоянии и начнет выполняться лишь после вызова функция ResumeThread. </p>
     <p>• DETACHED_PROCESS и CREATE_NEW_CONSOLE — взаимоисключающие значения, которые не должны устанавливаться оба одновременно. Первый флаг означает создание нового процесса, у которого консоль отсутствует, а второй — процесса, у которого имеется собственная консоль. Если ни один из этих флагов не указан, то новый процесс наследует консоль родительского процесса.</p>
     <p>• Create_New_Process_Group — указывает на то, что создаваемый процесс является корневым для новой группы процессов. Если все процессы, принадлежащие данной группе, разделяют общую консоль, то все они будут получать управляющие сигналы консоли (Ctrl-C или Ctrl-break). Обработчики управляющих сигналов консоли описывались в главе 4, а их применение было продемонстрировано в программе 4.5. Упомянутые группы процессов в некотором отношении аналогичны группам процессов UNIX и рассматриваются далее в этой главе.</p>
     <p>Некоторые из флагов управляют приоритетами потоков нового процесса. О возможных значениях этих флагов более подробно говорится в главе 7. Пока же нам будет достаточно использовать приоритет родительского процесса (этот режим устанавливается по умолчанию) или указывать значение NORMAL_PRIORITY_CLASS.</p>
     <p>lpEnvironment — указывает на блок параметров настройки окружения нового процесса. Если задано значение NULL, то новый процесс будет использовать значения параметров окружения родительского процесса. Блок параметров содержит строки, в которых заданы пары "имя-значение", определяющие, например, пути доступа к файлам.</p>
     <p>lpCurDir — указатель на строку, содержащую путь к текущему каталогу нового процесса. Если задано значение NULL, то в качестве текущего каталога будет использоваться рабочий каталог родительского процесса.</p>
     <p>lpStartupInfo — указатель на структуру, которая описывает внешний вид основного окна и содержит дескрипторы стандартных устройств нового процесса. Используйте соответствующую информацию из родительского процесса, которую можно получить при помощи функции GetStartupInfo. Можно поступить и по-другому, обнулив структуру STARTUPINFO перед вызовом функции CreateProcess. Для указания стандартных устройств ввода, вывода информации и вывода сообщений об ошибках следует определить значения полей дескрипторов стандартных устройств (hStdInput, hStdOutput и hStdError) в структуре STARTUPINFO. Чтобы эти значения не игнорировались, следует задать для другого элемента этой же структуры, а именно, элемента dwFlags, значение STARTF_USESTDHANDLES и определить все дескрипторы, которые потребуются дочернему процессу. Убедитесь в том, что эти дескрипторы являются наследуемыми и что при вызове функции CreateProcess значение параметра bInheritHandles установлено равным TRUE. Более подробная информация по этому вопросу, сопровождаемая соответствующим примером, приводится в разделе "Наследуемые дескрипторы". </p>
     <p>lpProInfо — указатель на структуру, в которую будут помещены возвращаемые функцией значения дескрипторов и глобальных идентификаторов процесса и потока. Структура PROCESS_INFORMATION, о которой идет речь, имеет следующий вид: </p>
     <cite>
      <p><code>typedef struct PROCESS_INFORMATION {</code></p>
      <p><code> HANDLE hProcess;</code></p>
      <p><code> HANDLE hThread;</code></p>
      <p><code> DWORD dwProcessId;</code></p>
      <p><code> DWORD dwThreadId; </code></p>
      <p><code>} PROCESS_INFORMATION;</code></p>
     </cite>
     <p>Зачем процессам и потокам нужны еще и дескрипторы, если они снабжаются глобальными идентификаторами (ID)? Глобальные идентификаторы остаются уникальными для данного объекта на протяжении всего времени его существования и во всех процессах, тогда дескрипторов процесса может быть несколько и каждый из которых может характеризоваться собственным набором атрибутов, например определенными разрешениями доступа. В силу указанных причин одним функциям управления процессами требуется предоставлять идентификаторы процессов, а другим — дескрипторы. Кроме того, необходимость в дескрипторах процессов возникает при использовании универсальных функций, которые требуют указания дескрипторов. В качестве примера можно привести функции ожидания, обсуждаемые далее в этой главе, которые обеспечивают отслеживание переходов объектов различного типа, в том числе и процессов, указываемых с помощью дескрипторов, в определенные состояния. Точно так же, как и дескрипторы файлов, дескрипторы процессов и потоков должны закрываться сразу же после того, как необходимость в них отпала.</p>
     <cite>
      <p><strong>Примечание</strong></p>
      <p>Новый процесс получает информацию об окружении, рабочем каталоге и иную информацию в результате вызова функции CreateProcess. По завершении этого вызова любые изменения характеристик родительского процесса никак не отразятся на дочернем процессе. Так, после вызова функции CreateProcess рабочий каталог родительского процесса может измениться, но на дочерний процесс это не окажет никакого влияния, если только он сам не сменит рабочий каталог. Оба процесса полностью независимы друг от друга. </p>
     </cite>
     <cite>
      <p>Модели процесса в UNIX и Windows значительно отличаются друг от друга. Прежде всего, в Windows отсутствует эквивалент UNIX-функции fork, создающей копию родительского процесса, включая его пространство данных, кучу и стек. В Windows трудно добиться точной эмуляции fork, но как ни расценивать последствия этого ограничения, остается фактом, что проблемы с использованием функции fork существуют и в многопоточных системах UNIX, поскольку любые попытки создания точной реплики многопоточной системы с копиями всех потоков и объектов синхронизации, особенно в случае SMP-систем, приводят к возникновению множества трудностей. Поэтому в действительности функция fork вообще плохо подходит для многопоточных систем.</p>
      <p>В то же время, функция CreateProcess аналогична обычной для UNIX цепочке последовательных вызовов функций fork и execl (или одной из пяти остальных функций exec). В отличие от Windows пути доступа в UNIX определяются исключительно переменной среды PATH.</p>
      <p>Как ранее уже отмечалось, отношения "предок-потомок" между процессами в Windows не поддерживаются. Так, выполнение дочернего процесса будет продолжаться даже после того, как завершится родительский процесс. Кроме того, в Windows отсутствуют группы процессов. Существует, однако, ограниченная форма группы процессов, в которой все процессы получают управляющие события консоли.</p>
      <p>Процессы Windows идентифицируются как дескрипторами, так и идентификаторами процессов, тогда как в UNIX дескрипторы процессов отсутствуют.</p>
     </cite>
    </section>
    <section>
     <title>
      <p>Указание исполняемого модуля и командной строки</p>
     </title>
     <p>Для указания имени файла исполняемого модуля используются как параметр lpApplicationName, так и параметр lpCommandLine. При этом действуют следующие правила:</p>
     <p>• Указатель lpApplicationName, если его значение не равно NULL, указывает на строку, содержащую имя файла исполняемого модуля. Если имя модуля содержит пробелы, его следует заключить в кавычки. Более детальное описание приводится ниже.</p>
     <p>• Если же значение указателя lpApplicationName равно NULL, то имя модуля определяется первой из лексем, переданных параметром lpCommandLine.</p>
     <p>Обычно задается только параметр lpCommandLine, в то время как параметр lpApplicationName полагается равным NULL. Тем не менее, ниже приведены более подробные правила, которые определяют порядок использования этих двух параметров.</p>
     <p>• Параметр lpApplicationName, если он не равен NULL, определяет исполняемый модуль. В строке, на которую указывает этот указатель, задайте полный путь доступа и имя файла или же ограничьтесь только именем файла, и тогда будут использоваться текущие диск и каталог; дополнительный поиск при этом производиться не будет. В имя файла включите расширение, например, .EXE или .ВАТ.</p>
     <p>• Если значение параметра lpApplicationName равно NULL, то именем исполняемого модуля является первая из разделенных пробельными символами лексем, переданных параметром lpCommandLine. Если имя полный путь доступа не указан, то поиск файла осуществляется в следующем порядке: </p>
     <p> 1. Каталог модуля текущего процесса.</p>
     <p> 2. Текущий каталог.</p>
     <p> 3. Системный каталог Windows, информацию о котором можно получить с помощью функции GetSystemDirectory.</p>
     <p> 4. Каталог Windows, возвращаемый функцией GetWindowsDirectory.</p>
     <p> 5. Каталоги, перечисленные в переменной окружения PATH.</p>
     <p>Новый процесс может получить командную строку посредством обычного argv-механизма или путем вызова функции GetCommandLine для получения командной строки в виде одиночной строки символов.</p>
     <p>Заметьте, что командная строка не является строковой константой. Это согласуется с тем, что параметры argv главной программы не являются константами. Программа может модифицировать свои аргументы, хотя для внесения любых изменений рекомендуется использовать копию строки аргументов.</p>
     <p>Вовсе не обязательно, чтобы новый процесс создавался с тем же определением UNICODE, что и родительский процесс. Возможны любые комбинации. Использование _tmain, как обсуждалось в главе 2, облегчает разработку программного кода, который сможет работать как с символами Unicode, так и с символами ASCII.</p>
    </section>
    <section>
     <title>
      <p>Наследуемые дескрипторы</p>
     </title>
     <p>Часто бывает так, что дочернему процессу требуется доступ к объекту, к которому можно обратиться через дескриптор, определенный в родительском процессе, и если этот дескриптор — наследуемый, то дочерний процесс может получить копию открытого дескриптора родительского процесса. Часто именно так обеспечивается возможность использования дескрипторов стандартного ввода и вывода дочерним процессом. Преобразование дескриптора в наследуемый, чтобы дочерний процесс мог получить и использовать его копию, требует выполнения нескольких шагов.</p>
     <p>Флаг bInheritHandles, который можно указать при вызове функции CreateProcess, определяет, будет ли дочерний процесс наследовать копии наследуемых дескрипторов открытых файлов, процессов и так далее. Этот флаг можно рассматривать как главный переключатель, действующий в отношении всех дескрипторов.</p>
     <p>Кроме того, чтобы сделать наследуемым любой отдельный дескриптор, также требуется предпринимать специальные действия, поскольку дескрипторы не становятся таковыми по умолчанию. Создать наследуемый дескриптор можно либо путем использования структуры SECURITY_ATTRIBUTES в момент создания дескриптора, либо путем копирования существующего дескриптора.</p>
     <p>В структуре SECURITY_ATTRIBUTES присутствует флаг bInheritHandle, значение которого должно быть установлено равным TRUE. He забывайте также о том, что элемент nLength должен инициализироваться следующим значением:</p>
     <p><code>sizeof(SECURITY_ATTRIBUTES)</code></p>
     <p>Приведенный ниже фрагмент кода иллюстрирует создание наследуемых файловых или иных дескрипторов в типичных случаях. В этом примере дескриптор защиты в структуре атрибутов защиты установлен в NULL; подробнее об использовании дескрипторов защиты говорится в главе 15. </p>
     <p><code>HANDLE h1, h2, h3; </code></p>
     <p><code>SECURITY_ATTRIBUTES sa = { sizeof(SECURITY_ATTRIBUTES), NULL, TRUE };</code></p>
     <p><code>…</code></p>
     <p><code>h1 = CreateFile(…, &amp;sa, …); /* Наследуемый. */ </code></p>
     <p><code>h2 = CreateFile(…, NULL, …); /* Ненаследуемый. */ </code></p>
     <p><code>h3 = CreateFile(…, &amp;sa, …); /* Наследуемый. Возможно повторное использование структуры sa. */</code></p>
     <p>Однако дочернему процессу значение наследуемого дескриптора пока еще не известно, и поэтому родительский процесс должен передать это значение дочернему процессу либо через механизм межпроцессного взаимодействия (Interprocess Communication, IPC), либо путем назначения дескриптора стандартному устройству ввода/вывода в структуре STARTUPINFO, как это делается в первом из примеров, приведенных в данной главе (программа 6.1), а также в ряде примеров в остальной части книги. Обычно последний метод является более предпочтительным, так как он позволяет перенаправить ввод/вывод стандартным способом без внесения каких-либо изменений в дочернюю программу.</p>
     <p>В случае дескрипторов, которые не являются дескрипторами файлов или не используются для перенаправления ввода/вывода, применим другой способ, в соответствии с которым дескриптор преобразуется в текстовый формат и помещается в командную строку или переменную окружения. Такой подход можно использовать лишь в том случае, если дескриптор является наследуемым, поскольку и родительский, и дочерний процессы используют для идентификации дескриптора одно и то же значение. Один из способов реализации этого подхода предлагается в упражнении 6.2, а соответствующее решение приводится на Web-сайте книги.</p>
     <p>Унаследованные дескрипторы представляют собой отдельные экземпляры. Поэтому родительский и дочерний процессы могут получить доступ к одному и тому же файлу, используя различные указатели файлов. Более того, каждый из обоих процессов может и должен самостоятельно закрывать принадлежащий ему дескриптор.</p>
     <p>На рис. 6.2 показан пример двух процессов с двумя различными таблицами дескрипторов, в которых с одним и тем же файлом или иным объектом связаны два различных дескриптора. Процесс 1 является родительским, процесс 2 — дочерним. Если принадлежащий дочернему процессу дескриптор был унаследован им, как это имеет место в случае дескрипторов 1 и 3, то значения дескрипторов в обоих процессах будут одинаковыми.</p>
     <p>Однако подобные дескрипторы могут иметь и различные значения. Так, на файл D указывают два дескриптора, причем процесс 2 получил дескриптор за счет вызова функции CreateFile, а не путем наследования. Наконец, возможны ситуации, когда один из процессов имеет дескриптор объекта, а второй — не имеет, что наблюдается для файлов В и Е. Так происходит в тех случаях, когда дескриптор создается дочерним процессом или дублируется из одного процесса в другой, о чем говорится в разделе "Дублирование дескрипторов". </p>
     <image l:href="#Any2FbImgLoader87"/>
     <p><strong>Рис. 6.2.</strong> Таблицы дескрипторов объектов для двух процессов</p>
    </section>
   </section>
   <section>
    <title>
     <p>Счетчики дескрипторов процессов</p>
    </title>
    <p>Распространенной ошибкой программистов является пренебрежение закрытием дескрипторов после того, как необходимость в них отпала; это может стать причиной утечки ресурсов, что, в свою очередь, может приводить к снижению производительности или сбоям в программе и даже влиять на другие процессы. В версии NT 5.1 добавлена новая функция, позволяющая определить количество открытых дескрипторов, принадлежащих указанному процессу. Таким способом вы можете контролировать как собственный, так и другие процессы.</p>
    <p>Приведенное ниже определение упомянутой функции не нуждается в отдельных пояснениях:</p>
    <cite>
     <p><code>BOOL GetProcessHandleCount( HANDLE hProcess, PDWORD pdwHandleCount)</code> </p>
    </cite>
   </section>
   <section>
    <title>
     <p>Идентификаторы процессов</p>
    </title>
    <p>Процесс может получить идентификатор и дескриптор нового дочернего процесса из структуры PROCESS_INFORMATION. Разумеется, закрытие дескриптора дочернего процесса не приводит к уничтожению самого процесса; становится невозможным лишь доступ к нему со стороны родительского процесса. Для получения идентификационной информации о текущем процессе служат две функции. </p>
    <cite>
     <p><code>HANDLE GetCurrentProcess(VOID)</code></p>
     <p><code>DWORD GetCurrentProcessId(VOID)</code> </p>
    </cite>
    <p>В действительности функция GetCurrentProcess возвращает <emphasis>псевдодескриптор </emphasis>(pseudohandle), который не является наследуемым. Это значение может использоваться вызывающим процессом всякий раз, когда ему требуется его собственный дескриптор. Реальный дескриптор процесса создается на основе идентификатора (ID) процесса, включая и тот, который возвращается функцией GetCurrentProcessID, путем использования функции OpenProcess. Как и в случае любого разделяемого объекта, при отсутствии надлежащих разрешений доступа попытка открытия объекта процесса окажется неуспешной. </p>
    <cite>
     <p><code>HANDLE OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)</code></p>
     <p><strong>Возвращаемое значение: </strong>в случае успешного завершения — дескриптор процесса, иначе — NULL. </p>
    </cite>
    <subtitle><emphasis>Параметры</emphasis></subtitle>
    <p>dwDesiredAccess — определяет права доступа к процессу. Некоторые из возможных значений этого параметра перечислены ниже.</p>
    <p>• SYNCHRONIZE — разрешается использование дескриптора процесса в функциях ожидания завершения процесса, которые описываются далее в этой главе.</p>
    <p>• PROCESS_ALL_ACCESS — устанавливаются все флаги доступа к процессу.</p>
    <p>• PROCESS_TERMINATE — делает возможным завершение процесса с использованием функции TerminateProcess.</p>
    <p>• PROCESS_QUERY_INFORMATION — разрешает использование дескриптора процесса в функциях GetExitCodeProcess и GetPriorityClass для получения информации о процессе.</p>
    <p>bInheritHandle — позволяет указать, является ли новый дескриптор наследуемым. Параметр dwProcessID является идентификатором процесса, запрашивающего дескриптор.</p>
    <p>Наконец, выполняющийся процесс может определить полный путь доступа к файлу исполняемого модуля, который использовался для его запуска, с помощью функций GetModuleFileName или GetModuleFileNameEx, при вызове которых значение параметра hModule должно устанавливаться равным NULL. При вызове этой функции из DLL будет возвращено имя файла DLL, а не .ЕХЕ-файла, который использует эту библиотеку DLL. </p>
   </section>
   <section>
    <title>
     <p>Дублирование дескрипторов</p>
    </title>
    <p>Родительскому и дочернему процессам может требоваться различный доступ к объекту, идентифицируемому дескриптором, который наследует дочерний процесс. Кроме того, процессу вместо псевдодескриптора, получаемого с помощью функции GetModuleFileName или GetModuleFileNameEx, может потребоваться реальный, наследуемый дескриптор, который мог бы использоваться дочерним процессом. Родительский процесс может обеспечить это, создав копию дескриптора с желаемыми разрешениями доступа и свойствами наследования. Функция, позволяющая создавать копии дескрипторов, имеет следующий вид: </p>
    <cite>
     <p><code>BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lphTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)</code> </p>
    </cite>
    <p>По завершении выполнения функции указатель lphTargetHandle будет указывать на копию исходного дескриптора, hSourceHandle. hSourceHandle является дескриптором дублируемого объекта в процессе, указанном дескриптором hSourceProcessHandle, и должен иметь права доступа PROCESS_DUP_HANDLE; если указанного дескриптора в исходном процессе не существует, функция DuplicateHandle завершается ошибкой. Новый дескриптор, на который указывает указатель lphTargetHandle, является действительным в целевом процессе, hTargetProcessHandle. Обратите внимание на то, что в нашем рассмотрении фигурировали три процесса, включая вызывающий. Часто в роли вызывающего процесса выступает целевой или исходный процесс, и тогда соответствующий дескриптор получают с помощью функции GetCurrentProcess. Заметьте также, что процесс может создать дескриптор в другом процессе; если вы это делаете, то вам потребуется механизм, с помощью которого можно было бы передать в другой процесс идентификационные данные нового дескриптора.</p>
    <p>Функция DuplicateHandle может применяться к дескрипторам любого типа.</p>
    <p>Если действие параметра dwDesiredAccess не отменяется флагом DUPLICATE_SAME_ACCESS параметра dwOptions, то у него может быть много возможных значений (для получения более подробных сведений обратитесь к библиотеке MSDN оперативного справочного руководства).</p>
    <p>Параметр dwOptions может содержать любую комбинацию указанных ниже двух флагов.</p>
    <p>• DUPLICATE_CLOSE_SOURCE — вызывает закрытие исходного дескриптора.</p>
    <p>• DUPLICATE_SAME_ACCESS — вынуждает игнорировать параметр dwDesiredAccess. </p>
    <cite>
     <p><strong>Напоминание</strong></p>
     <p>Ядро Windows поддерживает счетчики ссылок для всех объектов; этот счетчик представляет количество различных дескрипторов, ссылающихся на данный объект. В то же время, приложения не имеют доступа к этому счетчику. Любой объект не может быть уничтожен до тех пор, пока не будет закрыт его последний дескриптор, а счетчик ссылок не примет нулевое значение. Унаследованные и продублированные дескрипторы считаются отличными от исходных и также учитываются в счетчике ссылок. Наследуемые дескрипторы используются в программе 6.1 далее в этой главе. В то же время, дескрипторы, переданные из одного процесса в другой посредством той или иной формы механизма IPC, не считаются независимыми, и поэтому если один процесс закрывает такой дескриптор, то другие процессы использовать его не могут. Подобной методикой пользуются редко, однако в упражнении 6.2 вам предлагается передать значение унаследованного дескриптора из одного процесса в другой, используя механизм IPC.</p>
    </cite>
    <p>Далее вы узнаете о том, как определить, завершено ли выполнение процесса.</p>
   </section>
   <section>
    <title>
     <p>Завершение и прекращение выполнения процесса</p>
    </title>
    <p>После того как процесс завершил свою работу, он, или, точнее, выполняющийся в этом процессе поток, может вызвать функцию ExitProcess, указав в качестве параметра кодом завершения (exit code):</p>
    <cite>
     <p><code>VOID ExitProcess(UINT uExitCode)</code> </p>
    </cite>
    <p>Эта функция не осуществляет возврата. Вместо этого она завершает вызывающий процесс и все его потоки. Обработчики завершения игнорируются, но делаются все необходимые вызовы точек входа DllMain (см. главу 5) с кодом отключения от библиотеки. Код завершения связывается с процессом. Выполнение оператора return в основной программе с использованием кода возврата равносильно вызову функции ExitProcess, в котором этот код возврата указан в качестве кода завершения.</p>
    <p>Другой процесс может определить код завершения, вызвав функцию GetExitCodeProcess: </p>
    <cite>
     <p><code>BOOL GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode)</code> </p>
    </cite>
    <p>Процесс, идентифицируемый дескриптором hProcess, должен обладать правами доступа PROCESS_QUERY_INFORMATION (см. описание функции OpenProcess, которая нами уже обсуждалась). lpExitCode указывает на переменную типа DWORD, которая принимает значение кода завершения. Одним из ее возможных значений является STILL_ACTIVE, означающее, что данный процесс еще не завершился. </p>
    <p>Наконец, один процесс может прекратить выполнение другого процесса, если у дескриптора завершаемого процесса имеются права доступа PROCESS_TERMINATE. При вызове функции завершения процесса указывается код завершения. </p>
    <cite>
     <p><code>BOOL TerminateProcess(HANDLE hProcess, UINT uExitCode)</code> </p>
    </cite>
    <cite>
     <p><strong>Предостережение</strong></p>
     <p>Прежде чем завершить выполнение процесса, убедитесь в том, что все ресурсы, которые он мог разделять с другими процессами, освобождены. В частности, должны быть корректно обработаны ресурсы синхронизации, о которых говорится в главе 8 (мьютексы, семафоры и события). В этом отношении могут оказаться полезными SEH (глава 4), а вызов функции ExitProcess может быть осуществлен из обработчика. В то же время, при вызове функции ExitProcess обработчики __finally и __except <emphasis>не</emphasis> выполняются, поэтому в идее завершения выполнения изнутри программы нет ничего хорошего. Особенно рискованно применять функцию TerminateProcess, поскольку у завершаемого процесса в этом случае отсутствует возможность выполнить свои SEH или вызвать функции DllMain связанных с ним библиотек DLL. Ограниченной альтернативой являются обработчики управляющих сигналов консоли, обеспечивающие возможность передачи сигнала одним процессом другому, который после этого может корректно организовать свое завершение.</p>
    </cite>
    <p>Программа 6.3 иллюстрирует применение методики, обеспечивающей взаимодействие между процессами. В этом примере один процесс посылает другому процессу запрос завершения выполнения, получив который второй процесс сможет аккуратно завершить свою работу. </p>
    <cite>
     <p>Процессы UNIX имеют свои идентификаторы, pid, которые сопоставимы с идентификаторами процессов Windows. Функция getpid аналогична функции GetCurrentProcessID, но эквивалентов функциям getppid и getgpid в Windows не находится ввиду отсутствия предков процессов и групп процессов.</p>
     <p>И, наоборот, в UNIX отсутствуют дескрипторы процессов, и поэтому в ней нет функций, которые можно было бы сравнить с функциями GetCurrentProcess или OpenProcess.</p>
     <p>В UNIX допускается использование дескрипторов (descriptors) открытых файлов после вызова функции exec, если для дескриптора файла не был установлен флаг close-on-exec. Это правило применимо только к дескрипторам файлов, которые, в силу вышесказанного, можно сравнить с наследуемыми дескрипторами (handles) файлов Windows.</p>
     <p>Функция UNIX exit, которая фактически является функцией библиотеки С, аналогична функции ExitProcess; чтобы прекратить выполнение другого процесса ему следует послать сигнал SIGKILL. </p>
    </cite>
   </section>
   <section>
    <title>
     <p>Ожидание завершения процесса</p>
    </title>
    <p>Простейшим, но наряду с этим и обладающим наиболее ограниченными возможностями, методом синхронизации с другим процессом является ожидание его завершения. Представленные ниже стандартные функции ожидания Windows обладают рядом интересных свойств.</p>
    <p>• Функции ожидания могут работать с самыми различными типами объектов; дескрипторы процессов являются лишь самым первым из рассматриваемых нами примеров применения этих функций.</p>
    <p>• Эти функции могут ожидать завершения одного процесса, первого из нескольких указанных процессов или всех процессов, образующих группу.</p>
    <p>• Существует возможность устанавливать конечный интервал ожидания (time-out).</p>
    <p>Обе рассмотренных ниже функции ожидают перехода объекта синхронизации в <emphasis>сигнальное</emphasis> состояние. Например, система переводит процесс в сигнальное состояние, когда он завершается или его выполнение прекращается извне. Функциями ожидания, которые мы будем впоследствии неоднократно использовать, являются следующие функции: </p>
    <cite>
     <p><code>DWORD WaitForSingleObject(HANDLE hObject, DWORD dwMilliseconds)</code> </p>
    </cite>
    <cite>
     <p><code>DWORD WaitForMultipleObjects(DWORD nCount, CONST HANDLE *lpHandles, BOOL fWaitAll, DWORD dwMilliseconds)</code> </p>
    </cite>
    <p>Возвращаемое значение: указывает причину завершения ожидания или, в случае ошибки, равно 0xFFFFFFFF (для получения более подробной информации используйте функцию GetLastError).</p>
    <p>В аргументах этих функций указывается либо дескриптор одиночного процесса (hObject), либо дескрипторы ряда отдельных объектов, хранящиеся в массиве, на который указывает указатель lpHandles. Значение параметра nCount, определяющего размер массива, не должно превышать значение MAXIMUM_WAIT_OBJECTS (определено равным 64 в файле WINNT.Н).</p>
    <p>dwMilliseconds — число миллисекунд интервала ожидания. Если значение этого параметра равно 0, то возврат из функции осуществляется сразу же после проверки состояния указанного объекта, что позволяет программе опрашивать процессы для определения их состояния завершения. Если же значение этого параметра равно INFINITE, то ожидание длится до тех пор, пока ожидаемый процесс не завершится.</p>
    <p>fWaitAll — параметр второй функции, указывающий (если его значение равно TRUE) на необходимость ожидания завершения всех процессов, а не только одного.</p>
    <p>Возможными возвращаемыми значениями этой функции в случае ее успешного завершения являются следующие:</p>
    <p>• WAIT_OBJECT_0 — означает, что указанный объект перешел в сигнальное состояние (в случае функции WaitForSingleObject) или что одновременно все nCount объектов перешли в сигнальное состояние (в специальном случае функции WaitForMultipleObject, когда значение параметра fWaitAll равно TRUE).</p>
    <p>• WAIT_OBJECT_0+n, где 0 &#8804; n &lt; nCount — вычтите значение WAIT_OBJECT_0 из возвращенного значения, чтобы определить, выполнение какого именно процесса завершилось, когда ожидается завершение выполнения любого из группы процессов. Если в сигнальное состояние перешли несколько объектов, то возвращается наименьшее из возможных значений. WAIT_ABANDONED является возможным базовым значением в случае использования дескрипторов мьютексов; см. главу 8.</p>
    <p>• WAIT_TIMEOUT — указывает на то, что в течение отведенного периода ожидания сигнализируемый объект (объекты) не смогли удовлетворить условию ожидания.</p>
    <p>• WAIT_FAILED — означает неудачное завершение функции, вызванное, например, тем, что у дескриптора отсутствовали права доступа SYNCHRONIZE.</p>
    <p>• WAIT_ABANDONED_0 — это значение невозможно в случае процессов и рассматривается в главе 8 при рассмотрении мьютексов.</p>
    <p>Для определения кода завершения процесса используется функция GetExitCodeProcess, описанная в предыдущем разделе.</p>
   </section>
   <section>
    <title>
     <p>Блоки и строки окружения</p>
    </title>
    <section>
     <p>Схема, представленная на рис. 6.1, включает блок окружения процесса. Блок окружения (environment block) процесса содержит последовательность строк вида:</p>
     <p><code>Имя = Значение</code></p>
     <p>Каждая строка окружения (environment string), будучи символьной строкой, заканчивается нулевым символом, а весь блок строк в целом завершается дополнительным нулевым символом. Одним из примеров широко используемых переменных среды является переменная PATH. </p>
     <p>Чтобы передать информацию об окружении из родительского процесса в дочерний, параметр lpEnvironment при вызове функции CreateProcess следует установить равным NULL. В свою очередь, любой процесс может запросить или изменить свои переменные окружения или добавить новые в блок окружения.</p>
     <p>Для получения, а также создания новых или изменения существующих переменных окружения используются следующие функции: </p>
     <cite>
      <p><code>DWORD GetEnvironmentVariable(LPCTSTR lpName, LPTSTR lpValue, DWORD cchValue)</code></p>
      <p><code>BOOL SetEnvironmentVariable(LPCTSTR lpName, LPCTSTR lpValue)</code> </p>
     </cite>
     <p>lpName — указатель на строку, содержащую имя переменной окружения. После определения переменной окружения она добавляется в блок окружения при условии, что такая переменная ранее не существовала, а определяемое значение не равно NULL. Если же определяемое значение равно NULL, то переменная удаляется из блока. Строка значения не может содержать символы "=".</p>
     <p>В случае успешного завершения функция GetEnvironmentVariable возвращает длину строки значения переменной окружения, иначе — 0. Если размер буфера lpValue, указанный значением параметра cchValue, оказался недостаточно большим, то возвращаемое значение равно количеству символов, которое фактически требуется для сохранения значения переменной. Вспомните, что аналогичный механизм используется и в функции GetCurrentDirectory (глава 2).</p>
    </section>
    <section>
     <title>
      <p>Защита процесса</p>
     </title>
     <p>Обычно функция CreateProcess предоставляет права доступа к процессу на уровне PROCESS_ALL_ACCESS. Однако имеется возможность определения детализированных прав доступа, из которых в качестве примера можно назвать права доступа PROCESS_QUERY_INFORMATION, CREATE_PROCESS, PROCESS_TERMINATE, PROCESS_SET_INFORMATION, DUPLICATE_HANDLE и CREATETHREAD. В частности, с учетом возможных рисков, которые могут подстерегать вас в случае принудительного завершения выполняющихся процессов, на что мы уже неоднократно обращали ваше внимание, может оказаться полезным ограничить предоставление прав доступа к процессам на уровне PROCESS_TERMINATE для родительского процесса. Подробнее об атрибутах защиты процессов и других объектов говорится в главе 15. </p>
     <cite>
      <p>В UNIX для ожидания завершения процессов используются функции wait и waitpid, однако отсутствует понятие интервала ожидания, хотя функция waitpid может опрашивать процессы (существует возможность ее вызова без блокировки). Эти функции способны ожидать лишь завершения дочерних процессов, и эквивалентных им функций, применимых к ряду процессов, не существует, хотя и возможно ожидание завершения всех процессов, относящихся к одной группе. Кроме того, имеется одно незначительное отличие, заключающееся в том, что функции wait и waitpid возвращают код завершения сами, в результате чего отпадает необходимость в вызове отдельной функции, эквивалентной функции GetExitCodeProcess.</p>
      <p>Строки окружения, аналогичные строкам окружения Windows, поддерживаются и в UNIX. Функция getenv (входящая в библиотеку С) имеет те же самые функциональные возможности, что и функция GetEnvironmentVariable, но программист сам должен заботиться о необходимом размере буфера. Функции putenv, setenv и unsetenv обеспечивают различные способы добавления, изменения и удаления переменных окружения и их значений, предлагая функциональность, аналогичную функциональности SetEnvironmentVariable.</p>
     </cite>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: параллельный поиск указанного текстового шаблона</p>
    </title>
    <p>Настало время посмотреть на процессы Windows в действии. Приведенная ниже в качестве примера программа grepMP создает процессы для поиска указанного текстового шаблона в файлах, по одному процессу на каждый файл. Эта программа моделирует UNIX-утилиту grep, хотя используемая нами методика применима к любой программе, которая полагается на стандартный вывод. Рассматривайте программу поиска как "черный ящик" и считайте, что она является просто исполняемой программой, выполнение которой должно контролироваться родительским процессом.</p>
    <p>Командная строка программы имеет следующий вид:</p>
    <p><code>grepMP <emphasis>шаблон</emphasis> F1 F2 … FN</code></p>
    <p>Программа 6.1 выполняет следующие виды обработки:</p>
    <p>• Для поиска указанного шаблона в каждом из входных файлов, от F1 до FN, используется отдельный процесс, запускающий один и тот же исполняе мый модуль. Для каждого процесса программа создает командную строку такого вида: grep <emphasis>шаблон</emphasis> FK.</p>
    <p>• Полю hStdOut структуры STARTUPINFO нового процесса присваивается значение дескриптора временного файла, который определяется как наследуемый.</p>
    <p>• Программа организует ожидание завершения всех процессов поиска, используя для этого функцию WaitForMultipleObjects.</p>
    <p>• По завершении всех процессов поиска осуществляется поочередный вывод результатов (временных файлов). Вывод временного файла осуществляет процесс, выполняющий утилиту cat (программа 2.3).</p>
    <p>• Возможности функции WaitForMultipleObjects ограничиваются лишь максимально допустимым количеством дескрипторов, которое устанавливается значением MAXIMUM_WAIT_OBJECTS (64), поэтому она вызывается многократно.</p>
    <p>• Для определения успешности попытки нахождения данным процессом заданного шаблона программа использует код завершения процесса grep.</p>
    <p>Порядок обработки файлов программой 6.1 иллюстрируется на рис. 6.3. </p>
    <image l:href="#Any2FbImgLoader88"/>
    <p><strong>Рис. 6.З.</strong> Поиск текстового шаблона в файлах с использованием нескольких процессов</p>
    <empty-line/>
    <subtitle>Программа 6.1. grepMP: выполнение параллельного поиска текстового шаблона </subtitle>
    <p><code>/* Глава 6. grepMP. */</code></p>
    <p><code>/* Версия команды grep, использующая несколько процессов. */</code></p>
    <p><code>#include "EvryThng.h"</code></p>
    <empty-line/>
    <p><code>int _tmain(DWORD argc, LPTSTR argv[])</code></p>
    <p><code>/* Для выполнения поиска в каждом из файлов, указанных в командной строке, создается отдельный процесс. Каждому процессу предоставляется временный файл в текущем каталоге, в котором сохраняются результаты. */</code></p>
    <p><code>{</code></p>
    <p><code> HANDLE hTempFile;</code></p>
    <p><code> SECURITY_ATTRIBUTES StdOutSA = /* Атрибуты защиты для наследуемого дескриптора. */</code></p>
    <p><code>  {sizeof(SECURITY_ATTRIBUTES), NULL, TRUE};</code></p>
    <p><code> TCHAR CommandLine[MAX_PATH + 100];</code></p>
    <p><code> STARTUPINFO StartUpSearch, Startup;</code></p>
    <p><code> PROCESS_INFORMATION ProcessInfo;</code></p>
    <p><code> DWORD iProc, ExCode;</code></p>
    <p><code> HANDLE *hProc; /* Указатель на массив дескрипторов процессов. */</code></p>
    <p><code> typedef struct {TCHAR TempFile[MAX_PATH];} PROCFILE;</code></p>
    <p><code> PROCFILE *ProcFile; /* Указатель на массив имен временных файлов. */</code></p>
    <p><code> GetStartupInfo(&amp;StartUpSearch);</code></p>
    <p><code> GetStartupInfo(&amp;StartUp);</code></p>
    <p><code> ProcFile = malloc((argc – 2) * sizeof(PROCFILE));</code></p>
    <p><code> hProc = malloc((argc – 2) * sizeof(HANDLE));</code></p>
    <p><code> /* Создать для каждого файла отдельный процесс "grep". */</code></p>
    <p><code> for (iProc = 0; iProc &lt; argc – 2; iProc++) {</code></p>
    <p><code>  _stprintf(CommandLine, _T("%s%s %s"), _T("grep "), argv[1], argv[iProc + 2]);</code></p>
    <p><code>  GetTempFileName(_T("."), _T("gtm"), 0, ProcFile[iProc].TempFile); /* Для хранения результатов поиска.*/</code></p>
    <p><code>  hTempFile = /* Этот дескриптор является наследуемым */</code></p>
    <p><code>   CreateFile(ProcFile[iProc].TempFile, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, &amp;StdOutSA, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); </code></p>
    <p><code>  StartUpSearch.dwFlags = STARTF_USESTDHANDLES;</code></p>
    <p><code>  StartUpSearch.hStdOutput = hTempFile;</code></p>
    <p><code>  StartUpSearch.hStdError = hTempFile;</code></p>
    <p><code>  StartUpSearch.hStdInput = GetStdHandle(STD_INPUT_HANDLE);</code></p>
    <p><code>  /* Создать процесс для выполнения командной строки. */</code></p>
    <p><code>  CreateProcess(NULL, CommandLine, NULL, NULL, TRUE, 0, NULL, NULL, &amp;StartUpSearch, &amp;ProcessInfo);</code></p>
    <p><code>  /* Закрыть ненужные дескрипторы. */</code></p>
    <p><code>  CloseHandle(hTempFile);</code></p>
    <p><code>  CloseHandle(ProcessInfo.hThread);</code></p>
    <p><code>  hProc[iProc] = ProcessInfo.hProcess;</code></p>
    <p><code> }</code></p>
    <p><code> /* Выполнить все процессы и дождаться завершения каждого из них. */</code></p>
    <p><code> for (iProc = 0; iProc &lt; argc – 2; iProc += MAXIMUM_WAIT_OBJECTS) WaitForMultipleObjects( /* Разрешить использование достаточно большого количества процессов */</code></p>
    <p><code>  min(MAXIMUM_WAIT_OBJECTS, argc – 2 – iProc), &amp;hProc [iProc], TRUE, INFINITE);</code></p>
    <p><code> /* Переслать результирующие файлы на стандартный вывод с использованием утилиты cat */ </code></p>
    <p><code> for (iProc = 0; iProc &lt; argc – 2; iProc++) {</code></p>
    <p><code>  if (GetExitCodeProcess(hProc[iProc], &amp;ExCode) &amp;&amp; ExCode==0) {</code></p>
    <p><code>   /* Обнаружен шаблон — Вывести результаты. */</code></p>
    <p><code>   if (argc &gt; 3) _tprintf(_T("%s:\n"), argv [iProc + 2]);</code></p>
    <p><code>   fflush(stdout); /* Использование стандартного вывода несколькими процессами. */</code></p>
    <p><code>   _stprintf(CommandLine, _T("%s%s"), _Т("cat "), ProcFile[iProc].TempFile);</code></p>
    <p><code>   CreateProcess(NULL, CommandLine, NULL, NULL, TRUE, 0, NULL, NULL, &amp;StartUp, &amp;ProcessInfo);</code></p>
    <p><code>   WaitForSingleObject(ProcessInfo.hProcess, INFINITE);</code></p>
    <p><code>   CloseHandle(ProcessInfo.hProcess);</code></p>
    <p><code>   CloseHandle(ProcessInfo.hThread);</code></p>
    <p><code>  }</code></p>
    <p><code>  CloseHandle(hProc [iProc]);</code></p>
    <p><code>  DeleteFile(ProcFile[iProc].TempFile);</code></p>
    <p><code> }</code></p>
    <p><code> free(ProcFile);</code></p>
    <p><code> free(hProc);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code> </p>
   </section>
   <section>
    <title>
     <p>Процессы в многопроцессорной среде</p>
    </title>
    <p>В программе 6.1 процессы и их основные (и только эти) потоки выполняются практически полностью независимо друг от друга. Единственная зависимость между ними проявляется лишь в конце выполнения родительского процесса, поскольку он ожидает завершения выполнения каждого из них, чтобы перейти к последовательной обработке выходных файлов. Поэтому в SMP-системах планировщик Windows может и будет обеспечивать параллельное выполнение потоков процесса на нескольких независимых процессорах. В результате этого производительность, если оценивать ее по времени выполнения всей программы, значительно повышается, причем для этого с вашей стороны не требуется предпринимать никаких действий.</p>
    <p>Типичные результаты тестирования производительности приведены в приложении В. Ввиду выполнения программой ряда вспомогательных операций, а также необходимости последовательного вывода результатов, зависимость производительности от количества процессоров не является линейной. Тем не менее, улучшение производительности налицо, и это автоматически обеспечивается организацией программы, которая предусматривает передачу выполнения независимых вычислительных задач независимым процессам.</p>
    <p>Вместе с тем, существует возможность привязки процессов к определенным процессорам, что позволяет всегда быть уверенным в том, что другие процессоры остаются свободными и их можно использовать для решения каких-либо иных, критических задач. Это достигается за счет применения маски родства процессора (processor affinity mask) (см. главу 9) в объекте задачи. Объекты задач (job objects) описываются в одном из следующих разделов настоящей главы. </p>
    <p>Наконец, внутри процесса можно создавать независимые потоки, и для этих потоков также будет спланировано выполнение с использованием отдельных процессоров SMP для каждого из них. Связь между использованием потоков и показателями производительности обсуждается в главе 7.</p>
   </section>
   <section>
    <title>
     <p>Временные характеристики процесса</p>
    </title>
    <p>Воспользовавшись функцией GetProcessTimes, которая в Windows 9x отсутствует, можно получить различные временные характеристики процесса, а именно: истекшее время (elapsed time), время, затраченное ядром (kernel time), и пользовательское время (user time). </p>
    <cite>
     <p><code>BOOL GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)</code> </p>
    </cite>
    <p>Дескриптор процесса может ссылаться как на процесс, который продолжает выполняться, так и на процесс, выполнение которого прекратилось. Вычитая время создания процесса (creation time) из времени завершения процесса (exit time), мы получаем истекшее время, как показано в следующем примере. Тип данных FILETIME является 64-битовым; для вычисления указанной разности объедините переменную этого типа с переменной тип LARGE_INTEGER в структуру типа union. Ранее преобразование и отображение отметок времени файлов было продемонстрировано в главе 3 на примере программы lsw.</p>
    <p>Функция GetThreadTimes аналогична только что описанной, но требует указания дескриптора потока в качестве параметра. Управлению потоками посвящена глава 7.</p>
   </section>
   <section>
    <title>
     <p>Пример: временные характеристики процессов</p>
    </title>
    <section>
     <p>Наш следующий пример (программа 6.2) представляет собой команду timep (от <emphasis>time print —</emphasis> вывод временных параметров), аналогичную UNIX-команде time (поскольку команда time поддерживается процессором командной строки, мы должны использовать для нашей команды другое имя). Программа позволяет вывести все три временные характеристики, однако в Windows 9x будет доступно лишь истекшее время процесса.</p>
     <p>Одним из возможных применений этой команды является сравнительный анализ времени выполнения и эффективности различных версий функций копирования и преобразования файлов из ASCII в Unicode, реализованных в предыдущих главах.</p>
     <p>В данной программе используется функция Windows GetCommandLine, которая возвращает целую командную строку, а не отдельные строки из массива argv.</p>
     <p>Кроме того, программа использует вспомогательную функцию SkipArg, которая просматривает командную строку и устанавливает в ней указатель в позицию, непосредственно следующую за именем исполняемого файла. Листинг функции SkipArg приведен в приложении А.</p>
     <p>Для определения версии ОС в программе 6.2 используется функция GetVer-sionEx. В операционных системах Windows 9x и Windows СЕ доступным будет лишь истекшее время процесса. Программный код для этих систем представлен с той целью, чтобы показать, что в некоторых случаях работоспособность программ, по крайней мере — с частичным сохранением их функциональности, удается обеспечивать для целого диапазона различных версий Windows.</p>
     <subtitle>Программа 6.2. timep: временные характеристики процессов </subtitle>
     <p><code>/* Глава 6. timep. */</code></p>
     <p><code>#include "EvryThng.h"</code></p>
     <empty-line/>
     <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
     <p><code> STARTUPINFO Startup;</code></p>
     <p><code> PROCESS_INFORMATION ProcInfo;</code></p>
     <p><code> union { /* Эта структура используется для выполнения арифметических операций с участием временных параметров. */</code></p>
     <p><code>  LONGLONG li;</code></p>
     <p><code>  FILETIME ft;</code></p>
     <p><code> } CreateTime, ExitTime, ElapsedTime;</code></p>
     <p><code> FILETIME KernelTime, UserTime;</code></p>
     <p><code> SYSTEMTIME ElTiSys, KeTiSys, UsTiSys, StartTimeSys, ExitTimeSys;</code></p>
     <p><code> LPTSTR targv = SkipArg(GetCommandLine());</code></p>
     <p><code> OSVERSIONINFO OSVer;</code></p>
     <p><code> BOOL IsNT;</code></p>
     <p><code> HANDLE hProc;</code></p>
     <p><code> OSVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);</code></p>
     <p><code> GetVersionEx(&amp;OSVer);</code></p>
     <p><code> IsNT = (OSVer.dwPlatformId == VER_PLATFORM_WIN32_NT);</code></p>
     <p><code> /* NT (все версии) возвращает VER_PLATFORM_WIN32_NT. */</code></p>
     <p><code> GetStartupInfo(&amp;StartUp);</code></p>
     <p><code> GetSystemTime(&amp;StartTimeSys);</code></p>
     <p><code> /* Выполнить командную строку; дождаться завершения процесса. */</code></p>
     <p><code> CreateProcess (NULL, targv, NULL, NULL, TRUE, NORMAL_PRIORITY_CLASS, NULL, NULL, &amp;StartUp, &amp;ProcInfo);</code></p>
     <p><code> /* Убедиться в наличии ВСЕХ НЕОБХОДИМЫХ прав доступа к процессу. */</code></p>
     <p><code> DuplicateHandle(GetCurrentProcess(), ProcInfo.hProcess, GetCurrentProcess(), &amp;hProc, PROCESS_QUERY_INFORMATION | SYNCHRONIZE, FALSE, 0); </code></p>
     <p><code> WaitForSingleObject(hProc, INFINITE);</code></p>
     <p><code> GetSystemTime (&amp;ExitTimeSys);</code></p>
     <p><code> if (IsNT) { /* Windows NT. Для процесса вычисляется истекшее время, время выполнения в режиме ядра и время выполнения в пользовательском режиме. */ </code></p>
     <p><code>  GetProcessTimes(hProc, &amp;CreateTime.ft, &amp;ExitTime.ft, &amp;KernelTime, &amp;UserTime);</code></p>
     <p><code>  ElapsedTime.li = ExitTime.li – CreateTime.li;</code></p>
     <p><code>  FileTimeToSystemTime(&amp;ElapsedTime.ft, &amp;ElTiSys);</code></p>
     <p><code>  FileTimeToSystemTime(&amp;KernelTime, &amp;KeTiSys);</code></p>
     <p><code>  FileTimeToSystemTime(&amp;UserTime, &amp;UsTiSys);</code></p>
     <p><code>  _tprintf(_T("Истекшее время: %02d:%02d:%02d:%03d\n"), ElTiSys.wHour, ElTiSys.wMinute, ElTiSys.wSecond, ElTiSys.wMilliseconds);</code></p>
     <p><code>  _tprintf(_T("Пользовательское время: %02d:%02d:%02d:%03d\n"), UsTiSys.wHour, UsTiSys.wMinute, UsTiSys.wSecond, UsTiSys.wMilliseconds);</code></p>
     <p><code>  _tprintf(_T("Системное время: %02d:%02d:%02d:%03d\n"), KeTiSys.wHour, KeTiSys.wMinute, KeTiSys.wSecond, KeTiSys.wMilliseconds);</code></p>
     <p><code> } else {</code></p>
     <p><code>  /* Windows 9x и СЕ. Вычисляется лишь истекшее время. */</code></p>
     <p><code>  …</code></p>
     <p><code> }</code></p>
     <p><code> CloseHandle(ProcInfo.hThread);</code></p>
     <p><code> CloseHandle(ProcInfo.hProcess);</code></p>
     <p><code> CloseHandle(hProc);</code></p>
     <p><code> return 0;</code></p>
     <p><code>}</code></p>
    </section>
    <section>
     <title>
      <p>Использование команды timep</p>
     </title>
     <p>Теперь мы можем воспользоваться командой timep для анализа производительности различных вариантов программ копирования файлов и их преобразования из ASCII в Unicode, таких, например, как утилиты atou (программа 2.4) и sortMP (программа 5.5). Некоторые из полученных результатов и краткий их анализ представлены в приложении В.</p>
     <p>Обратите внимание, что для таких программ, как grepMP, тестирование предоставляет системное и пользовательское время только для родительских процессов. Объекты задач, описанные в конце настоящей главы, позволяют собрать информацию, касающуюся группы процессов. Как показано в приложении В, в случае SMP-систем производительность может повышаться за счет того, что отдельные процессы, вернее, потоки, выполняются на различных процессорах. Выигрыш в производительности возможен и в тех случаях, когда файлы располагаются на различных физических дисках.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Генерация управляющих событий консоли</p>
    </title>
    <p>Прерывание выполнения процесса извне может порождать проблемы, поскольку это лишает процесс возможности произвести необходимую завершающую обработку данных и очистку ресурсов. Воспользоваться SEH в данном случае нельзя ввиду того, что не существует общего метода, который позволял бы одному процессу возбуждать исключения в другом<a l:href="#n_25" type="note">[25]</a>. В то же время, с учетом некоторых ограничений, механизм управляющих событий консоли делает возможной передачу одним процессом другому управляющих сигналов, или событий, консоли. В программе 4.5 было продемонстрировано, как установить обработчик для перехвата сигналов и организовать генерацию исключений этим обработчиком. В указанном примере сигнал генерировался по приказу пользователя средствами пользовательского интерфейса.</p>
    <p>Таким образом, вполне можно добиться того, чтобы один процесс генерировал сигнал, соответствующий определенному событию, в другом указанном процессе или группе процессов. Вспомните флаг CREATE_NEW_PROCESS_GROUP функции CreateProcess. Если этот флаг установлен, то идентификатор нового процесса идентифицирует группу процессов и является корневым (root) процессом данной группы. Все новые процессы, создаваемые данным родительским процессом, будут автоматически попадать в эту группу до тех пор, пока при вызове функции CreateProcess не будет использован флаг CREATE_NEW_PROCESS_GROUP. Сгруппированные процессы аналогичны группам процессов в UNIX.</p>
    <p>Процесс может генерировать события CTRL_C_EVENT или CTRL_BREAK_EVENT в указанной группе процессов, идентифицируя ее с помощью идентификатора корневого процесса. Консоль целевых процессов должна совпадать с консолью процесса, генерирующего событие. В частности, вызывающий процесс не может быть создан с использованием собственной консоли (посредством флагов CREATE_NEW_CONSOLE или DETACHED_PROCESS). </p>
    <cite>
     <p><code>BOOL GenerateConsoleCtrlEvent(DWORD dwCtrlEvent, DWORD dwProcessGroup)</code> </p>
    </cite>
    <p>Тогда значением первого параметра должно быть либо CTRL_C_EVENT, либо CTRL_BREAK_EVENT. Второй параметр идентифицирует группу процессов. </p>
   </section>
   <section>
    <title>
     <p>Пример: простое управление задачами</p>
    </title>
    <section>
     <p>Оболочки UNIX предоставляют команды, позволяющие выполнять процессы в фоновом режиме и получать их текущее состояние. В этом разделе разрабатывается простой "процессор задач" ("job shell") с аналогичным набором команд, перечень которых приводится ниже.</p>
     <p>• jobbg — использует остальную часть командной строки в качестве командной строки для нового процесса, или <emphasis>задачи</emphasis> (job), однако возврат из команды осуществляется немедленно, без ожидания завершения нового процесса. По желанию пользователя новый процесс может либо получить собственную консоль, либо выполняться как <emphasis>отсоединенный</emphasis> (detached) процесс, то есть как процесс, связь с которым не поддерживается. Этот подход аналогичен запуску команд UNIX с указанием опции &amp; в конце команды.</p>
     <p>• jobs — выводит список текущих активных задач, снабжая каждую из задач порядковым номером и идентификатором процесса. Эта команда аналогична одноименной команде UNIX.</p>
     <p>• kill — прекращает выполнение задачи. В данной реализации используется функция TerminateProcess, которая, как ранее уже отмечалось, не обеспечивает корректного завершения задачи, сопровождающегося "уборкой мусора". Доступна также опция, позволяющая передавать управляющие сигналы консоли.</p>
     <p>Создать дополнительные команды, позволяющие приостанавливать существующие задачи или переводить их в фоновый режим, вам будет несложно.</p>
     <p>Поскольку выполнение оболочки, которая поддерживает список задач, может быть прекращено, она использует специфический для каждого пользователя разделяемый файл, в котором содержатся идентификаторы процессов, команды и другая необходимая информация. Благодаря этому перезапуск оболочки никак не отразится на списке задач. В одном из упражнений вам предлагается применять для хранения этой информации не временный файл, а реестр.</p>
     <p>Реализация программы наталкивается на определенные проблемы, связанные с параллельным выполнением задач. Некоторые процессы, запущенные из командных строк различных оболочек, могут одновременно пытаться управлять задачами. Чтобы справиться с этим, функции управления задачами используют блокировки (глава 3) в файле списка задач, в результате чего пользователь может активизировать управление задачами из различных оболочек или процессов.</p>
     <p>В полном варианте программы, находящемся на Web-сайте книги, содержится ряд дополнительных возможностей, не представленных в приводимых листингах, например, возможность получения входных данных для командной строки из файла. Программа JobDhell послужит основой для создания более общего "процессора служб" ("service processor") в главе 13 (программа 13.3). Службы NT являются фоновыми процессами, обычно — серверами, управление которыми осуществляется командами запуска, остановки, приостановки, а также другими командами. </p>
    </section>
    <section>
     <title>
      <p>Создание фоновых задач</p>
     </title>
     <p>Программа 6.3 реализует процессор задач, в котором пользователю предлагается ввести одну из трех возможных команд для их дальнейшего выполнения программой. В этой программе используется набор функций управления задачами, представленный программами 6.4, 6.5 и 6.6.</p>
     <subtitle>Программа 6.3. JobShell: создание, вывод списка и прекращение выполнения фоновых задач </subtitle>
     <p><code>/* Глава 6. */</code></p>
     <p><code>/* JobShell.с – команды управления задачами:</code></p>
     <p><code>   jobbg — Выполнить задачу в фоновом режиме.</code></p>
     <p><code>   jobs — Вывести список всех фоновых задач.</code></p>
     <p><code>   kill — Прекратить выполнение указанной задачи из семейства задач.</code></p>
     <p><code>   Существует опция, позволяющая генерировать управляющие сигналы консоли. */ </code></p>
     <p><code>#include "EvryThng.h" </code></p>
     <p><code>#include "JobMgt.h"</code></p>
     <empty-line/>
     <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
     <p><code> BOOL Exit = FALSE;</code></p>
     <p><code> TCHAR Command[MAX_COMMAND_LINE + 10], *pc;</code></p>
     <p><code> DWORD i, LocArgc; /* Локальный параметр argc. */</code></p>
     <p><code> TCHAR argstr[MAX_ARG][MAX_COMMAND_LINE];</code></p>
     <p><code> LPTSTR pArgs[MAX_ARG];</code></p>
     <p><code> for (i = 0; i &lt; MAX_ARG; i++) pArgs[i] = argstr[i];</code></p>
     <p><code> /* Вывести подсказку пользователю, считать команду и выполнить ее. */</code></p>
     <p><code> _tprintf(_Т("Управление задачами Windows\n"));</code></p>
     <p><code> while (!Exit) {</code></p>
     <p><code>  _tprintf(_T("%s"), _T("JM$"));</code></p>
     <p><code>  _fgetts(Command, MAX_COMMAND_LINE, stdin);</code></p>
     <p><code>  pc = strchr(Command, '\n');</code></p>
     <p><code>  *pc = '\0';</code></p>
     <p><code>  /* Выполнить синтаксический разбор входных данных с целью получения командной строки для новой задачи. */</code></p>
     <p><code>  GetArgs(Command, &amp;LocArgc, pArgs); /* См. Приложение А. */</code></p>
     <p><code>  CharLower(argstr[0]);</code></p>
     <p><code>  if(_tcscmp(argstr[0], _T("jobbg")) == 0) {</code></p>
     <p><code>   Jobbg(LocArgc, pArgs, Command);</code></p>
     <p><code>  } else if(_tcscmp(argstr[0], _T("jobs")) == 0) {</code></p>
     <p><code>   Jobs(LocArgc, pArgs, Command);</code></p>
     <p><code>  } else if(_tcscmp(argstr[0], _T("kill")) == 0) {</code></p>
     <p><code>   Kill(LocArgc, pArgs, Command);</code></p>
     <p><code>  } else if(_tcscmp(argstr[0], _T("quit")) == 0) {</code></p>
     <p><code>   Exit = TRUE;</code></p>
     <p><code>  } else _tprintf(_T("Такой команды не существует. Повторите ввод\n"));</code></p>
     <p><code> }</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>/* jobbg [параметры] командная строка [Параметры являются взаимоисключающими]</code></p>
     <p><code> –с: Предоставить консоль новому процессу.</code></p>
     <p><code> -d: Отсоединить новый процесс без предоставления ему консоли.</code></p>
     <p><code> Если параметры не заданы, процесс разделяет консоль с jobbg. */ </code></p>
     <p><code>int Jobbg(int argc, LPTSTR argv[], LPTSTR Command) {</code></p>
     <p><code> DWORD fCreate;</code></p>
     <p><code> LONG JobNo;</code></p>
     <p><code> BOOL Flags[2];</code></p>
     <p><code> STARTUPINFO Startup;</code></p>
     <p><code> PROCESS_INFORMATION ProcessInfo;</code></p>
     <p><code> LPTSTR targv = SkipArg(Command);</code></p>
     <p><code> GetStartupInfo(&amp;StartUp);</code></p>
     <p><code> Options(argc, argv, _T("cd"), &amp;Flags[0], &amp;Flags[1], NULL);</code></p>
     <p><code> /* Пропустить также поле параметра, если он присутствует. */</code></p>
     <p><code> if (argv[1][0] == '-') targv = SkipArg(targv);</code></p>
     <p><code> fCreate = Flags[0] ? CREATE_NEW_CONSOLE : Flags [1] ? DETACHED_PROCESS : 0;</code></p>
     <p><code> /* Создать приостановленную задачу/поток. Возобновить выполнение после ввода номера задачи. */</code></p>
     <p><code> CreateProcess(NULL, targv, NULL, NULL, TRUE, fCreate | CREATE_SUSPENDED | CREATE_NEW_PROCESS_GROUP, NULL, NULL, &amp;StartUp, &amp;ProcessInfo);</code></p>
     <p><code> /* Создать номер задачи и ввести ID и дескриптор процесса в "базу данных" задачи. */</code></p>
     <p><code> JobNo = GetJobNumber(&amp;ProcessInfo, targv); /* См. "JobMgt.h" */</code></p>
     <p><code> if (JobNo &gt;= 0) ResumeThread(ProcessInfo.hThread);</code></p>
     <p><code> else {</code></p>
     <p><code>  TerminateProcess(ProcessInfo.hProcess, 3);</code></p>
     <p><code>  CloseHandle(ProcessInfo.hProcess);</code></p>
     <p><code>  ReportError(_T("Ошибка: Не хватает места в списке задач."), 0, FALSE);</code></p>
     <p><code>  return 5;</code></p>
     <p><code> }</code></p>
     <p><code> CloseHandle(ProcessInfo.hThread);</code></p>
     <p><code> CloseHandle(ProcessInfo.hProcess);</code></p>
     <p><code> _tprintf(_T(" [%d] %d\n"), JobNo, ProcessInfo.dwProcessId);</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>/* jobs: вывод списка всех выполняющихся и остановленных задач. */ </code></p>
     <p><code>int Jobs(int argc, LPTSTR argv[], LPTSTR Command) {</code></p>
     <p><code> if (!DisplayJobs ()) return 1; /*См. описание функций управления задачами*/</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>/* kill [параметры] Номер задачи (JobNumber)</code></p>
     <p><code> –b: Генерировать Ctrl-Break.</code></p>
     <p><code> –с: Генерировать Ctrl-C.</code></p>
     <p><code> В противном случае прекратить выполнение процесса. */</code></p>
     <p><code>int Kill(int argc, LPTSTR argv[], LPTSTR Command) {</code></p>
     <p><code> DWORD ProcessId, JobNumber, iJobNo;</code></p>
     <p><code> HANDLE hProcess;</code></p>
     <p><code> BOOL CntrlC, CntrlB, Killed;</code></p>
     <p><code> iJobNo = Options(argc, argv, _T("bc"), &amp;CntrlB, &amp;CntrlC, NULL);</code></p>
     <p><code> /* Найти ID процесса, связанного с данной задачей. */</code></p>
     <p><code> JobNumber = _ttoi(argv [iJobNo]);</code></p>
     <p><code> ProcessId = FindProcessId(JobNumber); /* См. описание функций управления задачами. */</code></p>
     <p><code> hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcessId);</code></p>
     <p><code> if (hProcess == NULL) { /* ID процесса может не использоваться. */</code></p>
     <p><code>  ReportError(_T("Выполнение процесса уже прекращено.\n"), 0, FALSE);</code></p>
     <p><code>  return 2;</code></p>
     <p><code> }</code></p>
     <p><code> if (CntrlB) GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, ProcessId);</code></p>
     <p><code> else if (CntrlC) GenerateConsoleCtrlEvent(CTRL_C_EVENT, ProcessId);</code></p>
     <p><code> else TerminateProcess(hProcess, JM_EXIT_CODE);</code></p>
     <p><code> WaitForSingleObject(hProcess, 5000);</code></p>
     <p><code> CloseHandle(hProcess);</code></p>
     <p><code> _tprintf(T("Задача [%d] прекращена или приостановлена \n"), JobNumber);</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code> </p>
     <p>Обратите внимание на то, как команда jobbg создает процесс в приостановленном состоянии, а затем вызывает функцию управления задачами Get JobNumber (программа 6.4) для получения номера задачи, а также регистрации задачи и процесса, который с ней связан. Если в силу каких-либо причин задача не может быть зарегистрирована, выполнение данного процесса немедленно прекращается. Обычно' генерируется корректный номер задачи, после чего выполнение основного потока возобновляется, и он может продолжать выполнение.</p>
    </section>
    <section>
     <title>
      <p>Получение номера задачи</p>
     </title>
     <p>Следующие три программы представляют три отдельные функции управления задачами. Все эти функции включены в единый файл JobMgt.c, содержащий все исходные тексты.</p>
     <p>Первая из них, программа 6.4, представляет функцию Get JobNumber. Обратите внимание на использование блокирования файлов, а также обработчиков завершения, осуществляющих разблокирование файлов. Эта методика обеспечивает защиту от исключений и непреднамеренного обхода вызова функции разблокирования файлов. Переходы такого рода могут быть случайно вставлены в процессе сопровождения кода, даже если исходная программа корректна. Обратите также внимание на блокирование попыток записи за пределами конца файла в тех случаях, когда файл должен быть расширен за счет добавления новой записи.</p>
     <subtitle>Программа 6.4. JobMgt: создание информации о новой задаче </subtitle>
     <p><code>/* Вспомогательная функция управления задачами. */</code></p>
     <p><code>#include "EvryThng.h"</code></p>
     <p><code>#include "JobMgt.h" /* Листинг приведен в приложении А. */</code></p>
     <p><code>void GetJobMgtFileName (LPTSTR);</code></p>
     <empty-line/>
     <p><code>LONG GetJobNumber(PROCESS_INFORMATION *pProcessInfo, LPCTSTR Command) </code></p>
     <p><code>/* Создать номер задачи для нового процесса и ввести информацию о новом процессе в базу данных задачи. */ </code></p>
     <p><code>{</code></p>
     <p><code> HANDLE hJobData, hProcess;</code></p>
     <p><code> JM_JOB JobRecord;</code></p>
     <p><code> DWORD JobNumber = 0, nXfer, ExitCode, FsLow, FsHigh;</code></p>
     <p><code> TCHAR JobMgtFileName[MAX_PATH];</code></p>
     <p><code> OVERLAPPED RegionStart;</code></p>
     <p><code> if (!GetJobMgtFileName(JobMgtFileName)) return –1;</code></p>
     <p><code> /* Предоставление результата в виде строки "\tmp\UserName.JobMgt" */</code></p>
     <p><code> hJobData = CreateFile(JobMgtFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);</code></p>
     <p><code> if (hJobData == INVALID_HANDLE_VALUE) return –1;</code></p>
     <p><code> /* Блокировать весь файл плюс одну возможную запись для получения исключительного доступа. */</code></p>
     <p><code> RegionStart.Offset = 0;</code></p>
     <p><code> RegionStart.OffsetHigh = 0;</code></p>
     <p><code> RegionStart.hEvent = (HANDLE)0;</code></p>
     <p><code> FsLow = GetFileSize(hJobData, &amp;FsHigh);</code></p>
     <p><code> LockFileEx(hJobData, LOCKFILE_EXCLUSIVE_LOCK, 0, FsLow + SJM_JOB, 0, &amp;RegionStart);</code></p>
     <p><code> __try {</code></p>
     <p><code>  /* Чтение записи для нахождения пустого сегмента. */</code></p>
     <p><code>  while(ReadFile(hJobData, &amp;JobRecord, SJM_JOB, &amp;nXfer, NULL) &amp;&amp; (nXfer &gt; 0)) {</code></p>
     <p><code>   if (JobRecord.ProcessId == 0) break;</code></p>
     <p><code>   hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, JobRecord.ProcessId);</code></p>
     <p><code>   if (hProcess == NULL) break;</code></p>
     <p><code>   if (GetExitCodeProcess(hProcess, &amp;ExitCode) &amp;&amp; (ExitCode != STILL_ACTIVE)) break;</code></p>
     <p><code>   JobNumber++;</code></p>
     <p><code>  } </code></p>
     <p><code>  /* Либо найден пустой сегмент, либо мы находимся в конце файла и должны создать новый сегмент. */</code></p>
     <p><code>  if (nXfer != 0) /* Не конец файла. Резервировать. */</code></p>
     <p><code>   SetFilePointer(hJobData, –(LONG)SJM_JOB, NULL, FILE_CURRENT);</code></p>
     <p><code>  JobRecord.ProcessId = pProcessInfo-&gt;dwProcessId;</code></p>
     <p><code>  _tcsnccpy(JobRecord.CommandLine, Command, MAX_PATH);</code></p>
     <p><code>  WriteFile(hJobData, &amp;JobRecord, SJM_JOB, &amp;nXfer, NULL);</code></p>
     <p><code> } /* Конец try-блока. */</code></p>
     <p><code> __finally {</code></p>
     <p><code>  UnlockFileEx(hJobData, 0, FsLow + SJM_JOB, 0, &amp;RegionStart);</code></p>
     <p><code>  CloseHandle(hJobData);</code></p>
     <p><code> }</code></p>
     <p><code> return JobNumber + 1; </code></p>
     <p><code>}</code></p>
    </section>
    <section>
     <title>
      <p>Вывод списка фоновых задач</p>
     </title>
     <p>Программа 6.5 реализует функцию управления задачами DisplayJobs.</p>
     <subtitle>Программа 6.5. JobMgt: отображение списка активных задач </subtitle>
     <p><code>BOOL DisplayJobs(void)</code></p>
     <p><code>/* Просмотреть файл базы данных, сообщить статус задачи. */</code></p>
     <p><code>{</code></p>
     <p><code> HANDLE hJobData, hProcess;</code></p>
     <p><code> JM_JOB JobRecord;</code></p>
     <p><code> DWORD JobNumber = 0, nXfer, ExitCode, FsLow, FsHigh;</code></p>
     <p><code> TCHAR JobMgtFileName[MAX_PATH];</code></p>
     <p><code> OVERLAPPED RegionStart;</code></p>
     <p><code> GetJobMgtFileName(JobMgtFileName);</code></p>
     <p><code> hJobData = CreateFile(JobMgtFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);</code></p>
     <p><code> RegionStart.Offset = 0;</code></p>
     <p><code> RegionStart.OffsetHigh = 0;</code></p>
     <p><code> RegionStart.hEvent = (HANDLE)0;</code></p>
     <p><code> FsLow = GetFileSize(hJobData, &amp;FsHigh);</code></p>
     <p><code> LockFileEx(hJobData, LOCKFILE_EXCLUSIVE_LOCK, 0, FsLow, FsHigh, &amp;RegionStart);</code></p>
     <p><code> __try {</code></p>
     <p><code>  while(ReadFile(hJobData, &amp;JobRecord, SJM_JOB, &amp;nXfer, NULL) &amp;&amp; (nXfer &gt; 0)) {</code></p>
     <p><code>   JobNumber++;</code></p>
     <p><code>   if (JobRecord.ProcessId == 0) continue; </code></p>
     <p><code>   hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, JobRecord.ProcessId);</code></p>
     <p><code>   if (hProcess != NULL) GetExitCodeProcess(hProcess, &amp;ExitCode);</code></p>
     <p><code>   _tprintf(_T(" [%d] "), JobNumber);</code></p>
     <p><code>   if (hProcess == NULL) _tprintf(_T(" Готово"));</code></p>
     <p><code>   else if (ExitCode != STILL_ACTIVE) _tprintf(_T("+ Готово"));</code></p>
     <p><code>   else _tprintf(_T(" "));</code></p>
     <p><code>   _tprintf(_T(" %s\n"), JobRecord.CommandLine);</code></p>
     <p><code>   /* Удалить процессы, которые в системе уже не присутствуют. */</code></p>
     <p><code>   if (hProcess == NULL) {</code></p>
     <p><code>    /* Зарезервировать одну запись. */</code></p>
     <p><code>    SetFilePointer(hJobData, –(LONG)nXfer, NULL, FILE_CURRENT);</code></p>
     <p><code>    JobRecord.ProcessId = 0;</code></p>
     <p><code>    WriteFile(hJobData, &amp;JobRecord, SJM_JOB, &amp;nXfer, NULL);</code></p>
     <p><code>   }</code></p>
     <p><code>  } /* Конец цикла while. */</code></p>
     <p><code> } /* Конец __try-блока. */</code></p>
     <p><code> __finally {</code></p>
     <p><code>  UnlockFileEx(hJobData, 0, FsLow, FsHigh, &amp;RegionStart);</code></p>
     <p><code>  CloseHandle(hJobData);</code></p>
     <p><code> }</code></p>
     <p><code> return TRUE; </code></p>
     <p><code>}</code></p>
    </section>
    <section>
     <title>
      <p>Поиск задачи в файле списка задач</p>
     </title>
     <p>Программа 6.6 представляет последнюю функцию управления задачами, FindProcessID, которая получает идентификатор процесса, соответствующего задаче с указанным номером. В свою очередь, идентификатор процесса может использоваться вызывающей программой для получения дескриптора и другой информации о состоянии процесса.</p>
     <subtitle>Программа 6.6. JobMgt: получение идентификатора процесса по номеру задачи </subtitle>
     <p><code>DWORD FindProcessId(DWORD JobNumber)</code></p>
     <p><code>/* Получить ID процесса для задачи с указанным номером. */ </code></p>
     <p><code>{</code></p>
     <p><code> HANDLE hJobData;</code></p>
     <p><code> JM_JOB JobRecord;</code></p>
     <p><code> DWORD nXfer;</code></p>
     <p><code> TCHAR JobMgtFileName[MAX_PATH];</code></p>
     <p><code> OVERLAPPED RegionStart;</code></p>
     <p><code> /* Открыть файл управления задачами. */</code></p>
     <p><code> GetJobMgtFileName(JobMgtFileName);</code></p>
     <p><code> hJobData = CreateFile(JobMgtFileName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);</code></p>
     <p><code> if (hJobData == INVALID_HANDLE_VALUE) return 0;</code></p>
     <p><code> /* Перейти к позиции записи, соответствующей указанному номеру задачи.</code></p>
     <p><code>  * В полной версии программы обеспечивается принадлежность номера задачи (JobNumber) допустимому диапазону значений. */</code></p>
     <p><code> SetFilePointer(hJobData, SJM_JOB * (JobNumber – 1), NULL, FILE_BEGIN);</code></p>
     <p><code> /* Блокировка и чтение записи. */</code></p>
     <p><code> RegionStart.Offset = SJM_JOB * (JobNumber – 1);</code></p>
     <p><code> RegionStart.OffsetHigh =0; /* Предполагаем, что файл "короткий". */</code></p>
     <p><code> RegionStart.hEvent = (HANDLE)0;</code></p>
     <p><code> LockFileEx(hJobData, 0, 0, SJM_JOB,0, &amp;RegionStart);</code></p>
     <p><code> ReadFile(hJobData, &amp;JobRecord, SJM_JOB, &amp;nXfer, NULL);</code></p>
     <p><code> UnlockFileEx(hJobData, 0, SJM_JOB, 0, &amp;RegionStart);</code></p>
     <p><code> CloseHandle(hJobData);</code></p>
     <p><code> return JobRecord.ProcessId; </code></p>
     <p><code>}</code> </p>
    </section>
   </section>
   <section>
    <title>
     <p>Объекты задач</p>
    </title>
    <p>Процессы можно объединять в объекты задач (job objects), что позволяет управлять процессами как группой, устанавливать лимиты ресурсов для всех процессов, входящих в объект задачи, и вести учетную информацию. Объекты задач были впервые введены в Windows 2000 и теперь поддерживаются во всех системах NT5.</p>
    <p>Первым шагом является создание пустого объекта задачи с помощью функции CreateObject, которая принимает два аргумента, имя и атрибуты защиты, и возвращает дескриптор объекта задачи. Существует также функция OpenJobObject, которую можно применять к именованным объектам задач. Для уничтожения объектов используется функция CloseHandle.</p>
    <p>Функция AssignProcessToJobObject просто добавляет процесс с указанным дескриптором в объект задачи; она принимает только два параметра. Процесс может принадлежать только одной задаче, поэтому в тех случаях, когда процесс, связанный с указанным дескриптором, уже является элементом какого-либо задания, функция AssignProcessToJobObject завершается с ошибкой. Добавляемый в задачу процесс наследует значения всех ограничений, связанных с задачей, и добавляет в задачу свою учетную информацию, например использованное процессорное время.</p>
    <p>По умолчанию новый дочерний процесс, созданный функцией CreateProcess, также принадлежит задаче, если только в аргументе dwCreationFlags при вызове функции CreateProcess не был задан флаг CREATE_BREAKWAY_FROM_JOB. В предусмотренном по умолчанию случае попытки назначения дочернего процесса задаче при помощи функции AssignProcessToJobObject приводят к ее сбойному завершению. </p>
    <p>Наконец, для установления управляющих лимитов процессов, входящих в задачу, используется функция SetInformationJobObject. </p>
    <cite>
     <p><code>BOOL SetInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength)</code></p>
    </cite>
    <p>• hJob — дескриптор существующего объекта задачи.</p>
    <p>• JobObjectInformationClass — указывает информационный класс устанавливаемых ограничений. Всего существует пять возможных значений; одним из них является значение JobObjectBasicLimitInformation, используемое для указания такой информации, как ограничения общего времени и времени, приходящегося на один процесс, ограничения размеров рабочего набора (working set)<a l:href="#n_26" type="note">[26]</a>, ограничения на количество активных процессов, приоритет и родство процессоров (в SMP-системах родственными называются процессоры, которые могут использоваться потоками в процессах задач).</p>
    <p>• lpJobObjectInformation — указывает на фактическую информацию, необходимую для предыдущего параметра. Для каждого информационного класса существует своя структура.</p>
    <p>• JOBOBJECT_BASIC_ACCOUNTING_INFORMATION — позволяет получить суммарные временные характеристики (пользовательское, системное и истекшее время) процессов, входящих в задачу.</p>
    <p>• Значением последнего параметра является размер предыдущей структуры.</p>
    <p>Функция QueryJobInformationObject позволяет получить значения текущих ограничений. Другие информационные классы устанавливают ограничения в отношении пользовательского интерфейса, портов завершения ввода/вывода (см. главу 14), атрибутов защиты, а также завершения задачи.</p>
   </section>
   <section>
    <title>
     <p>Резюме</p>
    </title>
    <section>
     <p>Windows предоставляет простой механизм управления процессами и синхронизацией их выполнения. Приведенные примеры продемонстрировали способы управления параллельным выполнением нескольких процессов, а также получения информации о временных характеристиках каждого процесса. Отношения "предок-потомок" между процессами в Windows не поддерживаются, так что в необходимых случаях управление этой информацией возлагается на программиста.</p>
    </section>
    <section>
     <title>
      <p>В следующих главах</p>
     </title>
     <p>В следующей главе описываются потоки, являющиеся независимыми единицами выполнения внутри процесса. В некоторых отношениях управление потоками аналогично управлению процессами; все, что связано с кодами завершения, прекращением выполнения и ожиданием завершения, применимо и к потокам. Чтобы продемонстрировать эту аналогию, самый первый из рассматриваемых в главе 7 примеров является переделанным вариантом программы grepMP (программа 6.1), который приспособлен для работы с потоками.</p>
     <p>Глава 8 ознакомит вас с методами синхронизации, которые могут быть использованы для координации выполнения потоков, принадлежащих одному и тому же или различным процессам.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Упражнения</p>
    </title>
    <p>6.1. Расширьте возможности программы 6.1 (grepMP) таким образом, чтобы она принимала также параметры командной строки, а не только текстовый шаблон.</p>
    <p>6.2. Вместо того чтобы передавать дочернему процессу имя временного файла, как это делается в программе 6.1, преобразуйте наследуемый дескриптор файла к типу DWORD (для типа HANDLE требуется 4 байта), а затем в строку символов. Передайте эту строку дочернему процессу в командной строке. В свою очередь, дочерний процесс должен осуществить обратное преобразование строки символов в значение дескриптора файла, который будет использован для вывода. Эту методику иллюстрируют программы catHA.с и grepHA.с, доступные на Web-сайте книги.</p>
    <p>6.3. Программа 6.1 ожидает завершения всех процессов и лишь после этого выводит результаты. При этом возможность определения того, в каком именно порядке завершились процессы внутри программы, отсутствует. Модифицируйте программу таким образом, чтобы она определяла очередность завершения процессов. <emphasis>Подсказка.</emphasis> Измените вызов функции WaitForMultipleObjects таким образом, чтобы возврат из нее осуществлялся после завершения каждого отдельного процесса. Другой возможностью является сортировка времени завершения процессов.</p>
    <p>6.4. В программе 6.1 временные файлы должны удаляться явным образом. Возможно ли использование флага FILE_FLAG_DELETE_ON_CLOSE при создании временных файлов таким образом, чтобы избавиться от необходимости удаления указанных файлов?</p>
    <p>6.5. Определите, заметны ли какие-либо преимущества программы grepMP в отношении производительности (по сравнению с простой последовательной обработкой) в случае SMP-систем, если такая возможность у вас имеется, или при размещении файлов на отдельных или сетевых дисках. Частичные результаты соответствующих тестов приведены в приложении В. </p>
    <p>6.6. Можете ли вы предложить способ, возможно, связанный с использованием объектов задач, для определения времени, затраченного на выполнение операций в пользовательском режиме и в режиме ядра? Использование объектов задач может потребовать внесения изменений в программу grepMP.</p>
    <p>6.7. Улучшите функцию grepMP (программа 6.5) таким образом, чтобы она сообщала код завершения для каждой завершенной задачи. Кроме того, организуйте вывод временных характеристик (истекшего времени, времени работы в режиме ядра и времени работы в пользовательском режиме) суммарно для всех процессов.</p>
    <p>6.8. У функций управления задачами есть один трудно устранимый недостаток. Предположим, что задача уничтожена и что главная программа повторно использует идентификатор процесса данного задания еще до того, как этот идентификатор будет удален из файла управления задачами. Вместе с тем, ранее этот идентификатор мог быть использован функцией OpenProcess для создания дескриптора какого-либо процесса, хотя теперь этот же идентификатор ссылается на совершенно другой процесс. Чтобы устранить возможность появления проблем подобного рода, требуется создать вспомогательный процесс, в котором будут храниться копии дескрипторов каждого созданного процесса, что позволит избежать повторного использования идентификаторов. Другая возможная методика заключается в сохранении времени запуска процесса в файле управления задачами. Это время должно совпадать со временем запуска процесса, полученного с использованием идентификатора. <emphasis>Примечание.</emphasis> Идентификаторы процессов быстро исчерпываются, и поэтому вероятность их повторного использования очень велика. В UNIX для получения идентификаторов новых процессов применяются последовательно увеличиваемые значения 32-битового счетчика, так что идентификаторы могут повторяться только после исчерпания этих значений, что происходит очень редко. В отличие от этого, в программах Windows никогда нельзя полагаться на то, что идентификатор процесса не будет повторно использован.</p>
    <p>6.9. Измените программу JobShell таким образом, чтобы информация сохранялась в реестре, а не во временном файле. </p>
    <p>6.10. Измените программу JobShell таким образом, чтобы процессы связывались с объектом задачи. Наложите временные и другого рода ограничения на объекты задач, предоставив пользователю возможность ввода числовых значений некоторых из этих ограничений.</p>
    <p>6.11. Улучшите программу JobShell таким образом, чтобы команда jobs обеспечивала подсчет числа дескрипторов, используемых каждой из задач. <emphasis>Подсказка.</emphasis> Воспользуйтесь функцией GetProcessHandleCount, для которой требуется NT 5.1. </p>
    <p>6.12. Создайте проект Version (находится на Web-сайте), использующий программу verison.c. Попытайтесь произвести пробные запуски этой программы под управлением как можно большего числа различных версий Windows, к которым у вас имеется доступ, включая Windows 9x и NT 4.0, если это возможно. Каковы старшие и младшие номера версий для этих систем, полученные вами, и какую дополнительную информацию о версиях вам удалось получить?</p>
   </section>
  </section>
  <section>
   <title>
    <p>ГЛАВА 7</p>
    <p>Потоки и планирование выполнения</p>
   </title>
   <section>
    <p>Основной единицей выполнения в Windows является поток, и одновременно несколько потоков могут выполняться в рамках одного процесса, разделяя его адресное пространство и другие ресурсы. В главе 6 процессы ограничивались только одним потоком, однако существует много ситуаций, в которых возможность использования более одного потока была бы весьма желательной. Настоящая глава посвящена описанию потоков и иллюстрации областей их применения. Глава 8 продолжает эту тему описанием объектов синхронизации и анализом как положительных, так и отрицательных аспектов использования потоков, в то время как в главе 9 исследуется проблема повышения производительности и компромиссные способы ее решения. В главе 10 описываются методы и модели программирования объектов синхронизации, позволяющие значительно упростить проектирование и разработку надежных многопоточных программ. Эти методы применяются далее во всей оставшейся части книги.</p>
    <p>Завершается настоящая глава кратким обсуждением облегченных потоков, посредством которых можно создавать отдельные задачи в контексте потоков. Ввиду того, что облегченные потоки используются довольно редко, можно предположить, что многие читатели предпочтут пропустить этот материал при первом чтении.</p>
   </section>
   <section>
    <title>
     <p>Обзор потоков</p>
    </title>
    <section>
     <p><emphasis>Поток</emphasis> (thread) — это независимая единица выполнения в контексте процесса. Программист, разрабатывающий многопоточную программу, должен организовать выполнение потоков таким образом, чтобы это позволило упростить программу и воспользоваться предоставляемыми самим хост-компьютером возможностями распараллеливания задач.</p>
     <p>При традиционном подходе программы выполняются в виде единственного потока. Несмотря на возможность организации параллельного выполнения нескольких процессов, что было продемонстрировано на ряде примеров в главе 6, и даже их взаимодействия между собой посредством таких механизмов, как разделение памяти или каналы (глава 11), однопоточные процессы имеют ряд недостатков.</p>
     <p>• Переключение между выполняющимися процессами потребляет заметную долю временных и других ресурсов ОС, а в случаях, аналогичных многопроцессному поиску (grepMP, программа 6.1), все процессы заняты выполнением одной и той же программы. Организация параллельной обработки файла с помощью потоков в контексте единственного процесса позволяет снизить общие накладные расходы системы.</p>
     <p>• Не считая случаев разделения памяти, между процессами существует лишь слабая взаимосвязь, а организация разделения ресурсов, например, открытых файлов, вызывает затруднения.</p>
     <p>• С использованием только однопоточных процессов трудно организовать простое и эффективное управление несколькими параллельно выполняющимися задачами, взаимодействующими между собой, в таких, например, случаях, как ожидание и обработка пользовательского ввода, ожидание ввода из файла или сети и выполнение вычислений.</p>
     <p>• Тесно связанные с выполнением операций ввода/вывода программы, подобные рассмотренной в главе 2 программе преобразования файлов из ASCII в Unicode (atou, программа 2.4), вынуждены ограничиваться простой моделью "чтение-изменение-запись". При обработке последовательностей файлов гораздо эффективнее инициализировать выполнение как можно большего числа операций чтения. Windows NT предлагает дополнительные возможности перекрывающегося асинхронного ввода/вывода (глава 14), однако потоки позволяют добиться того же эффекта с меньшими усилиями.</p>
     <p>• В SMP-системах планировщик Windows распределяет выполнение отдельных потоков между различными процессорами, что во многих случаях приводит к повышению производительности.</p>
     <p>В этой главе обсуждаются потоки и способы управления ими. Использование потоков рассматривается на примере задач параллельного поиска и многопоточной сортировки содержимого файлов. Эти две задачи позволяют сопоставить применение потоков в операциях ввода/вывода и в операциях, связанных с выполнением интенсивных вычислений. Кроме того, в этой главе представлен общий обзор планирования выполнения процессов и потоков в Windows.</p>
    </section>
    <section>
     <title>
      <p>Перспективы и проблемы</p>
     </title>
     <p>Согласно принятой в этой и последующих главах точке зрения использование потоков не только позволяет упростить проектирование и реализацию некоторых программ, но и (при условии соблюдения нескольких элементарных правил и следования определенным моделям программирования) обеспечивает повышение производительности и надежности программ, а также делает более понятной их структуру и облегчает их обслуживание. Функции управления потоками весьма напоминают функции управления процессами, так что, например, наряду с функцией GetProcessExitCode существует также функция GetThreadExitCode.</p>
     <p>Указанная точка зрения не является общепринятой. Многие авторы и разработчики программного обеспечения обращают внимание на всевозможные риски и проблемы, которые возникают в случае использования потоков, и отдают предпочтение использованию нескольких процессов, когда требуется параллелизм операций. К числу проблем упомянутого рода относятся следующие:</p>
     <p>• Поскольку потоки разделяют общую память и другие ресурсы, принадлежащие одному процессу, существует вероятность того, что один поток может случайно изменить данные, относящиеся к другому потоку.</p>
     <p>• При определенных обстоятельствах вместо улучшения производительности может наблюдаться ее резкое ухудшение.</p>
     <p>• Разделение потоками общей памяти и других ресурсов в контексте одного процесса может стать причиной нарушения условий состязаний между процессами и вызывать блокирование некоторых из них.</p>
     <p>Некоторых проблем, с которыми действительно приходится сталкиваться, можно избежать, тщательно проектируя и программируя соответствующие задачи, тогда как природа других проблем обусловлена самим параллелизмом, независимо от того, реализуется он путем разбиения процессов на потоки, использованием нескольких процессов или применением специальных методов, например, методов асинхронного ввода/вывода, предоставляемых Windows.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Основные сведения о потоках</p>
    </title>
    <p>В предыдущей главе на рис. 6.1 было показано, каким образом обеспечивается существование потоков в среде процесса. Использование потоков на примере многопоточного сервера, способного обрабатывать запросы одновременно нескольких клиентов, иллюстрирует рис. 7.1; каждому клиенту отведен поток. Эта модель будет реализована в главе 11.</p>
    <p>Потоки, принадлежащие одному процессу, разделяют общие данные и код, поэтому очень важно, чтобы каждый поток имел также собственную область памяти, относящуюся только к нему. В Windows удовлетворение этого требования обеспечивается несколькими способами.</p>
    <p>• У каждого потока имеется собственный стек, который она использует при вызове функций и обработке некоторых данных.</p>
    <p>• При создании потока вызывающий процесс может передать ему аргумент (Arg на рис. 7.1), который обычно является указателем. На практике этот аргумент помещается в стек потока.</p>
    <p>• Каждый поток может распределять индексы собственных локальных областей хранения (Thread Local Storage, TLS), а также считывать и устанавливать значения TLS. TLS, описанные далее, предоставляют в распоряжение потоков небольшие массивы данных, и каждый из потоков может обращаться к собственной TLS. Одним из преимуществ TLS является то, что они обеспечивают защиту данных, принадлежащих одному потоку, от воздействия со стороны других потоков.</p>
    <image l:href="#Any2FbImgLoader94"/>
    <p><strong>Рис. 7.1.</strong> Потоки в среде сервера</p>
    <empty-line/>
    <p>Аргумент потока и TLS могут использоваться для указания произвольной структуры данных. Применительно к представленному на рис. 7.1 примеру сервера эта структура может содержать текущий запрос и отклик потока на этот запрос, а также предоставлять рабочую память для других целей.</p>
    <p>В случае SMP-систем Windows обеспечивает параллельное выполнение различных потоков, в том числе и принадлежащих одному и тому же процессу, на разных процессорах. Правильное использование этой возможности позволяет повысить производительность, однако, как будет показано в двух следующих главах, в результате непродуманных действий без заранее определенной стратегии использования нескольких процессоров производительность SMP-систем может даже ухудшиться по сравнению с однопроцессорными системами.</p>
   </section>
   <section>
    <title>
     <p>Управление потоками</p>
    </title>
    <section>
     <p>Вероятно, вы не будете удивлены, узнав о том, что у потоков, как и у любого другого объекта Windows, имеются дескрипторы и что для создания потоков, выполняющихся в адресном пространстве вызывающего процесса, предусмотрен системный вызов CreateThread. Как и в случае процессов, мы будем говорить иногда о "родительских" и "дочерних" потоках, хотя ОС не делает в этом отношении никаких различий. Системный вызов CreateThread предъявляет ряд специфических требований:</p>
     <p>• Укажите начальный адрес потока в коде процесса.</p>
     <p>• Укажите размер стека, и необходимое пространство стека будет выделено из виртуального адресного пространства процесса. Размер стека по умолчанию равен размеру стека основного потока (обычно 1 Мбайт). Первоначально для стека отводится одна страница (см. главу 5). Новые страницы стека выделяются по мере надобности до тех пор, пока стек не достигнет своего максимального размера, поэтому не сможет больше расти.</p>
     <p>• Задайте указатель на аргумент, передаваемый потоку. Этот аргумент может быть чем угодно и должен интерпретироваться самим потоком.</p>
     <p>• Функция возвращает значение идентификатора (ID) и дескриптор потока.</p>
     <p>В случае ошибки возвращаемое значение равно NULL.</p>
     <cite>
      <p><code>HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpsa, DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddr, LPVOID lpThreadParm, DWORD dwCreationFlags, LPDWORD lpThreadId)</code> </p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>lpsa — указатель на уже хорошо знакомую структуру атрибутов защиты.</p>
     <p>dwStackSize — размер стека нового потока в байтах. Значению 0 этого параметра соответствует размер стека по умолчанию, равный размеру стека основного потока.</p>
     <p>lpStartAddr — указатель на функцию (принадлежащую контексту процесса), которая должна выполняться. Эта функция принимает единственный аргумент в виде указателя и возвращает 32-битовый код завершения. Этот аргумент может интерпретироваться потоком либо как переменная типа DWORD, либо как указатель. Функция потока (ThreadFunc) имеет следующую сигнатуру: </p>
     <cite>
      <p><code>DWORD WINAPI <emphasis>ThreadFunc</emphasis>(LPVOID)</code> </p>
     </cite>
     <p>lpThreadParm — указатель, передаваемый потоку в качестве аргумента, который обычно интерпретируется потоком как указатель на структуру аргумента.</p>
     <p>dwCreationFlags — если значение этого параметра установлено равным 0, то поток запускается сразу же после вызова функции CreateThread. Установка значения CREATE_SUSPENDED приведет к запуску потока в приостановленном состоянии, из которого поток может быть переведен в состояние готовности путем вызова функции ResumeThread.</p>
     <p>lpThreadId — указатель на переменную типа DWORD, которая получает идентификатор нового потока; в Windows 9x и Windows NT 3.51 значение NULL для этого параметра устанавливать нельзя.</p>
     <p>Любой поток процесса может сама завершить свое выполнение, вызвав функцию ExitThread, однако более обычным способом самостоятельного завершения потока является возврата из функции потока с использованием кода завершения в качестве возвращаемого значения. По завершении выполнения потока память, занимаемая ее стеком, освобождается. В случае если поток был создан в библиотеке DLL, будет вызвана соответствующая точка входа DllMain (глава 4) с указанием флага DLL_THREAD_DETACH в качестве "причины" этого вызова. </p>
     <cite>
      <p><code>VOID ExitThread(DWORD dwExitCode)</code> </p>
     </cite>
     <p>Когда завершается выполнение последнего потока, завершается и выполнение самого процесса.</p>
     <p>Выполнение потока также может быть завершено другим потоком с помощью функции TerminateThread, однако освобождения ресурсов потока при этом не происходит, обработчики завершения не выполняются и уведомления библиотекам DLL не посылаются. Лучше всего, когда поток сам завершает свое выполнение; применять для этого функцию TerminateThread крайне нежелательно. Функции TerminateThread присущи те же недостатки, что и функции TerminateProcess.</p>
     <p>Поток, выполнение которого было завершено (напомним, что обычно поток должен самостоятельно завершать свое выполнение), продолжает существовать до тех пор, пока посредством функции CloseHandle не будет закрыт ее последний дескриптор. Любой другой поток, возможно и такой, который ожидает завершения другого потока, может получить код завершения потока. </p>
     <cite>
      <p><code>BOOL GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode)</code> </p>
     </cite>
     <p>lpExitCode — будет содержать код завершения потока, указывающий на его состояние. Если поток еще не завершен, значение этой переменной будет равно STILL_ACTIVE.</p>
    </section>
    <section>
     <title>
      <p>Идентификация потоков</p>
     </title>
     <p>Функции, используемые для получения идентификаторов (ID) и дескрипторов потоков, напоминают те, которые используются для аналогичных целей в случае процессов. </p>
     <p>• GetCurrentThread — возвращает ненаследуемый псевдодескриптор вызывающего потока.</p>
     <p>• GetCurrentThreadId — позволяет получить идентификатор потока, а не его дескриптор.</p>
     <p>• GetThreadId — позволяет получить идентификатор потока, если известен его дескриптор; эта функция требует использования Windows Server 2003.</p>
     <p>• OpenThread — создает дескриптор потока по известному идентификатору.</p>
     <p>В программе JobShell (программа 6.3) нам очень пригодилась функция OpenProcess, и функция OpenThread может применяться для аналогичных целей.</p>
    </section>
    <section>
     <title>
      <p>Дополнительные функции управления потоками</p>
     </title>
     <p>Несмотря на то что функций управления потоками, которые мы выше обсуждали, вполне достаточно для большинства случаев, в том числе и для примеров, приведенных в этой книге, в Windows XP и Windows Server 2003 были введены две дополнительные функции. Их краткие описания представлены ниже.</p>
     <p>1. Функция GetProcessIdOfThread, требующая использования Windows Server 2003, позволяет получать идентификатор процесса, которому принадлежит поток, по известному дескриптору потока. Вы могли бы задействовать эту функцию в программах, предназначенных для управления потоками, принадлежащими другим процессам, или взаимодействия с такими потоками. Если необходимо получить дескриптор процесса, применяйте для этого функцию OpenProcess.</p>
     <p>2. Функция GetThreadIOPendingFlag позволяет определить, имеются ли у потока, на который указывает дескриптор, необслуженные запросы ввода/вывода. Например, поток мог быть заблокирован во время выполнения операции ReadFile. В качестве результата возвращается состояние потока во время выполнения данной функции; фактическое состояние может в любой момент измениться, если целевой поток завершает или начинает выполнение операции. Эта функция требует использования NT 5.1 и поэтому доступна лишь в Windows XP или Windows Server 2003.</p>
    </section>
    <section>
     <title>
      <p>Приостановка и возобновление выполнения потока</p>
     </title>
     <p>Для каждого потока поддерживается <emphasis>счетчик приостановок</emphasis> (suspend count), и выполнение потока может быть продолжено лишь в том случае, если значение этого счетчика равно 0. Поток может увеличивать или уменьшать значение счетчика приостановок другого потока с помощью функций SuspendThread и Resume-Thread. Вспомните, что поток можно создать в приостановленном состоянии со счетчиком приостановок равным 1. </p>
     <cite>
      <p><code>DWORD ResumeThread(HANDLE hThread)</code></p>
      <p><code>DWORD SuspendThread(HANDLE hThread)</code> </p>
     </cite>
     <p>В случае успешного выполнения обе функции возвращают предыдущее значение счетчика приостановок, иначе — 0xFFFFFFFF.</p>
    </section>
    <section>
     <title>
      <p>Ожидание завершения потока</p>
     </title>
     <p>Поток может дожидаться завершения выполнения другого потока точно так же, как потоки могут дожидаться завершения процесса, что обсуждалось в главе 6. В этом случае при вызове функций ожидания (WaitForSingleObject и WaitForMultipleObjects) вместо дескрипторов процессов следует использовать дескрипторы потоков. Заметьте, что не все дескрипторы в массиве, передаваемом функции WaitForMultipleObjects, должны быть обязательно одного и того же типа; например, в одном вызове могут быть одновременно указаны дескрипторы потоков, процессов и других объектов.</p>
     <p>Допустимое количество объектов, одновременно ожидаемых функцией WaitForMultipleObjects, ограничено значением MAXIMUM_WAIT_OBJECTS (64), но при большом количестве потоков можно воспользоваться серией вызовов функций ожидания. Эта техника уже была продемонстрирована в программе 6.1; программы, приведенные в книге, ожидают завершения выполнения одиночных объектов, но на Web-сайте приведены полные решения.</p>
     <p>Функция ожидания дожидается, пока объект, указанный дескриптором, не перейдет в <emphasis>сигнальное</emphasis> состояние. В случае потоков объект потока переводится в сигнальное состояние при помощи функций ExitThread и TerminateThread, что приводит к освобождению всех других потоков, дожидающихся перехода данного объекта в сигнальное состояние, включая и те потоки, которые могли оставаться в состоянии ожидания и впоследствии, после того, как поток завершится. Дескриптор потока, перешедший в сигнальное состояние, не выходит из этого состояния. То же самое остается справедливым и по отношению к дескрипторам процессов, но не относится к дескрипторам некоторых других объектов, например, мьютексов и событий (описываются в следующей главе).</p>
     <p>Заметьте, что дожидаться перехода в сигнальное состояние одного и того же объекта могут одновременно несколько потоков. Аналогично, функция ExitProcess переводит в сигнальное состояние как сам процесс, так и все его потоки.</p>
    </section>
    <section>
     <title>
      <p>Удаленные потоки</p>
     </title>
     <p>Функция CreateRemoteThread позволяет создавать потоки, выполняющиеся в другом процессе. По сравнению с функцией CreateThread в ней имеется один дополнительный параметр для указания дескриптора процесса, а адрес функции, задающий начальный адрес нового потока, должен находиться в адресном пространстве целевого процесса. Использование функции CreateRemoteThread относится к числу интересных, однако рискованных способов непосредственного воздействия одним процессом на другой, и может пригодиться, например, при написании отладчиков. </p>
     <p>У функции CreateRemoteThread есть одно очень интересное применение. Вместо того чтобы вызывать функцию TerminateProcess, управляющий процесс может создать поток, выполняющийся в другом процессе, который и организует корректное завершение этого процесса. Однако в главе 10 демонстрируется более безопасный метод, позволяющий одному потоку завершить другой с использованием асинхронного вызова процедур. </p>
     <cite>
      <p>Понятие о потоках твердо упрочилось во многих ОС, и исторически так сложилось, что многие поставщики и пользователи UNIX предоставляли собственные частные варианты их реализации. Были разработаны некоторые библиотеки, обеспечивающие многопоточную поддержку вне ядра. В настоящее время стандартом в этой области являются потоки POSIX Pthreads. Потоки Pthreads включены в частные варианты реализации UNIX и Linux и иногда считаются частью UNIX. Соответствующие системные вызовы отличаются от обычных системных вызовов UNIX наличием в именах префикса pthread. Потоки Pthreads поддерживаются также некоторыми другими системами, отличными от UNIX, такими, например, как Open VMS.</p>
      <p>Системный вызов pthread_create эквивалентен вызову CreateThread, a системный вызов pthread_exit — вызову ExitThread. Для организации ожидания одним потоком завершения другого применяется системный вызов pthread_join. Потоки Pthreads предоставляют очень полезную функцию pthread_cancel, гарантирующую, в отличие от функции TerminateThread, выполнение обработчиков завершения и уничтожение ненужных дескрипторов. Возможность уничтожения потоков была бы в Windows крайне желательной, но в главе 10 представлен метод, обеспечивающий получение такого же эффекта.</p>
     </cite>
    </section>
   </section>
   <section>
    <title>
     <p>Использование библиотеки С впотоках</p>
    </title>
    <section>
     <p>В большинстве программ требуется библиотека С, хотя бы для того, чтобы обеспечить выполнение операций над строками. Исторически так сложилось, что библиотека С была рассчитана на применение в однопоточных процессах, поэтому для хранения промежуточных результатов многие функции используют области глобальной памяти. Подобные библиотеки, в которых отсутствует многопоточная поддержка, не являются безопасными (thread-safe) с точки зрения одновременного выполнения нескольких потоков, поскольку, например, одновременно две независимые потоки могут пытаться получить доступ к библиотеке и изменить данные, содержащиеся в ее глобальной памяти. Принципы проектирования многопоточных программ будут вновь обсуждаться в главе 8, в которой описывается синхронизация объектов Windows.</p>
     <p>Пример функции strtok показывает, почему при написании некоторых функций библиотеки С не учитывалась многопоточная поддержка. Функция strtok, просматривающая строку в поиске очередного вхождения определенной лексемы, поддерживает сохранение состояния (persistent state) между последовательными вызовами функции, и это состояние хранится в области статической памяти, совместный доступ к которой имеют все потоки, вызывающие эту функцию. </p>
     <p>Microsoft С решает эту проблему, предлагая реализацию библиотеки С под названием LIBCMT.LIB, которая обеспечивает многопоточную поддержку. Однако, это еще не все. Вы не должны использовать функцию CreateThread; для запуска потока и создания специфической для него области рабочей памяти библиотеки LIBCMT.LIB необходимо пользоваться специальной функцией С, а именно, функцией _beginthreadex. Для завершения потока вместо функции ExitThread применяется функция _endthreadex.</p>
     <cite>
      <p><strong>Примечание</strong></p>
      <p>В качестве упрощенного варианта функции _beginthreadex предусмотрена функция _beginthread, однако <emphasis>использовать ее не рекомендуется.</emphasis> Прежде всего, функция _beginthread не имеет ни атрибутов, ни флагов защиты и не возвращает идентификатор потока. Более того, в действительности она закрывает дескриптор потока, который создает, в результате чего возвращенное значение дескриптора может оказаться недействительным на момент его сохранения родительским потоком. Не следует вызывать и функцию _endthread; она не позволяет пользоваться возвращаемым значением.</p>
     </cite>
     <p>Аргументы функции _beginthreadex в точности совпадают с аргументами функций Windows, однако типы данных Windows для этой функции не определены, и поэтому тип возвращаемого значения функции _beginthread необходимо привести к типу HANDLE, что позволит избежать появления предупреждающих сообщений. Убедитесь в том, что определение символической константы _МТ предшествует любому из включаемых файлов; в примерах программ это определение содержится в файле Envirmnt.h. Больше от вас ничего не требуется. Резюмируя, перечислим действия, которые вы должны выполнить, если имеете дело со средой разработки Visual C++.</p>
     <p>• Подключите библиотеку LIBCMT.LIB и откажитесь от использования библиотеки, заданной по умолчанию.</p>
     <p>• Включите директиву #define _MT во все исходные файлы, в которых используется библиотека С.</p>
     <p>• Добавьте включаемый файл &lt;process.h&gt;, содержащий определения функций _beginthreadex и _endthreadex.</p>
     <p>• Создайте потоки с помощью функции _beginthreadex; не применяйте для этой цели функцию CreateThread.</p>
     <p>• Завершите потоки посредством функции _endthreadex или просто воспользуйтесь оператором return в конце функции потока.</p>
     <p>В приложении А вы найдете указания относительно того, как создавать многопоточные приложения. В частности, можно, и даже рекомендуется, указывать библиотеку и определять константу _МТ непосредственно в среде разработки.</p>
     <p>Именно так будут построены все наши примеры, и функция CreateThread никогда не будет непосредственно применяться в программах даже в тех случаях, когда библиотека С в функциях потоков не используется. </p>
    </section>
    <section>
     <title>
      <p>Библиотеки с многопоточной поддержкой</p>
     </title>
     <p>При проектировании пользовательских библиотек следует уделять самое пристальное внимание тому, чтобы избежать возникновения проблем, связанных с параллельным выполнением нескольких потоков, особенно в тех случаях, когда речь идет о сохранении информации о состоянии процессов. Одна из возможных стратегий демонстрируется в примере в главе 12 (программа 12.4), где библиотека DLL для сохранения информации о состоянии использует отдельный параметр.</p>
     <p>Еще один пример в главе 12 (программа 12.5) иллюстрирует альтернативный подход, в котором применяется функция DllMain и TLS, описанные далее в настоящей главе.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: многопоточный поиск контекста</p>
    </title>
    <p>В программе 6.1 (grepMP) для выполнения одновременного поиска текстового шаблона в нескольких файлах использовались процессы. Программа 7.1 (grepMT), которая включает исходный код функции поиска текстового шаблона grep, обеспечивает выполнение поиска несколькими потоками в рамках одного процесса. Код функции поиска основан на вызовах функций файлового ввода/вывода библиотеки С. Основная программа аналогична той, которая предлагалась в варианте реализации, основанном на использовании процессов.</p>
    <p>Этот пример также показывает, что применение потоков позволяет выполнять асинхронные операции ввода/вывода даже без привлечения специально для этого предназначенных методов, описанных в главе 14. В данном примере параллельным вводом/выводом с участием нескольких файлов управляет программа, в то время как основной или любого другого потока предоставляется возможность в ожидании завершения ввода/вывода выполнять дополнительную обработку. По мнению автора, способ реализации асинхронного ввода/вывода, обеспечиваемый потоками, является более простым, а сравнительный анализ эффективности различных методов, представленный в главе 14, поможет вам выработать собственное мнение на этот счет.</p>
    <p>Мы увидим, однако, что в сочетании с портами завершения ввода/вывода операции асинхронного ввода/вывода становятся очень полезным, а часто и необходимым средством в тех случаях, когда количество потоков очень велико.</p>
    <p>В иллюстративных целях в программу grepMT введено дополнительное отличие по сравнению с программой grepMP. В данном случае функция WaiForMultipleObjects ожидает завершения не всех потоков, а только одного. Соответствующая информация выводится без ожидания завершения других потоков. В большинстве случае порядок завершения потоков будет меняться от одного запуска программы к другому. Программу легко видоизменить таким образом, чтобы результаты отображались в порядке указания аргументов в командной строке; для этого будет достаточно сымитировать программу grepMP. </p>
    <p>Наконец, обратите внимание на ограничение в 64 потока, обусловленное значением константы MAXIMUM_WAIT_OBJECTS, которая ограничивает количество дескрипторов при вызове функции WaitForMultipleObjects. Если у вас возникнет необходимость в большем количестве потоков, организуйте для функций WaitForSingleObjects или WaitForMultipleObjects соответствующий цикл.</p>
    <cite>
     <p><strong>Предостережение</strong></p>
     <p>Программа grepMP осуществляет асинхронный ввод/вывод в том смысле, что отдельные потоки выполняют параллельное синхронное чтение различных файлов, которые блокируются до момента завершения операции чтения. Можно также организовать параллельное чтение одного и того же файла, если у него имеются различные дескрипторы (обычно, по одному дескриптору для каждого потока). Эти дескрипторы должны быть сгенерированы функцией CreateFile, а не функцией DuplicateHandle. В главе 14 описывается асинхронный ввод/вывод, осуществляемый как с использованием, так и без использования пользовательских потоков, а в примере, доступном на Web-сайте (программа atouMT, описанная в главе 14), операции ввода/вывода выполняются с использованием нескольких потоков по отношению к одному и тому же файлу.</p>
    </cite>
    <subtitle>Программа 7.1. grepMT: многопоточный поиск текстового шаблона </subtitle>
    <p><code>/* Глава 7. grepMT. */</code></p>
    <p><code>/* Параллельный поиск текстового шаблона — версия, использующая несколько потоков. */</code></p>
    <p><code>#include "EvryThng.h"</code></p>
    <empty-line/>
    <p><code>typedef struct { /* Структура данных потока поиска. */</code></p>
    <p><code> int argc;</code></p>
    <p><code> TCHAR targv[4][МАХ_РАТН]; </code></p>
    <p><code>} GREP_THREAD_ARG; </code></p>
    <p><code>typedef GREP_THREAD_ARG *PGR_ARGS;</code></p>
    <p><code>static DWORD WINAPI ThGrep(PGR_ARGS pArgs);</code></p>
    <empty-line/>
    <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> GREP_THREAD_ARG * gArg;</code></p>
    <p><code> HANDLE * tHandle;</code></p>
    <p><code> DWORD ThdIdxP, ThId, ExitCode;</code></p>
    <p><code> TCHAR CmdLine[MAX_COMMAND_LINE];</code></p>
    <p><code> int iThrd, ThdCnt;</code></p>
    <p><code> STARTUPINFO Startup;</code></p>
    <p><code> PROCESS_INFORMATION ProcessInfo;</code></p>
    <p><code> GetStartupInfo(&amp;StartUp);</code></p>
    <p><code> /* Основной поток: создает отдельные потоки поиска на основе функции "grep" для каждого файла. */</code></p>
    <p><code> tHandle = malloc((argc – 2) * sizeof(HANDLE));</code></p>
    <p><code> gArg = malloc((argc – 2) * sizeof(GREP_THREAD_ARG));</code></p>
    <p><code> for (iThrd = 0; iThrd &lt; argc – 2; iThrd++) {</code></p>
    <p><code>  _tcscpy(gArg[iThrd].targv[1], argv[1]); /* Pattern. */</code></p>
    <p><code>  _tcscpy(gArg[iThrd].targv[2], argv[iThrd + 2]);</code></p>
    <p><code>  GetTempFileName /* Имя временного файла. */</code></p>
    <p><code>   (".", "Gre", 0, gArg[iThrd].targv[3]); </code></p>
    <p><code>  gArg[iThrd].argc = 4;</code></p>
    <p><code>  /* Создать рабочий поток для выполнения командной строки. */</code></p>
    <p><code>  tHandle[iThrd] = (HANDLE)_beginthreadex(NULL, 0, ThGrep, &amp;gArg[iThrd], 0, &amp;ThId);</code></p>
    <p><code> }</code></p>
    <p><code> /* Перенаправить стандартный вывод для вывода списка файлов. */</code></p>
    <p><code> Startup.dwFlags = STARTF_USESTDHANDLES;</code></p>
    <p><code> Startup.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);</code></p>
    <p><code> /* Выполняются все рабочие потоки. Ожидать их завершения. */</code></p>
    <p><code> ThdCnt = argc – 2;</code></p>
    <p><code> while (ThdCnt &gt; 0) {</code></p>
    <p><code>  ThdIdxP = WaitForMultipleObjects(ThdCnt, tHandle, FALSE, INFINITE);</code></p>
    <p><code>  iThrd = (int)ThdIdxP – (int)WAIT_OBJECT_0;</code></p>
    <p><code>  GetExitCodeThread(tHandle [iThrd], &amp;ExitCode);</code></p>
    <p><code>  CloseHandle(tHandle [iThrd]);</code></p>
    <p><code>  if (ExitCode ==0) { /* Шаблон найден. */</code></p>
    <p><code>   if (argc &gt; 3) {</code></p>
    <p><code>    /* Вывести имя файла, если имеется несколько файлов. */</code></p>
    <p><code>    _tprintf(_T("\n**Результаты поиска – файл: %s\n"), gArg[iThrd].targv [2]);</code></p>
    <p><code>    fflush(stdout);</code></p>
    <p><code>   }</code></p>
    <p><code>   /* Использовать программу "cat" для перечисления результирующих файлов. */</code></p>
    <p><code>   _stprintf(CmdLine, _T("%s%s"), _Т("cat "), gArg [iThrd].targv[3]);</code></p>
    <p><code>   CreateProcess(NULL, CmdLine, NULL, NULL, TRUE, 0, NULL, NULL, &amp;StartUp, &amp;ProcessInfo);</code></p>
    <p><code>   WaitForSingleObject(ProcessInfo.hProcess, INFINITE);</code></p>
    <p><code>   CloseHandle(ProcessInfo.hProcess);</code></p>
    <p><code>   CloseHandle(ProcessInfo.hThread);</code></p>
    <p><code>  }</code></p>
    <p><code>  DeleteFile(gArg[iThrd].targv[3]);</code></p>
    <p><code>  /* Скорректировать массивы потоков и имен файлов. */</code></p>
    <p><code>  tHandle[iThrd] = tHandle[ThdCnt – 1];</code></p>
    <p><code>  _tcscpy(gArg[iThrd].targv[3], gArg[ThdCnt – 1].targv[3]);</code></p>
    <p><code>  _tcscpy(gArg[iThrd].targv[2], gArg[ThdCnt – 1].targv[2]);</code></p>
    <p><code>  ThdCnt--;</code></p>
    <p><code> }</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* Прототип функции контекстного поиска: </code></p>
    <p><code>static DWORD WINAPI ThGrep(PGR_ARGS pArgs){ } */</code></p>
   </section>
   <section>
    <title>
     <p>Потоки и производительность</p>
    </title>
    <p>Программы grepMP и grepMT по своей структуре и сложности сопоставимы друг с другом, однако, как и следовало ожидать, программа grepMT характеризуется более высокой производительностью, так как переключение между потоками осуществляется ядром намного эффективнее, чем переключение между процессами. В приложении В показано, что эти теоретические ожидания отвечают действительности, и это особенно заметно в тех случаях, когда файлы размещены на различных дисках. Оба варианта реализации способны работать в SMP-системах, существенно улучшая показатели производительности в терминах общего времени выполнения (истекшего времени); потоки, независимо от того, принадлежат ли они одному и тому же или разным процессам, параллельно выполняются на различных процессорах. Измеренное пользовательское время в действительности превышает общее время выполнения, поскольку рассчитывается в виде суммарной величины для всех процессоров.</p>
    <p>В то же время, существует весьма распространенное заблуждение, суть которого состоит в том, что отмеченный параллелизм, независимо от того, касается ли он использования нескольких процессов, как в случае grepMP, или же применения нескольких потоков, как в случае grepMT, способен приводить к повышению производительности лишь в случае SMP-систем. Выигрыш в производительности можно получить и при использовании нескольких дисков, а также при любом другом распараллеливании в системе хранения. Во всех подобных случаях операции ввода/вывода с участием нескольких файлов будут осуществляться в параллельном режиме.</p>
   </section>
   <section>
    <title>
     <p>Модель "хозяин/рабочий" и другие модели многопоточных приложений</p>
    </title>
    <p>Программа grepMT демонстрирует модель многопоточных приложений, носящую название модели "хозяин/рабочий" ("boss/worker"), а рис. 6.3, после замены в нем термина "процесс" на термин "поток", может служить графической иллюстрацией соответствующих отношений. Главный поток (основной поток в данном случае) поручает выполнение отдельных задач рабочим потокам. Каждый рабочий, поток получает файл, в котором она должна выполнить поиск, а полученные рабочим потоком результаты передаются главному потоку во временном файле.</p>
    <p>Существуют многочисленные вариации этой модели, одной из которых является модель рабочей группы (work crew model), в которой рабочие потоки объединяют свои усилия для решения одной задачи, причем каждый отдельный поток выполняет свою небольшую часть работы. Модель рабочей группы используется в нашем следующем примере (рис. 7.2). Рабочие группы даже могут самостоятельно распределять работу между собой без получения каких-либо указаний со стороны главного потока. В многопоточных программах может быть применена практически любая из схем управления, разработанных для коллективов в человеческом обществе. </p>
    <image l:href="#Any2FbImgLoader97"/>
    <p><strong>Рис. 7.2.</strong> Выполнение сортировки слиянием с использованием нескольких потоков</p>
    <empty-line/>
    <p>Двумя другими основными моделями являются модель <emphasis>"клиент/сервер"</emphasis> (client/server) (проиллюстрирована на рис. 7.1, а пример ее практической реализации рассматривается в главе 11) и <emphasis>конвейерная модель</emphasis> (pipeline model), в которой выполнение задания передается от одного потока к другому (пример многоступенчатого конвейера рассматривается в главе 10 и иллюстрируется на рис. 10.1).</p>
    <p>При проектировании многопоточных систем эти модели обладают целым рядом преимуществ, к числу которых можно отнести следующие:</p>
    <p>• Большинство проблем многопоточного программирования могут быть разрешены с использованием одной из стандартных моделей, облегчающих проектирование, разработку и отладку программ.</p>
    <p>• Применение понятных и проверенных моделей не только позволяет избежать многих ошибок, которые легко допустить при написании многопоточных программ, но и способствует повышению производительности результирующих приложений.</p>
    <p>• Эти модели естественным образом соответствуют структуре большинства обычных задач программирования.</p>
    <p>• Программистам, сопровождающим программу, будет гораздо легче понять ее устройство, если она будет описана в документации на понятном языке. </p>
    <p>• Находить неполадки в незнакомой программе гораздо легче, если ее можно анализировать в терминах моделей. Очень часто главную причину неполадок удается установить на основании видимых нарушений базовых принципов одной из моделей.</p>
    <p>• Многие распространенные дефекты программ, например, нарушение условий состязаний задач и их блокирование, также можно описать с использованием простых моделей, к числу которых относятся эффективные методы использования объектов синхронизации, описанные в главах 9 и 10.</p>
    <p>Эти классические модели потоков реализованы во многих ОС. В модели компонентных объектов (Component Object Model, COM), широко используемой во многих Windows-системах, применяется другая терминология, и хотя рассмотрение модели СОМ выходит за рамки данной книги, об этих моделях говорится в конце главы 11, где они сравниваются с другими примерами программ.</p>
   </section>
   <section>
    <title>
     <p>Пример: применение принципа "разделяй и властвуй" для решения задачи сортировки слиянием в SMP-системах</p>
    </title>
    <p>Этот пример демонстрирует возможности значительного повышения производительности за счет использования потоков, особенно в случае SMP-систем. Основная идея заключается в разбиении задачи на более мелкие составляющие, распределении выполнения подзадач между отдельными потоками и последующем объединении результатов для получения окончательного решения. Планировщик Windows автоматически назначит потокам отдельные процессоры, в результате чего задачи будут выполняться параллельно, снижая общее время выполнения приложения.</p>
    <p>Эта стратегия, которую часто называют стратегией "разделяй и властвуй" (divide and conquer), или <emphasis>моделью рабочей группы</emphasis> (work crew model), оказалась весьма полезной и в качестве средства повышения производительности, и в качестве метода проектирования алгоритмов. Одним из примеров ее применения служит программа grepMT (программа 7.1), в которой для каждой файловой операции ввода/вывода и для поиска шаблона создается отдельный поток. Как показано в приложении B, в случае SMP-систем производительность повышается, поскольку планировщик может распределять выполнение потоков между различными процессорами.</p>
    <p>Далее мы рассмотрим другой пример, в котором задача сортировки содержимого файла разбивается на ряд подзадач, выполнение которых делегируется отдельным потокам.</p>
    <p>Решение задачи сортировки слиянием (merge-sort), в которой сортируемый массив разбивается на несколько массивов меньшего размера, является классическим примером алгоритма, построенного на принципе "разделяй и властвуй". Каждый из массивов небольшого размера сортируется по отдельности, после чего отсортированные массивы попарно объединяются с образованием отсортированных массивов большего размера. Описанное слияние массивов попарно осуществляется вплоть до завершения всего процесса сортировки. В общем случае, сортировка слиянием начинается с массивов размерности 1, которые сами по себе не нуждаются в сортировке. В данном примере сортировка начинается с массивов большей размерности, чтобы на каждый процессор приходилось по одному массиву. Блок-схема используемого алгоритма показана на рис. 7.2.</p>
    <p>Детали реализации представлены в программе 7.2. Число задач задается пользователем в командной строке. Временные показатели сортировки приведены в приложении В. В упражнении 7.9 вам предлагается изменить программу sortMT таким образом, чтобы она сначала определяла количество доступных процессоров, используя для этого функцию GetSystemInfo, а затем создавала по одному потоку для каждого процессора.</p>
    <p>Заметьте, что эта программа эффективно выполняется в однопроцессорных системах, в которых имеется достаточно большой запас оперативной памяти, и обеспечивает значительное повышение производительности в SMP-системах. <emphasis>Предостережение.</emphasis> Представленный алгоритм будет корректно работать лишь при условии, что число записей в сортируемом файле нацело делится на число потоков, а число потоков выражается степенью 2. В упражнении 7.8 упомянутые ограничения снимаются.</p>
    <cite>
     <p><strong>Примечание</strong></p>
     <p>Изучая работу этой программы, постарайтесь отделить логику управления потоками от логики определения части массива, которую должна сортировать тот или иной поток. Обратите также внимание на использование функции qsort из библиотеки С, применение которой избавляет нас от необходимости самостоятельно разрабатывать эффективную функцию сортировки.</p>
    </cite>
    <subtitle>Программа 7.2. sortMT: сортировка слиянием с использованием нескольких потоков </subtitle>
    <p><code>/* Глава 7. SortMT.</code></p>
    <p><code>   Сортировка файлов с использованием нескольких потоков (рабочая группа).</code></p>
    <p><code>   sortMT [параметры] число_задач файл */</code></p>
    <empty-line/>
    <p><code>#include "EvryThng.h"</code></p>
    <p><code>#define DATALEN 56 /* Данные: 56 байт; ключ: 8 байт. */</code></p>
    <p><code>#define KEYLEN 8</code></p>
    <empty-line/>
    <p><code>typedef struct _RECORD {</code></p>
    <p><code> CHAR Key[KEYLEN];</code></p>
    <p><code> TCHAR Data[DATALEN]; </code></p>
    <p><code>} RECORD;</code></p>
    <empty-line/>
    <p><code>#define RECSIZE sizeof (RECORD) </code></p>
    <p><code>typedef RECORD * LPRECORD;</code></p>
    <empty-line/>
    <p><code>typedef struct _THREADARG { /* Аргумент потока */</code></p>
    <p><code> DWORD iTh; /* Номер потока: 0, 1, 2, … */</code></p>
    <p><code> LPRECORD LowRec; /* Младшая часть указателя записи */</code></p>
    <p><code> LPRECORD HighRec; /* Старшая часть указателя записи */</code></p>
    <p><code>} THREADARG, *PTHREADARG;</code></p>
    <empty-line/>
    <p><code>static int KeyCompare(LPCTSTR, LPCTSTR);</code></p>
    <p><code>static DWORD WINAPI ThSort(PTHREADARG pThArg);</code></p>
    <p><code>static DWORD nRec; /* Общее число записей, подлежащих сортировке. */</code></p>
    <p><code>static HANDLE* ThreadHandle;</code></p>
    <empty-line/>
    <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> HANDLE hFile;</code></p>
    <p><code> LPRECORD pRecords = NULL;</code></p>
    <p><code> DWORD FsLow, nRead, LowRecNo, nRecTh, NPr, ThId, iTh;</code></p>
    <p><code> BOOL NoPrint;</code></p>
    <p><code> int iFF, iNP;</code></p>
    <p><code> PTHREADARG ThArg;</code></p>
    <p><code> LPTSTR StringEnd;</code></p>
    <p><code> iNP = Options(argc, argv, _T("n"), &amp;NoPrint, NULL);</code></p>
    <p><code> iFF = iNP + 1;</code></p>
    <p><code> NPr = _ttoi(argv[iNP]); /* Количество потоков. */</code></p>
    <p><code> hFile = CreateFile(argv[iFF], GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);</code></p>
    <p><code> FsLow = GetFileSize(hFile, NULL);</code></p>
    <p><code> nRec = FsLow / RECSIZE; /* Общее число записей. */</code></p>
    <p><code> nRecTh = nRec / NPr; /* Количество записей на один поток. */</code></p>
    <p><code> /* Распределить память для аргументов потока и массива дескрипторов и выделить в памяти место для файла. Считать весь файл. */</code></p>
    <p><code> ThArg = malloc(NPr * sizeof(THREADARG));</code></p>
    <p><code> /* Аргументы потоков. */</code></p>
    <p><code> ThreadHandle = malloc(NPr * sizeof(HANDLE));</code></p>
    <p><code> pRecords = malloc(FsLow + sizeof(TCHAR));</code></p>
    <p><code> ReadFile(hFile, pRecords, FsLow, &amp;nRead, NULL);</code></p>
    <p><code> CloseHandle(hFile);</code></p>
    <p><code> LowRecNo = 0; /* Создать потоки, выполняющие сортировку. */</code></p>
    <p><code> for (iTh = 0; iTh &lt; NPr; iTh++) {</code></p>
    <p><code>  ThArg[iTh].iTh = iTh;</code></p>
    <p><code>  ThArg[iTh].LowRec = pRecords + LowRecNo;</code></p>
    <p><code>  ThArg[iTh].HighRec = pRecords + (LowRecNo + nRecTh);</code></p>
    <p><code>  LowRecNo += nRecTh;</code></p>
    <p><code>  ThreadHandle[iTh] = (HANDLE)_beginthreadex (NULL, 0, ThSort, &amp;ThArg[iTh], CREATE_SUSPENDED, &amp;ThId);</code></p>
    <p><code> }</code></p>
    <p><code> for (iTh = 0; iTh &lt; NPr; iTh++) /* Запустить все потоки сортировки. */</code></p>
    <p><code>  ResumeThread(ThreadHandle [iTh]);</code></p>
    <p><code> WaitForSingleObject(ThreadHandle[0], INFINITE);</code></p>
    <p><code> for (iTh = 0; iTh &lt; NPr; iTh++) CloseHandle(ThreadHandle [iTh]);</code></p>
    <p><code> StringEnd = (LPTSTR)pRecords + FsLow;</code></p>
    <p><code> *StringEnd = '\0';</code></p>
    <p><code> if (!NoPrint) printf("\n%s", (LPCTSTR)pRecords);</code></p>
    <p><code> free(pRecords);</code></p>
    <p><code> free(ThArg);</code></p>
    <p><code> free(ThreadHandle);</code></p>
    <p><code> return 0;</code></p>
    <p><code> } /* Конец tmain. */</code></p>
    <empty-line/>
    <p><code>static VOID MergeArrays(LPRECORD, LPRECORD);</code></p>
    <empty-line/>
    <p><code>DWORD WINAPI ThSort(PTHREADARG pThArg) {</code></p>
    <p><code> DWORD GrpSize = 2, RecsInGrp, MyNumber, TwoToI = 1;</code></p>
    <p><code> LPRECORD First;</code></p>
    <p><code> MyNumber = pThArg-&gt;iTh;</code></p>
    <p><code> First = pThArg-&gt;LowRec;</code></p>
    <p><code> RecsInGrp = pThArg-&gt;HighRec – First;</code></p>
    <p><code> qsort(First, RecsInGrp, RECSIZE, KeyCompare);</code></p>
    <p><code> while ((MyNumber % GrpSize) == 0 &amp;&amp; RecsInGrp &lt; nRec) {</code></p>
    <p><code>  /* Объединить слиянием отсортированные массивы. */</code></p>
    <p><code>  WaitForSingleObject(ThreadHandle[MyNumber + TwoToI], INFINITE);</code></p>
    <p><code>  MergeArrays(First, First + RecsInGrp);</code></p>
    <p><code>  RecsInGrp *= 2;</code></p>
    <p><code>  GrpSize *= 2;</code></p>
    <p><code>  TwoToI *= 2;</code></p>
    <p><code> }</code></p>
    <p><code> _endthreadex(0);</code></p>
    <p><code> return 0; /* Подавить вывод предупреждающих сообщений. */ </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>static VOID MergeArrays(LPRECORD p1, LPRECORD p2) {</code></p>
    <p><code> DWORD iRec = 0, nRecs, i1 = 0, i2 = 0;</code></p>
    <p><code> LPRECORD pDest, p1Hold, pDestHold;</code></p>
    <p><code> nRecs = p2 – p1;</code></p>
    <p><code> pDest = pDestHold = malloc(2 * nRecs * RECSIZE);</code></p>
    <p><code> p1Hold = p1;</code></p>
    <p><code> while (i1 &lt; nRecs &amp;&amp; i2 &lt; nRecs) {</code></p>
    <p><code>  if (KeyCompare((LPCTSTR)p1, (LPCTSTR)p2) &lt;= 0) {</code></p>
    <p><code>   memcpy(pDest, p1, RECSIZE);</code></p>
    <p><code>   i1++;</code></p>
    <p><code>   p1++;</code></p>
    <p><code>   pDest++;</code></p>
    <p><code>  } else {</code></p>
    <p><code>   memcpy(pDest, p2, RECSIZE);</code></p>
    <p><code>   i2++;</code></p>
    <p><code>   p2++;</code></p>
    <p><code>   pDest++;</code></p>
    <p><code>  }</code></p>
    <p><code> }</code></p>
    <p><code> if (i1 &gt;= nRecs) memcpy(pDest, p2, RECSIZE * (nRecs – i2));</code></p>
    <p><code> else memcpy(pDest, p1, RECSIZE * (nRecs – i1));</code></p>
    <p><code> memcpy(p1Hold, pDestHold, 2 * nRecs * RECSIZE);</code></p>
    <p><code> free (pDestHold);</code></p>
    <p><code> return; </code></p>
    <p><code>}</code> </p>
   </section>
   <section>
    <title>
     <p>Производительность</p>
    </title>
    <p>В приложении В представлены результаты сортировки файлов большого размера, содержащих записи длиной 64 байта, для случаев использования одной, двух и четырех потоков. SMP-системы позволяют получать значительно лучшие результаты. Упомянутый принцип "разделяй и властвуй" обеспечивает нечто большее, чем просто стратегию проектирования алгоритмов; он также служит ключом к использованию потоков и SMP. Результаты для однопроцессорных систем могут быть различными в зависимости от остальных характеристик системы. В системах с ограниченным объемом памяти (то есть объема физической памяти не достаточно для того, чтобы наряду с ОС и другими активными процессами в ней уместился весь файл) использование нескольких потоков увеличивает время сортировки, поскольку потоки состязаются между собой в захвате доступной физической памяти. С другой стороны, если памяти имеется достаточно, то многопоточный вариант может привести к повышению производительности и в случае однопроцессорных систем. Кроме того, как следует из приложения В, получаемые результаты существенно зависят от начального распределения данных.</p>
   </section>
   <section>
    <title>
     <p>Локальные области хранения потоков</p>
    </title>
    <p>Потокам могут требоваться собственные, независимо распределяемые и управляемые ими области памяти, защищенные от других потоков того же процесса. Одним из методов создания таких областей является вызов функции CreateThread (или _beginthreadex) с параметром lpvThreadParm, указывающим на структуру данных, уникальную для каждого потока. После этого поток может распределять память для дополнительных структур данных и получать доступ к ним через указатель lpvThreadParm. Эта методика используется в программе 7.1.</p>
    <p>Кроме того, Windows предоставляет локальные области хранения потоков (Thread Local Storage, TLS), обеспечивающие каждый из потоков собственным массивом указателей. Организация TLS показана на рис. 7.3.</p>
    <p>Индексы (строки) TLS первоначально не распределены, но в любой момент времени можно добавлять новые строки и освобождать существующие, причем минимально возможное число строк для любого процесса определяется значением TLS_MINIMUM_AVAILABLE (равным, по крайней мере, 64). Число столбцов может изменяться по мере создания новых потоков и завершения существующих.</p>
    <p>Сначала мы рассмотрим управление индексами TLS. Логическим пространством для этого служит основной поток, но управлять индексами может любой поток.</p>
    <p>Функция TlsAlloc возвращает распределенный индекс (&gt; 0) или –1 (0xFFFFFFFF) в случае отсутствия доступных индексов. </p>
    <cite>
     <p><code>DWORD TlsAlloc(VOID)</code></p>
     <p><code>BOOL TlsFree(DWORD dwIndex)</code> </p>
    </cite>
    <image l:href="#Any2FbImgLoader100"/>
    <p><strong>Рис. 7.3.</strong> Локальные области хранения потоков в контексте процесса</p>
    <empty-line/>
    <p>Каждый отдельный поток может выбирать и устанавливать значения (указатели типа void), связанные с ее областью памяти, используя индексы TLS.</p>
    <p>Программист всегда должен убеждаться в том, что параметр индекса TLS является действительным, то есть что он был распределен с помощью функции TlsAlloc, но не был освобожден. </p>
    <cite>
     <p><code>LPVOID TlsGetValue(DWORD dwTlsIndex)</code></p>
     <p><code>BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)</code> </p>
    </cite>
    <p>TLS предоставляют удобный механизм организации памяти, являющейся глобальной в контексте потока, но недоступной другим потокам. Обычные глобальные хранилища разделяются всеми потоками. Несмотря на то что ни один поток не может получить доступа к TLS другого потока, любой поток может уничтожить индекс TLS другого потока, вызвав функцию TlsFree, так что этой функцией следует пользоваться с осторожностью. TLS часто используются DLL в качестве замены глобальной памяти библиотеки; в результате этого каждый поток получает в свое распоряжение собственную глобальную память. Кроме того, TLS обеспечивают вызывающим программам удобный способ взаимодействия с функциями DLL, и именно этот способ применения TLS является наиболее распространенным. В качестве примера в главе 12 (программа 12.4) TLS используются для создания библиотеки DLL с многопоточной поддержкой; другим важным элементом этого решения являются уведомления DLL о присоединении/отсоединении потоков и процессов путем вызова функции DllMain (глава 5). </p>
   </section>
   <section>
    <title>
     <p>Приоритеты процессов и потоков и планирование выполнения</p>
    </title>
    <section>
     <p>Ядро Windows всегда запускает тот из потоков, готовых к выполнению, который обладает наивысшим приоритетом. Поток не является готовым к выполнению, если он находится в состоянии ожидания, приостановлен или блокирован по той или иной причине.</p>
     <p>Потоки получают приоритеты на базе классов приоритета своих процессов. Как обсуждалось в главе б, первоначально функцией CreateProcess устанавливаются четыре класса приоритета, каждый из которых имеет <emphasis>базовый приоритет</emphasis> (base priority):</p>
     <p>• IDLE_PRIORITY_CLASS, базовый приоритет 4.</p>
     <p>• NORMAL_PRIORITY_CLASS, базовый приоритет 9 или 7.</p>
     <p>• HIGH_PRIORITY_CLASS, базовый приоритет 13.</p>
     <p>• REALTIME_PRIORITY_CLASS, базовый приоритет 24.</p>
     <p>Оба предельных класса используются редко, и в большинстве случаев можно обойтись нормальным (normal) классом. Windows NT (все версии) не является ОС реального времени (real-time), чего нельзя сказать, например, о Windows СЕ, и в случаях, аналогичных последнему, классом REALTIME_PRIORITY_CLASS следует пользоваться с осторожностью, чтобы не допустить вытеснения других процессов. Нормальный базовый приоритет равен 9, если фокус ввода с клавиатуры находится в окне; в противном случае этот приоритет равен 7.</p>
     <p>Один процесс может изменить или установить свой собственный приоритет или приоритет другого процесса, если это разрешено атрибутами защиты. </p>
     <cite>
      <p><code>BOOL SetPriorityClass(HANDLE hProcess, DWORD dwPriority)</code></p>
      <p><code>DWORD GetPriorityClass(HANDLE hProcess)</code></p>
     </cite>
     <p>Приоритеты потоков устанавливаются относительно базового приоритета процесса, и во время создания потока его приоритет устанавливается равным приоритету процесса. Приоритеты потоков могут принимать значения в интервале ±2 относительно базового приоритета процесса. Результирующим пяти значениям приоритета присвоены следующие символические имена:</p>
     <p>• THREAD_PRIORITY_LOWEST</p>
     <p>• THREAD_PRIORITY_BELOW_NORMAL</p>
     <p>• THREAD_PRIORITY_NORMAL</p>
     <p>• THREAD_PRIORITY_HIGHEST </p>
     <p>Для установки и выборки относительного приоритета потока следует использовать эти значения. Обратите внимание на использование целых чисел со знаком вместо чисел типа DWORD. </p>
     <cite>
      <p><code>BOOL SetThreadPriority(HANDLE hThread, int nPriority)</code></p>
      <p><code>int GetThreadPriority(HANDLE hThread)</code> </p>
     </cite>
     <p>Существуют два дополнительных значения приоритета потоков. Они являются абсолютными, а не относительными, и используются только в специальных случаях.</p>
     <p>• THREAD_PRIORITY_IDLE имеет значение 1 (или 16 — для процессов, выполняющихся в режиме реального времени).</p>
     <p>• THREAD_PRIORITY_TIME_CRITICAL имеет значение 15 (или 31 — для процессов, выполняющихся в режиме реального времени).</p>
     <p>Приоритеты потоков автоматически изменяются при изменении приоритета процесса. Помимо этого, ОС может регулировать приоритеты потоков динамическим путем на основании поведения потоков. Вы можете активизировать или отключить это средство с помощью функции SetThreadPriorityBoost.</p>
    </section>
    <section>
     <title>
      <p>Предостережение относительно использования<strong> приоритетов потоков и процессов</strong></p>
     </title>
     <p>Высокими приоритетами потоков и высокими классами приоритета процессов необходимо пользоваться с осторожностью. Следует решительно избегать использования приоритетов реального времени для обычных пользовательских процессов; эти приоритеты должны использоваться лишь в тех случаях, когда приложения действительно являются приложениями реального времени. Нарушение этого правила чревато тем, что пользовательские потоки будут тормозить выполнение потоков операционной системы.</p>
     <p>Кроме того, приводимые в последующих главах высказывания относительно корректности многопоточных программ справедливы лишь при условии соблюдения принципа <emphasis>равноправия</emphasis> (fairness) потоков. Равноправие потоков означает, что все они, в конечном счете, будут выполняться. Если не соблюдать этот принцип, то потоки с более низким приоритетом смогут удерживать ресурсы, необходимые потокам, имеющим более высокий приоритет. При описании недостатков планирования, осуществляемого с нарушением принципа равноправия, используют термины зависание потоков (thread starvation) и инверсия приоритетов (priority inversion). </p>
    </section>
   </section>
   <section>
    <title>
     <p>Состояния потоков</p>
    </title>
    <p>На рис. 7.4, взятом из [9] (см. также [38], версию, обновленную Соломоном (Solomon) и Руссиновичем (Russinovych)), представлена схема планирования потоков и показаны их возможные состояния. Кроме того, этот рисунок иллюстрирует результаты работы программы. Такие диаграммы состояния являются общими для всех многозадачных ОС и помогают выяснить, каким образом планируется выполнение потоков и как они переходят из одного состояния в другое. </p>
    <image l:href="#Any2FbImgLoader101"/>
    <p> <strong>Рис. 7.4.</strong> Состояния потоков и переходы между состояниями (Источник: <emphasis>Inside Windows NT,</emphasis> Copyright © 1993, by Helen Custer. Copyright Microsoft Press. Воспроизводится с разрешения Microsoft Press. Все права сохранены.)</p>
    <empty-line/>
    <p>Ниже приводится краткая сводка основных положений. Для получения более подробной информации по этому вопросу обратитесь в [38] или к руководству по ОС.</p>
    <p>• Поток находится в <emphasis>состоянии выполнения</emphasis> (running state), если она фактически выполняется процессором. В SMP-системах в состоянии выполнения могут находиться одновременно несколько потоков.</p>
    <p>• Планировщик переводит поток в <emphasis>состояние ожидания</emphasis> (wait state), если он выполняет функцию ожидания несигнализирующих объектов, например, потоков или процессов, или перехода в сигнальное состояние объектов синхронизации, о чем говорится в главе 8. Операции ввода/вывода также будут ожидать завершения передачи дисковых или иных данных, но ожидание может быть вызвано и другими многочисленными функциями. О потоках, находящихся в состоянии ожидания, нередко говорят как о <emphasis>блокированных</emphasis> (blocked) или <emphasis>спящих</emphasis> (sleeping).</p>
    <p>• Поток находится в <emphasis>состоянии готовности</emphasis> (ready state), если она может выполняться. Планировщик в любой момент может перевести такой поток в состояние выполнения. Когда процессор станет доступным, планировщик запустит тот из потоков, находящихся в состоянии готовности, который обладает наивысшим приоритетом, а при наличии нескольких потоков с одинаковым высшим приоритетом запущен будет та, который пребывал в состоянии готовности дольше всех. При этом поток проходит через <emphasis>состояние простоя</emphasis> (standby state), или <emphasis>резервное состояние.</emphasis></p>
    <p>• Обычно, в соответствии с приведенным описанием, планировщик помещает поток, находящийся в состоянии готовности, на любой доступный процессор. Программист может указать <emphasis>маску родства процессоров</emphasis> (processor affinity mask) для потока (см. главу 9), предоставляя потоку процессоры, на которых он может выполняться. Используя этот способ, программист может распределять процессоры между потоками. Соответствующими функциями являются SetProcessorAffinityMask и GetProcessorAffinityMask. Функция SetThreadIdealProcessor позволяет указать предпочтительный процессор, подлежащий использованию планировщиком при первой же возможности.</p>
    <p>• После истечения кванта времени, отведенного выполняющемуся потоку, планировщик без ожидания переводит его в состояние готовности. В результате выполнения функции Sleep(0) поток также будет переведен из состояния выполнения в состояние готовности.</p>
    <p>• Планировщик переводит ожидающий поток в состояние готовности сразу же, как только соответствующие дескрипторы оказываются в сигнальном состоянии, хотя при этом поток фактически проходит через промежуточное <emphasis>переходное состояние</emphasis> (transition state). В подобных случаях принято говорить о том, что поток <emphasis>пробуждается</emphasis> (wakes).</p>
    <p>• Не существует способа, позволяющего программе определить состояние другого потока (разумеется, если поток выполняется, то он находится в состоянии выполнения, и поэтому ему нет никакого смысла определять свое состояние). Даже если бы такой способ и существовал, то состояние потока может измениться еще до того, как опрашивающий поток успеет предпринять какие-либо действия в ответ на полученную информацию.</p>
    <p>• Поток, независимо от его состояния, может быть приостановлен (suspended), и приостановленный поток не будет запущен, даже если он находится в состоянии готовности. В случае приостановки выполняющегося потока, независимо от того, по собственной ли инициативе или по инициативе потока, выполняющегося на другом процессоре, он переводится в состояние готовности.</p>
    <p>• Поток переходит в <emphasis>состояние завершения</emphasis> (terminated state) тогда, когда его выполнение завершается, и остается в этом состоянии до тех пор, пока остается открытым хотя бы один из ее дескрипторов. Это позволяет другим потокам запрашивать состояние данного потока и его код завершения.</p>
   </section>
   <section>
    <title>
     <p>Возможные ловушки и распространенные ошибки</p>
    </title>
    <p>Существует ряд факторов, о которых следует всегда помнить при разработке многопоточных программ. Пренебрежение некоторыми базовыми принципами может привести к появлению серьезных дефектов в программе, и лучше заранее стремиться к тому, чтобы не допустить ошибок, чем впоследствии затрачивать время на тестирование и отладку программ.</p>
    <p>Существенно то, что потоки выполняются в асинхронном режиме. По отношению к ним не действует никакая система упорядочения, если только вы не создали ее явно. Именно асинхронное поведение потоков делает их столь полезными, однако при отсутствии должного внимания можно столкнуться с серьезными трудностями.</p>
    <p>Часть соответствующих рекомендаций представлена ниже, а остальные будут даваться по мере изложения материала в последующих главах.</p>
    <p>• Не делайте никаких предположений относительно очередности выполнения родительских и дочерних потоков. Вполне возможно, что дочерний поток будет выполняться вплоть до своего завершения, прежде чем родительский поток вернется из функции CreateThread, или наоборот, дочерний поток может вообще не выполняться в течение длительного периода времени. В случае же SMP-систем возможно параллельное выполнение родительского и одного или нескольких дочерних потоков.</p>
    <p>• Убедитесь в том, что до вызова функции CreateThread были завершены все действия по инициализации данных, необходимые для правильной работы дочернего потока, либо приостановите поток или же воспользуйтесь любой другой подходящей методикой. Несвоевременная инициализация данных, требуемых дочерним потоком, может создать "условия состязаний" ("race conditions"), суть которых заключается в том, что родительский поток "состязается" с дочерним, чтобы инициализировать данные до того, как они начнут использоваться дочерним потоком.</p>
    <p>• Проследите за тем, чтобы каждый отдельный поток имел собственную структуру данных, переданную ему через параметр функции потока. Не делайте никаких предположений относительно очередности завершения дочерних потоков (иначе можете столкнуться с другой разновидностью "проблемы состязаний").</p>
    <p>• Выполнение любого потока может быть прервано в любой момент, и точно так же выполнение любого потока в любой момент может быть возобновлено.</p>
    <p>• Не пользуйтесь приоритетами потоков в качестве замены явной синхронизации.</p>
    <p>• Никогда не прибегайте к аргументации наподобие "вряд ли это может произойти" при анализе корректности программы. Если что-то <emphasis>может</emphasis> произойти, оно <emphasis>обязательно</emphasis> произойдет, причем тогда, когда вы меньше всего этого ожидаете.</p>
    <p>• В еще большей степени, чем в случае однопоточных программ, справедливо утверждение о том, что, хотя тестирование и необходимо, но его одного еще не достаточно для проверки корректности многопоточной программы. Довольно часто программы способны успешно пройти через самые различные тесты, несмотря на наличие в них дефектов. Ничто не может заменить тщательно выполненных проектирования, реализации и анализа кода.</p>
    <p>• Поведение многопоточных программ может заметно меняться в зависимости от быстродействия и количества процессоров, версии ОС и множества других факторов. Тестирование программы в самых различных системах помогает выявлению всевозможных дефектов, но предыдущее предостережение остается в силе.</p>
    <p>• Убедитесь в том, что предусмотрели для потоков достаточно большой объем стека, хотя заданного по умолчанию стека размером 1 Мбайт в большинстве случаев вам должно хватить.</p>
    <p>• Потоки следует использовать только тогда, когда это действительно необходимо. Таким образом, если по самой своей природе некоторые операции допускают параллелизм, то каждое такое действие может быть представлено потоком. В то же время, если операциям присуща очередность, то потоки лишь усложнят программу, а связанный с ними расход системных ресурсов может привести к снижению производительности.</p>
    <p>• К счастью, чаще всего корректно работают самые простые программы и те, отличительной чертой которых является элегантность. При малейшей возможности избегайте усложнения программ.</p>
   </section>
   <section>
    <title>
     <p>Ожидание в течение конечного интервала времени</p>
    </title>
    <p>Наконец, рассмотрим функцию Sleep, позволяющую потоку отказаться от процессора и перейти из состояния выполнения в состояние ожидания, которое будет длиться в течение заданного промежутка времени. Например, выполнение задачи потоком может продолжаться в течение некоторого периода времени, после чего поток приостанавливается. По истечении периода ожидания планировщик вновь переводит поток в состояние готовности. Именно эта техника применена в одной из программ в главе 11 (программа 11.4). </p>
    <cite>
     <p><code>VOID Sleep(DWORD dwMilliseconds)</code> </p>
    </cite>
    <p>Длительность интервала ожидания указывается в миллисекундах, и одним из ее возможных значений является INFINITE, что соответствует бесконечному периоду ожидания, при котором выполнение приостанавливается на неопределенное время. Значению 0 соответствует отказ потока от оставшейся части отведенного ей временного промежутка; в этом случае ядро переводит поток из состояния выполнения в состояние готовности, как показано на рис. 7.4.</p>
    <p>Функция SwitchToThread предоставляет потоку еще один способ уступить процессор другому потоку из числа тех, которые находятся в состоянии готовности, если таковые имеются. </p>
    <cite>
     <p>UNIX-функция sleep аналогична функции Sleep, но длительность периода ожидания измеряется в секундах. Чтобы получить миллисекундное разрешение, используйте функции select или poll без дескрипторов файлов.</p>
    </cite>
   </section>
   <section>
    <title>
     <p>Облегченные потоки</p>
    </title>
    <cite>
     <p><strong>Примечание</strong></p>
     <p>Облегченные потоки относятся к специальной тематике. Ознакомьтесь с комментарием, включенным в конце первого абзаца приведенного ниже списка, и решите для себя, стоит ли вам читать данный раздел.</p>
    </cite>
    <p><emphasis>Облегченные потоки</emphasis> (fibers), как говорит само их название, являются элементами потока. Точнее, облегченный поток — это единица выполнения в контексте потока, планируемая приложением, а не ядром. В потоке могут быть запланированы несколько облегченных потоков, и облегченные потоки сами определяют, какой из них должен выполняться следующим. Облегченные потоки имеют независимые стеки, но во всем остальном выполняются исключительно в контексте потока, имея, например, доступ к TLS потока и любому мьютексу<a l:href="#n_27" type="note">[27]</a>, владельцем которого является данный поток. Более того, вся работа с облегченными потоками осуществляется вне ядра исключительно в пользовательском пространстве. Между потоками и облегченными потоками существуют многочисленные отличия.</p>
    <p>Облегченные потоки могут использоваться в нескольких целях. </p>
    <p>• Следует отметить тот немаловажный факт, что во многих приложениях, особенно в приложениях UNIX, использующих патентованные реализации потоков, которые в настоящее время можно, как правило, считать устаревшими, предусмотрено планирование собственных потоков. Использование облегченных потоков упрощает перенос таких приложений в среду Windows. <emphasis>Поскольку для большинства читателей этот вопрос не является актуальным, они, вероятно, предпочтут пропустить данный раздел.</emphasis></p>
    <p>• Потоки вовсе не обязательно должны блокироваться в ожидании блокировки файла, мьютекса, именованного входного канала или иных ресурсов. Вместо этого один облегченный поток может опрашивать ресурсы и, если эти ресурсы остаются недоступными, передавать управление другому указанному облегченному потоку.</p>
    <p>• Облегченные потоки действуют в контексте потока и имеют доступ к ресурсам потока и процесса. В отличии от потоков вытесняющее планирование к облегченным потокам не применяется. В действительности планировщику Windows об облегченных потоках ничего не известно; управление такими потоками осуществляется из DLL облегченных потоков исключительно в пользовательском пространстве.</p>
    <p>• Облегченные потоки позволяют реализовать механизм <emphasis>сопрограмм</emphasis> (co-routines), посредством которого приложение может переключаться между несколькими взаимосвязанными задачами. Добиться этого с помощью потоков невозможно, поскольку в распоряжении программиста нет средств, обеспечивающих непосредственное управление очередностью выполнения потоков.</p>
    <p>• Основные разработчики программного обеспечения, использующие облегченные потоки, представляют этот элемент как фактор повышения производительности. Так, в приложении Oracle Database 10g предусмотрена возможность переключения в "режим облегченных потоков" ("fiber mode") (см. http://download.oracle.com/owsf_2003/40171_colello.ppt; там же находится описание многопоточной модели).</p>
    <p>API облегченных потоков представлен шестью функциями. Порядок их использования описывается ниже и иллюстрируется рис. 7.5.</p>
    <p>1. Прежде всего, поток должен сделать возможным выполнение облегченного потока, вызвав функцию ConvertThreadToFiber. В результате этого поток становится облегченным потоком, который может рассматриваться в качестве <emphasis>основного</emphasis> (primary). Вызов упомянутой функции обеспечивает получение указателя на данные облегченного потока, который может быть использован во многом так же, как аргумент потока использовался для создания специфических для этого потока данных.</p>
    <p>2. Основной или другие облегченные потоки создают дополнительные облегченные потоки с помощью функции CreateFiber. Каждый облегченный поток характеризуется начальным адресом, размером стека и параметром. Каждый новый облегченный поток идентифицируется с помощью адреса, а не дескриптора.</p>
    <p>3. Отдельный облегченный поток может получить свои данные, назначенные ему функцией CreateFiber, обратившись к функции GetFiberData.</p>
    <p>4. Аналогично, облегченный поток может идентифицировать себя при помощи функции GetCurrentFiber.</p>
    <p>5. Выполняющийся облегченный поток может уступить управление другому облегченному потоку, указав его адрес в вызове функции SwitchToFiber. Облегченные потоки должны явно указывать очередной облегченный поток, который должен выполняться в контексте данного потока.</p>
    <p>6. Функция DeleteFiber уничтожает существующий облегченный поток и все относящиеся к нему данные.</p>
    <p>7. В Windows XP (NT 5.1) наряду с локальными областями хранения облегченных потоков введены новые функции, такие, например, как ConvertFiberToThread (которая освобождает ресурсы, созданные функцией ConvertThreadToFiber). </p>
    <image l:href="#Any2FbImgLoader102"/>
    <p><strong>Рис. 7.5.</strong> Передача управления между облегченными потоками внутри потока</p>
    <empty-line/>
    <p>Схема взаимодействия между облегченными потоками в контексте потока представлена на рис. 7.5. Этот пример иллюстрирует два способа вытеснения одного потока другим.</p>
    <p>• <strong>Подчиненное планирование (master-slave scheduling). </strong>Только один, главный (master) облегченный поток, в данном случае — основной, принимает решения относительно того, какой облегченный поток должен выполняться, и этот облегченный поток всегда уступает управление главному облегченный потоке. На рис. 7.5 главным является облегченный поток 1.</p>
    <p>• <strong>Равноправное планирование (peer-to-peer scheduling). </strong>Облегченный поток сам определяет, какой из других облегченных потоков должен выполняться следующим. Определение очередного облегченного потока может базироваться на таких стратегиях, как круговое планирование (round-robin scheduling), приоритетное планирование на основании схемы приоритетов и тому подобное. По принципу равноправного планирования реализуются сопрограммы. На рис. 7.5 такого типа передача управления осуществляется между облегченными потоками 0 и 2.</p>
   </section>
   <section>
    <title>
     <p>Резюме</p>
    </title>
    <section>
     <p>Windows поддерживает потоки, которые планируются независимо друг от друга, но разделяют адресное пространство и ресурсы одного и того же процесса. Потоки дают программисту возможность упростить программу и использовать параллелизм выполнения задач для повышения производительности приложения. Потоки могут обеспечивать выигрыш в производительности даже в однопроцессорных системах.</p>
    </section>
    <section>
     <title>
      <p>В следующих главах</p>
     </title>
     <p>Рассмотрение темы синхронизации, которое начинается в главе 8 с описания и сравнительного анализа объектов синхронизации Windows, продолжается в главах 9 и 10 обсуждением более сложных вопросов синхронизации с привлечением многочисленных примеров. В главе 11 реализуется сервер с многопоточной поддержкой; он показан на рис. 7.1.</p>
    </section>
    <section>
     <title>
      <p>Дополнительная литература</p>
     </title>
     <subtitle><emphasis>Windows</emphasis></subtitle>
     <p>Книга [1] полностью посвящена потокам Win32. Также заслуживают внимания книги [26] и [7]. В то же время во многих из этих и других книг не учтены новшества, появившиеся в Windows 2000, XP и Server 2003. </p>
     <subtitle><emphasis>UNIX и Pthreads</emphasis></subtitle>
     <p>В книге [40] применение потоков в UNIX не рассматривается, однако для изучения этой темы можно порекомендовать книгу [6]. В этой книге даются многочисленные рекомендации, касающиеся проектирования и реализации многопоточных программ. Приведенная в ней информация применима в равной степени как к потокам Pthreads, так и к потокам Windows, и многие примеры без труда переносятся в Windows. В ней также хорошо изложены модели "хозяин/рабочий", "клиент/сервер" и конвейерная модель, и представление Бутенхофа (Butenhof) было положено в основу описания указанных моделей в данной главе.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Упражнения</p>
    </title>
    <p>7.1. Реализуйте набор функций, позволяющий приостанавливать и возобновлять выполнение потоков, и, кроме того, получать значение счетчика приостановок потоков.</p>
    <p>7.2. Сравните производительность программ параллельного поиска, одна из которых использует потоки (программа 7.1, GrepMT), а другая — процессы (программа 6.1, GrepMP). Сравните полученные результаты с теми, которые приведены в приложении В.</p>
    <p>7.3. Проведите дополнительное исследование производительности программы GrepMT для случаев, когда файлы находятся на различных дисках или являются сетевыми файлами. Определите также выигрыш в производительности, если таковой будет наблюдаться, в случае SMP-систем.</p>
    <p>7.4. Измените программу 7.1, GrepMT, таким образом, чтобы она выводила результаты в той очередности, в какой файлы указаны в командной строке. Сказываются ли эти изменения каким-либо образом на показателях производительности?</p>
    <p>7.5. Дополнительно усовершенствуйте программу 7.1, GrepMT, таким образом, чтобы она выводила время, потребовавшееся для выполнения каждого из потоков. Для этого вам понадобится функция GetThreadTimes, аналогичная функции GetProcessTimes, которая была использована в главе 6. Указанное усовершенствование сможет работать лишь в Windows NT4 и более поздних версиях.</p>
    <p>7.6. На Web-сайте книги находится многопоточная программа подсчета слов, wcMT.c, структура которой аналогична структуре программы grepMT.c. Там же находится версия этой программы, wcMTx, в которую были намеренно введены некоторые дефекты. Попытайтесь найти и устранить указанные дефекты, в том числе и синтаксические ошибки, не сверяясь с корректным решением. Кроме того, создайте тестовые примеры, иллюстрирующие эти дефекты, и выполните эксперименты по определению производительно сти, аналогичные тем, которые предлагались для программы grepMT. На Web-сайте находится также однопоточная версия упомянутой программы, wcST.c, которую можно использовать для того, чтобы определить, обеспечивают ли потоки выигрыш в производительности по сравнению с последовательной обработкой.</p>
    <p>7.7. На Web-сайте находится программа grepMTx.c, в которой имеются дефекты, связанные с нарушением базовых правил, соблюдение которых необходимо для безопасного выполнения нескольких потоков. Опишите, к чему это приводит, а также найдите и устраните ошибки.</p>
    <p>7.8. Для правильного выполнения программы sortMT требуется, чтобы количество записей в массиве нацело делилось на количество потоков, а количество потоков равнялось степени 2. Устраните эти ограничения.</p>
    <p>7.9. Усовершенствуйте программу sortMT таким образом, чтобы в случаях, когда количество потоков, заданное в командной строке, равно 0, программа определяла количество процессоров, установленных в локальной системе, с помощью функции GetSystemInfo. Задавая количество потоков равным различным кратным количества процессоров (используя коэффициенты кратности 1, 2, 4 и так далее), определите, изменяется ли при этом производительность. </p>
    <p>7.10. Видоизмените программу sortMT таким образом, чтобы рабочие потоки не приостанавливались при их создании. Сказываются ли, и если да, то каким именно образом, возникающие при этом нежелательные условия состязаний на работе программы?</p>
    <p>7.11. В программе sortMT, еще до того, как создаются потоки, выполняющие сортировку, осуществляется считывание всего файла основным потоком. Видоизмените программу таким образом, чтобы каждый поток самостоятельно считывал необходимую часть файла.</p>
    <p>7.12. Видоизмените одну из приведенных в данной главе программ (grepMT или sortMT) таким образом, чтобы специфическая для потоков информация частично или полностью передавалась через TLS, а не через структуры данных.</p>
    <p>7.13. Наблюдается ли выигрыш в производительности в случае предоставления некоторым потокам в программе sortMT более высокого приоритета по сравнению со всеми остальными? Например, может оказаться выгодным предоставить таким потокам, как поток 3 на рис. 7.2, которая занята лишь сортировкой без слияния, более высокий приоритет, чем всем остальным. Объясните результаты.</p>
    <p>7.14. В программе sortMT все потоки создаются в приостановленном состоянии с той целью, чтобы избежать создания условий состязаний. Видоизмените эту программу таким образом, чтобы потоки создавались в обратном порядке и в состоянии выполнения. Продолжают ли после этого оставаться какие-либо предпосылки для существования условий состязаний? Сравните показатели производительности измененной и исходной версий программы. </p>
    <p>7.15. Алгоритм быстрой сортировки (Quicksort), обычно используемый функцией qsort библиотеки С, как правило, характеризуется высоким быстродействием, но в некоторых случаях может замедляться. В большинстве учебников по алгоритмам рассматривается его версия, которая работает быстрее всего в тех случаях, когда массив отсортирован в обратном порядке, и медленнее всего, когда массив является уже отсортированным. Однако реализация этого алгоритма в библиотеке Microsoft С ведет себя иначе. Определите из кода библиотечной программы, какого типа последовательности элементов массива будут приводить к наилучшим и наихудшим результатам, и исследуйте показатели производительности программы sortMT для этих двух крайних случаев. Как влияет на результаты увеличение или уменьшение количества потоков? <emphasis>Примечание.</emphasis> Исходный код библиотеки С мог быть установлен в подкаталоге CRT основного каталога Visual Studio на вашей машине. Ищите функцию qsort.с. Кроме того, вы можете попытаться отыскать эту функцию на установочном компакт-диске.</p>
    <p>7.16. На Web-сайте содержится программа sortMTx, в которую были намеренно внесены некоторые дефекты. Продемонстрируйте наличие дефектов на тестовых примерах, а затем объясните и устраните указанные дефекты, не сверяясь с корректными решениями. <emphasis>Предостережение.</emphasis> Версии программ, в которых присутствуют дефекты, могут содержать как синтаксические ошибки, так и ошибки в логике организации выполнения потоков.</p>
    <p>7.17. Прочитайте статью Джейсона Кларка (Jason Clark) "Waiting for More than 64 Objects" ("Ожидание более чем 64 объектов"), опубликованную в октябрьском номере журнала <emphasis>Windows Developer's Journal</emphasis> за 1997 год. Примените описанное в ней решение к программе grepMT. Найти старые выпуски журналов иногда бывает очень трудно, поэтому воспользуйтесь каким-нибудь поисковым механизмом для поиска сразу по нескольким ключевым словам. Мною для этого поиска была использована фраза "wait for multiple objects more than 64", хотя другие варианты могут оказаться более эффективными. </p>
   </section>
  </section>
  <section>
   <title>
    <p>ГЛАВА 8</p>
    <p>Синхронизация потоков</p>
   </title>
   <section>
    <p>Потоки могут упрощать проектирование и реализацию программ и повышать их производительность, но их использование требует принятия мер по защите разделяемых ресурсов от попыток их изменения одновременно несколькими потоками, а также создания таких условий, при которых потоки выполняются лишь в ответ на запрос или тогда, когда это является необходимым. В настоящей главе представлены способы решения этих задач с помощью объектов синхронизации Windows — критических участков кода, мьютексов, семафоров и событий, а также описаны некоторые из проблем, например, взаимоблокировка потоков и возникновение состязаний между ними, которые могут наблюдаться в результате неправильного использования потоков. Объекты синхронизации могут применяться для синхронизации потоков, принадлежащих как одному и тому же, так и различным процессам.</p>
    <p>Примеры иллюстрируют объекты синхронизации, а также создают почву для обсуждения как положительных, так и отрицательных аспектов применения тех или иных методов синхронизации на производительность. В последующих главах демонстрируется использование синхронизации для решения дополнительных задач программирования и повышения производительности программ, а также рассказывается о возможных ловушках и применении более развитых средств.</p>
    <p>Синхронизация потоков является одной из важнейших и интереснейших тем и играет существенную роль почти в любом многопоточном приложении. <emphasis>Тем не менее, те из читателей, которые заинтересованы главным образом в межпроцессном взаимодействии, сетевом программировании и построении серверов с многопоточной поддержкой, могут перейти непосредственно к главе 11 и вернуться к изучению глав 8-10 в качестве вспомогательного материала, лишь в том случае, если в этом возникнет необходимость.</emphasis></p>
   </section>
   <section>
    <title>
     <p>Необходимость в синхронизации потоков</p>
    </title>
    <section>
     <p>В главе 7 были продемонстрированы методы создания рабочих потоков и управления ими в условиях, когда каждый рабочий поток обращался к собственным ресурсам. В приведенных в главе 7 примерах каждый поток обрабатывает отдельный файл или отдельную область памяти, но даже и в этом случае возникает необходимость в простейшей синхронизации во время создания и завершения потоков. Так, в программе grepMT все рабочие потоки выполняются независимо друг от друга, но главный поток должен ожидать завершения рабочих потоков, прежде чем вывести сгенерированные ими результаты. Заметьте, что главный поток разделяет общую память с рабочими потоками, но структура программы гарантирует, что главный поток не получит доступа к памяти до тех пор, пока рабочий поток не завершит своего выполнения.</p>
     <p>Программа sortMT несколько сложнее, поскольку рабочие потоки должны синхронизировать свое выполнение, ожидая завершения смежных потоков, и не могут быть запущены до тех пор, пока главный поток не создаст все рабочие потоки. Как и в случае программы grepMT, синхронизация достигается за счет ожидания завершения одного или нескольких потоков.</p>
     <p>Однако во многих случаях требуется, чтобы выполнение двух и более потоков могло координироваться на протяжении всего времени жизни каждой из них. Например, несколько потоков могут обращаться к одной и той же переменной или набору переменных, и тогда возникает вопрос о взаимоисключающем доступе. В других случаях поток не может продолжать выполнение до тех пор, пока другой поток не достигнет определенного этапа выполнения. Каким образом программист может получить уверенность в том, что, например, два или более потоков не попытаются одновременно изменить данные, хранящиеся в глобальной памяти, такие, например, как статистические данные о производительности? Как, далее, программист может добиться того, чтобы поток не предпринимал попыток удаления элемента из очереди, если очередь не содержит хотя (бы одного элемента?</p>
     <p>Несколько примеров иллюстрируют ситуации, которые могут приводить к нарушению условий безопасного выполнения нескольких потоков. (Код считается безопасным в этом смысле, если он может выполняться одновременно несколькими потоками без каких-либо нежелательных последствий.) Условия безопасного выполнения потоков обсуждаются далее в этой и последующих главах.</p>
     <p>На рис. 8.1 показано, что может случиться, когда две несинхронизированные потоки разделяют общий ресурс, например ячейку памяти. Оба потока увеличивают значение переменной N на единицу, но в силу специфики очередности, в которой могут выполняться потоки, окончательное значение N равно 5, тогда как правильным значением является 6. Заметьте, что представленный здесь частный результат не обладает ни повторяемостью, ни предсказуемостью; другая очередность выполнения потоков могла бы привести к правильному результату. В SMP-системах эта проблема еще более усугубляется.</p>
    </section>
    <section>
     <title>
      <p>Критические участки кода</p>
     </title>
     <p>Инкрементирование N при помощи единственного оператора, например, в виде N++, не улучшает ситуацию, поскольку компилятор сгенерирует последовательность из одной или более машинных инструкций, которые вовсе не обязательно должны выполняться <emphasis>атомарно</emphasis> (atomically), то есть как одна неделимая единица выполнения.</p>
     <image l:href="#Any2FbImgLoader104"/>
     <p><strong>Рис. 8.1</strong>. Разделение общей памяти несинхронизированными потоками</p>
     <empty-line/>
     <p>Основная проблема состоит в том, что имеется <emphasis>критический участок кода</emphasis> (critical section) (в данном примере — код, который увеличивает N на 1), характеризующийся тем, что если один из потоков приступил к его выполнению, то никакой другой поток не должен входить в данный код до тех пор, пока его не покинет первый поток. Проблему критических участков кода можно считать разновидностью проблемы состязаний, поскольку первый поток "состязается" со вторым потоком в том, чтобы завершить выполнения критического участка еще до того, как его начнет выполнять любой другой поток. Таким образом, мы должны так синхронизировать выполнение потоков, чтобы можно было гарантировать, что в каждый момент времени код будет выполняться только одним потоком.</p>
     <subtitle><emphasis>Неудачные пути решения проблемы критических участков кода</emphasis></subtitle>
     <p>К аналогичным непредсказуемым результатам будет приводить и код, в котором предпринимается попытка защитить участок инкрементирования переменной путем опроса состояния флага.</p>
     <p><code>while (Flag) Sleep (1000);</code></p>
     <p><code>Flag = TRUE;</code></p>
     <p><code>N++;</code></p>
     <p><code>Flag = FALSE;</code></p>
     <p>Даже в этом случае поток может быть вытеснен в процессе выполнения программы от момента тестирования значения флага до момента, когда его значение будет установлено равным TRUE; критический участок кода образуют два оператора, которые не защищены должным образом от параллельного доступа к ним двух и более потоков.</p>
     <p>Другая разновидность попытки решения проблемы синхронизации выполнения потоками критического участка кода могла бы состоять в том, чтобы предоставить каждому потоку собственный экземпляр переменной N, например, так, как показано ниже:</p>
     <p><code>DWORD WINAPI ThFunc(TH_ARGS pArgs) {</code></p>
     <p><code> volatile DWORD N;</code></p>
     <p><code> … N++; … </code></p>
     <p><code>}</code></p>
     <p>Однако такой подход ничем не лучше предыдущего, поскольку каждый поток имеет собственный экземпляр переменной в своем стеке, но может, например, требоваться, чтобы N представляло суммарное число действующих потоков. В то же время, этот тип решения необходим в тех случаях, когда каждый поток должен иметь собственный, независимый от других потоков экземпляр переменной. Эта методика часто встречается в наших примерах.</p>
     <p>Заметьте, что проблемы подобного рода не ограничиваются случаем потоков одного процесса. С этими проблемами приходится сталкиваться также в случаях, когда два процесса разделяют общую память или изменяют один и тот же файл.</p>
     <subtitle><emphasis>Класс памяти volatile</emphasis></subtitle>
     <p>Даже если решить проблему синхронизации, все равно остается еще один скрытый дефект. Оптимизирующие компиляторы могут оставлять значение N в регистре, а не заносить его обратно в ячейку памяти, соответствующую переменной N. Попытка решения этой проблемы путем переустановки переключателей опций компилятора окажет отрицательное воздействие на скорость выполнения остальных участков программы. Правильное решение состоит в том, чтобы использовать определенный в стандарте ANSI С спецификатор памяти volatile, который гарантирует, что после изменения значения переменной оно будет сохраняться в памяти, а при необходимости будет всегда извлекаться из памяти. Ключевое слово volatile сообщает компилятору, что значение переменной может быть в любой момент изменено.</p>
    </section>
    <section>
     <title>
      <p>Функции взаимоблокировки</p>
     </title>
     <p>Если все, что требуется — это увеличение, уменьшение или обмен значениями переменных, как в нашем первом простом примере, то <emphasis>функций взаимоблокировки</emphasis> (interlocked functions) вам будет вполне достаточно. Функции взаимоблокировки проще в использовании, обеспечивают более высокое быстродействие по сравнению с другими возможными методами и не приводят к блокированию потоков. Двумя членами этого семейства функций, которые представляют для нас интерес, являются функции InterlockedIncrement и InterlockedDecrement. Обе функции применяются по отношению к 32-битовым целым числам со знаком.</p>
     <p>Эти функции имеют ограниченную область применимости, но будут использоваться нами при любой удобной возможности.</p>
     <p>Задача инкрементирования N, представленная на рис. 8.1, может быть реализована посредством единственной строки кода:</p>
     <p><code>InterlockedIncrement(&amp;N);</code></p>
     <p>N — это целое число типа long со знаком, и функция возвращает его новое значение, несмотря на то что другой поток мог изменить значение N еще до того, как поток, вызвавший функцию InterlockedIncrement, успеет воспользоваться возвращенным значением.</p>
     <p>Следует, однако, проявлять осторожность и, например, не вызывать эту функцию два раза подряд, если, значение переменной должно быть увеличено на 2, поскольку поток может быть вытеснен в промежутке между двумя вызовами функции. Вместо этого лучше воспользоваться функцией InterlockedExchangeAdd, описание которой приводится далее в настоящей главе.</p>
    </section>
    <section>
     <title>
      <p>Локальная и глобальная память</p>
     </title>
     <p>Суть другого требования, предъявляемого к корректному многопоточному коду, состоит в том, что глобальная память не должна использоваться для локальных целей. Так, применение функции ThFunc, приводившейся ранее в качестве примера, будет необходимым и уместным в тех случаях, когда поток должен располагать собственным экземпляром N. N может быть использовано для хранения временных результатов или размещения аргумента функции. Если же N размещается в глобальной памяти, то все процессы будут разделять единственный экземпляр N, что может стать причиной некорректного поведения программы, как бы тщательно вы ни планировали синхронизацию доступа к этой переменной. Ниже приводится пример подобного некорректного использования N. N должно быть локальной переменной, размещаемой в стеке функции потока.</p>
     <p><code>DWORD N;</code></p>
     <p><code>DWORD WINAPI ThFunc (TH_ARGS pArgs) {</code></p>
     <p><code> …</code></p>
     <p><code> N = 2 * pArgs-&gt;Count; …</code></p>
     <p><code>}</code></p>
    </section>
    <section>
     <title>
      <p>Резюме: безопасный многопоточный код</p>
     </title>
     <p>Прежде чем мы приступим к рассмотрению объектов синхронизации, ознакомьтесь с пятью начальными рекомендациями, соблюдение которых будет гарантировать корректное выполнение программ в многопоточной среде.</p>
     <p>1. Переменные, являющиеся локальными по отношению к потоку, не должны быть статическими, и их следует размещать в стеке потока или же в структуре данных или TLS, непосредственный доступ к которым имеет только отдельный поток.</p>
     <p>2. В тех случаях, когда функцию могут вызывать несколько потоков, а какой-либо специфический для состояния потока параметр, например счетчик, должен сохранять свое значение в течение промежутков времени, отделяющих один вызов функции от другого, значение параметра состояния должно храниться в TLS или в структуре данных, выделенной специально для этого потока, например, в структуре данных, передаваемой потоку при его создании. Использовать стек для сохранения постоянно хранимых (persistent) значений не следует. Применение необходимой методики при построении безопасных многопоточных DLL иллюстрируют программы 12.4 и 12.5.</p>
     <p>3. Старайтесь не создавать предпосылок для формирования условий состязаний наподобие тех, которые возникли бы в программе 7.2 (sortMT), если бы потоки не создавались в приостановленном состоянии. Если предполагается, что в определенной точке программы должно выполняться некоторое условие, используйте ожидание объекта синхронизации для гарантии того, что, например, дескриптор всегда будет ссылаться на существующий поток.</p>
     <p>4. Вообще говоря, потоки не должны изменять окружение процесса, поскольку это окажет воздействие на все потоки. Таким образом, поток не должен определять дескрипторы стандартного ввода и вывода или изменять переменные окружения. Это не касается только основного потока, который может вносить такие изменения до создания других потоков.</p>
     <p>5. Переменные, разделяемые всеми потоками, должны быть статическими или храниться в глобальной памяти, объявленной с использованием спецификатора volatile, а также должны быть защищены с использованием описанных ниже механизмов синхронизации.</p>
     <p>Объекты синхронизации обсуждаются в следующем разделе. Приведенных в нем объяснений вам будет достаточно для того, чтобы разработать простой пример системы "производитель/потребитель" (producer/consumer).</p>
    </section>
   </section>
   <section>
    <title>
     <p>Объекты синхронизации потоков</p>
    </title>
    <p>До сих пор нами были обсуждены только два механизма, обеспечивающие синхронизацию процессов и потоков друг с другом:</p>
    <p>1. Поток, выполняющийся в контексте одного процесса, может дожидаться завершения другого процесса с использованием функции ExitProcess путем применения к дескриптору процесса функций ожидания WaitForSingleObject или WaitForMultipleObject. Тем же способом поток может организовать ожидание завершения (с помощью функции ExitThread или выполнения оператора return) другого потока.</p>
    <p>2. Блокировки файлов, предназначенные для частного случая синхронизации доступа к файлам.</p>
    <p>Windows предоставляет четыре других объекта, предназначенных для синхронизации потоков и процессов. Три из них — мьютексы, семафоры и события — являются объектами ядра, имеющими дескрипторы. События используются также для других целей, например, для асинхронного ввода/вывода (глава 14).</p>
    <p>Мы начнем обсуждение с четвертого объекта, а именно, объекта критического участка кода CRITICAL_SECTION. В силу своей простоты и предоставляемых ими преимуществ в отношении производительности объекты критических участков кода являются предпочтительным механизмом, если их возможностей достаточно для того, чтобы удовлетворить требования программиста.</p>
    <p>В то же время, при этом возникают некоторые проблемы, связанные с производительностью, о чем говорится в главе 9.</p>
    <cite>
     <p><strong>Предостережение</strong></p>
     <p>Неправильное применение объектов критических участков кода порождает определенные риски. Эти риски, такие, например, как риск блокировки, описываются в этой и последующих главах наряду с изложением методик, предназначенных для разработки надежного кода. Однако прежде всего мы приведем некоторые примеры синхронизации в реалистических ситуациях.</p>
    </cite>
    <p>Рассмотрение двух других объектов синхронизации — таймеров ожидания и портов завершения ввода/вывода — отложено до главы 14. Эти типы объектов требуют использования методик асинхронного ввода/вывода Windows, которые описываются в указанной главе.</p>
   </section>
   <section>
    <title>
     <p>Объекты критических участковкода</p>
    </title>
    <section>
     <p>Как уже упоминалось ранее, объект критического участка кода — это участок программного кода, который каждый раз должен выполняться только одним потоком; параллельное выполнение этого участка несколькими потоками может приводить к непредсказуемым или неверным результатам.</p>
     <p>В качестве простого механизма реализации и применения на практике концепции критических участков кода Windows предоставляет объект CRITICAL_SECTION.</p>
     <p>Объекты CRITICAL_SECTION (CS) можно инициализировать и удалять, но они не имеют дескрипторов и не могут совместно использоваться другими процессами. Соответствующие переменные должны объявляться как переменные типа CRITICAL_SECTION. Потоки входят в объекты CS и покидают их, но выполнение кода отдельного объекта CS каждый раз разрешено только одному потоку. Вместе с тем, один и тот же поток может входить в несколько отдельных объектов CS и покидать их, если они расположены в разных местах программы.</p>
     <p>Для инициализации и удаления переменной типа CRITICAL_SECTION используются, соответственно, функции InitializeCriticalSection и DeleteCriticalSection: </p>
     <cite>
      <p><code>VOID InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection)</code> </p>
     </cite>
     <cite>
      <p><code>VOID DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)</code> </p>
     </cite>
     <p>Функция EnterCriticalSection блокирует поток, если на данном критическом участке кода присутствует другой поток. Ожидающий поток разблокируется после того, как другой поток выполнит функцию LeaveCriticalSection. Говорят, что поток <emphasis>получил права владения </emphasis>объектом CS, если произошел возврат из функции EnterCriticalSection, тогда как для уступки прав владения используется функция LeaveCriticalSection. <emphasis>Всегда следите за своевременной переуступкой прав владения объектами CS; несоблюдение этого правила может привести к тому, что другие потоки будут пребывать в состоянии ожидания в течение неопределенного времени даже после завершения выполнения потока-владельца.</emphasis></p>
     <p>Мы часто будем говорить о <emphasis>блокировании</emphasis> и <emphasis>разблокировании</emphasis> объектов CS, а вхождение в CS будет означать то же, что и блокирование CS. </p>
     <cite>
      <p><code>VOID EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)</code></p>
      <p><code>VOID LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)</code></p>
     </cite>
     <p>Поток, владеющий объектом CS, может повторно войти в этот же CS без его блокирования; это означает, что объекты CRITICAL_SECTION являются <emphasis>рекурсивными </emphasis>(recursive). Поддерживается счетчик вхождений в объект CS, и поэтому поток должен покинуть данный CS столько раз, сколько было вхождений в него, чтобы разблокировать этот объект для других потоков. Эта возможность может оказаться полезной для реализации рекурсивных функций и обеспечения безопасного многопоточного выполнения функций общих (разделяемых) библиотек.</p>
     <p>Выход из объекта CS, которым данный поток не владеет, может привести к непредсказуемым результатам, включая блокирование самого потока.</p>
     <p>Для возврата из функции EnterCriticalSection не существует конечного интервала ожидания; другие потоки будут блокированы на неопределенное время, пока поток, владеющий объектом CS, не покинет его. Однако, используя функцию TryEnterCriticalSection, можно тестировать (опросить) CS, чтобы проверить, не владеет ли им другой поток. </p>
     <cite>
      <p><code>BOOL TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)</code> </p>
     </cite>
     <p>Возврат функцией TryEnterCriticalSection значения True означает, что вызывающий поток приобрел права владения критическим участком кода, тогда как возврат значения False говорит о том, что данный критический участок кода уже принадлежит другого потока.</p>
     <p>Объекты CRITICAL_SECTION обладают тем преимуществом, что они не являются объектами ядра и поддерживаются в пользовательском пространстве. Обычно, но не всегда, это приводит к дополнительному улучшению показателей производительности. К обсуждению аспектов производительности мы вернемся после того, как ознакомимся с объектами синхронизации, относящимися к ядру.</p>
    </section>
    <section>
     <title>
      <p>Настройка спин-счетчика</p>
     </title>
     <p>Обычно, если в результате выполнения функции EnterCriticalSection поток обнаруживает, что объект CS уже принадлежит другому потоку, он входит в ядро и остается блокированным до тех пор, пока не освободится объект CRITICAL_SECTION, что требует определенного времени. Однако в SMP-системах вы можете потребовать, чтобы поток повторил попытку завладеть объектом CS, прежде чем блокироваться, поскольку существует вероятность того, что поток, владеющий CS, выполняется на другом процессоре и в любой момент может освободить CS. Это может оказаться полезным для повышения производительности, если между потоками наблюдается высокая состязательность за право владения единственным объектом CRITICAL_SECTION. Влияние упомянутых факторов на производительность обсуждается далее в этой и последующих главах.</p>
     <p>Для настройки счетчика занятости, или спин-счетчика (spin-count), предназначены две функции, одна из которых, SetCriticalSectionSpinCount, обеспечивает динамическую настройку счетчика, а вторая, InitializeCritical-SectionAndSpinCount, выступает в качестве замены функции Initialize-CriticalSection. Настройка спин-счетчика рассматривается в главе 9.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Использование объектов CRITICAL_SECTION для защиты разделяемыхпеременных</p>
    </title>
    <p>Использование объектов CRITICAL_SECTION не вызывает сложностей, и одним из наиболее распространенных способов их применения является обеспечение доступа потоков к разделяемым глобальным переменным. Рассмотрим, например, многопоточный сервер (аналогичный представленному на рис. 7.1), в котором необходимо вести учет следующих статистических данных:</p>
    <p>• Общее количество полученных запросов.</p>
    <p>• Общее количество отправленных ответов.</p>
    <p>• Количество запросов, обрабатываемых в настоящее время всеми потоками сервера. </p>
    <p>Поскольку переменные счетчиков являются глобальными переменными процесса, нельзя допустить того, чтобы одновременно два потока изменяли их значения. Один из методов обеспечения этого, базирующийся на применении объектов CRITICAL_SECTION, иллюстрирует схема, показанная ниже на рис. 8.2. Использование объектов CRITICAL_SECTION демонстрируется на примере программы 8.1, представляющей намного более простую систему, чем серверная.</p>
    <p>Объекты CS могут привлекаться для решения задач, аналогичных той, которую иллюстрирует рис. 8.1, где два потока увеличивают значение одной и той же переменной. Приведенный ниже фрагмент кода обеспечивает нечто большее, нежели простое увеличение переменной, поскольку для этого достаточно было бы воспользоваться функциями взаимоблокировки. Обратите внимание на спецификатор volatile, предотвращающий размещение текущего значения переменной оптимизирующим компилятором в регистре, а не в ячейке памяти, отведенной для хранения переменной. Кроме того, в этом примере используется промежуточная переменная; этот необязательный элемент снижает эффективность программы, однако позволяет более отчетливо продемонстрировать, каким образом решается задача, иллюстрируемая рис. 8.1.</p>
    <p><code>CRITICAL_SECTION cs1;</code></p>
    <p><code>volatile DWORD N = 0, М;</code></p>
    <p><code>/* N — глобальная переменная, разделяемая всеми потоками. */</code></p>
    <p><code>InitializeCriticalSection (&amp;cs1);</code></p>
    <p><code>…</code></p>
    <p><code>EnterCriticalSection (&amp;cs1);</code></p>
    <p><code>if (N &lt; N_MAX) { M = N; M += 1; N = M; } </code></p>
    <p><code>LeaveCriticalSection (&amp;cs1);</code></p>
    <p><code>…</code></p>
    <p><code>DeleteCriticalSection (&amp;cs1);</code></p>
    <p>На рис. 8.2 представлена одна из возможных последовательностей выполнения программы для случая, изображенного на рис. 8.1, и продемонстрировано, каким образом объекты CS упрощают решение проблемы синхронизации.</p>
    <p>Программа 8.1 демонстрирует, насколько полезными могут быть объекты CS.</p>
   </section>
   <section>
    <title>
     <p>Пример: простая система "производитель/потребитель"</p>
    </title>
    <section>
     <p>Программа 8.1 иллюстрирует, насколько полезными могут быть объекты CS. Кроме того, эта программа демонстрирует, как создаются защищенные структуры данных для хранения состояний объектов, и знакомит с понятием <emphasis>инварианта</emphasis> (invariant) — свойства состояния объекта, относительно которого гарантируется (путем соответствующей реализации программы), что оно будет истинным за пределами критического участка кода. </p>
     <image l:href="#Any2FbImgLoader106"/>
     <p><strong>Рис. 8.2.</strong> Разделение общей памяти синхронизированными потоками </p>
     <empty-line/>
     <p>Описание задачи приводится ниже.</p>
     <p>• Имеются два потока, <emphasis>производитель</emphasis> (producer) и <emphasis>потребитель</emphasis> (consumer), работающие в полностью асинхронном режиме.</p>
     <p>• Производитель периодически создает сообщения, содержащие таблицу чисел, например, таблицу биржевых котировок, которая периодически обновляется.</p>
     <p>• По требованию пользователя потребитель отображает текущие данные. Требуется, чтобы отображаемые данные представляли собой <emphasis>самый последний полный набор данных, но никакие данные не должны отображаться дважды.</emphasis></p>
     <p>• Данные не должны отображаться в те промежутки времени, когда они обновляются производителем; устаревшие данные также не должны отображаться. Обратите внимание на то, что многие сообщения вообще никогда не используются и, таким образом, "теряются". Этот пример является частным случаем конвейерной модели, в которой данные передаются из одного потока в другой.</p>
     <p>• В качестве средства контроля целостности данных производитель вычисляет простую контрольную сумму<a l:href="#n_28" type="note">[28]</a> данных таблицы, которая далее сравнивается с аналогичной суммой, вычисленной потребителем, дабы удостовериться в том, что данные не были повреждены при их передаче из одного потока в другой. Данные, полученные при обращении к таблице в моменты ее обновления, будут недействительными; использование объектов CS гарантирует, что этого никогда не произойдет. Инвариантом блока сообщения (message block invariant) является корректность контрольной суммы для содержимого текущего сообщения.</p>
     <p>• Обоими потоками поддерживается статистика суммарного количества отправленных, полученных и утерянных сообщений.</p>
     <subtitle>Программа 8.1.simplePC: простая система "производитель/потребитель"</subtitle>
     <p><code>/* Глава 8. simplePC.с */</code></p>
     <p><code>/* Поддерживает два потока — производителя и потребителя. */</code></p>
     <p><code>/* Производитель периодически создает буферные данные с контрольными */</code></p>
     <p><code>/* суммами, или "блоки сообщений", отображаемые потребителем по запросу */</code></p>
     <p><code>/* пользователя. */</code></p>
     <empty-line/>
     <p><code>#include "EvryThng.h" </code></p>
     <p><code>#include &lt;time.h&gt; </code></p>
     <p><code>#define DATA_SIZE 256</code></p>
     <empty-line/>
     <p><code>typedef struct msg_block_tag { /* Блок сообщения. */</code></p>
     <p><code> volatile DWORD f_ready, f_stop; /* Флаги готовности и прекращения сообщений. */</code></p>
     <p><code> volatile DWORD sequence; /* Порядковый номер блока сообщения. */</code></p>
     <p><code> volatile DWORD nCons, nLost;</code></p>
     <p><code> time_t timestamp;</code></p>
     <p><code> CRITICAL_SECTION mguard; /* Структура защиты блока сообщения. */</code></p>
     <p><code> DWORD checksum; /* Контрольная сумма содержимого сообщения. */</code></p>
     <p><code> DWORD data[DATA_SIZE]; /* Содержимое сообщения. */ </code></p>
     <p><code>} MSG_BLOCK;</code></p>
     <empty-line/>
     <p><code>/* Одиночный блок, подготовленный к заполнению новым сообщением. */ </code></p>
     <p><code>MSG_BLOCK mblock = { 0, 0, 0, 0, 0 };</code></p>
     <empty-line/>
     <p><code>DWORD WINAPI produce(void*); </code></p>
     <p><code>DWORD WINAPI consume(void*); </code></p>
     <p><code>void MessageFill(MSG_BLOCK*); </code></p>
     <p><code>void MessageDisplay(MSG_BLOCK*);</code></p>
     <empty-line/>
     <p><code>DWORD _tmain(DWORD argc, LPTSTR argv[]) {</code></p>
     <p><code> DWORD Status, ThId;</code></p>
     <p><code> HANDLE produce h, consume_h;</code></p>
     <p><code> /* Инициализировать критический участок блока сообщения. */</code></p>
     <p><code> InitializeCriticalSection (&amp;mblock.mguard);</code></p>
     <p><code> /* Создать два потока. */</code></p>
     <p><code> produce_h = (HANDLE)_beginthreadex(NULL, 0, produce, NULL, 0, &amp;ThId);</code></p>
     <p><code> consume_h = (HANDLE)_beginthreadex (NULL, 0, consume, NULL, 0, &amp;ThId); </code></p>
     <p><code> /* Ожидать завершения потоков производителя и потребителя. */</code></p>
     <p><code> WaitForSingleObject(consume_h, INFINITE);</code></p>
     <p><code> WaitForSingleObject(produce_h, INFINITE);</code></p>
     <p><code> DeleteCriticalSection(&amp;mblock.mguard);</code></p>
     <p><code> _tprintf(_T("Потоки производителя и потребителя завершили выполнение\n"));</code></p>
     <p><code> _tprintf(_T("Отправлено: %d, Получено: %d, Известные потери: %d\n"), mblock.sequence, mblock.nCons, mblock.nLost);</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>DWORD WINAPI produce(void *arg)</code></p>
     <p><code>/* Поток производителя — создание новых сообщений через случайные */</code></p>
     <p><code>/* интервалы времени. */</code></p>
     <p><code>{</code></p>
     <p><code> srand((DWORD)time(NULL)); /* Создать начальное число для генератора случайных чисел. */</code></p>
     <p><code> while (!mblock.f_stop) {</code></p>
     <p><code>  /* Случайная задержка. */</code></p>
     <p><code>  Sleep(rand() / 100);</code></p>
     <p><code>  /* Получить и заполнить буфер. */</code></p>
     <p><code>  EnterCriticalSection(&amp;mblock.mguard);</code></p>
     <p><code>  __try {</code></p>
     <p><code>   if (!mblock.f_stop) {</code></p>
     <p><code>    mblock.f_ready = 0;</code></p>
     <p><code>    MessageFill(&amp;mblock);</code></p>
     <p><code>    mblock.f_ready = 1;</code></p>
     <p><code>    mblock.sequence++;</code></p>
     <p><code>   }</code></p>
     <p><code>  } __finally { LeaveCriticalSection (&amp;mblock.mguard); }</code></p>
     <p><code> }</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>DWORD WINAPI consume (void *arg) {</code></p>
     <p><code> DWORD ShutDown = 0;</code></p>
     <p><code> CHAR command, extra;</code></p>
     <p><code> /* Принять ОЧЕРЕДНОЕ сообщение по запросу пользователя. */</code></p>
     <p><code> while (!ShutDown) { /* Единственный поток, получающий доступ к стандартным устройствам ввода/вывода. */</code></p>
     <p><code>  _tprintf(_T("\n**Введите 'с' для приема; 's' для прекращения работы: "));</code></p>
     <p><code>  _tscanf("%c%c", &amp;command, &amp;extra);</code></p>
     <p><code>  if (command == 's') {</code></p>
     <p><code>   EnterCriticalSection(&amp;mblock.mguard);</code></p>
     <p><code>   ShutDown = mblock.f_stop = 1;</code></p>
     <p><code>   LeaveCriticalSection(&amp;mblock.mguard);</code></p>
     <p><code>  } else if (command == 'c') { /* Получить новый буфер для принимаемых сообщений. */ </code></p>
     <p><code>   EnterCriticalSection(&amp;mblock.mguard); </code></p>
     <p><code>   __try {</code></p>
     <p><code>    if (mblock.f_ready == 0) _tprintf(_T("Новые сообщения отсутствуют. Повторите попытку.\n"));</code></p>
     <p><code>    else {</code></p>
     <p><code>     MessageDisplay(&amp;mblock);</code></p>
     <p><code>     mblock.nCons++;</code></p>
     <p><code>     mblock.nLost = mblock.sequence – mblock.nCons;</code></p>
     <p><code>     mblock.f_ready = 0; /* Новые сообщения отсутствуют. */</code></p>
     <p><code>    }</code></p>
     <p><code>   } __finally { LeaveCriticalSection (&amp;mblock.mguard); }</code></p>
     <p><code>  } else {</code></p>
     <p><code>   tprintf(_T("Такая команда отсутствует. Повторите попытку.\n"));</code></p>
     <p><code>  }</code></p>
     <p><code> }</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>void MessageFill(MSG_BLOCK *mblock) {</code></p>
     <p><code> /* Заполнить буфер сообщения содержимым, включая контрольную сумму и отметку времени. */</code></p>
     <p><code> DWORD i;</code></p>
     <p><code> mblock-&gt;checksum = 0;</code></p>
     <p><code> for (i = 0; i &lt; DATA_SIZE; i++) {</code></p>
     <p><code>  mblock-&gt;data[i] = rand();</code></p>
     <p><code>  mblock-&gt;checksum ^= mblock-&gt;data[i];</code></p>
     <p><code> }</code></p>
     <p><code> mblock-&gt;timestamp = time(NULL);</code></p>
     <p><code> return; </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>void MessageDisplay(MSG_BLOCK *mblock) {</code></p>
     <p><code> /* Отобразить буфер сообщения, отметку времени и контрольную сумму. */</code></p>
     <p><code> DWORD i, tcheck = 0;</code></p>
     <p><code> for (i = 0; i &lt; DATA_SIZE; i++) tcheck ^= mblock-&gt;data[i];</code></p>
     <p><code> _tprintf(_T("\nВремя генерации сообщения № %d: %s"), mblock-&gt;sequence, _tctime(&amp;(mblock-&gt;timestamp)));</code></p>
     <p><code> _tprintf(_T("Первая и последняя записи: %х %х\n"), mblock-&gt;data[0], mblock-&gt;data[DATA_SIZE – 1]);</code></p>
     <p><code> if (tcheck == mblock-&gt;checksum) _tprintf(_T("УСПЕШНАЯ ОБРАБОТКА –&gt;Контрольная сумма совпадает.\n"));</code></p>
     <p><code> else tprintf(_T("СБОЙ –&gt;Несовпадение контрольной суммы. Сообщение запорчено.\n"));</code></p>
     <p><code> return; </code></p>
     <p><code>}</code></p>
    </section>
    <section>
     <title>
      <p>Комментарии к примеру простой системы "производитель/потребитель"</p>
     </title>
     <p>Этот пример иллюстрирует некоторые моменты и соглашения, касающиеся программирования, которые будут важны для нас на протяжении этой и последующих глав.</p>
     <p>• Объект CRITICAL_SECTION является частью объекта (блока сообщения), защиту которого он обеспечивает.</p>
     <p>• Каждый доступ к сообщению осуществляется на критическом участке кода.</p>
     <p>• Типом переменных, доступ к которым осуществляется разными потоками, является volatile.</p>
     <p>• Использование обработчиков завершения гарантирует, что объекты CS будут обязательно освобождены. Хотя в данном случае эта методика и не является для нас существенной, она дополнительно гарантирует, что вызов функции LeaveCriticalSection не будет случайно опущен впоследствии при изменении кода программы. Имейте также в виду, что обработчик завершения ограничен использованием средств С, и его не следует использовать совместно с C++.</p>
     <p>• Функции MessageFill и MessageDisplay вызываются лишь на критических участках кода и используют для нужд своих вычислений не глобальную, а локальную память. Кстати, обе они будут применяться и в последующих примерах, но их листинги больше приводиться не будут.</p>
     <p>• Не существует удобного способа, при помощи которого поток производителя мог бы известить поток потребителя о наличии нового сообщения, и поэтому поток потребителя должен просто ожидать, пока не будет установлен флаг готовности, который используется для индикации появления нового сообщения. Устранить этот недостаток нам помогут объекты событий ядра.</p>
     <p>• Одним из инвариантных свойств, которые гарантируются этой программой, является то, что контрольная сумма блока сообщения будет всегда корректной <emphasis>вне</emphasis> критических участков кода. Другим инвариантным свойством является следующее:</p>
     <p><code>0 &lt;= nLost + nCons &lt;= sequence</code></p>
     <p>Об этом важном свойстве далее еще будет идти речь.</p>
     <p>• О необходимости прекращения передачи поток производителя узнает лишь после проверки флага, устанавливаемого в блоке сообщения потока потребителя. Поскольку потоки не могут обмениваться между собой никакими сигналами, а вызов функции TerminateThread чреват нежелательными побочными эффектами, эта методика является простейшим способом остановки другого потока. Разумеется, чтобы эта методика была эффективной, работа потоков должна быть скоординированной. В то же время, подобное решение требует, чтобы поток не блокировался, иначе он не сможет тестировать флаг; способы решения проблемы блокированных потоков обсуждаются в главе 10.</p>
     <p>Объекты CRITICAL_SECTION предоставляют в наше распоряжение мощный механизм синхронизации, но, тем не менее, они не в состоянии обеспечить всю полноту необходимых функциональных возможностей. О невозможности отправки сигналов одним потоком другому уже говорилось, кроме того, эти объекты не позволяют воспользоваться конечными интервалами ожидания (time-out). Объекты синхронизации ядра Windows позволяют снизить остроту не только этих, но и других ограничений.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Мьютексы</p>
    </title>
    <section>
     <p>Объект <emphasis>взаимного исключения</emphasis> (mutual exception), или <emphasis>мьютекс</emphasis> (mutex), обеспечивает более универсальную функциональность по сравнению с объектом CRITICAL_SECTION. Поскольку мьютексы могут иметь имена и дескрипторы, их можно использовать также для синхронизации потоков, принадлежащих различным процессам. Так, два процесса, разделяющие общую память посредством отображения файлов, могут использовать мьютексы для синхронизации доступа к разделяемым областям памяти.</p>
     <p>Объекты мьютексов аналогичны объектам CS, однако, дополнительно к возможности их совместного использования различными процессами, они допускают конечные периоды ожидания, а мьютексы, <emphasis>покинутые</emphasis> (abandoned) завершающимся процессом, переходят в сигнальное состояние.<a l:href="#n_29" type="note">[29]</a> Поток приобретает права владения мьютексом (или <emphasis>блокирует</emphasis> (block) мьютекс) путем вызова функции ожидания (WaitForSingleObject или WaitForMultipleObjects) по отношению к дескриптору мьютекса и уступает эти права посредством вызова функции ReleaseMutex.</p>
     <p>Как всегда, необходимо тщательно следить за тем, чтобы потоки своевременно освобождали ресурсы, в которых они больше не нуждаются. Поток может завладевать одним и тем же ресурсом несколько раз, и при этом не будет блокироваться даже в тех случаях, когда уже владеет данным ресурсом. В конечном счете, поток должен освободить мьютекс столько раз, сколько она его захватывала. Такая возможность рекурсивного захвата ресурсов, существующая и в случае объектов CS, может оказаться полезной для ограничения доступа к рекурсивным функциям, а также в приложениях, реализующих вложенные транзакции (nested transactions).  </p>
     <p>При работе с мьютексами мы будем пользоваться функциями CreateMutex, ReleaseMutex и OpenMutex.</p>
     <cite>
      <p><code>HANDLE CreateMutex(LPSECURITY_ATTRIBUTES lpsa, BOOL bInitialOwner, LPCTSTR lpMutexName)</code></p>
      <p><code>BOOL ReleaseMutex(HANDLE hMutex)</code></p>
     </cite>
     <p>bInitialOwner — если значение этого флага установлено равным True, вызывающий поток немедленно приобретает права владения новым мьютексом. Эта атомарная операция позволяет предотвратить приобретение прав владения мьютексом другими потоками, прежде чем это сделает поток, создающий мьютекс. Как следует из самого его названия (initial owner — исходный владелец), этот флаг не оказывает никакого действия, если мьютекс уже существует.</p>
     <p>lpMutexName — указатель на строку, содержащую имя мьютекса; в отличие от файлов имена мьютексов чувствительны к регистру. Если этот параметр равен NULL, то мьютекс создается без имени. События, мьютексы, семафоры, отображения файлов и другие объекты ядра, упоминаемые в данной книге, — все они используют одно и то же пространство имен, отличное от пространства имен файловой системы. Поэтому имена всех объектов синхронизации должны быть различными. Длина указанных имен не может превышать 260 символов.</p>
     <p>Возвращаемое значение имеет тип HANDLE; значение NULL указывает на неудачное завершение функции.</p>
     <p>Функция OpenMutex открывает существующий именованный мьютекс. Впоследствии эта функция не обсуждается, но используется в некоторых примерах. Эта функция дает возможность потокам, принадлежащим различным процессам, синхронизироваться так, как если бы они принадлежали одному и тому же процессу. Вызову функции OpenMutex в одном процессе должен предшествовать вызов функции CreateMutex в другом процессе. Для семафоров и событий, как и для отображенных файлов (глава 5), также имеются соответствующие функции Create и Open. При вызове этих функций всегда предполагается, что сначала один процесс, например сервер, вызывает функцию Create для создания именованного объекта, а затем другие процессы вызывают функцию Open, которая завершается неудачей, если именованный объект к этому моменту еще не был создан. Возможен и такой вариант, когда все процессы самостоятельно используют вызов функции Create с одним и тем же именем, если порядок создания объектов не имеет значения.</p>
     <p>Функция ReleaseMutex освобождает мьютекс, которым владеет вызывающий поток. Если мьютекс не принадлежит потоку, функция завершается с ошибкой. </p>
     <cite>
      <p><code>BOOL ReleaseMutex(HANDLE hMutex)</code> </p>
     </cite>
     <cite>
      <p>Спецификация POSIX Pthreads поддерживает мьютексы. Имеются следующие основные функции:</p>
      <p><code>• pthread_mutex_init</code></p>
      <p><code>• pthread_mutex_destroy</code></p>
      <p><code>• pthread_mutex_lock</code></p>
      <p><code>• pthread_mutex_unlock</code></p>
      <p>Функция pthread_mutex_lock является блокирующей и поэтому эквивалентна функции WaitForSingleObject в случае ее применения к дескриптору мьютекса. Функция pthread_mutex_trylock осуществляет опрос и не является блокирующей, соответствуя функции WaitForSingleObject в случае ее применения с нулевым значением интервала ожидания. Потоки Pthreads не поддерживают конечные интервалы ожидания и не предлагают средств, аналогичных Windows-объектам CRITICAL_SECTION.</p>
     </cite>
    </section>
    <section>
     <title>
      <p>Покинутые мьютексы</p>
     </title>
     <p>Мьютекс, владевший которым поток завершился, не освободив его, называют <emphasis>покинутым</emphasis> (abandoned), и его дескриптор переходит в сигнальное состояние. На то, что сигнализирующий дескриптор (дескрипторы) представляет покинутый мьютекс (мьютексы), указывает возврат функцией WaitForSingleObject значения WAIT_ABANDONED_0 или использование значения WAIT_ABANDONED_0 в качестве базового значения функцией WaitForMultipleObject.</p>
     <p>То, что дескрипторы покинутых мьютексов переходят в сигнальное состояние, является весьма полезным их свойством, недоступным в случае объектов CS. Обнаружение покинутого мьютекса может означать наличие дефекта в коде, организующем работу потоков, поскольку потоки должны программироваться таким образом, чтобы ресурсы всегда освобождались, прежде чем поток завершит свое выполнение. Возможно также, что выполнение данного потока было прервано другим потоком.</p>
    </section>
    <section>
     <title>
      <p>Мьютексы, критические участки кода и взаимоблокировки</p>
     </title>
     <p>Несмотря на то что объекты CS и мьютексы обеспечивают решение задач, подобных той, которая иллюстрируется на рис. 8.1, при их использовании следует соблюдать осторожность, иначе можно создать ситуацию <emphasis>взаимоблокировки</emphasis> (deadlock), в которой каждый из двух потоков ждет освобождения ресурсов, принадлежащих другому потоку.</p>
     <p>Взаимоблокировки являются одним из наиболее распространенных и коварных дефектов синхронизации и часто возникают, когда должны быть одновременно блокированы (lock) два и более мьютекса. Рассмотрим следующую задачу:</p>
     <p>• Имеется два связных списка, список А и список В, каждый из которых содержит идентичные структуры и поддерживается рабочими потоками. </p>
     <p>• Для одного класса элементов списка корректность операции зависит от того факта, что данный элемент X находится или отсутствует одновременно в обоих списках. Здесь мы имеем дело с инвариантом, который неформально можно выразить так: "X либо находится в обоих списках, либо не находится ни в одном из них".</p>
     <p>• В других ситуациях допускается нахождение элемента только в одном из списков, но не в обоих одновременно. <emphasis>Мотивация.</emphasis> Указанными списками могут быть списки сотрудников отделов А и В, когда некоторым сотрудникам разрешена работа одновременно в двух отделах.</p>
     <p>• В связи с вышеизложенным для обоих списков требуются различные мьютексы (объекты CS), но при добавлении или удалении общих элементов списков блокироваться должны одновременно оба мьютекса. Использование только одного мьютекса оказало бы отрицательное влияние на производительность, препятствуя независимому параллельному обновлению двух списков, поскольку мьютекс оказался бы "слишком большим".</p>
     <p>Ниже приведен пример возможной реализации функций рабочего потока, предназначенных для добавления и удаления общих элементов списков:</p>
     <p><code>static struct {</code></p>
     <p><code> /* Инвариант: действительность списка. */</code></p>
     <p><code> HANDLE guard; /* Дескриптор мьютекса. */</code></p>
     <p><code> struct ListStuff;</code></p>
     <p><code> } ListA, ListB;</code></p>
     <p><code>…</code></p>
     <p><code>DWORD WINAPI AddSharedElement(void *arg) /* Добавляет общий элемент в списки А и В. */</code></p>
     <p><code>{ /* Инвариант: новый элемент либо находится в обоих списках, либо не находится ни в одном из них. */</code></p>
     <p><code> WaitForSingleObject(ListA.guard, INFINITE);</code></p>
     <p><code> WaitForSingleObject(ListB.guard, INFINITE);</code></p>
     <p><code> /* Добавить элемент в оба списка … */</code></p>
     <p><code> ReleaseMutex(ListB.guard);</code></p>
     <p><code> ReleaseMutex(ListA.guard);</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <p><code>DWORD WINAPI DeleteSharedElement(void *arg) /* Удаляет общий элемент из списков А и В. */ </code></p>
     <p><code>{</code></p>
     <p><code> WaitForSingleObject(ListB.guard, INFINITE);</code></p>
     <p><code> WaitForSingleObject(ListA.guard, INFINITE);</code></p>
     <p><code> /* Удалить элемент из обоих списков … */</code></p>
     <p><code> ReleaseMutex(ListB.guard);</code></p>
     <p><code> ReleaseMutex(ListA.guard);</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code> </p>
     <p>С учетом ранее данных рекомендаций этот код выглядит вполне корректным. Однако вытеснение потока AddSharedElement сразу же после того, как он блокирует список А, и непосредственно перед тем, как он попытается заблокировать список В, приведет к взаимоблокировке потоков, если поток DeleteSharedElement начнет выполняться до того, как возобновится выполнение потока AddSharedElement. Каждый из потоков владеет мьютексом, который необходим другому потоку, и ни один из потоков не может перейти к вызову функции ReleaseMutex, который разблокировал бы другой поток.</p>
     <p>Обратите внимание, что взаимоблокировка по сути дела является еще одной разновидностью состязаний, поскольку каждый из потоков состязается с другим за право первым овладеть всеми своими мьютексами.</p>
     <p>Один из способов, позволяющих избежать взаимоблокировки, заключается в применении метода "проб и ошибок", когда поток вызывает функцию WaitForSingleObject с конечным интервалом ожидания, и если оказывается, что мьютекс уже принадлежит другому потоку, то первый поток уступает процессор или "засыпает" на короткое время, а затем вновь повторяет попытку. Намного лучше и эффективнее с самого начала проектировать программу таким образом, чтобы исключить саму возможность возникновения взаимоблокировок, о чем говорится ниже.</p>
     <p>Гораздо более простой метод, который описывается почти в любом учебнике по ОС, заключается в предварительном определении "иерархии мьютексов" и программировании потоков таким образом, чтобы захват ими мьютексов осуществлялся в строгом соответствии с заданным иерархическим порядком, а освобождение — в обратном порядке. Эта иерархия может устанавливаться произвольно или естественным образом определяться структурой самой задачи, но в любом случае ее должны придерживаться все потоки. В данном примере лишь требуется, чтобы функция удаления мьютекса поочередно ожидала освобождения списков А и В, и тогда взаимоблокировка потоков никогда не случится, если указанная иерархическая очередность будет соблюдаться всеми потоками в любом месте программы.</p>
     <p>Еще одним действенным методом снижения риска взаимоблокировки является размещение двух дескрипторов мьютексов в массиве и использование функции WaitForMultipleObjects с флагом fWaitAll, значение которого установлено равным True, вследствие чего поток в результате выполнения одной атомарной операции будет захватывать либо оба мьютекса, либо ни одного. В случае использования объектов CRITICAL_SECTION описанная методика неприменима.</p>
    </section>
    <section>
     <title>
      <p>Сравнительный обзор: мьютексы и объекты CRITICAL_SECTION</p>
     </title>
     <p>Как уже неоднократно упоминалось, мьютексы и объекты CRITICAL_SECTION весьма напоминают друг друга и предназначены для решения одного и того же круга задач. В частности, объекты обоих типов могут принадлежать только одного потока, и если объектом, которым уже владеет какой-либо поток, пытаются завладеть другие потоки, то они будут блокированы до тех пор, пока объект не освободится. Мьютексы могут обеспечивать большую гибкость, однако достигается это лишь за счет ухудшения производительности. В заключение перечислим наиболее важные отличия, существующие между указанными двумя типами объектов синхронизации.</p>
     <p>• Мьютексы, покинутые завершающимися потоками, переходят в сигнальное состояние, в результате чего другие потоки не будут блокироваться на неопределенное время.</p>
     <p>• Имеется возможность организовать ожидание мьютекса с использованием конечного интервала ожидания, тогда как в случае объектов CS возможен только опрос их состояния.</p>
     <p>• Мьютексам можно присваивать имена, и их могут совместно использовать потоки, принадлежащие разным процессам.</p>
     <p>• К мьютексам применима функция WaitForMultipleObjects, что не только удобно с точки зрения программирования, но и позволяет избежать взаимоблокировки потоков при надлежащей организации программы.</p>
     <p>• Поток, создающий мьютекс, может сразу же указать, что он становится его владельцем. В случае объектов CS за право владения объектом могут состязаться несколько потоков.</p>
     <p>• Обычно, хотя и не всегда, использование объектов CS обеспечивает более высокую производительность по сравнению с той, которая достигается при использовании мьютексов. Этот вопрос более подробно обсуждается в главе 9.</p>
    </section>
    <section>
     <title>
      <p>Синхронизация куч</p>
     </title>
     <p>В NT для синхронизации доступа к кучам (глава 5) предусмотрены две функции — HeapLock и HeapUnlock. В каждой из этих функций единственным аргументом является дескриптор. Эти функции удобно применять в тех случаях, когда используется флаг HEAP_NO_SERIALIZE, или когда потоку необходимы права исключительного доступа к куче.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Семафоры</p>
    </title>
    <section>
     <p>Объекты второго из трех упомянутых в начале главы типов объектов синхронизации ядра — <emphasis>семафоры</emphasis> (semaphores), поддерживают счетчики, и когда значение этого счетчика больше 0, объект семафора находится в сигнальном состоянии. Если же значение счетчика становится нулевым, объект семафора переходит в несигнальное состояние.</p>
     <p>Потоки и процессы организуют ожидание обычным способом, используя для этого одну или несколько функций ожидания. При разблокировании ожидающего потока значение счетчика уменьшается на 1. </p>
     <p>К функциям управления семафорами относятся CreateSemaphore, OpenSemaphore и ReleaseSemaphore, причем последняя функция может инкрементировать значение счетчика на 1 и более. Эти функции аналогичны своим эквивалентам, предназначенным для управления мьютексами. </p>
     <cite>
      <p><code>HANDLE CreateSemaphore(LPSECURITY_ATTRIBUTES lpsa, LONG lSemInitial, LONG lSemMax, LPCTSTR lpSemName)</code> </p>
     </cite>
     <p>Параметр lSemMax, значение которого должно быть равным, по крайней мере, 1, определяет максимально допустимое значение счетчика семафора. Параметр lSemInitial — начальное значение этого счетчика, которое должно удовлетворять следующему условию: 0&#8804; lSemInitial&#8804; lSemMax и никогда не должно выходить за пределы указанного диапазона. Возвращение функцией значения NULL указывает на ее неудачное выполнение.</p>
     <p>Каждая отдельная операция ожидания может уменьшить значение счетчика только на 1, но с помощью функции ReleaseSemaphore значение его счетчика может быть увеличено до любого значения вплоть до максимально допустимого. </p>
     <cite>
      <p><code>BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG cReleaseCount, LPLONG lpPreviousCount)</code> </p>
     </cite>
     <p>Обратите внимание на возможность получения предыдущего значения счетчика, определяемого указателем lpPreviousCount, которое он имел до освобождения объекта синхронизации при помощи функции ReleaseSemaphore, но если необходимости в этом нет, то значение упомянутого указателя следует установить равным NULL.</p>
     <p>Число, прибавляемое к счетчику семафора (cReleaseCount), должно быть больше 0, но если выполнение функции ReleaseSemaphore приводит к выходу значения счетчика за пределы допустимого диапазона, то она завершается с ошибкой, возвращая значение FALSE, а значение счетчика семафора остается неизменным. Предыдущим значением счетчика следует пользоваться с осторожностью, поскольку оно могло быть изменено другими потоками. Кроме того, невозможно определить, достиг ли счетчик максимально допустимого значения, поскольку не предусмотрено средство, отслеживающее увеличение счетчика в результате его освобождения. Пример использования предыдущего значения счетчика семафора приведен на Web-сайте книги.</p>
     <p>Как ни соблазнительно пытаться рассматривать мьютекс как частный случай семафора, значение счетчика которого задано равным 1, это было бы заблуждением ввиду отсутствия понятия прав владения семафором. Семафор может быть освобожден любым потоком, а не только тем, который ожидает. Точно так же, поскольку нельзя говорить о правах владения семафором, отсутствует и понятие покинутого семафора.</p>
    </section>
    <section>
     <title>
      <p>Использование семафоров</p>
     </title>
     <p>Классической областью применения семафоров является управление распределением конечных ресурсов, когда значение счетчика семафора ассоциируется с определенным количеством доступных ресурсов, например, количеством сообщений, находящихся в очереди. Тогда максимальное значение счетчика соответствует максимальному размеру очереди. Таким образом, производитель помещает сообщение в буфер и вызывает функцию ReleaseSemaphore, обычно с увеличением значения счетчика на 1 (cReleaseCount). Потоки потребителя будут ожидать перехода семафора в сигнальное состояние, получая сообщения и уменьшая значения счетчика.</p>
     <p>Вслед за рассмотрением программы 9.1 обсуждается другой важный случай применения семафоров, когда они используются для ограничения количества рабочих потоков, фактически выполняющихся в любой момент времени, что позволяет снизить состязательность между ними, а в некоторых случаях — повысить производительность. Эта методика, в которой используются дроссели семафоров (semaphore throttles), обсуждается в главе 9.</p>
     <p>Опасность возникновения условий состязаний в программе sortMT (программа 7.2) иллюстрирует другое возможное применение семафоров, связанное с управлением точным количеством потоков, которые должны находиться в пробужденном состоянии. Можно создать все потоки, не приостанавливая их. После этого все они сразу же переходят к ожиданию перехода в сигнальное состояние семафора, инициализированного значением 0. Далее, главный поток вместо того, чтобы освобождать потоки, просто вызывает функцию ReleaseCount с увеличением счетчика, например, на 4 (или на любое другое значение, соответствующее количеству потоков), в результате чего возможность выполняться получат четыре потока.</p>
     <p>Несмотря на все удобства, которые сулит использование семафоров, они являются в некотором смысле излишними в том смысле, что мьютексы и события (описанные в одном из следующих разделов), при условии их совместного использования, предлагают гораздо более широкие возможности, чем семафоры. Более подробная информация по этому поводу содержится в главе 10.</p>
    </section>
    <section>
     <title>
      <p>Ограниченность семафоров</p>
     </title>
     <p>В Windows существуют важные ограничения, касающиеся реализации семафоров. Например, каким образом поток может потребовать, чтобы счетчик семафора уменьшился на 2? Для этого поток мог бы организовать ожидание два раза подряд, как показано ниже, но эта операция не была бы атомарной, поскольку в промежутке между двумя вызовами функции ожидания данный поток может быть вытеснен. В результате этого, как описывается ниже, может наступить взаимоблокировка (deadlock) потоков.</p>
     <p><code>/* hsem – дескриптор семафора. Максимальное значение счетчика семафора равно 2. */</code></p>
     <p><code>…</code></p>
     <p><code>/* Уменьшить значение счетчика семафора на 2. */ </code></p>
     <p><code>WaitForSingleObject(hSem, INFINITE); </code></p>
     <p><code>WaitForSingleObject(hSem, INFINITE);</code></p>
     <p><code>…</code></p>
     <p><code>/* Увеличить значение счетчика семафора на 2. */ </code></p>
     <p><code>ReleaseSemaphore(hSem, 2, &amp;PrevCount);</code></p>
     <p>Чтобы увидеть, каким образом в подобной ситуации может возникнуть взаимоблокировка, предположим, что максимальное и начальное значения счетчика устанавливаются равными 2 и что первый из двух потоков завершает первый цикл ожидания, а затем вытесняется. Далее второй поток может завершить первый цикл ожидания и уменьшить значение счетчика до 0. Оба потока окажутся блокированными на неопределенное время, поскольку ни одна из них не сможет выполнить второй цикл ожидания. Такая простая ситуация взаимоблокировки является довольно типичной.</p>
     <p>Один из возможных вариантов правильного решения заключается в том, чтобы защитить циклы ожидания при помощи мьютекса или объекта CRITI-CAL_SECTION, как показано в приведенном ниже фрагменте программного кода:</p>
     <p><code>/* Уменьшаем значение счетчика семафора на 2. */ </code></p>
     <p><code>EnterCriticalSection(&amp;csSem); </code></p>
     <p><code>WaitForSingleObject(hSem, INFINITE); </code></p>
     <p><code>WaitForSingleObject(hSem, INFINITE); </code></p>
     <p><code>LeaveCriticalSection (&amp;csSem);</code></p>
     <p><code>…</code></p>
     <p><code>ReleaseSemaphore(hSem, 2, &amp;PrevCount);</code></p>
     <p>Но и эта реализация, в таком общем виде, страдает ограничениями. Предположим, например, что в счетчике семафора остается две единицы, и потоку А необходимы три единицы, а потоку В — только две. Если первой начнет выполняться поток А, то он выполнит два цикла ожидания и блокируется на третьем, продолжая владеть мьютексом. При этом поток В, которому были необходимы только две единицы, по-прежнему будет оставаться блокированным.</p>
     <p>Казалось бы, можно воспользоваться функцией WaitForMultipleObjects с использованием одного и того же дескриптора семафора в нескольких элементах массива дескрипторов. Однако такое предложение было бы неудачным по двум причинам. Прежде всего, обнаружив, что два дескриптора указывают на один и тот же объект, функция WaitForMultipleObjects завершится с ошибкой. Более того, даже если значение счетчика семафора будет составлять только 1, сигнализироваться будут все дескрипторы, что противоречит самой исходной цели.</p>
     <p>Полное решение проблемы множественных циклов ожидания предлагается в упражнении 10.11. </p>
     <p>Проектировать семафоры Windows было бы гораздо удобнее, если бы существовала возможность выполнять множественные циклы ожидания в виде одной атомарной операции (atomic multiple-wait operation).</p>
    </section>
   </section>
   <section>
    <title>
     <p>События</p>
    </title>
    <section>
     <p>Последним из рассматриваемых нами типов объектов синхронизации ядра являются <emphasis>события</emphasis> (events). Объекты события используются для того, чтобы сигнализировать другим потокам о наступлении какого-либо события, например, о появлении нового сообщения.</p>
     <p>Важной дополнительной возможностью, обеспечиваемой объектами событий, является то, что переход в сигнальное состояние единственного объекта события способен вывести из состояния ожидания одновременно несколько потоков. Объекты события делятся на сбрасываемые вручную и автоматически сбрасываемые, и это их свойство устанавливается при вызове функции CreateEvent.</p>
     <p>• Сбрасываемые вручную события (manual-reset events) могут сигнализировать одновременно всем потокам, ожидающим наступления этого события, и переводятся в несигнальное состояние программно.</p>
     <p>• Автоматически сбрасываемые события (auto-reset event) сбрасываются самостоятельно после освобождения одного из ожидающих потоков, тогда как другие ожидающие потоки продолжают ожидать перехода события в сигнальное состояние.</p>
     <p>События используют пять новых функций: CreateEvent, OpenEvent, SetEvent, ResetEvent и CreateEvent. </p>
     <cite>
      <p><code>HANDLE CreateEvent(LPSECURITY_ATTRIBUTES lpsa, BOOL bManualReset, BOOL bInitialState, LPTCSTR lpEventName)</code> </p>
     </cite>
     <p>Чтобы создать событие, сбрасываемое вручную, необходимо установить значение параметра bManualReset равным True. Точно так же, чтобы сделать начальное состояние события сигнальным, установите равным True значение параметра bInitialState. Для открытия именованного объекта события используется функция OpenEvent, причем это может сделать и другой процесс.</p>
     <p>Для управления объектами событий используются следующие три функции: </p>
     <cite>
      <p><code>BOOL SetEvent(HANDLE hEvent) </code></p>
      <p><code>BOOL ResetEvent(HANDLE hEvent) </code></p>
      <p><code>BOOL PulseEvent(HANDLE hEvent)</code> </p>
     </cite>
     <p>Поток может установить событие в сигнальное состояние, используя функцию SetEvent. Если событие является автоматически сбрасываемым, то оно автоматически возвращается в несигнальное состояние уже после освобождения только одного из ожидающих потоков. В отсутствие потоков, ожидающих наступления этого события, оно остается в сигнальном состоянии до тех пор, пока такой поток не появится, после чего этот поток сразу же освобождается. Заметьте, что таким же образом ведет себя семафор, максимальное значение счетчика которого установлено равным 1.</p>
     <p>С другой стороны, если событие является сбрасываемым вручную, то оно остается в сигнальном состоянии до тех пор, пока какой-либо поток не вызовет функцию ResetEvent, указав дескриптор этого события в качестве аргумента. В это время все ожидающие потоки освобождаются, но до выполнения такого сброса события другие потоки могут как переходить в состояние его ожидания, так и освобождаться.</p>
     <p>Функция PulseEvent освобождает все потоки, ожидающие наступления сбрасываемого вручную события, но после этого событие сразу же автоматически сбрасывается. В случае же использования автоматически сбрасываемого события функция PulseEvent освобождает только один ожидающий поток, если таковые имеются.</p>
     <cite>
      <p><strong>Примечание</strong></p>
      <p>Хотя в книгах многих авторов и даже в некоторых документах Microsoft (см. примечания в разделе MSDN, содержащем описание функции PulseEvent) рекомендуется избегать использования функции PulseEvent, лично я считаю эту функцию не только полезной, но и существенно важной, как это следует из обсуждения многочисленных примеров, приведенных в двух следующих главах.</p>
     </cite>
     <p>Следует отметить, что функция PulseEvent становится полезной лишь после того, как сбрасываемое вручную событие установлено в сигнальное состояние с помощью функции SetEvent. Будьте внимательны, когда используете функцию WaitForMultipleObjects для ожидания перехода в сигнальное состояние <emphasis>всех</emphasis> событий. Ожидающий поток освободится только тогда, когда одновременно все события будут находиться в сигнальном состоянии, и некоторые из событий, находящихся в сигнальном состоянии, могут быть сброшены, прежде чем поток освободится.</p>
     <p>В упражнении 8.5 вам предлагается изменить программу sortMT (программа 7.2) за счет использования в ней событий. </p>
     <cite>
      <p><emphasis>Переменные условий </emphasis>(condition variables) Pthreads в некоторой степени сравнимы с событиями, но используются в сочетании с мьютексами. Такой способ их использования в действительности является очень плодотворным и будет описан в главе 10. Для создания и уничтожения переменной условий используются, соответственно, системные вызовы pthread_cond_init и pthread_cond_destroy. Функциями ожидания являются pthread_cond_wait и pthread_cond_timedwait. Системный вызов pthread_cond_signal осуществляет возврат после освобождения одного ожидающего потока аналогично Windows-функции PulseEvent в случае автоматически сбрасываемых событий, тогда как вызов pthread_cond_broadcast сигнализирует всем ожидающим потокам, и поэтому его можно сопоставить функции PulseEvent, применяемой к сбрасываемому вручную событию. Эквивалентов функций PulseEvent и ResetEvent, используемых в случае сбрасываемых вручную событий, не существует.</p>
     </cite>
    </section>
    <section>
     <title>
      <p>Обзор: четыре модели использования событий</p>
     </title>
     <p>Комбинирование автоматически сбрасываемых и сбрасываемых вручную событий с функциями SetEvent и PulseEvent приводит к четырем различным способам использования событий. Каждая из четырех комбинаций уникальна и каждая из них оказывается полезной или даже необходимой в той или иной ситуации, так что все они будет соответствующим образом использованы в примерах и упражнениях, приведенных в этой и следующей главах.</p>
     <cite>
      <p><strong>Предостережение</strong></p>
      <p>Некорректное использование событий может привести к возникновению условий состязаний, взаимоблокировок и других тонких, трудно обнаруживаемых ошибок. В главе 10 описываются методики, применение которых является обязательным почти во всех случаях использования событий, за исключением самых тривиальных.</p>
     </cite>
     <p>В табл. 8.1 описаны четыре возможные ситуации. </p>
     <empty-line/>
     <p>Таблица 8.1. Сводная таблица свойств событий </p>
     <empty-line/>
     <table>
      <tr align="left">
       <th align="left" valign="top"/>
       <th align="left" valign="top">Автоматически сбрасываемые события</th>
       <th align="left" valign="top">Сбрасываемые вручную события</th>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><strong>SetEvent</strong></td>
       <td align="left" valign="top">Освобождается строго один поток. Если в этот момент ни один из потоков не ожидает наступления события, то поток, который первым перейдет в состояние ожидания следующих событий, будет сразу же освобожден. После этого событие немедленно автоматически сбрасывается.</td>
       <td align="left" valign="top">Освобождаются все потоки, которые в настоящее время ожидают наступления события. Событие остается в сигнальном состоянии до тех пор, пока не будет сброшено каким-либо потоком.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><strong>PulseEvent</strong></td>
       <td align="left" valign="top">Освобождается строго один поток, но только в том случае, если имеется поток, ожидающий наступления события.</td>
       <td align="left" valign="top">Освобождаются все потоки, которые в этот момент ожидают наступления события, если таковые имеются, после чего событие сбрасывается и переходит в несигнальное состояние. </td>
      </tr>
     </table>
     <p>Образно говоря, автоматически сбрасываемое событие — это дверь, снабженная пружиной, которая обеспечивает автоматическое закрытие двери, в то время как вручную сбрасываемое событие можно уподобить двери, в которой пружина отсутствует и которая, будучи раз открытой, продолжает оставаться в таком состоянии. Используя эту метафору, можно сказать, что функция PulseEvent открывает дверь и закрывает ее сразу же после того, как через нее проходят одна (автоматически сбрасываемые события) или все (вручную сбрасываемые события) ожидающие потоки. Функция SetEvent открывает дверь и освобождает ее.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: система "производитель/потребитель"</p>
    </title>
    <p>В этом примере возможности программы 8.1 расширяются таким образом, чтобы потребитель мог дожидаться момента, когда появится доступное сообщение. Тем самым устраняется одна из проблем, связанная с тем, что в предыдущем варианте программы потребитель должен был непрерывно повторять попытки получения новых сообщений. Результирующая программа (программа 8.2) называется eventPC.</p>
    <p>Заметьте, что в предлагаемом решении вместо объектов CRITICAL_SECTION используются мьютексы; единственной причиной для этого послужило лишь желание проиллюстрировать применение мьютексов. В то же время, использование автоматически сбрасываемого события и функции SetEvent в потоке потребителя является весьма существенным для работы программы, поскольку это гарантирует освобождение только одного потока.</p>
    <p>Также обратите внимание на способ связывания мьютекса и события со структурой данных блока сообщения. Мьютекс активизирует критический участок кода для доступа к объекту структуры данных, тогда как событие используется для уведомления о том, что появилось новое сообщение. Обобщая, можно сказать, что мьютекс гарантирует сохранение инвариантов объекта, а событие сигнализирует о нахождении объекта в заданном состоянии. Эта базовая методика широко применяется в последующих главах.</p>
    <subtitle>Программа 8.2. eventPC: система "производитель/потребитель", использующая сигналы </subtitle>
    <p><code>/* Глава 8. eventPC.с */</code></p>
    <p><code>/* Поддерживает два потока — производителя и потребителя. */</code></p>
    <p><code>/* Производитель периодически создает буферные данные с контрольными */</code></p>
    <p><code>/* суммами, или "блоки сообщений", сигнализирующие потребителю о готовности*/</code></p>
    <p><code>/* сообщения. Поток потребителя отображает информацию в ответ на запрос.*/</code></p>
    <empty-line/>
    <p><code>#include "EvryThng.h" </code></p>
    <p><code>#include &lt;time.h&gt; </code></p>
    <p><code>#define DATA_SIZE 256</code></p>
    <empty-line/>
    <p><code>typedef struct msg_block_tag { /* Блок сообщения. */</code></p>
    <p><code> volatile DWORD f_ready, f_stop; /* Флаги готовности и прекращения сообщений. */</code></p>
    <p><code> volatile DWORD sequence; /* Порядковый номер блока сообщения. */</code></p>
    <p><code> volatile DWORD nCons, nLost; time_t timestamp;</code></p>
    <p><code> HANDLE mguard; /* Мьютекс, защищающий структуру блока сообщения. */ </code></p>
    <p><code> HANDLE mready; /* Событие "Сообщение готово". */</code></p>
    <p><code> DWORD checksum; /* Контрольная сумма сообщения. */</code></p>
    <p><code> DWORD data[DATA_SIZE]; /* Содержимое сообщения. */ </code></p>
    <p><code>} MSG_BLOCK;</code></p>
    <empty-line/>
    <p><code>/* … */</code></p>
    <empty-line/>
    <p><code>DWORD _tmain(DWORD argc, LPTSTR argv[]) {</code></p>
    <p><code> DWORD Status, ThId;</code></p>
    <p><code> HANDLE produce_h, consume_h;</code></p>
    <p><code> /* Инициализировать мьютекс и событие (автоматически сбрасываемое) в блоке сообщения. */</code></p>
    <p><code> mblock.mguard = CreateMutex(NULL, FALSE, NULL);</code></p>
    <p><code> mblock.mready = CreateEvent(NULL, FALSE, FALSE, NULL);</code></p>
    <p><code> /* Создать потоки производителя и потребителя; ожидать их завершения.*/</code></p>
    <p><code> /* … Как в программе 9.1 … */</code></p>
    <p><code> CloseHandle(mblock.mguard);</code></p>
    <p><code> CloseHandle(mblock.mready);</code></p>
    <p><code> _tprintf(_T("Потоки производителя и потребителя завершили выполнение\n"));</code></p>
    <p><code> _tprintf(_T("Отправлено: %d, Получено: %d, Известные потери: %d\n"), mblock.sequence, mblock.nCons, mblock.nLost);</code></p>
    <p><code> return 0; </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>DWORD WINAPI produce(void *arg) </code></p>
    <p><code>/* Поток производителя — создание новых сообщений через случайные */</code></p>
    <p><code>/* интервалы времени. */</code></p>
    <p><code>{</code></p>
    <p><code> srand((DWORD)time(NULL)); /* Создать начальное число для генератора случайных чисел. */</code></p>
    <p><code> while(!mblock.f_stop) {</code></p>
    <p><code>  /* Случайная задержка. */</code></p>
    <p><code>  Sleep(rand() / 10); /* Длительный период ожидания следующего сообщения. */</code></p>
    <p><code>  /* Получить и заполнить буфер. */</code></p>
    <p><code>  WaitForSingleObject(mblock.mguard, INFINITE);</code></p>
    <p><code>  __try {</code></p>
    <p><code>   if (!mblock.f_stop) {</code></p>
    <p><code>    mblock.f_ready = 0;</code></p>
    <p><code>    MessageFill(&amp;mblock);</code></p>
    <p><code>    mblock.f_ready = 1;</code></p>
    <p><code>    mblock.sequence++;</code></p>
    <p><code>    SetEvent(mblock.mready); /* Сигнал "Сообщение готово". */</code></p>
    <p><code>   }</code></p>
    <p><code>  } __finally { ReleaseMutex (mblock.mguard); }</code></p>
    <p><code> }</code></p>
    <p><code> return 0; </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>DWORD WINAPI consume (void *arg) {</code></p>
    <p><code> DWORD ShutDown = 0;</code></p>
    <p><code> CHAR command, extra;</code></p>
    <p><code> /* Принять ОЧЕРЕДНОЕ сообщение по запросу пользователя. */</code></p>
    <p><code> while (!ShutDown) { /* Единственный поток, получающий доступ к стандартным устройствам ввода/вывода. */</code></p>
    <p><code>  _tprintf(_T("\n** Введите 'с' для приема; 's' для прекращения работы: "));</code></p>
    <p><code>  _tscanf("%c%c", &amp;command, &amp;extra);</code></p>
    <p><code>  if (command == 's') {</code></p>
    <p><code>   WaitForSingleObject(mblock.mguard, INFINITE);</code></p>
    <p><code>   ShutDown = mblock.f_stop = 1;</code></p>
    <p><code>   ReleaseMutex(mblock.mguard);</code></p>
    <p><code>  } else if (command == 'c') {</code></p>
    <p><code>   /* Получить новый буфер принимаемых сообщений. */</code></p>
    <p><code>   WaitForSingleObject(mblock.mready, INFINITE);</code></p>
    <p><code>   WaitForSingleObject(mblock.mguard, INFINITE);</code></p>
    <p><code>   __try {</code></p>
    <p><code>    if (!mblock.f_ready) _leave;</code></p>
    <p><code>    /* Ожидать наступление события, указывающего на готовность сообщения. */</code></p>
    <p><code>    MessageDisplay(&amp;mblock);</code></p>
    <p><code>    mblock.nCons++;</code></p>
    <p><code>    mblock.nLost = mblock.sequence – mblock.nCons;</code></p>
    <p><code>    mblock.f_ready = 0; /* Новые готовые сообщения отсутствуют. */</code></p>
    <p><code>   } __finally { ReleaseMutex (mblock.mguard); }</code></p>
    <p><code>  } else {</code></p>
    <p><code>   _tprintf(_T("Недопустимая команда. Повторите попытку.\n"));</code></p>
    <p><code>  }</code></p>
    <p><code> }</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <cite>
     <p><strong>Примечание</strong></p>
     <p>Существует вероятность того, что поток потребителя, уведомленный о готовности сообщения, в действительности не успеет обработать текущее сообщение до того, как поток производителя сгенерирует еще одно сообщение до захвата мьютекса потоком потребителя. В результате такого поведения программы поток потребителя может обработать одно и то же сообщение дважды, если бы не проверка, предусмотренная в начале try-блока потребителя. Эта и другие аналогичные проблемы обсуждаются в главе 10.</p>
    </cite>
   </section>
   <section>
    <title>
     <p>Обзор: объекты синхронизации Windows</p>
    </title>
    <section>
     <p>Наиболее важные свойства объектов синхронизации Windows перечислены в табл. 8.2.</p>
     <empty-line/>
     <p>Таблица 8.2. Сравнительные характеристики объектов синхронизации Windows</p>
     <table>
      <tr align="left">
       <th align="left" valign="top"/>
       <th align="left" valign="top">CRITICAL_SECTION </th>
       <th align="left" valign="top">Мьютекс </th>
       <th align="left" valign="top">Семафор </th>
       <th align="left" valign="top">Событие</th>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><strong>Именованный защищаемый объект синхронизации</strong></td>
       <td align="left" valign="top">Нет</td>
       <td align="left" valign="top">Да</td>
       <td align="left" valign="top">Да</td>
       <td align="left" valign="top">Да</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><strong>Доступность из нескольких процессов</strong></td>
       <td align="left" valign="top">Нет</td>
       <td align="left" valign="top">Да</td>
       <td align="left" valign="top">Да</td>
       <td align="left" valign="top">Да</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><strong>Синхронизация</strong></td>
       <td align="left" valign="top">Вхождение</td>
       <td align="left" valign="top">Ожидание</td>
       <td align="left" valign="top">Ожидание</td>
       <td align="left" valign="top">Ожидание</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><strong>Освобождение </strong></td>
       <td align="left" valign="top">Выход </td>
       <td align="left" valign="top">Мьютекс может быть освобожден или оставлен без контроля. </td>
       <td align="left" valign="top">Освобождается любым потоком. </td>
       <td align="left" valign="top">Функции SetEvent, PulseEvent.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><strong>Права владения</strong></td>
       <td align="left" valign="top">В каждый момент времени иметь права владельца может только один поток. Владеющий поток может осуществлять вхождение несколько раз, не блокируя свое выполнение.</td>
       <td align="left" valign="top">В каждый момент времени иметь права владельца может только один поток. Владеющий поток может выполнять функцию ожидания несколько раз, не блокируя свое выполнение.</td>
       <td align="left" valign="top">Понятие владения неприменимо. Доступ разрешен одновременно нескольким потокам, число которых ограничено максимальным значением счетчика.</td>
       <td align="left" valign="top">Понятие владения неприменимо. Функции SetEvent и PulseEvent могут быть вызваны любым потоком.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top"><strong>Результат освобождения</strong></td>
       <td align="left" valign="top">Разрешается вхождение одного потока из числа ожидающих.</td>
       <td align="left" valign="top">Вслед за последним освобождением права владения разрешается приобрести одному потоку из числа ожидающих.</td>
       <td align="left" valign="top">Продолжать выполнение могут несколько потоков, число которых определяется текущим значением счетчика.</td>
       <td align="left" valign="top">После вызова функций SetEvent или PulseEvent продолжать выполнение будет один или несколько ожидающих потоков.</td>
      </tr>
     </table>
    </section>
    <section>
     <title>
      <p>Ожидание сообщений и объектов</p>
     </title>
     <p>Функция MsgWaitForMultipleObjects аналогична функции WaitForMultipleObjects. Применяйте ее для того, чтобы разрешить потоку или процессу обработку событий пользовательского интерфейса, таких как щелчки мышью, во время ожидания перехода объектов синхронизации в сигнальное состояние. </p>
    </section>
   </section>
   <section>
    <title>
     <p>Дополнительные рекомендации относительно использования мьютексов и объектов CRITICAL_SECTION</p>
    </title>
    <p>К этому времени мы успели познакомиться со всеми объектами синхронизации Windows и исследовали их применимость на ряде примеров. Мьютексы и объекты CS рассматривались первыми, а поскольку события мы еще будем интенсивно использовать в следующей главе, то настоящую главу целесообразно завершить рекомендациями относительно применения мьютексов и объектов CS для обеспечения корректности выполнения, удобства сопровождения и повышения производительности программ.</p>
    <p>Приведенные ниже утверждения сформулированы, как правило, в терминах мьютексов, однако, если не оговорено иное, все сказанное относится и к объектам CS.</p>
    <p>• Если функция WaitForSingleObject, одним из аргументов которой является дескриптор мьютекса, вызывается без использования конечного интервала ожидания, то вызывающий поток может оказаться блокированным на неопределенное время. Ответственность за то, чтобы захваченный (блокированный) мьютекс в конечном счете был освобожден (разблокирован), возлагается на программиста.</p>
    <p>• Если поток завершает выполнение или его выполнение прерывается до того, как он покинет (разблокирует) объект CS, то этот объект остается блокированным. Чрезвычайно полезным свойством мьютексов является то, что владеющий ими поток может завершить выполнение, не уступив прав владения мьютексом.</p>
    <p>• Не пытайтесь получить доступ к ресурсам, защищаемым мьютексом, если функция WaitForSingleObject вызвана с использованием конечного интервала ожидания.</p>
    <p>• Ожидать перехода блокированного мьютекса в сигнальное состояние могут сразу несколько потоков. Когда мьютекс освобождается, то только один из ожидающих потоков получает права владения мьютексом и переводится в состояние готовности планировщиком ОС на основании действующей стратегии приоритетов и планирования. Не следует делать никаких предположений относительно того, что какой-либо поток будет пользоваться приоритетом; как и в любом другом случае, программу следует проектировать таким образом, чтобы приложение работало корректно независимо от того, какой именно из ожидающих потоков получит права владения мьютексом и возобновит выполнение. Те же замечания остаются справедливыми и в отношении потоков, ожидающих наступления события; никогда не следует предполагать, что при переходе объекта события в сигнальное состояние освободится какой-то определенный поток или что потоки будут разблокированы в какой-то определенной очередности.  </p>
    <p>• К критическому участку кода относятся все операторы, расположенные между точками программы, в которых поток приобретает права владения мьютексом и уступает их. Для определения нескольких критических участков кода может быть использован один и тот же мьютекс. Корректная организация программы предполагает, что критический участок кода, определяемый мьютексом, в каждый момент времени может выполняться только одним потоком.</p>
    <p>• Определяемая мьютексами степень детализации программы, или гранулярность мьютексов (mutex granularity), оказывает влияние на производительность и требует серьезного рассмотрения. Размер каждого критического участка кода ни в коем случае не должен превышать необходимой величины, и мьютекс не должен захватываться на более длительный промежуток времени, чем это необходимо. Использование критических участков кода чрезмерно большого размера, захватываемых на длительные промежутки времени, снижает параллелизм и может оказывать отрицательное влияние на производительность.</p>
    <p>• Связывайте мьютекс непосредственно с ресурсом, защиту которого он должен обеспечивать, возможно, с использованием структуры данных. (Именно эта методика задействована в программах 8.1 и 8.2.)</p>
    <p>• Максимально точно документируйте инвариант, используя для этого словесные описания либо логические, или булевские, выражения. Инвариант— это свойство защищаемого ресурса, сохранение которого неизменным вне критического участка кода вы гарантируете. Форма выражения инвариантов может быть самой различной: "элемент принадлежит обоим спискам или не принадлежит ни одному из них", "контрольная сумма данных в буфере является достоверной", "связанный список является действительным" или "0 &lt;= nLost + nCons &lt;= sequence". Точно сформулированные инварианты могут использоваться совместно с макросом ASSERT при отладке программ, хотя оператор ASSERT должен иметь собственный критический участок кода.</p>
    <p>• Убедитесь в том, что каждый критический участок кода имеет только одну точку входа, в которой поток блокирует мьютекс, и только одну точку выхода, в которой поток освобождает мьютекс. Избегайте использования сложных операторов ветвления и таких операторов, как break, return или goto, предоставляющих возможность выхода за пределы критического участка кода. Для защиты от подобных рисков оказываются удобными обработчики завершения.</p>
    <p>• Если требуемая логика работы программы приводит к чрезмерному разрастанию критического участка кода (скажем, его размер превышает одну страницу), попробуйте разместить этот код в отдельной функции, чтобы можно было легко понять схему синхронизации. Так, целесообразно выделить в отдельную функцию код, предназначенный для удаления узла из сбалансированного дерева поиска, пока дерево остается блокированным. </p>
   </section>
   <section>
    <title>
     <p>Другие функции взаимоблокировки</p>
    </title>
    <p>Ранее уже было продемонстрировано, что функции InterlockedIncrement и InterlockedDecrement могут пригодиться в тех случаях, когда все, что требуется — это выполнение простейших операций над переменными, доступ к которым разделяется несколькими потоками. Используя некоторые другие функции, вы можете выполнять атомарные операции, позволяющие осуществлять сравнение и обмен значениями пар переменных.</p>
    <p>Функции взаимоблокировки настолько же полезны, насколько и эффективны; эти функции реализуются в пользовательском пространстве с применением всего лишь нескольких машинных команд.</p>
    <p>Функция InterlockedExchange сохраняет значение одной переменной в другой. </p>
    <cite>
     <p><code>LONG InterlockedExchange(LPLONG Target, LONG Value)</code> </p>
    </cite>
    <p>Эта функция возвращает текущее значение переменной, на которую указывает параметр Target, и устанавливает значение этой переменной равным Value. Функция InterlockedExchangeAdd прибавляет второе значение к первому. </p>
    <cite>
     <p><code>LONG InterlockedExchangeAdd(PLONG Addend, LONG Increment)</code> </p>
    </cite>
    <p>Значение Increment прибавляется к значению переменной, на которую указывает параметр Addend, а начальное значение этой переменной возвращается функцией. Данная функция позволяет увеличивать значение переменной на 2 (и более) атомарным образом, чего невозможно добиться последовательными вызовами функции InterlockedIncrement.</p>
    <p>Последняя из функций этой группы, которую мы рассмотрим — это функция InterlockedCompareExchange, аналогичная функции InterlockedExchange, если не считать того, что обмен значениями осуществляется лишь в случае равенства сравниваемых значений. </p>
    <cite>
     <p><code>PVOID InterlockedCompareExchange(PVOID *Destination, PVOID Exchange, PVOID Comparand)</code> </p>
    </cite>
    <p>Эта функция выполняет атомарным образом следующие действия (использование типа данных PVOID для двух последних параметров может казаться вам непонятным):</p>
    <p><code>Temp = *Destination;</code></p>
    <p><code>if (*Destination == Comparand) *Destination = Exchange;</code></p>
    <p><code>return Temp;</code></p>
    <p>Одним из вариантов применения этой функции является управление блокировкой с целью реализации критического участка кода. *Destination является <emphasis>переменной блокировки</emphasis> (lock variable), причем значению 1 соответствует разблокированное состояние, а значению 0 — блокированное. Значение Exchange задается равным 0, a Comparand — 1. Вызывающему потоку известно, что она владеет критическим участком, если функция возвращает 1. В противном случае вызывающий поток должен "уснуть", или выполнить ожидание в состоянии занятости ("spin"), то есть совершать в течение короткого промежутка времени цикл, в котором ничего не делается, с той только целью, чтобы выждать некоторое время, а затем вновь повторить попытку. По существу, именно такой цикл и выполняет функция EnterCriticalSection, ожидая перехода в сигнальное состояние объекта CRITICAL_SECTION с ненулевым значением спин-счетчика; для получения более подробной информации по этому вопросу обратитесь к главе 9.</p>
   </section>
   <section>
    <title>
     <p>Учет факторов производительности при организации управленияпамятью</p>
    </title>
    <p>Программа 9.1, приведенная в следующей главе, позволяет исследовать различные аспекты производительности в условиях, когда несколько потоков соревнуются между собой за право обладания разделяемыми ресурсами. Аналогичные эффекты будут наблюдаться и в случае, когда потоки привлекаются для управления памятью с использованием функций malloc и free из многопоточной стандартной библиотеки С, поскольку эти функции используют объекты CRITICAL_SECTION для синхронизации доступа к структуре данных кучи (вы можете в этом сами убедиться, просмотрев исходный код библиотеки С). Ниже описаны два возможных способа улучшения производительности.</p>
    <p>• Каждый поток, управляющий памятью, может создать дескриптор типа HANDLE для собственной кучи с помощью функции HeapCreate (глава 5). После этого для распределения памяти вместо функций malloc и free можно использовать функции HeapAlloc и HeapFree.</p>
    <p>• Значение переменной окружения времени выполнения __MSVCRT_HEAP_SELECT можно установить равным __GLOBAL_HEAP_SELECTED. Это приведет к тому, что функции malloc и free будут использовать для управления памятью схему Windows, которая использует спин-блокировки (spin locks) вместо объектов CS и может быть намного более эффективной. Этот метод был предложен Гербертом Орашем (Gerbert Orasche) в статье "Configuring VC++ Multithreaded Memory Management", опубликованной в майском выпуске журнала <emphasis>Windows Developer's Journal</emphasis> за 2000 год, а представленные в этой статье результаты убедительно свидетельствуют о преимуществах данного метода в отношении производительности.</p>
   </section>
   <section>
    <title>
     <p>Резюме</p>
    </title>
    <section>
     <p>Windows поддерживает полный набор операций синхронизации, способных обеспечить безопасную реализацию потоков и процессов. Синхронизация привносит в проектирование и разработку программ массу проблем, требующих самого тщательного рассмотрения, которое могло бы гарантировать не только корректную работу программ, но и их высокую производительность.</p>
    </section>
    <section>
     <title>
      <p>В следующих главах</p>
     </title>
     <p>В главе 9 внимание концентрируется на тех аспектах производительности, которые связаны с многопоточным характером приложений и применением в них объектов синхронизации. Сначала анализируются факторы, влияющие на производительность SMP-систем; в некоторых случаях производительность может резко ухудшаться из-за конфликтов за право владения ресурсами, в связи с чем предлагается несколько стратегий, обеспечивающих поддержание эксплуатационных характеристик SMP-систем на высоком уровне. Далее следует сравнительный анализ достоинств и недостатков мьютексов и объектов CRITICAL_SECTION, а затем рассматривается тонкая настройка объектов CRITICAL_SECTION с использованием спин-счетчиков. Завершается глава рекомендациями, в которых суммируются известные методики повышения производительности и заостряется внимание на возможных рисках.</p>
    </section>
    <section>
     <title>
      <p>Дополнительная литература</p>
     </title>
     <subtitle><emphasis>Windows</emphasis></subtitle>
     <p>Вопросы синхронизации важны для любой ОС, и поэтому многие руководства по ОС содержат их подробное обсуждение в рамках более общего контекста.</p>
     <p>Ранее уже упоминались другие книги, посвященные синхронизации в Windows. В то же время, при чтении книг по Windows более общего характера следует быть очень внимательными, поскольку в том, что касается потоков и синхронизации, некоторые из них могут попросту дезориентировать, и большинство из них не были обновлены с целью включения в рассмотрение средств NT5, которые мы используем в данной книге. Так, в одной очень популярной книге, получившей положительные отзывы рецензентов, несмотря на большой объем содержащихся в ней словесных описаний, ни слова не говорится о классе памяти volatile, не совсем правильно объяснены четыре модели событий, а в качестве метода, позволяющего изменить значение счетчика семафора более чем на единицу, рекомендуется решение, в котором используются многократные вызовы функций ожидания, что чревато возникновением взаимоблокировок (вспомните обсуждение в разделе, посвященном семафорам).</p>
     <p>Для углубленного изучения тематики потоков и синхронизации можно порекомендовать книгу [6], которая будет полезна даже тем, кто программирует исключительно в среде Windows. Приведенные в этой книге обсуждения и описания в равной степени применимы, как правило, и к Windows, а перенос примеров программ послужит вам хорошим упражнением.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Упражнения</p>
    </title>
    <p>8.1.  На Web-сайте книги находится версия программы simplePC.c (программа 8.1), содержащая дефекты, которая называется simplePCx.c. Проверьте работу этой программы и опишите симптомы дефектов, если они проявляются. Внесите в программу необходимые исправления, не сверяясь с правильным решением.</p>
    <p>8.2. Измените программу simplePC.c таким образом, чтобы промежуток времени между генерацией новых сообщений увеличился. <emphasis>(Подсказка.</emphasis> Уберите операцию деления в том месте программы, где вызывается функция sleep.) Убедитесь в правильности логики, определяющей наличие новых сообщений. Кроме того, самостоятельно поэкспериментируйте с программой simplePCx.с, содержащей дефекты.</p>
    <p>8.3. Переделайте программу simplePC. с, задействовав в ней мьютексы.</p>
    <p>8.4. Переделайте программу sortMT.c (программа 7.2), использовав для синхронизации запуска рабочих потоков не приостановку потоков, а семафор.</p>
    <p>8.5. Переделайте программу sortMT.c (программа 7.2), использовав для синхронизации запуска рабочих потоков не приостановку потоков, а события. В рекомендуемом решении используется функция SetEvent и сбрасываемое вручную событие. Другие комбинации не могли бы гарантировать корректную работу программы. Дайте этому свои объяснения.</p>
    <p>8.6. Поэкспериментируйте с программой 8.2, используя различные комбинации автоматически и вручную сбрасываемых событий, а также функций SetEvent и PulseEvent (в текущем решении используются функция SetEvent и автоматически сбрасываемое событие). Могут ли считаться корректными альтернативные и исходный варианты реализации с учетом объявленного функционального назначения программы? (См. примечание после программы 8.2.) Объясните результаты и поясните, в чем с функциональной точки зрения состоит полезность альтернативных вариантов реализации. Можете ли вы добиться того, чтобы заработали альтернативные варианты реализации, изменив логику программы? </p>
    <p>8.7. Создайте пул рабочих потоков, но организуйте такое управление частотой выполнения рабочих потоков, чтобы на протяжении любого односекундного интервала времени выполняться мог только один поток. Измените программу таким образом, чтобы на протяжении одного интервала могли выполняться два потока, но суммарная частота выполнения потоков соответствовала одному потоку в секунду. <emphasis>Подсказка.</emphasis> Рабочие потоки должны ожидать наступления события (события какого типа?) и управляющий поток должен переводить событие в сигнальное состояние (с помощью функции SetEvent или PulseEvent?) каждую секунду.</p>
    <p>8.8. <emphasis>Упражнение повышенной сложности.</emphasis> Объекты CRITICAL_SECTION предназначены для использования потоками в рамках одного и того же процесса. Что произойдет, если объект CS будет создан в разделяемой отображаемой области памяти? Смогут ли использовать CS оба процесса? Вы можете провести самостоятельный эксперимент, изменив программу таким образом, чтобы производитель и потребитель выполнялись в различных процессах.  </p>
   </section>
  </section>
  <section>
   <title>
    <p>ГЛАВА 9</p>
    <p>Влияние синхронизации на производительность и рекомендации по ее повышению</p>
   </title>
   <section>
    <p>В предыдущей главе были введены операции синхронизации, использование которых иллюстрировалось с привлечением нескольких относительно простых примеров. В следующей главе предлагаются более сложные, но вместе с тем более реалистичные и полезные примеры, а также описывается общая модель синхронизации, позволяющая решить многие практические задачи и повысить надежность программ. В данной же небольшой главе анализируется влияние синхронизация на производительность приложений и рассматриваются методы, минимизирующие отрицательные последствия этого влияния.</p>
    <p>Несмотря на всю важность синхронизации потоков, применение этого средства сопряжено со значительными рисками снижения производительности, которые ниже частично обсуждаются на примере как однопроцессорных, так и многопроцессорных (SMP) систем. У возможных альтернативных решений имеются собственные достоинства и недостатки. Например, объекты CRITICAL_SECTION (CS) и мьютексы обладают почти одинаковыми свойствами и решают одну и ту же фундаментальную задачу. Вообще говоря, наиболее эффективным механизмом блокирования являются объекты CS, хотя это справедливо не во всех ситуациях. Кроме того, как показано в главе 10, объекты CS менее удобны в работе по сравнению с мьютексами. В некоторых случаях достаточно использовать функции взаимоблокировки потоков, а при тщательном проектировании и реализации приложения иногда можно вообще обойтись без использования объектов синхронизации.</p>
    <p>Сначала мы обсудим сравнительные достоинства и недостатки объектов CS и мьютексов, дополнив этот анализ учетом факторов, проявляющихся в SMP-системах. К числу других рассмотренных ниже тем относятся спин-счетчики объектов CS, дросселирование семафоров и родство процессоров. Глава заканчивается сводкой рекомендаций, касающихся оптимизации производительности.</p>
    <cite>
     <p><strong>Примечание</strong></p>
     <p>В NT 5.0 достигнут значительный прогресс в плане повышения производительности. В ранних версиях NT и в Windows 9x некоторые из отмеченных выше проблем носили гораздо более острый характер.</p>
    </cite>
   </section>
   <section>
    <title>
     <p>Влияние синхронизации на производительность</p>
    </title>
    <section>
     <p>Использование синхронизации в программах может и будет ухудшать их производительность, и в этом отношении следует быть особенно осмотрительным в случае SMP-систем. На первый взгляд, это противоречит здравому смыслу, поскольку от SMP-систем в целом можно было, бы ожидать только повышения производительности, а уж о том, что при переходе к ним быстродействие программ может снижаться, казалось бы, и речи идти не может. Тем не менее, в силу особенностей внутренних механизмов реализации, а также конкуренции между процессорами за право доступа к памяти могут наблюдаться неожиданные эффекты, в том числе и резкое ухудшение производительности программы.</p>
    </section>
    <section>
     <title>
      <p>Достоинства и недостатки объектов CRITICAL_SECTION</p>
     </title>
     <p>Прежде всего, мы попытаемся количественно оценить влияние объектов синхронизации на производительность, и сравним между собой объекты CRITICAL_SECTION и мьютексы. В программе statsMX.c (программа 9.1) для синхронизации доступа к специфической для каждого потока структуре данных используется мьютекс. Программа statsCS.c, листинг которой здесь не приводится, но его можно найти на Web-сайте книги, делает точно то же, но с использованием объекта CRITICAL_SECTION, тогда как в программе stats IN. с для этого привлекаются функции взаимоблокировки (interlocked functions). Наконец, в программе statsNS.с, которая также здесь не приводится, синхронизация вообще не используется; оказывается, в данном примере можно вообще обойтись без синхронизации, поскольку каждый рабочий поток обращается к собственной уникальной области памяти. Некоторые предостережения по этому поводу приведены в конце данного раздела. В реальных программах количество рабочих потоков может быть неограниченным, однако для простоты в программе 9.1 обеспечивается поддержка 64 потоков.</p>
     <p>Описанная совокупность программ не только позволяет оценить зависимость производительности от выбора конкретного типа объекта синхронизации, но и говорит о следующих вещах:</p>
     <p>• При тщательном проектировании программы в некоторых случаях можно вообще обойтись без использования синхронизации. </p>
     <p>• В простейших ситуациях, например, когда требуется инкрементировать значение совместно используемой переменной, достаточно использовать функции взаимоблокировки.</p>
     <p>• В большинстве случаев использование мьютексов обеспечивают более высокое быстродействие программы по сравнению с использованием объектов CS.</p>
     <p>• Обычная методика заключается в определении структуры данных аргумента потока таким образом, чтобы она содержала информацию о состоянии, которая должна поддерживаться потоком, а также указатель на мьютекс или иной объект синхронизации.</p>
     <subtitle>Программа 9.1. statsMX: поддержка статистики потоков</subtitle>
     <p><code>/* Глава 9. statsMX.c */</code></p>
     <p><code>/* Простая система "хозяин/рабочий", в которой каждый рабочий поток */</code></p>
     <p><code>/* информирует главный поток о результатах своей работы для их отображения.*/</code></p>
     <p><code>/* Версия, использующая мьютекс. */</code></p>
     <p><code>#include "EvryThng.h" </code></p>
     <p><code>#define DELAY_COUNT 20</code></p>
     <p><code>/* Использование: statsMX nthread ntasks */</code></p>
     <p><code>/* Запускается "nthread" рабочих потоков, каждой из которых поручается */</code></p>
     <p><code>/* выполнение "ntasks" единичных рабочих заданий. Каждый поток сохраняет*/</code></p>
     <p><code>/* информацию о выполненной работе в собственной неразделяемой ячейке */</code></p>
     <p><code>/* массива, хранящего данные о выполненной потоком работе. */</code></p>
     <p><code>DWORD WINAPI worker(void *);</code></p>
     <p><code>typedef struct _THARG {</code></p>
     <p><code> int thread_number;</code></p>
     <p><code> HANDLE *phMutex;</code></p>
     <p><code> unsigned int tasks_to_complete;</code></p>
     <p><code> unsigned int *tasks_complete; </code></p>
     <p><code>} THARG;</code></p>
     <empty-line/>
     <p><code>int _tmain(DWORD argc, LPTSTR argv[]) {</code></p>
     <p><code> INT tstatus, nthread, ithread;</code></p>
     <p><code> HANDLE *worker_t, hMutex;</code></p>
     <p><code> unsigned int* task_count, tasks_per_thread;</code></p>
     <p><code> THARG* thread_arg;</code></p>
     <p><code> /* Создать мьютекс. */</code></p>
     <p><code> hMutex = CreateMutex(NULL, FALSE, NULL);</code></p>
     <p><code> nthread = _ttoi(argv[1]);</code></p>
     <p><code> tasks_per_thread = _ttoi(argv[2]);</code></p>
     <p><code> worker_t = malloc(nthread * sizeof(HANDLE));</code></p>
     <p><code> task_count = calloc(nthread, sizeof(unsigned int));</code></p>
     <p><code> thread_arg = calloc(nthread, sizeof(THARG));</code></p>
     <p><code> for(ithread = 0; ithread &lt; nthread; ithread++) {</code></p>
     <p><code>  /* Заполнить данными аргумент потока. */</code></p>
     <p><code>  thread_arg[ithread].thread_number = ithread; </code></p>
     <p><code>  thread_arg[ithread].tasks_to_complete = tasks_per_thread;</code></p>
     <p><code>  thread_arg[ithread].tasks_complete = &amp;task_count[ithread];</code></p>
     <p><code>  thread_arg[ithread].phMutex = &amp;hMutex;</code></p>
     <p><code>  worker_t[ithread] = (HANDLE)_beginthreadex (NULL, 0, worker, &amp;thread_arg[ithread], 0, &amp;ThId);</code></p>
     <p><code> }</code></p>
     <p><code> /* Ожидать завершения рабочих потоков. */</code></p>
     <p><code> WaitForMultipleObjects(nthread, worker_t, TRUE, INFINITE);</code></p>
     <p><code> free(worker_t);</code></p>
     <p><code> printf("Выполнение рабочих потоков завершено\n");</code></p>
     <p><code> for (ithread = 0; ithread &lt; nthread; ithread++) {</code></p>
     <p><code>  _tprintf(_T("Количество заданий, выполненных потоком %5d: %6d\n"), ithread, task_count[ithread]);</code></p>
     <p><code> }</code></p>
     <p><code> return 0;</code></p>
     <p><code> free(task_count);</code></p>
     <p><code> free(thread_arg); </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>DWORD WINAPI worker(void *arg) {</code></p>
     <p><code> THARG * thread_arg;</code></p>
     <p><code> int ithread;</code></p>
     <p><code> thread_arg = (THARG*)arg;</code></p>
     <p><code> ithread = thread_arg-&gt;thread_number;</code></p>
     <p><code> while (*thread_arg-&gt;tasks_complete &lt; thread_arg-&gt;tasks_to_complete) {</code></p>
     <p><code>  delay_cpu(DELAY_COUNT);</code></p>
     <p><code>  WaitForSingleObject(*(thread_arg-&gt;phMutex), INFINITE);</code></p>
     <p><code>  (*thread_arg-&gt;tasks_complete)++;</code></p>
     <p><code>  ReleaseMutex(*(thread_arg-&gt;phMutex));</code></p>
     <p><code> }</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code> </p>
     <p>Для изучения поведения различных вариантов реализации можно воспользоваться программой timep из главы 6 (программа 6.2). Тесты, которые проводились на системах, не загруженных никакими другими задачами, и состояли в выполнении 250 000 единичных рабочих заданий с использованием 1,2,4, 8, 16, 32, 64 и 128 потоков, показали следующие результаты:</p>
     <p>• При небольшом количестве потоков (4 и менее) для выполнения каждого из вариантов реализации NS (отсутствие синхронизации), IN (функции взаимоблокировки) и CS (объекты CRITICAL_SECTION) требуется примерно одно и то же время. Вариант CS может оказаться несколько более медленным (10-20 процентов), демонстрируя типичное замедление работы программ, использующих синхронизацию. Вместе с тем, для выполнения варианта MX (мьютексы) требуется в два-три раза больше времени. </p>
     <p>• Производительность варианта CS на однопроцессорных системах при использовании 5 и более потоков не всегда изменяется пропорционально количеству потоков. Картина может меняться при переходе от одной NT5-системы к другой, однако, как свидетельствуют данные, для каждой конкретной системы результаты согласуются между собой. В случае некоторых систем истекшее время удваивается при переходе к следующему члену ряда 1, 2, 4 и так далее, соответствующему количеству используемых потоков, но в одном случае (Windows 2000, процессор Pentium с частотой 1 ГГц, портативный компьютер) оно составляло (в секундах) 0.5, 1.0, 2.0, 4.0, 14.9, 16.0, 32.1 и 363.4, а в другом (Windows 2000, процессор Pentium 500 МГц, на стольный компьютер) — 1.2, 2.3, 4.7, 9.3, 42.7, 101.3, 207.8 и 1212.5 секунд. Как правило, резкое изменение поведения происходит тогда, когда количество потоков начинает превышать 4 или 8, но производительность остается приемлемой, пока количество потоков не превышает 128.</p>
     <p>• В случае однопроцессорных систем вариант MX уступает варианту CS, причем отношение показателей производительности варьирует в пределах от 2:1 до 10:1 в зависимости от типа системы.</p>
     <p>• <emphasis>В случае SMP-систем производительность может резко ухудшаться</emphasis> в десятки и сотни раз. Интуитивно кажется, что с увеличением количества процессоров производительность может только повышаться, но в силу механизмов внутренней реализации процессоры конкурируют между собой за право владения блокировками и обращения к памяти, и это объясняет, почему результаты для вариантов MX и CS оказываются практически одинаковыми. В случае объектов CS некоторого улучшения производительности удавалось добиться за счет тонкой настройки спин-счетчиков, о чем говорится в одном из следующих разделов.</p>
     <p>• Для ограничения количества готовых к выполнению рабочих потоков без изменения базовой программной модели можно использовать семафоры. Эта методика рассматривается далее в этой главе.</p>
     <cite>
      <p><strong>Предупреждение</strong></p>
      <p>В массиве task_count намеренно использованы 32-битовые целые числа, чтобы увеличить верхний предел значений счетчика заданий и избежать создания предпосылок для возникновения "разрыва слов" ("word tearing") и "конфликтов строки кэша" ("cache line conflict") в SMP-системах. Два независимых процессора, на которых выполняются смежные рабочие потоки, могут одновременно изменять значения счетчиков смежных заданий путем внесения соответствующих изменений в свои кэши (32-битовые в системах на основе Intel x86). Вместе с тем, реально записываться в память будет только один кэш, что может сделать результаты недействительными. Чтобы избежать возможных рисков, следует позаботиться об отделении рабочих ячеек каждым из потоков друг от друга и их выравнивании в соответствии с размерами кэшей. В данном примере счетчик заданий может быть сгруппирован с аргументом потока, так что использованию 32-битовых счетчиков ничто не препятствует. Эта тема исследуется в упражнении 9.6. </p>
     </cite>
    </section>
   </section>
   <section>
    <title>
     <p>Модельная программа для исследования факторов производительности</p>
    </title>
    <p>На Web-сайте книги находится проект TimedMutualExclusion, который вы можете использовать для проведения собственных экспериментов с различными моделями "хозяин/рабочий" и характеристиками прикладных приложений. Ниже приводится перечень возможностей этой программы, которыми можно управлять из командной строки.</p>
    <p>• Использование объектов CS или мьютексов.</p>
    <p>• Глубина, или <emphasis>рекурсивность,</emphasis> счетчиков.</p>
    <p>• Время удержания блокировки, или <emphasis>задержка</emphasis> (delay), которое моделирует объем работы, выполненной в пределах критического участка кода.</p>
    <p>• Количество рабочих потоков, ограниченное системными ресурсами.</p>
    <p>• Количество <emphasis>точек "засыпания"</emphasis> (sleep points), в которых рабочий поток уступает процессор, используя вызов Sleep(0), но продолжает владеть блокировкой. Точки "засыпания" моделируют ожидание рабочим потоком операций ввода/вывода или событий, тогда как задержка моделирует активность ЦП.</p>
    <p>• Количество активных потоков, о чем говорится в разделе, посвященном дросселированию семафоров.</p>
    <p>Регулируя параметры задержек и точек "засыпания", можно оказывать заметное воздействие на производительность, поскольку от этих параметров зависит доля времени, в течение которого поток владеет блокировкой, не давая выполняться другим потокам.</p>
    <p>В листинг программы включены детальные комментарии, объясняющие порядок запуска программы и настройки параметров. В упражнении 9.1 вам предлагается провести самостоятельные эксперименты с использованием как можно большего количества различных систем, к которым у вас имеется доступ. Видоизмененный вариант этой программы под названием MutualExclusionSC поддерживает спин-счетчики, о которых говорится в следующем разделе.</p>
    <cite>
     <p><strong>Примечание</strong></p>
     <p>Программа TimedMutualExclusion представляет простую модель, способную отражать многие из особенностей рабочих потоков. Во многих случаях ее можно настроить так, чтобы она представляла реальное приложение, и если эта модель позволяет выявить определенные проблемы, связанные с ухудшением производительности, то не исключено, что с аналогичными трудностями вы столкнетесь и в случае реального приложения. С другой стороны, хорошие эксплуатационные показатели модели вовсе не обязательно означают, что такими же качествами будет обладать и реальное приложение, хотя хорошая исходная модель и способна упростить настройку его производительности.</p>
    </cite>
   </section>
   <section>
    <title>
     <p>Настройка производительности SMP-систем с помощью спин-счетчиков</p>
    </title>
    <section>
     <p>Эффективность методики блокирования (вхождение в раздел) и разблокирования (выход из раздела) объекта CRITICAL_SECTION объясняется тем, что тестирование объекта CS выполняется в пользовательском пространстве без использования системных вызовов ядра, как это требуется в случае мьютексов. Снятие блокировки раздела также выполняется полностью в пространстве пользователя, в отличие от функции ReleaseMutex, которая требует использования системного вызова. Объекты CS работают следующим образом:</p>
     <p>• Поток, выполняющий функцию EnterCriticalSection (ECS), непрерывно тестирует бит блокировки объекта CS. Если обнаруживается, что бит выключен (объект разблокирован), ECS автоматически устанавливает его, выполняя эту операцию как часть инструкций тестирования, и продолжает дальнейшее выполнение уже без какого-либо ожидания. Поэтому блокирование разблокированного объекта CS осуществляется чрезвычайно эффективным образом и требует, как правило, всего лишь одной или двух машинных команд. Идентификационные данные владеющего потока, а также рекурсивный счетчик поддерживаются структурой данных объекта CS.</p>
     <p>• Если обнаруживается, что объект CS блокирован, ECS входит в жесткий цикл (tight loop) на SMP-системах и выполняет многократное тестирование бита блокировки, не уступая процессора (разумеется, поток может быть вытеснен). Количество повторений цикла, после выполнения которых ECS прекращает дальнейшее тестирование, определяется значением спин-счетчика CS. В однопроцессорных системах тестирование прекращается немедленно; спин-счетчики используются лишь в случае SMP-систем.</p>
     <p>• Как только ECS прекращает тестирование бита блокировки (в случае однопроцессорных систем это происходит немедленно), она входит в ядро, и поток переводится в состояние ожидания. Следовательно, блокирование объектов CS оказывается эффективным лишь в условиях низкой состязательности между потоками или когда спин-счетчик предоставляет другому процессору время для разблокирования CS.</p>
     <p>• Функция LeaveCriticalSectibn реализуется путем выключения бита блокировки после проверки того, что вызывающий поток действительно является владельцем CS. Кроме того, ядро должно быть также уведомлено о том, существуют ли еще другие ожидающие потоки, для чего используется функции ReleaseSemaphore.</p>
     <p>Таким образом, в случае однопроцессорных систем объекты CS эффективны тогда, когда высока вероятность их разблокирования, что иллюстрирует вариант CS программы 9.1. Преимущества SMP-систем обусловлены тем фактом, что пока ожидающий поток выполняет цикл ожидания, управляемый спин-счетчиком, объект CS может оказаться разблокированным потоком, выполняющимся на другом процессоре.</p>
     <p>Далее будет показано, как устанавливать значения спин-счетчиков и настраивать приложения путем выбора наиболее оптимальных значений. Еще раз подчеркнем, что спин-счетчики оказываются полезными лишь в случае SMP-систем; на однопроцессорных системах они не используются.</p>
    </section>
    <section>
     <title>
      <p>Установка значений спин-счетчиков</p>
     </title>
     <p>Спин-счетчики CS могут устанавливаться на стадии инициализации объектов CS или динамическим путем. В первом случае функция InitializeCriticalSection заменяется функцией InitializeCriticalSectionAndSpinCount, в которой добавлен параметр счетчика. В то же время, способа, позволяющего считать значение спин-счетчика, не существует.</p>
     <cite>
      <p><code>VOID InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwCount)</code> </p>
     </cite>
     <p>Значение спин-счетчика можно в любой момент изменить. </p>
     <cite>
      <p><code>VOID SetCriticalSectionSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwCount) </code></p>
     </cite>
     <p>В документации Microsoft говорится о том, что рекомендуемым для управления кучей значением спин-счетчика является 4000. Однако оптимальное значение зависит от свойств приложения, и поэтому спин-счетчики должны настраиваться индивидуально для каждого приложения, выполняющегося в реалистическом SMP-окружении. Наилучшее значение будет различным в зависимости от количества процессоров, характера приложения и тому подобного.</p>
     <p>На Web-сайте книги находится программа TimedMutualExclusionSC. Эта программа представляет собой видоизмененный вариант уже знакомой вам программы TimedMutualExclusion, в котором значение спин-счетчика указания в качестве параметра командной строки. Вы можете запустить эту программу на своей машине для приблизительной оценки того, какое значение спин-счетчика будет наиболее приемлемым для выполнения того или иного из вариантов тестовых программ на доступных вам SMP-системах, что и предлагается сделать в упражнении 9.2. </p>
    </section>
   </section>
   <section>
    <title>
     <p>Дросселирование семафора для уменьшения состязательности между потоками</p>
    </title>
    <p>Слишком большое количество потоков, соревнующихся между собой за право владения единственным ресурсом, например, мьютексом или объектом CS, могут стать причиной снижения производительности как в однопроцессорных, так и в многопроцессорных системах. В большинстве случаев негативное влияние некоторых факторов на производительность может быть сведено к минимуму за счет использования спин-счетчиков, тщательного выбора типа объектов синхронизации или перестройки структуры программы с целью увеличения степени детализации блокировок и длительности периодов блокирования.</p>
    <p>Если ни один из этих методов не дает желаемого улучшения, то могло бы показаться, что нет иного выхода, кроме как уменьшить количество потоков, но при этом вы будете вынуждены заставлять одиночные потоки мультиплексировать те операции, которые естественнее было бы распределить между несколькими потоками. Выход из этой ситуации обеспечивают семафоры, которые дают возможность сохранить естественную многопоточную модель, но вместе с тем свести к минимуму количество активных потоков, конкурирующих между собой. Такое решение является концептуально простым, и его можно без труда включить в любую существующую прикладную программу, например TimedMutualExclusion. В системе "хозяин/рабочий" решение, носящее название <emphasis>"дросселя" семафора</emphasis> (semaphore throttle), использует следующую методику:</p>
    <p>• Главный поток создает семафор с небольшим, например 4, максимальным значением параметра, представляющего максимально допустимое количество активных потоков, которое, например, можно принимать равным количеству процессоров, установленных в системе, для обеспечения приемлемой производительности. Начальное значение счетчика семафора также следует установить равным максимальному значению. Это число можно сделать параметром и подбирать его оптимальное значение экспериментальным путем так же, как и в случае спин-счетчиков. Другим возможным значением этого параметра может служить количество процессоров, которое может быть определено во время выполнения программы (см. следующий раздел).</p>
    <p>• Каждый рабочий поток ожидает перехода семафора в сигнальное состояние, прежде чем войти в критический участок кода. Ожидание семафора может непосредственно предшествовать ожиданию мьютекса или объекта CS.</p>
    <p>• Если максимальное значение счетчика семафора равно 1, то использование мьютекса становится излишним. Подобное решение нередко является наилучшим для SMP-систем. </p>
    <p>• Общий уровень состязательности между объектами CS или мьютексами снижается, если при сериализации выполнения потоков лишь небольшое количество потоков ожидают перехода мьютексов или объектов CS в сигнальное состояние.</p>
    <p>Счетчик семафора просто представляет число потоков, которые могут быть активными в любой момент времени, и ограничивает количество потоков, соревнующихся между собой за право владения мьютексом, объектом CS или иным ресурсом. Главный поток даже может регулировать, или, как говорят, "дросселировать" (throttle) выполнение рабочих потоков и динамически настраивать работу приложения, ожидая, пока не уменьшится значение счетчика, если он решает, что уровень состязательности слишком высок, или увеличивая значение счетчика с помощью функции ReleaseSemaphore, чтобы дать возможность выполняться большему количеству потоков. Заметьте, однако, что максимальное значение счетчика семафора устанавливается при его создании, и изменить его впоследствии невозможно.</p>
    <p>В приведенном ниже фрагменте кода представлен видоизмененный рабочий цикл, выполняющий две операции с семафором.</p>
    <p><code>while (TRUE) { // Рабочий цикл</code></p>
    <p><code> WaitForSingleObject(hThrottleSem, INFINITE);</code></p>
    <p><code> WaitForSingleObject(hMutex, INFINITE);</code></p>
    <p><code> … Критический участок кода …</code></p>
    <p><code> ReleaseMutex(hMutex);</code></p>
    <p><code> ReleaseSemaphore(hThrottleSem, 1, NULL);</code></p>
    <p><code>} // Конец рабочего цикла</code></p>
    <p>Можно предложить еще одну разновидность программы. Если некоторый рабочий поток потребляет "слишком много" ресурсов, то можно заставить его выжидать некоторое время, пока значение счетчика семафора не уменьшится на несколько единиц. Однако, как уже отмечалось в предыдущей главе, использование двух последовательных циклов ожидания может стать причиной взаимоблокировки (deadlock) потоков. В следующей главе в одном из упражнений (упражнение 10.11) показано, как построить сложный объект семафора, допускающий атомарное выполнение многократных функций ожидания.</p>
    <p>В уже упоминавшемся примере программы TimedMutualExclusion добавлен шестой параметр, являющийся начальным значением дроссельного счетчика семафора для количества активных потоков. Вы можете поэкспериментировать со значениями этого счетчика, как предлагается в одном из упражнений. На рис. 9.1 показана зависимость различных временных характеристик для шести потоков, синхронизируемых посредством одного объекта CS, от количества активных потоков, изменяющегося в интервале от 1 до 6. Во всех случаях объем выполняемой работы остается одним и тем же, но истекшее время резко увеличивается, когда количество активных потоков превышает 4.</p>
    <empty-line/>
    <image l:href="#Any2FbImgLoader110"/>
    <p><strong>Рис. 9.1.</strong> Зависимость производительности от количества потоков</p>
    <empty-line/>
    <p>Указанные зависимости получены на устаревших, медленных системах. Для системы Windows 2000 на базе процессора Intel 586 (Pentium), характеризующейся гораздо более высоким быстродействием, соответствующие значения истекшего времени для 1–6 потоков составили (в секундах) 0.8, 0.8, 2.3, 21.2, 28.4 и 29.0, и эти результаты могут быть последовательно воспроизведены. В этом случае ухудшение производительности становилось заметным, начиная уже с 3 активных потоков. <emphasis>В то же время,</emphasis> соответствующие временные характеристики, оцененные с использованием произвольно выбранной совокупности аналогичных систем, оказались примерно постоянными, независимо от количества активных потоков. Результаты некоторых экспериментов дают основания сделать следующие выводы:</p>
    <p>• В системе NT5 достигнут значительный прогресс по сравнению с NT4, по следовательно демонстрирующей результаты, аналогичные тем, которые представлены на рис. 9.1.</p>
    <p>• Получаемые результаты зависят от того, в каком режиме выполняются операции — приоритетном или фоновом, то есть, находится или не находится фокус на окне приложения, а также от присутствия в системе других выполняемых задач. </p>
    <p>• Как правило, мьютексы работают медленнее по сравнению с объектами CS, но в случае NT5 результаты остаются примерно постоянными, независимо от количества активных потоков.</p>
    <p>• В SMP-системах наиболее предпочтительным вариантом является дросселирование семафора при значении счетчика равном 1. В этом случае мьютексы становятся ненужными. Так, в случае двухпроцессорной системы Xeon частотой 1.8 ГГц использованные времена для варианта CS при 1, 2 и 4 активных потоках составили 1.8, 33.0 и 31.9 секунды. Соответствующие времена в случае мьютекса составили 34.0, 66.5 и 65.0 секунды.</p>
    <p><emphasis>Резюме.</emphasis> Дросселирование семафоров может обеспечивать хорошую производительность как для приоритетных, так и для фоновых операций даже в случае систем, загруженных выполнением других-задач. Дроссели семафоров могут играть очень важную роль в случае SMP-систем, для которых количество активных потоков должно быть равным 1. В том, что касается производительности, семафоры, по-видимому, более эффективны, чем мьютексы.</p>
   </section>
   <section>
    <title>
     <p>Родство процессоров</p>
    </title>
    <section>
     <p>Во всем предшествующем обсуждении предполагалось, что все процессоры SMP-системы доступны всем потокам, а планирование выполнения потоков и распределение процессоров между ними осуществляет ядро. По своей сути такой простой подход является вполне естественным и согласуется с природой SMP-систем. В то же время, имеется возможность назначать потокам определенные процессоры, задавая так называемое родство процессоров (processor affinity). Родство процессоров можно использовать в нескольких ситуациях.</p>
     <p>• Процессор может быть назначен небольшой группе, состоящей из одной и более высокоприоритетных потоков.</p>
     <p>• Рабочие потоки, конкурирующие за право владения единственным ресурсом, могут быть распределены для выполнения на одном процессоре, что позволяет избежать затруднений с производительностью в случае SMP-систем, о которых перед этим говорилось.</p>
     <p>• Возможен и другой вариант, когда потоки распределяются по доступным процессорам.</p>
     <p>• Различным процессорам можно назначать различные классы рабочих потоков.</p>
    </section>
    <section>
     <title>
      <p>Маски родства системы, процесса и потока</p>
     </title>
     <p>У каждого процесса имеется собственная маска родства процесса (process affinity mask), представляющая собой битовый вектор. Существует также маска родства системы (system affinity mask). </p>
     <p>• Маска родства системы отображает процессоры, сконфигурированные в системе.</p>
     <p>• Маска родства процесса отображает процессоры, на которых разрешается выполнение потоков данного процесса.</p>
     <p>• Каждый индивидуальный поток имеет маску родства потока (thread affinity mask), которая должна представлять собой подмножество значений маски родства процесса. Первоначально маска родства потока совпадает с маской родства процесса.</p>
     <p>Существуют функции для получения и установки масок, хотя системную маску вы можете только считывать (получать), а маски потоков — только устанавливать. Функции установки масок используют дескрипторы потоков и процессов, поэтому процессы или потоки могут устанавливать маску родства друг для друга, если имеются соответствующие права доступа, или для самих себя. Установка маски никак не повлияет на поток, уже выполняющийся на процессоре, использование которого вы пытаетесь исключить данной маской.</p>
     <p>Для считывания как системных масок родства, так и масок родства процессов используется одна функция — GetProcessAffinityMask. В однопроцессорных системах, включая Windows 9x, все биты маски должны быть равными 1.</p>
     <cite>
      <p><code>BOOL GetProcessAffinityMask(HANDLE hProcess, LPDWORD lpProcessAffinityMask, LPDWORD lpSystemAffinityMask)</code> </p>
     </cite>
     <p>Маска родства процесса, которая будет наследоваться любым дочерним процессом, устанавливается при помощи функции SetProcessAffinityMask. </p>
     <cite>
      <p><code>BOOL SetProcessAffinityMask(HANDLE hProcess, DWORD dwProcessAffinityMask)</code> </p>
     </cite>
     <p>В документации Microsoft говорится, что значение новой маски должно быть <emphasis>строгим подмножеством </emphasis>(proper subset) значений масок, получаемых с помощью функции GetProcessAffinityMask. Как показывает несложный эксперимент, включенный в код программы TimedMutualExclusion, новая маска может быть той же, что и маска системы или предыдущая маска процесса. Однако упомянутое ограничение не может быть справедливым, ибо в таком случае вы были бы лишены возможности восстанавливать маску родства системы до предыдущего значения.</p>
     <p>В Windows 9x поддержка SMP, а также функций манипулирования масками процессов не поддерживаются. Новые значения масок влияют на все потоки, принадлежащие данному процессу. </p>
     <p>Для установки маски родства потоков применяется аналогичная функция. </p>
     <cite>
      <p><code>DWORD SetThreadAffinityMask(HANDLE hThread, DWORD dwThreadAffinityMask)</code> </p>
     </cite>
     <p>Типы возвращаемых значений этих функций не согласуются между собой. Типом возвращаемого значения функции SetThreadAffinityMask является DWORD, a не BOOL, но результат остается одним и тем же (1 — в случае успеха, 0 — в противном случае). Функция SetThreadAffinityMask работает и под управлением Windows 9х, но маска должна быть единичной, что не дает никакого прока. Кроме того, невзирая на документацию, новая маска не обязательно должна быть строгим подмножеством системной маски.</p>
     <p>Функция SetThreadIdealProcessor является видоизменением функции SetThreadAffinityMask. Вы указываете предпочтительный ("идеальный") номер процессора (а не маску), и планировщик назначает потоку этот процессор, если такая возможность имеется, или назначит ему другой процессор, если предпочтительный процессор недоступен. Возвращаемым значением функции является номер предыдущего предпочтительного процессора, если таковой был назначен.</p>
    </section>
    <section>
     <title>
      <p>Определение количества процессоров в системе</p>
     </title>
     <p>Фактически, на количество процессоров, установленных в системе, указывает маска родства системы; чтобы его определить, вам достаточно подсчитать количество ненулевых битов в маске. Вместе с тем, гораздо проще вызвать функцию GetSystemInfo, возвращающую структуру SYSTEM_INFO, среди полей которой имеются поля, содержащие количество процессоров и активную маску процессоров, которая совпадает с маской системы. Простая программа и проект Version, доступные на Web-сайте книги, отображают эту информацию вместе с версией Windows.</p>
    </section>
    <section>
     <title>
      <p>Гиперпотоки и счетчик процессоров</p>
     </title>
     <p>Процессоры Intel Pentium 4 и Xeon поддерживают механизм HyperThreading (гиперпотоки), посредством которого состояния ожидания, возникающие в процессе выполнения потока, используются для выполнения другого потока. Для поддержки этого средства используется второй регистровый файл, что вполне осуществимо, поскольку архитектура процессоров х8б характеризуется сравнительно небольшим количеством регистров. Xeon или любой другой процессор, поддерживающий гиперпоточную обработку, воспринимается функциями GetSystemInfo и GetProcessAffinityMask как одиночный процессор. </p>
    </section>
   </section>
   <section>
    <title>
     <p>Порты завершения ввода/вывода</p>
    </title>
    <p>В главе 14 описываются порты завершения ввода/вывода, которые предоставляют другой механизм, позволяющий избежать состязательности между потоками путем ограничения их количества. Порты завершения ввода/вывода дают возможность небольшому количеству потоков управлять большим количеством параллельно выполняющихся операций ввода/вывода. Отдельные операции ввода/вывода начинают выполняться в асинхронном режиме и, вообще говоря, не завершаются сразу же после того, как осуществляется возврат из функции чтения или записи. В то же время, обработка данных по мере завершения операций, ожидающих выполнения, поручается одной из небольшого числа рабочих потоков. В главе 14 приведен пример сервера, связывающегося с удаленными клиентами (программа 14.4).</p>
   </section>
   <section>
    <title>
     <p>Рекомендации по повышению производительности и возможные риски</p>
    </title>
    <p>Многопоточные приложения предоставляют значительные программные преимущества, включая возможность использования более простых моделей программирования и повышение быстродействия программ. Вместе с тем, существует ряд факторов, которые способны оказывать на производительность заметное отрицательное влияние, с трудом поддающееся прогнозированию, причем характер этого влияния может быть различным на различных компьютерах, даже если на них и выполняются одни и те же версии Windows. Некоторые простые рекомендации, суммирующие сведения, изложенные в настоящей главе, помогут вам минимизировать эти риски. Часть этих рекомендаций, равно как и многие из советов по проектированию, отладке и тестированию программ, которые приводятся в следующей главе, в переработанном виде взята из [6].</p>
    <p>• Критически относитесь к аргументации предположительного и теоретического характера, касающейся вопросов производительности, которая часто звучит убедительно, но на практике оказывается ошибочной. Проверяйте предположения на простых прототипах программ, таких как TimedMutualExclusion, или проверяйте их действенность на альтернативных вариантах реализации своего приложения.</p>
    <p>• Используйте для тестирования производительности приложений как можно более широкий круг систем из числа тех, которые доступны вам. Полезно запускать программу с использованием самых различных конфигураций памяти, типов процессоров, версий Windows и количества процессоров. <emphasis>Приложение может продемонстрировать очень высокую производительность на одной системе, но крайне низкую на другой;</emphasis> см. обсуждение программы 9.1.</p>
    <p>• Блокирование потребляет значительные системные ресурсы; пользуйтесь этим средством лишь при настоятельной необходимости. Предоставляйте возможность удержания (владения) мьютекса или объекта CS строго в пределах лишь необходимого времени. Варьирование параметров задержки или точек "засыпания" демонстрирует снижение производительности с увеличением длительности периодов блокирования.</p>
    <p>• Используйте различные мьютексы для различных ресурсов, чтобы уменьшить степень детализации блокировок настолько, насколько это возможно. В частности, старайтесь не использовать глобальные блокировки.</p>
    <p>• Условия высокой состязательности между блокировками затрудняют достижение высокой производительности. Чем выше частота блокирования и разблокирования потоков, тем заметнее снижается производительность. Ухудшение производительности с увеличением количества потоков может быть очень резким, заметно отклоняясь от простой линейной зависимости.</p>
    <p>• Объекты CS предоставляют эффективный упрощенный механизм блокирования при небольшом количестве конкурирующих потоков, но в некоторых случаях мьютексы обеспечивают лучшую производительность. При использовании объектов CS в критических по отношению к производительности SMP-приложениях возможно настройка производительности с помощью спин-счетчиков.</p>
    <p>• Семафоры могут помочь уменьшить количество конкурирующих активных потоков, не вынуждая вас менять программную модель.</p>
    <p>• Переход на SMP-систему может приводить к неожиданному ухудшению производительности в тех случаях, когда производительность, казалось бы, могла только улучшиться. Сохранить приемлемую производительность в подобных ситуациях позволяют методики, уменьшающие состязательность между потоками и использующие маски родства потоков.</p>
    <p>• Заметное влияние на производительность оказывает также выбор модели — сигнальной или широковещательной, о чем более подробно говорится в главе 10.</p>
    <p>• Используйте доступные стандартные программы протоколирования, позволяющие оценивать время выполнения различных функций и анализировать факторы, влияющие на производительность, что поможет вам лучше представить себе поведение потоков в вашей программе и определить участки кода, выполнение которых занимает наибольшее время.</p>
   </section>
   <section>
    <title>
     <p>Резюме</p>
    </title>
    <section>
     <p>Применение синхронизации может отрицательно воздействовать на производительность как в однопроцессорных, так и в SMP-системах, причем степень такого влияния иногда может становиться весьма существенной. Добиться хорошей производительности в подобных ситуациях можно путем тщательного проектирования программы и правильного выбора типов объектов синхронизации. В этой главе рассмотрен целый ряд полезных методик и даны рекомендации, которые помогут вам поддерживать производительность своих программ на высоком уровне, а также изучен характер возникающих при этом проблем, которые были проиллюстрированы на примере простой тестовой программы, отражающей наиболее существенные характеристики многих реальных ситуаций.</p>
    </section>
    <section>
     <title>
      <p>В следующих главах</p>
     </title>
     <p>В главе 10 рассматриваются более общие способы использования объектов синхронизации Windows и обсуждаются некоторые модели программирования, помогающие обеспечивать корректность программ и удобство их сопровождения, а также повышать их производительность. Также в главе 10 создаются несколько сложных объектов синхронизации, которые оказываются полезными при разрешении ряда важных проблем. В последующих главах демонстрируются различные способы использования потоков и объектов синхронизации, находящие применение в таких, например, приложениях, как серверы. Наряду с этим внимание уделено и некоторым фундаментальным аспектам использования потоков. Например, в главе 12 обсуждаются такие темы, как безопасный многопоточный режим и повторное использование библиотек DLL.</p>
    </section>
    <section>
     <title>
      <p>Дополнительная литература</p>
     </title>
     <p>Литературные источники, относящиеся также к данной главе, перечислены в главе 10.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Упражнения</p>
    </title>
    <p>9.1. Поэкспериментируйте с программой statsMX, используя для этого собственную систему, а также как можно большее количество других доступных вам систем, отличающихся друг от друга не только аппаратным обеспечением, но и версиями Windows. Аналогичны ли полученные вами результаты тем, о которых сообщалось в настоящей главе? Что наблюдается в случае SMP-систем?</p>
    <p>9.2. Используйте функцию TimedMutualExclusionSC для экспериментальной проверки того, что путем изменения значений спин-счетчиков объектов CRITICAL_SECTION действительно можно улучшить производительность SMP-систем в случае большого количества потоков. Результаты могут меняться от системы к системе, однако практические эксперименты показали, что значения счетчиков, лежащие в интервале от 2000 до 10000, являются оптимальными.</p>
    <p>9.3. Используя функцию TimedMutualExclusion, которая находится на Web-сайте книги, проведите эксперименты путем варьирования длительности периодов задержки и количества точек "засыпания" потоков. </p>
    <p>9.4. Для ограничения количества выполняющихся потоков в функции TimedMutualExclusion наряду с другими средствами используется дросселирование семафоров. Поэкспериментируйте со значениями счетчиков как на однопроцессорных, так и на SMP-системах. Воспроизводят ли полученные вами результаты те, о которых сообщалось ранее в настоящей главе?</p>
    <p>9.5. Воспользуйтесь методикой дросселирования семафоров в программе statsMX (statsCS.c, statsMX.с).</p>
    <p>9.6. <emphasis>Упражнение повышенной сложности.</emphasis> Все ли из четырех разновидностей программы работают корректно, если не обращать внимания на производительность, на SMP-системах? Исследуйте результаты, получаемые при большом количестве потоков. Запустите программы на SMP-системах, работающих под управлением Windows 2000 или Windows Server 2003. Проявляются ли при этом проблемы "разрыва слов" ("word tearing") и "конфликтов строки кэша" ("cache line conflict"), описанных ранее в настоящей главе, а также в [6]? Для воспроизведения указанных проблем вам может потребоваться использование 16-битовых (тип данных short integer) счетчиков.</p>
    <p>9.7. Используйте родство процессора в качестве средства улучшения производительности, внеся необходимые изменения в программы, о которых шла речь в настоящей главе.</p>
    <p>9.8. Постарайтесь определить, оказывает ли использование гиперпотоков влияние на производительность приложений. Средства гиперпоточной обработки обеспечиваются, например, процессором Intel Xeon. </p>
   </section>
  </section>
  <section>
   <title>
    <p>ГЛАВА 10</p>
    <p>Усовершенствованные методы синхронизации потоков</p>
   </title>
   <section>
    <p>В предыдущей главе были описаны проблемы производительности, возникающие в Windows, и способы их преодоления в реалистичных ситуациях. В главе 8 обсуждался ряд простых задач, требующих привлечения объектов синхронизации. В настоящей главе на основании идей, изложенные в главах 8 и 9, решаются задачи, которые также встречаются в реальной практике, но отличаются большей сложностью.</p>
    <p>Первое, что нам предстоит сделать — это объединить два или более объекта синхронизации вместе с данными для создания сложного объекта синхронизации. Наиболее полезной комбинацией такого рода является модель переменных условий (condition variable model), включающая мьютекс и одно или несколько событий. Указанная модель играет весьма существенную роль в самых различных практических ситуациях, поскольку многие серьезные программные дефекты, обусловленные влиянием состязательности, проявляются именно тогда, когда объекты синхронизации Windows, особенно события, используются программистами неправильно. События имеют сложную природу и ведут себя по-разному в зависимости от того, какой именно из описанных в табл. 8.1 вариантов используется, и поэтому следует придерживаться определенных правил, устанавливаемых хорошо изученными моделями.</p>
    <p>В последующих разделах показано, как систематизировать управление запуском и отменой выполнения каждого из совместно работающих потоков при помощи асинхронного вызова процедур (Asynchronous Procedure Calls, APC).</p>
    <p>Другие проблемы производительности обсуждаются по мере необходимости.</p>
   </section>
   <section>
    <title>
     <p>Модель переменных условий и свойства безопасности</p>
    </title>
    <section>
     <p>Многопоточные программы намного легче разрабатывать, делать их более понятными и сопровождать, если использовать известные, хорошо разработанные методики и модели. Эти вопросы уже обсуждались в главе 7, в которой для создания полезной концептуальной основы, позволяющей понять принципы работы многопоточных программ, были введены модель "хозяин/рабочий" ("boss/worker") и модель рабочей группы (work crew model). Понятие критических участков кода (critical sections) играет существенную роль при использовании мьютексов, а определение инвариантов (invariants) используемых структур данных также может принести немалую пользу. Наконец, даже для дефектов существуют свои модели, как это было показано на примере взаимной блокировки (deadlock) потоков.</p>
     <cite>
      <p><strong>Примечание</strong></p>
      <p>Компания Microsoft разработала собственный набор моделей, таких как апартаментная модель (apartment model) или модель свободных потоков (free threading). Эта терминология чаще всего встречается в технологии СОМ и кратко обсуждается в конце главы 11.</p>
     </cite>
    </section>
    <section>
     <title>
      <p>Совместное использование событий и мьютексов</p>
     </title>
     <p>Далее показано, как обеспечить совместное использование мьютексов и событий путем обобщения программы 8.2, представляющей описанную ниже ситуацию, с которой нам еще не раз предстоит столкнуться. <emphasis>Примечание.</emphasis> Это обсуждение в равной степени применимо как к мьютексам, так и к объектам CRITICAL_SECTION.</p>
     <p>• Как мьютекс, так и событие связываются с блоком сообщений или иной структурой данных.</p>
     <p>• Мьютекс определяет критический участок кода для доступа к объекту структуры данных.</p>
     <p>• Событие используется для того, чтобы сигнализировать о появлении нового сообщения.</p>
     <p>• Обобщая, можно утверждать, что мьютекс обеспечивает соблюдение условий, определяемых инвариантами объекта (то есть поддерживает свойства безопасности), а событие сигнализирует о том, что состояние объекта изменилось (например, сообщение было добавлено в буфер сообщений или удалено из него), и он мог перейти в известное состояние (например, в буфере сообщений присутствует, по крайней мере, одно сообщение).</p>
     <p>• Один поток (в программе 8.2 — поток производителя) блокирует структуру данных, изменяет состояние объекта путем создания нового сообщения и применяет функции SetEvent или PulseEvent к событию, связанному с появлением нового сообщения.</p>
     <p>• По крайней мере, один поток из числа остальных (в данном примере — поток потребителя) ожидает наступления события, сигнализирующего о том, что объект достиг требуемого состояния. Ожидание должно выполняться за пределами критического участка кода, чтобы поток производителя мог иметь доступ к объекту.</p>
     <p>• Кроме того, поток потребителя может блокировать мьютекс, проверить состояние объекта (например, поступило ли в буфер новое сообщение) и отказаться от ожидания события, если объект уже находится в требуемом состоянии. </p>
    </section>
    <section>
     <title>
      <p>Модель переменных условий</p>
     </title>
     <p>А теперь давайте объединим все это в едином фрагменте кода, представляющем то, что мы будем называть <emphasis>моделью переменных условий</emphasis> (condition variable model, CV model), которая может существовать в виде <emphasis>сигнальной</emphasis> (signal) и <emphasis>широковещательной</emphasis> (broadcast) моделей. В первых примерах будет использована широковещательная модель. Результат представляет собой программную модель, с которой мы будем работать еще не один раз, и которая может быть использована для решения широкого круга задач синхронизации. Для удобства изложения примеры сформулированы в терминах задачи производителя и потребителя.</p>
     <p>Обсуждение может показаться вам несколько абстрактным, однако, поняв суть методики, вы сможете решать многие задачи синхронизации, справиться с которыми без наличия хорошей модели было бы очень трудно.</p>
     <p>В упомянутом фрагменте кода имеется несколько ключевых элементов.</p>
     <p>• Структура данных типа STATE_TYPE, в которой содержатся все данные, или <emphasis>переменные состояний</emphasis> (state variables), такие как сообщения, контрольные суммы и счетчики, используемые в программе 8.2.</p>
     <p>• Мьютекс и одно или более событий, связанных с этой структурой данных и обычно входящих в ее состав.</p>
     <p>• Одна или несколько булевых функций, предназначенных для вычисления <emphasis>предикатов переменных условий</emphasis> (condition variable predicates), представляющих собой условия (состояния), наступления которых может ожидать поток. Например, в качестве предикатов могут использоваться следующие условия: "готово новое сообщение", "имеется свободное место в буфере", "очередь не пуста". Можно связывать с каждым предикатом переменной условия отдельное событие, но возможно также использование одного события для представления изменения состояния или же для представления комбинации нескольких предикатов (получаемой посредством применения операции логического "или"). В последнем случае для определения фактического состояния должны проверяться возвращаемые значения отдельных предикативных функций при блокированном мьютексе. Если предикат (логическое выражение) является простым, необходимость в использовании отдельной функции отпадает.</p>
     <p>Эти принципы используются потоками производителя и потребителя в приведенном ниже фрагменте кода, включающем единственное событие и предикат переменной условия (реализованный с помощью функции cvp, которая здесь не представлена). В данном примере принимается, что если поток производителя сигнализирует о достижении требуемого состояния, то должны быть освобождены сразу несколько потоков, откуда следует, что сигнал должен рассылаться всем ожидающим потокам потребителя. Так, сигналом, соответствующим созданию потоком производителя нескольких сообщений, может служить увеличение значения счетчика сообщений. Во многих случаях вам может требоваться освобождение только одного потока, что обсуждается после приведенного ниже фрагмента кода. </p>
     <p>Этот код ориентирован на работу под управлением Windows 9x и всех версий Windows NT. Для упрощения решения впоследствии в нем будет использована функция SignalObjectAndWait.</p>
     <cite>
      <p><strong>Примечание и предостережение</strong></p>
      <p>В данном примере намеренно и вполне осознанно используется функция PulseEvent, хотя некоторые авторы, а кое-где и документация Microsoft (см. замечания в соответствующем разделе MSDN), этого делать не рекомендуют. Причины нашего выбора будут ясны из последующего обсуждения и подкреплены примерами, а читателю предлагается решить (корректно) эту задачу, используя функцию SetEvent.</p>
     </cite>
     <p><code>typedef struct _state_t {</code></p>
     <p><code> HANDLE Guard; /* Мьютекс, защищающий объект. */</code></p>
     <p><code> HANDLE CvpSet; /* Вручную сбрасываемое событие — выполняется условие, определяемое предикатом cvp(). */</code></p>
     <p><code> … <emphasis>другие переменные условий</emphasis> …</code></p>
     <p><code> /* Структура состояния, содержащая счетчики, контрольные суммы и прочее. */</code></p>
     <p><code> struct STATE_VAR_TYPE StateVar;</code></p>
     <p><code> } STATE_TYPE State;</code></p>
     <p><code>…</code></p>
     <p><code>/* Инициализировать состояние, создавая мьютекс и событие. */</code></p>
     <p><code>…</code></p>
     <p><code>/* Поток ПРОИЗВОДИТЕЛЯ, который изменяет состояние. */</code></p>
     <p><code>WaitForSingleObject(State.Guard, INFINITE);</code></p>
     <p><code>/* Изменить состояние таким образом, чтобы выполнялось условие, */</code></p>
     <p><code>/* определяемое предикатом CV. */</code></p>
     <p><code>/* Пример: к данному моменту подготовлено одно или несколько сообщений.*/</code></p>
     <p><code>State.StateVar.MsgCount += N;</code></p>
     <p><code>PulseEvent(State.CvpSet);</code></p>
     <p><code>ReleaseMutex(State.Guard);</code></p>
     <p><code>/* Конец интересующей нас части кода потока производителя. */</code></p>
     <p><code>…</code></p>
     <p><code>/* Ожидание определенного состояния функцией потока ПОТРЕБИТЕЛЯ. */ </code></p>
     <p><code>WaitForSingleObject(State.Guard, INFINITE); </code></p>
     <p><code>while (!cvp(&amp;State)) {</code></p>
     <p><code> ReleaseMutex(State.Guard);</code></p>
     <p><code> WaitForSingleObject(State.CvpSet, TimeOut);</code></p>
     <p><code> WaitForSingleObject(State.Guard, INFINITE); </code></p>
     <p><code>}</code></p>
     <p><code>/* Теперь этот поток владеет мьютексом, и выполняется условие, */ </code></p>
     <p><code>/* определяемое предикатом cvp(&amp;State). */ </code></p>
     <p><code>/* Предпринять соответствующее действие, возможно, изменяя состояние.*/</code></p>
     <p><code>…</code></p>
     <p><code>ReleaseMutex(State.Guard); </code></p>
     <p><code>/* Конец интересующей нас части кода потока потребителя. */</code> </p>
     <subtitle><emphasis>Комментарии по поводу модели переменных условий</emphasis></subtitle>
     <p>В приведенном выше фрагменте кода очень важная роль принадлежит циклу в той части кода, которая соответствует потребителю. Этот цикл включает три операции: 1) освобождение мьютекса, заблокированного до входа в цикл; 2) ожидание события; 3) повторное блокирование мьютекса. Как будет показано далее, <emphasis>использование конечного интервала ожидания события является весьма существенным.</emphasis></p>
     <p>Потоки Pthreads в том виде, в каком они реализованы во многих системах UNIX и других системах, сочетают эти три операции в одной функции — pthread_cond_wait, объединяющей мьютекс и переменную условия (которая аналогична, но не идентична событиям Windows). Именно поэтому и используется термин <emphasis>модель переменных условий.</emphasis> Существует также версия этой функции, допускающая использование конечных интервалов ожидания событий.</p>
     <p>Что немаловажно, в Pthreads первые две операции (освобождение мьютекса и ожидание события) реализуются посредством вызова одной функции как одна атомарная операция, так что никакой другой поток не сможет вклиниться раньше, чем начнется выполнения вызывающим потоком функции ожидания наступления события (или выполнения условия).</p>
     <p>Проектировщики Pthreads сделали мудрый выбор: единственный способ организовать ожидания выполнения условия, определенного для переменной условия, — это использование одной из двух указанных выше функций (с конечным и неопределенным интервалами ожидания), так что переменная условия должна всегда использоваться вместе с мьютексом. Windows вынуждает вас использовать для этой цели два или три отдельных вызова функций, и вы сами должны проследить за тем, чтобы все было сделано правильно, иначе вам не избежать проблем.</p>
     <p>Помимо того, что это упрощает разработку программ и является существенно необходимым в случае использования потоков Pthreads, есть еще одна причина, по которой следует изучать модель CV, заключающаяся в том, что именно эта модель используется рядом сторонних производителей для реализации классов потоков и объектов синхронизации, не зависящих от ОС. Владея изложенным в этой книге материалом, вы сможете очень быстро разобраться в особенностях этих реализаций.</p>
     <cite>
      <p><strong>Примечание</strong></p>
      <p>В версии Windows NT 4.0 была введена новая функция — SignalObjectAndWait (SOAW), которая выполняет упомянутые два шага атомарным образом. В дальнейших примерах программ предполагается, что эта функция доступна, и она будет использоваться, а это означает, что под управлением Windows 9x такие программы выполняться не смогут. Тем не менее, на стадии ознакомления с моделью CV функция SOAW не применяется, чтобы сделать более понятной мотивировку необходимости ее использования впоследствии, а на Web-сайте книги приведены альтернативные варианты реализации некоторых примеров, в которых вместо мьютексов используются объекты CS. (Функцию SOAW нельзя применять вместе с объектами CS.) О значительных преимуществах функции SignalObjectAndWait в отношении производительности свидетельствуют данные, представленные в приложении В (табл. В.5). </p>
     </cite>
     <subtitle><emphasis>Использование модели переменных условий</emphasis></subtitle>
     <p>Модель переменных условий при правильной ее реализации работает следующим образом:</p>
     <p>• Поток производителя блокирует мьютекс, изменяет состояние, применяет к событию функцию PulseEvent, когда это необходимо, и разблокирует мьютекс. Например, функция PulseEvent может вызываться в случае готовности одного или нескольких сообщений.</p>
     <p>• Функция PulseEvent должна применяться к событию при блокированном мьютексе, чтобы никакой другой поток не мог изменить объект, что могло бы сделать недействительным условие, определенное предикатом.</p>
     <p>• Поток потребителя тестирует предикат переменной условия при блокированном мьютексе. Если условие, выраженное предикатом, выполняется, выполнять функцию ожидания нет никакой необходимости.</p>
     <p>• Если же условие, выраженное предикатом, не выполняется, поток потребителя должен разблокировать мьютекс до выполнения ожидания события. Если этого не сделать, то никакой поток вообще не сможет изменить состояние и установить событие.</p>
     <p>• Интервал ожидания события должен быть конечным, чтобы обеспечить правильную обработку в том случае, если поток производителя применит к событию функцию PulseEvent в промежутке времени между освобождением мьютекса (шаг 1) и выполнением ожидания события (шаг 2). Таким образом, без использования <emphasis>конечного</emphasis> интервала ожидания сигнал мог бы потеряться, что является еще одним примером проявления проблемы состязательности. К потере сигналов могут приводить и асинхронные вызовы процедур, описанные далее в этой главе. Используемый в приведенном выше фрагменте кода интервал ожидания является настраиваемым параметром. (С комментариями по поводу оптимальных значений этого параметра вы можете ознакомиться, обратившись к приложению В.)</p>
     <p>• По завершении ожидания события поток потребителя всегда повторно проверяет выполнение условия, определенного предикатом. Среди прочих других причин, это необходимо делать с учетом того, что интервал ожидания может просто исчерпаться. Кроме того, за это время состояние также могло измениться. Например, поток производителя мог сгенерировать два сообщения, а затем освободить три ожидающих потока потребителя, в результате чего один из потребителей проверит состояние, определит, что сообщения отсутствуют, и продолжит выполнение ожидания. Наконец, повторная проверка предиката необходима для защиты от ложного пробуждения потоков, которое могло бы произойти в результате того, что поток установит событие в сигнальное состояние или применит к нему функцию PulseEvent без предварительного блокирования мьютекса. </p>
     <p>• После выхода из цикла поток потребителя всегда сохраняет за собой право владения мьютексом, независимо от того, выполнялось или не выполнялось тело цикла.</p>
     <subtitle><emphasis>Разновидности модели переменных условий</emphasis></subtitle>
     <p>Прежде всего, обратите внимание на то, что в предшествующем фрагменте кода используется сбрасываемое вручную событие и вызывается функция PulseEvent, а не функция SetEvent. Является ли такой выбор корректным и возможен ли иной способ использования события? Ответ на оба эти вопросы является положительным.</p>
     <p>Вернувшись к табл. 8.1, можно увидеть, что сбрасываемые вручную события характеризуются освобождением <emphasis>нескольких потоков.</emphasis> Это именно так в случае нашего примера, в котором генерируются несколько сообщений и существует несколько потоков потребителя, и все они должны быть оповещены о произошедших изменениях. В то же время, если поток производителя создает всего лишь одно сообщение и имеется несколько потоков потребителя, то событие должно быть автоматически сбрасываемым, а поток производителя должен вызывать функцию SetEvent, чтобы обеспечить освобождение только одного потока. В этом случае мы имеем дело не с сигнальной разновидностью модели CV, а с широковещательной. При этом по-прежнему остается существенным, чтобы освобожденный поток потребителя, который приобретает права владения мьютексом, изменил объект для указания того, что доступные сообщения отсутствуют (то есть, что условие, определяемое предикатом переменной условия, уже не выполняется).</p>
     <p>Из четырех возможных комбинаций, указанных в табл. 8.1, для модели переменных условий важны только две. Что касается двух других комбинаций, то в силу конечности интервала ожидания эффект комбинации "автоматически сбрасываемое событие/PulseEvent" будет тем же, что и комбинации "автоматически сбрасываемое событие/SetEvent" (сигнальная модель CV), однако зависимость от длительности интервала ожидания приведет к снижению характеристик реактивности.</p>
     <p>Использование же комбинации "вручную сбрасываемое событие/PulseEvent" приведет к появлению ложных сигналов (от которых, правда, можно защититься проверкой предикатов переменных условий), поскольку событие должно быть сброшено каким-либо из потоков, а до сброса события потоки будут состязаться между собой.</p>
     <p>Подводя итоги, можно сделать вывод, что комбинация "автоматически сбрасываемое событие/SetEvent" представляет собой сигнальную модель CV, в которой освобождается единственный из ожидающих потоков, а комбинация "вручную сбрасываемое событие/PulseEvent" — широковещательную модель CV, в которой освобождаются все ожидающие потоки. Для потоков Pthreads существуют те же различия, но использование конечных интервалов ожидания событий для широковещательной модели в данном случае не требуется, тогда как в Windows этот фактор является весьма существенным, поскольку освобождение мьютекса и ожидание события не выполняются атомарно, то есть за одну операцию. В то же время, введение функции SignalObjectAndWait меняет эту ситуацию.</p>
     <subtitle><emphasis>Пример предиката переменной условия</emphasis></subtitle>
     <p>Рассмотрим следующий предикат переменной условия:</p>
     <p><code>State.StateVar.Count &gt;= K;</code></p>
     <p>В данном случае поток потребителя будет ожидать до тех пор, пока значение счетчика не станет достаточно большим, и поток производителя может увеличивать это значение на произвольную величину. Отсюда, например, становится понятным, как можно реализовать сложные семафоры; вспомните, что обычные семафоры не допускают атомарного выполнения нескольких функций ожидания. В данном же случае поток потребителя может просто уменьшить значение счетчика на К единиц после выхода из цикла, но перед тем, как освободить мьютекс.</p>
     <p>Заметьте, что в данном случае подходит широковещательная модель CV, поскольку один поток производителя может увеличить значение счетчика и тем самым разрешить выполнение нескольким, но не всем ожидающим потокам потребителя.</p>
     <subtitle><emphasis>Семафоры и модель переменных условий</emphasis></subtitle>
     <p>В некоторых случаях уместнее использовать не события, а семафоры, преимущество которых заключается в том, что они позволяют указывать точное количество потоков, которые необходимо освободить. Например, если бы было известно, что каждый из потоков потребителя может получить только одно сообщение, то поток производителя мог бы вызвать функцию ReleaseSemaphore, используя в качестве параметра точное количество сгенерированных сообщений. Однако в общем случае потоку производителя ничего не известно о том, каким образом отдельные потоки потребителя изменят структуру переменной состояния, и поэтому модель переменных условий применима для решения более широкого круга задач.</p>
     <p>Модель CV обладает достаточно мощными возможностями, которых хватает для реализации семафоров. Как уже отмечалось ранее, в основе этого метода лежит определение предиката, эквивалентного утверждению: "значение счетчика является ненулевым", и создание структуры состояния, содержащей текущее значение счетчика и его максимально допустимое значение. В упражнении 10.11 представлено завершенное решение, позволяющее манипулировать функциями ожидания путем изменения значений счетчика на несколько единиц одной операцией. Создание семафоров для потоков Pthreads не предусмотрено, поскольку переменные условий предоставляют достаточно широкие возможности. </p>
    </section>
    <section>
     <title>
      <p>Использование функции SignalObjectAndWait</p>
     </title>
     <p>Цикл, выполняемый потоком потребителя в предшествующем фрагменте кода, играет очень важную роль в модели CV, поскольку в нем выполняется ожидание изменения состояния, а затем проверяется, является ли состояние именно тем, какое требуется. Последнее условие может не выдерживаться, если событие оказывается слишком <emphasis>обобщенным,</emphasis> указывая, например, только на сам факт изменения состояния, а не на характеристики такого изменения. К тому же, другие потоки могут дополнительно изменить состояние, например, очистить буфер сообщений. Упомянутый цикл требовал выполнения двух функций ожидания и одной функции освобождения мьютекса, как показано ниже.</p>
     <p><code>while (!cvp(&amp;State)) {</code></p>
     <p><code> ReleaseMutex(State.Guard);</code></p>
     <p><code> WaitForSingleObject(State.CvpSet, TimeOut);</code></p>
     <p><code> WaitForSingleObject(State.Guard, INFINITE); </code></p>
     <p><code>}</code></p>
     <p>Использование конечного интервала ожидания (time-out) при выполнении первой функции ожидания (ожидание события) требуется здесь для того, чтобы избежать потери сигналов или возникновения других вероятных проблем. Этот код будет работать как под управлением Windows 9x, так и под управлением Windows NT 3.5 (еще одна устаревшая версия Windows), а предыдущий фрагмент кода сохранит свою работоспособность и в том случае, если мьютексы заменить объектами CS.</p>
     <p>Однако в случае Windows NT 5.x (XP, 2000 и Server 2003) и даже Windows NT 4.0 мы можем использовать функцию SignalObjectAndWait — важный элемент усовершенствования, который избавляет от необходимости применения конечных интервалов ожидания и объединяет освобождение мьютекса и ожидание события. При этом кроме явного упрощения программы, производительность в общем случае повышается, что объясняется устранением системного вызова и отсутствием необходимости в настройке длительности интервала ожидания. </p>
     <cite>
      <p><code>DWORD SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)</code> </p>
     </cite>
     <p>Эта функция, при вызове которой используются дескрипторы, указывающие соответственно на мьютекс и событие, упрощает цикл потребителя. Интервал ожидания здесь отсутствует, поскольку вызывающий поток переходит к ожиданию второго дескриптора <emphasis>сразу же </emphasis>после того, как первый дескриптор переходит в сигнальное состояние (что в данном случае означает освобождение мьютекса). Перевод объекта в сигнальное состояние и переход к ожиданию осуществляются атомарным образом, то есть за одну операцию, так что никакой другой поток не может сигнализировать о наступлении события в течение промежутка времени между освобождением мьютекса вызывающим потоком и ожидания потоком события, на которое указывает второй дескриптор. Тогда упрощенный цикл потребителя приобретает следующий вид:</p>
     <p><code>while (!cvp(&amp;State)) {</code></p>
     <p><code> SignalObjectAndWait(State.Guard, State.CvpSet, INFINITE, FALSE);</code></p>
     <p><code> WaitForSingleObject (State.Guard, INFINITE); </code></p>
     <p><code>}</code></p>
     <p>Значением последнего аргумента этой функции, bAlertable, в данном случае является FALSE, однако в последующих разделах, посвященных рассмотрению АРС, он будет полагаться равным TRUE.</p>
     <p>Вообще говоря, оба дескриптора могут указывать на любые подходящие объекты синхронизации. В то же время, использовать объект CRITICAL_SECTION в качестве объекта, сигнальное состояние которого отслеживается, нельзя, поскольку допустимыми являются только объекты ядра.</p>
     <p>Функция SignalObjectAndWait применяется во всех примерах программ, представленных как в книге, так и на Web-сайте, хотя на Web-сайте находятся и другие варианты решений, о которых будет говориться в тексте. Если программа должна выполняться под управлением Windows 9x, то следует заменить эту функцию парой функций "сигнал/ожидание", как в первоначально приведенном фрагменте кода, и обязательно использовать конечный интервал ожидания.</p>
     <p>В разделе, посвященном АРС, представлены различные методы отправки сигналов ожидающим потокам, обеспечивающие получение сигналов только определенными потоками, тогда как в случае событий простых способов, позволяющих контролировать, каким потокам направляются сигналы, не существует.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: объект порогового барьера</p>
    </title>
    <section>
     <p>Предположим, вам необходимо, чтобы рабочие потоки оставались в состоянии ожидания и не выполнялись до тех пор, пока количество таких потоков не станет достаточным для образования рабочей группы, способной выполнить нужную работу. Как только количество потоков достигает порогового значения, все ожидающие рабочие потоки начинают выполняться, а появляющиеся впоследствии дополнительные рабочие потоки будут выполняться без ожидания. Эту задачу можно решить путем создания сложного объекта порогового барьера (threshold barrier compound object).</p>
     <p>В программах 10.1 и 10.2 представлена реализация трех функций, поддерживающих сложный объект барьера. Две из этих функций, CreateThresholdBarrier и CloseThresholdBarrier, управляют переменными THB_HANDLE, аналогичными дескрипторам, которые на протяжении всего времени применялись нами вместе с объектами ядра. Пороговое количество потоков является параметром функции CreateThresholdBarrier. </p>
     <p>Программа 10.1 представляет соответствующую часть заголовочного файла, SynchObj.h, тогда как программа 10.2 — реализацию трех упомянутых функций. Обратите внимание, что объект барьера содержит мьютекс, событие, счетчик и пороговое значение. Предикат переменной условия документирован в заголовочном файле, а именно, событие должно устанавливаться только тогда, когда значение счетчика достигает или становится больше порогового значения.</p>
     <subtitle>Программа 10.1. SynchObj.h: часть 1 — объявления объекта порогового барьера </subtitle>
     <p><code>/* Глава 10. Сложные объекты синхронизации. */</code></p>
     <p><code>#define CV_TIMEOUT 50 /* Настраиваемый параметр для модели CV. */</code></p>
     <p><code>/* ОБЪЕКТ ПОРОГОВОГО БАРЬЕРА — ОПРЕДЕЛЕНИЕ ТИПА И ПРОТОТИПЫ ФУНКЦИЙ. */ </code></p>
     <p><code>typedef struct THRESHOLD_BARRIER_TAG { /* Пороговый барьер. */</code></p>
     <p><code> HANDLE b_guard; /* Мьютекс для объекта. */</code></p>
     <p><code> HANDLE b_broadcast; /* Вручную сбрасываемое событие: b_count &gt;= b_threshold.*/</code></p>
     <p><code> volatile DWORD b_destroyed; /* Установить после закрытия. */</code></p>
     <p><code> volatile DWORD b_count; /* Количество потоков до достижения барьера. */</code></p>
     <p><code> volatile DWORD b_threshold; /* Пороговый барьер. */ </code></p>
     <p><code>} THRESHOLD_BARRIER, *THB_HANDLE;</code></p>
     <empty-line/>
     <p><code>/* Коды ошибок. */</code></p>
     <p><code>#define SYNCH_OBJ_NOMEM 1 /* Невозможно выделить ресурсы. */</code></p>
     <p><code>#define SYNCH_OBJ_BUSY 2 /* Объект используется и не может быть закрыт. */</code></p>
     <p><code>#define SYNCH_OBJ_INVALID 3 /* Объект более не является действительным. */</code></p>
     <p><code>DWORD CreateThresholdBarrier(THB_HANDLE *, DWORD /* Порог. */); </code></p>
     <p><code>DWORD WaitThresholdBarrier(THB_HANDLE); </code></p>
     <p><code>DWORD CloseThresholdBarrier(THB_HANDLE);</code> </p>
     <p>Рассмотрим теперь предложенную в программе 10.2 реализацию трех функций. На Web-сайте книги находится тестовая программа testTHB. Обратите внимание на уже знакомый вам цикл проверки переменной условия в функции ожидания WaitThresholdBarrier. Кроме того, эта функция не только ожидает наступления события, но и переводит объект события в сигнальное состояние с помощью функции PulseEvent. Предыдущее обсуждение модели "производитель/потребитель" предполагало использование отдельных функций потоков.</p>
     <p>Наконец, в данном случае предикат переменной условия обладает последействием. Как только условие выполнилось, оно будет выполняться и в дальнейшем, что исключает возможность перевода объекта события в сигнальное состояние более одного раза.</p>
     <subtitle>Программа 10.2. ThbObject.с: реализация объекта порогового барьера </subtitle>
     <p><code>/* Глава 10. Программа 10.2. */</code></p>
     <p><code>/* Библиотека сложных объектов синхронизации на основе порогового барьера.*/</code></p>
     <p><code>#include "EvryThng.h" </code></p>
     <p><code>#include "synchobj.h" </code></p>
     <p><code>/**********************************/</code></p>
     <p><code>/*   ОБЪЕКТЫ ПОРОГОВОГО БАРЬЕРА   */ </code></p>
     <p><code>/**********************************/</code></p>
     <p><code>DWORD CreateThresholdBarrier(THB_HANDLE *pthb, DWORD b_value) {</code></p>
     <p><code> THB_HANDLE hthb;</code></p>
     <p><code> /* Инициализация объекта барьера. Вариант программы с полной проверкой ошибок находится на Web-сайте. */</code></p>
     <p><code> hthb = malloc(sizeof(THRESHOLD_BARRIER));</code></p>
     <p><code> hthb-&gt;b_guard = CreateMutex(NULL, FALSE, NULL);</code></p>
     <p><code> hthb-&gt;b_broadcast = CreateEvent(NULL, FALSE /* Автоматически сбрасываемое событие. */, FALSE, NULL);</code></p>
     <p><code> hthb-&gt;b_threshold = b_value;</code></p>
     <p><code> hthb-&gt;b_count = 0;</code></p>
     <p><code> hthb-&gt;b_destroyed = 0;</code></p>
     <p><code> *pthb = hthb;</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>DWORD WaitThresholdBarrier(THB_HANDLE thb) {</code></p>
     <p><code> /* Ожидать, пока заданное количество потоков не достигнет порога, а затем установить событие. */</code></p>
     <p><code> if (thb-&gt;b_destroyed == 1) return SYNCH_OBJ_INVALID;</code></p>
     <p><code> WaitForSingleObject(thb-&gt;b_guard, INFINITE);</code></p>
     <p><code> thb-&gt;b_count++; /* Появился новый поток. */</code></p>
     <p><code> while (thb-&gt;b_count &lt; thb-&gt;b_threshold) {</code></p>
     <p><code>  SignalObjectAndWait(thb-&gt;b_guard, thb-&gt;b_broadcast, INFINITE, FALSE);</code></p>
     <p><code>  WaitForSingleObject(thb-&gt;b_guard, INFINITE);</code></p>
     <p><code> }</code></p>
     <p><code> PulseEvent(thb-&gt;b_broadcast) ;</code></p>
     <p><code> /* Широковещательная модель CV, освобождение всех ожидающих потоков. */</code></p>
     <p><code> ReleaseMutex(thb-&gt;b_guard);</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>DWORD CloseThresholdBarrier(THB_HANDLE thb) {</code></p>
     <p><code> /* Уничтожить мьютекс и событие объекта барьера. */</code></p>
     <p><code> /* Убедиться в отсутствии потоков, ожидающих объект. */</code></p>
     <p><code> if (thb-&gt;b_destroyed == 1) return SYNCH_OBJ_INVALID;</code></p>
     <p><code> WaitForSingleObject(thb-&gt;b_guard, INFINITE);</code></p>
     <p><code> if (thb-&gt;b_count &lt; thb-&gt;b_threshold) {</code></p>
     <p><code>  ReleaseMutex(thb-&gt;b_guard);</code></p>
     <p><code>  return SYNCH_OBJ_BUSY;</code></p>
     <p><code> }</code></p>
     <p><code> ReleaseMutex(thb-&gt;b_guard);</code></p>
     <p><code> CloseHandle(thb-&gt;b_guard);</code></p>
     <p><code> CloseHandle(thb-&gt;b_broadcast);</code></p>
     <p><code> free(thb);</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
    </section>
    <section>
     <title>
      <p>Комментарии по поводу реализации объекта порогового барьера</p>
     </title>
     <p>Возможности реализованного выше объекта порогового барьера в интересах простоты были намеренно ограничены. Вообще говоря, было бы желательно эмулировать объекты Windows следующим образом:</p>
     <p>• Разрешив объектам иметь атрибуты защиты (глава 15).</p>
     <p>• Разрешив присвоение имен объектам.</p>
     <p>• Допуская наличие у одного объекта нескольких "дескрипторов" и не уничтожая их до тех пор, пока счетчик ссылок не станет равным 0.</p>
     <p>• Разрешив совместное использование объекта несколькими процессами.</p>
     <p>На Web-сайте доступна полная реализация одного из таких объектов — сложного (multiple-wait) семафора, допускающего изменение счетчика семафора сразу на несколько единиц, которая использует методы, применимые по отношению к любому из объектов, рассматриваемых в данной главе.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Объект очереди</p>
    </title>
    <section>
     <p>До сих пор мы связывали с каждым мьютексом только одно событие, но в общем случае могут существовать несколько предикатов переменных условий. Например, в случае очереди, действующей по принципу "первым пришел, первым ушел" (first in first out, FIFO), поток, который пытается удалить элемент из очереди, должен дождаться события, указывающего на то, что очередь не является пустой, а поток, помещающий элемент в очередь, должен дождаться события, указывающего на то, что очередь не является заполненной. Решение заключается в предоставлении двух событий — по одному для каждого условия.</p>
     <p>В программе 10.3 представлены необходимые объявления объекта очереди и его функций. В объявлениях намеренно применяется стиль, отличающийся от того, который принят в Windows и который мы использовали до сих пор. Эта программа была получена преобразованием ее первоначального варианта, реализованного в UNIX на основе потоков Pthreads, чем и объясняется происхождение использованного нами стиля. Точно так же и вы можете наследовать тот или иной стиль или определить собственный, который соответствует вашему вкусу или принятым в вашей организации требованиям. В упражнении 10.7 вам предлагается преобразовать приведенный стиль к стилю Windows.</p>
     <p>Программы 10.4 и 10.5 представляют функции очереди и программу, которая их использует.</p>
     <subtitle>Программа 10.3. SynchObj.h: часть 2 — объявления объекта очереди </subtitle>
     <p><code>/* Объявления структуры обычной ограниченной синхронизированной очереди.*/ </code></p>
     <p><code>/* Очереди закольцованы и реализованы в виде массивов с индексацией */ </code></p>
     <p><code>/* последнего и первого сообщений. */</code></p>
     <p><code>/* Кроме того, каждая очередь содержит защитный мьютекс и */ </code></p>
     <p><code>/* переменные условий "очередь не пуста" и "очередь не заполнена". */ </code></p>
     <p><code>/* Наконец, имеется указатель массива сообщений произвольного типа. */ </code></p>
     <p><code>typedef struct queue_tag { /* Универсальная очередь. */</code></p>
     <p><code> HANDLE q_guard; /* Защита блока сообщения. */</code></p>
     <p><code> HANDLE q_ne; /* Очередь не пуста. Вручную сбрасываемое событие. (Автоматически сбрасываемое событие для "сигнальной модели".) */</code></p>
     <p><code> HANDLE q_nf; /* Очередь не заполнена. Вручную сбрасываемое событие. (Автоматически сбрасываемое событие для "сигнальной модели".) */</code></p>
     <p><code> volatile DWORD q_size; /* Максимальный размер очереди. */</code></p>
     <p><code> volatile DWORD q_first; /* Индекс первого сообщения. */</code></p>
     <p><code> volatile DWORD q_last; /* Индекс последнего сообщения. */</code></p>
     <p><code> volatile DWORD q_destroyed; /* Получатель сообщений очереди завершил выполнение. */</code></p>
     <p><code> PVOID msg_array; /* Массив q_size сообщений. */ </code></p>
     <p><code>} queue_t;</code></p>
     <empty-line/>
     <p><code>/* Функции управления очередью. */</code></p>
     <p><code>DWORD q_initialize(queue_t *, DWORD, DWORD);</code></p>
     <p><code>DWORD q_destroy(queue_t *);</code></p>
     <p><code>DWORD q_destroyed(queue_t *);</code></p>
     <p><code>DWORD q_empty(queue_t *);</code></p>
     <p><code>DWORD q_full(queue_t *);</code></p>
     <p><code>DWORD q_get(queue_t *, PVOID, DWORD, DWORD);</code></p>
     <p><code>DWORD q_put(queue_t *, PVOID, DWORD, DWORD);</code></p>
     <p><code>DWORD q_remove(queue_t *, PVOID, DWORD);</code></p>
     <p><code>DWORD q_insert(queue_t *, PVOID, DWORD);</code> </p>
     <p>В программе 10.4 представлены такие функции, как q_initialize и q_get, прототипы которых описаны в конце программы 10.3. Обратите внимание, что функции q_get и q_put обеспечивают синхронизацию доступа, а функции q_remove и q_insert, которые вызываются первыми двумя функциями, сами по себе не являются синхронизированными и могут быть использованы в однонитевых программах. В первых двух функциях предусмотрена возможность использования конечных интервалов ожидания, что требует незначительного расширения модели переменных условий.</p>
     <p>q_empty и q_full — две другие важные функции, которые используются для реализации предикатов переменных условий.</p>
     <p>Данная реализация использует функцию PulseEvent и вручную сбрасываемые события (широковещательная модель), так что все события уведомляются о том, что очередь не пуста или не заполнена.</p>
     <p>Замечательной особенностью этой реализации является симметрия функций q_get и q_put. Обратите внимание хотя бы на то, как в этих функциях используются предикаты пустой и заполненной очередей или события. Подобная простота не только восхитительна сама по себе, но и имеет благоприятные практические последствия, облегчающие написание, понимание и сопровождение программы, и все это было достигнуто за счет использования модели переменных условий. </p>
     <p>Наконец, те, кто программирует на C++, легко сообразят, что приведенный код может быть использован для создания класса синхронизированной очереди; именно это вам и предлагается сделать в упражнении 10.8.</p>
     <subtitle>Программа 10.4. QueueObj.с: функции управления очередью </subtitle>
     <p><code>/* Глава 10. QueueObj.c. */ </code></p>
     <p><code>/* Функции очереди */</code></p>
     <p><code>#include "EvryThng.h"</code></p>
     <p><code>#include "SynchObj.h"</code></p>
     <p><code>/* Функции управления конечной ограниченной очередью. */</code></p>
     <p><code>DWORD q_get(queue_t *q, PVOID msg, DWORD msize, DWORD MaxWait) {</code></p>
     <p><code> if (q_destroyed (q)) return 1;</code></p>
     <p><code> WaitForSingleObject(q-&gt;q_guard, INFINITE);</code></p>
     <p><code> while (q_empty(q)) {</code></p>
     <p><code>  SignalObjectAndWait(q-&gt;q_guard, q-&gt;q_ne, INFINITE, FALSE);</code></p>
     <p><code>  WaitForSingleObject(q-&gt;q_guard, INFINITE);</code></p>
     <p><code> }</code></p>
     <p><code> /* Удалить сообщение из очереди. */</code></p>
     <p><code> q_remove(q, msg, msize);</code></p>
     <p><code> /* Сигнализировать о том, что очередь не заполнена, поскольку мы удалили сообщение. */</code></p>
     <p><code> PulseEvent(q-&gt;q_nf);</code></p>
     <p><code> ReleaseMutex(q-&gt;q_guard);</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>DWORD q_put(queue_t *q, PVOID msg, DWORD msize, DWORD MaxWait) {</code></p>
     <p><code> if (q_destroyed(q)) return 1;</code></p>
     <p><code> WaitForSingleObject(q-&gt;q_guard, INFINITE);</code></p>
     <p><code> while(q_full(q)) {</code></p>
     <p><code>  SignalObjectAndWait(q-&gt;q_guard, q-&gt;q_nf, INFINITE, FALSE);</code></p>
     <p><code>  WaitForSingleObject(q-&gt;q_guard, INFINITE);</code></p>
     <p><code> }</code></p>
     <p><code> /* Поместить сообщение в очередь. */</code></p>
     <p><code> q_insert(q, msg, msize);</code></p>
     <p><code> /* Сигнализировать о том, что очередь не пуста; мы вставили сообщение.*/</code></p>
     <p><code> PulseEvent (q-&gt;q_ne);</code></p>
     <p><code> /* Широковещательная модель CV. */</code></p>
     <p><code> ReleaseMutex(q-&gt;q_guard);</code></p>
     <p><code> return 0;</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>DWORD q_initialize(queue_t *q, DWORD msize, DWORD nmsgs) {</code></p>
     <p><code> /* Инициализация очереди, включая ее мьютекс и события. */</code></p>
     <p><code> /* Выделить память для всех сообщений. */</code></p>
     <p><code> q-&gt;q_first = q-&gt;q_last = 0;</code></p>
     <p><code> q-&gt;q_size = nmsgs;</code></p>
     <p><code> q-&gt;q_destroyed = 0;</code></p>
     <p><code> q-&gt;q_guard = CreateMutex(NULL, FALSE, NULL); </code></p>
     <p><code> q-&gt;q_ne = CreateEvent(NULL, TRUE, FALSE, NULL);</code></p>
     <p><code> q-&gt;q_nf = CreateEvent(NULL, TRUE, FALSE, NULL);</code></p>
     <p><code> if ((q-&gt;msg_array = calloc(nmsgs, msize)) == NULL) return 1;</code></p>
     <p><code> return 0; /* Ошибки отсутствуют. */ </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>DWORD q_destroy(queue_t *q) {</code></p>
     <p><code> if (q_destroyed(q)) return 1;</code></p>
     <p><code> /* Освободить все ресурсы, созданные вызовом q_initialize. */</code></p>
     <p><code> WaitForSingleObject(q-&gt;q_guard, INFINITE);</code></p>
     <p><code> q-&gt;q_destroyed = 1;</code></p>
     <p><code> free(q-&gt;msg_array);</code></p>
     <p><code> CloseHandle(q-&gt;q_ne);</code></p>
     <p><code> CloseHandle(q-&gt;q_nf);</code></p>
     <p><code> ReleaseMutex(q-&gt;q_guard);</code></p>
     <p><code> CloseHandle(q-&gt;q_guard);</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>DWORD q_destroyed(queue_t *q) {</code></p>
     <p><code> return (q-&gt;q_destroyed); </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>DWORD q_empty(queue_t *q) {</code></p>
     <p><code> return (q-&gt;q_first == q-&gt;q_last); </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>DWORD q_full(queue_t *q) {</code></p>
     <p><code> return ((q-&gt;q_last – q-&gt;q_first) == 1 || (q-&gt;q_first == q-&gt;q_size-l &amp;&amp; q-&gt;q_last == 0)); </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>DWORD q_remove(queue_t *q, PVOID msg, DWORD msize) {</code></p>
     <p><code> char *pm;</code></p>
     <p><code> pm = (char *)q-&gt;msg_array;</code></p>
     <p><code> /* Удалить наиболее давнее ("первое") сообщение. */</code></p>
     <p><code> memcpy(msg, pm + (q-&gt;q_first * msize), msize);</code></p>
     <p><code> q-&gt;q_first = ((q-&gt;q_first + 1) % q-&gt;q_size);</code></p>
     <p><code> return 0; /* Ошибки отсутствуют. */ </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>DWORD q_insert(queue_t *q, PVOID msg, DWORD msize) {</code></p>
     <p><code> char *pm;</code></p>
     <p><code> pm = (char *)q-&gt;msg_array;</code></p>
     <p><code> /* Добавить новое ("последнее") сообщение. */</code></p>
     <p><code> if (q_full(q)) return 1; /* Ошибка – очередь заполнена. */</code></p>
     <p><code> memcpy(pm + (q-&gt;q_last * msize), msg, msize);</code></p>
     <p><code> q-&gt;q_last = ((q-&gt;q_last + 1) % q-&gt;q_size);</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code> </p>
    </section>
    <section>
     <title>
      <p>Комментарии по поводу функций управления очередью с точки зрения производительности</p>
     </title>
     <p>В приложении В представлены данные, характеризующие производительность программы 10.5, в которой используются функции управления очередью. Приведенные ниже замечания по поводу различных факторов, которые могут оказывать влияние на производительность, основываются на этих данных. Программные коды упоминаемых ниже альтернативных вариантов реализации находятся на Web-сайте книги.</p>
     <p>• В данной реализации используется широковещательная модель ("вручную сбрасываемое событие/PulseEvent"), обеспечивающая поддержку общего случая, когда один поток может запрашивать или создавать несколько сообщений. Если такая общность не требуется, можно использовать сигнальную модель ("автоматически сбрасываемое событие/SetEvent"), которая, к тому же, обеспечит значительно более высокую производительность, поскольку для тестирования предиката будет освобождаться только один поток. На Web-сайте находится файл QueueObj_Sig.с, содержащий исходный код, в котором вместо широковещательной модели используется сигнальная модель.</p>
     <p>• Использование для защиты объекта очереди объекта CRITICAL_SECTION вместо мьютекса также может привести к повышению производительности. Однако в этом случае вместо функции SignalObjectAndWait следует использовать функцию EnterCriticalSection с последующим ожиданием события. Этот альтернативный подход иллюстрируется двумя файлами — QueueObjCS.с и QueueObjCS_Sig.с, находящимися на Web-сайте книги.</p>
     <p>• На Web-сайте находятся два других файла с исходными кодами — QueueObj_noSOAW.с и QueueObjSig_noSOAW.с, в которых функция SignalObjectAndWait не используется и которые обеспечивают выполнение программы под управлением Windows 9x.</p>
     <p>• Результаты, приведенные в приложении В, свидетельствуют о нелинейном поведении производительности при большом количестве потоков, состязающихся за доступ к очереди. Проекты для каждой из альтернативных стратегий содержатся на Web-сайте книги; эти проекты соответствуют различным вариантам конвейерной системы ThreeStage, описанной в следующих разделах.</p>
     <p>•Резюмируя, следует подчеркнуть, что свойства очередей могут быть расширены таким образом, чтобы очередь могла совместно использоваться несколькими процессами и обеспечивать отправку или получение сразу нескольких сообщений за одну операцию. В то же время, некоторого выигрыша в производительности можно добиться за счет использования сигнальной модели, объектов CRITICAL_SECTIONS или функции SignalObjectAndWait. Соответствующие результаты представлены в приложении В. </p>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: использование очередей в многоступенчатом конвейере</p>
    </title>
    <section>
     <p>Модель "хозяин/рабочий", во всех ее вариациях, является одной из наиболее популярных моделей многопоточного программирования, а программа 8.2 представляет простую модель "производитель/потребитель", являющуюся частным случаем более общей конвейерной модели (pipeline model).</p>
     <p>В другом важном частном случае имеется один главный поток, который производит единичные рабочие задания (work units) для ограниченного количества рабочих потоков и помещает их в очередь. Такая методика может оказаться полезной при создании масштабируемого сервера с большим количеством клиентов (число которых может достигать тысячи и более), когда возможность выделения независимого рабочего потока для каждого клиента весьма сомнительна. В главе 14 задача создания масштабируемого сервера обсуждается в контексте портов завершения ввода/вывода.</p>
     <p>В конвейерной модели каждый поток или группа потоков определенным образом обрабатывает единичные задания, например, сообщения, и передает их другим потокам для дальнейшей обработки. Аналогом многопоточного конвейера может служить производственная сборочная линия. Идеальным механизмом реализации конвейера являются очереди.</p>
     <p>В программе 10.5 (ThreeStage.c) предусмотрено создание нескольких этапов производства и потребления, на каждой из которых поддерживается очередь рабочих заданий, подлежащих обработке. Каждая очередь имеет ограниченную, конечную длину. Всего существует три конвейерных ступени, соединяющих четыре этапа обработки. Программа имеет следующую структуру:</p>
     <p>• Производители (producers) периодически создают единичные сообщения, дополненные контрольными суммами, используя для этого ту же функцию, что и в программе 8.2, если не считать того, что в каждом сообщении содержится дополнительное поле адресата, указывающее поток потребителя (consumer), для которой предназначено это сообщение, причем каждый производитель связывается только с одним потребителем. Количество пар "производитель/потребитель" задается в виде параметра командной строки. Далее производитель посылает одиночное сообщение передающему потоку (transmitter), помещая его в очередь передачи сообщений. Если очередь заполнена, производитель ждет, пока ее состояние не изменится.</p>
     <p>• Передающий поток объединяет имеющиеся единичные сообщения (но не более пяти за один раз) и создает одно передаваемое сообщение, которое содержит заголовок и ряд единичных сообщений. Затем передающий поток помещает каждое передаваемое сообщение в очередь приема сообщений (receiver), блокируясь, если очередь заполнена. В общем случае передатчик и приемник могут связываться между собой через сетевое соединение. Произвольно выбранное здесь значение коэффициента блокирования (blocking factor), равное 5:1, легко поддается регулировке. </p>
     <p>• Принимающий поток обрабатывает единичные сообщения, входящие в состав каждого передаваемого сообщения, и помещает каждое из них в соответствующую очередь потребителя, если она не заполнена.</p>
     <p>• Каждый поток потребителя получает одиночные сообщения по мере их поступления и записывает сообщение в файл журнала регистрации.</p>
     <p>Блок-схема системы представлена на рис. 10.1. Обратите внимание, что эта система моделирует сетевое соединение, в котором сообщения, относящиеся к различным парам "отправитель/получатель" объединяются и передаются по общему каналу связи. </p>
     <image l:href="#Any2FbImgLoader117"/>
     <p><strong>Рис. 10.1. </strong>Многоступенчатый конвейер</p>
     <p>В программе 10.5 предложен вариант реализации, в котором используются функции очереди из программы 10.4. Функции генерации и отображения сообщений здесь не представлены, но они взяты из программы 8.1. При этом, наряду с контрольными суммами и данными, в блоки сообщений введены поля производителя и адресата.</p>
     <subtitle>Программа 10.5. ThreeStage.с: многоступенчатыйконвейер </subtitle>
     <p><code>/* Глава 10. ThreeStage.с */</code></p>
     <p><code>/* Трехступенчатая система производитель/потребитель. */</code></p>
     <p><code>/* Использование: ThreeStage npc goal. */</code></p>
     <p><code>/* Запустить "npc" пар потоков производителя и потребителя. */ </code></p>
     <p><code>/* Каждый производитель должен сгенерировать в общей сложности */ </code></p>
     <p><code>/* "goal" сообщений, каждое из которых снабжается меткой, указывающей */ </code></p>
     <p><code>/* потребителя, для которого оно предназначено. */</code></p>
     <p><code>/* Сообщения отправляются "передающему потоку", который, прежде чем */ </code></p>
     <p><code>/* отправить группу сообщений "принимающему потоку", выполняет некоторую*/ </code></p>
     <p><code>/* дополнительную обработку. Наконец, принимающий поток отправляет сообщения потокам потребителя. */</code></p>
     <empty-line/>
     <p><code>#include "EvryThng.h"</code></p>
     <p><code>#include "SynchObj.h"</code></p>
     <p><code>#include "messages.h"</code></p>
     <p><code>#include &lt;time.h&gt;</code></p>
     <empty-line/>
     <p><code>#define DELAY_COUNT 1000 </code></p>
     <p><code>#define MAX_THREADS 1024</code></p>
     <empty-line/>
     <p><code>/* Размеры и коэффициенты блокирования очередей. Эти величины являются */ </code></p>
     <p><code>/* произвольными и могут регулироваться для обеспечения оптимальной */ </code></p>
     <p><code>/* производительности. Текущие значения не являются сбалансированными. */</code></p>
     <p><code>#define TBLOCK_SIZE 5 /*Передающий поток формирует группы из 5 сообщений.*/ </code></p>
     <p><code>#define TBLOCK_TIMEOUT 50 /*Интервал ожидания сообщений передающим потоком.*/ </code></p>
     <p><code>#define P2T_QLEN 10 /* Размер очереди "производитель/передающий поток". */ </code></p>
     <p><code>#define T2R_QLEN 4 /*Размер очереди "передающий поток/принимающий поток".*/ </code></p>
     <p><code>#define R2C_QLEN 4 /* Размер очереди "принимающий поток/потребитель" -- */ </code></p>
     <p><code>/* для каждого потребителя существует только одна очередь.*/ </code></p>
     <empty-line/>
     <p><code>DWORD WINAPI producer(PVOID); </code></p>
     <p><code>DWORD WINAPI consumer(PVOID); </code></p>
     <p><code>DWORD WINAPI transmitter(PVOID); </code></p>
     <p><code>DWORD WINAPI receiver(PVOID);</code></p>
     <empty-line/>
     <p><code>typedef struct _THARG {</code></p>
     <p><code> volatile DWORD thread_number;</code></p>
     <p><code> volatile DWORD work_goal; /* Используется потоками производителей. */</code></p>
     <p><code> volatile DWORD work_done; /* Используется потоками производителей и потребителей. */ '</code></p>
     <p><code> char future[8]; </code></p>
     <p><code>} THARG;</code></p>
     <empty-line/>
     <p><code>/* Сгруппированные сообщения, посылаемые передающим потоком потребителю.*/ </code></p>
     <p><code>typedef struct t2r_msg_tag {</code></p>
     <p><code> volatile DWORD num_msgs; /* Количество содержащихся сообщений. */</code></p>
     <p><code> msg_block_t messages[TBLOCK_SIZE]; </code></p>
     <p><code>} t2r_msg_t;</code></p>
     <empty-line/>
     <p><code>queue_t p2tq, t2rq, *r2cq_array;</code></p>
     <empty-line/>
     <p><code>static volatile DWORD ShutDown = 0; </code></p>
     <p><code>static DWORD EventTimeout = 50;</code></p>
     <empty-line/>
     <p><code>DWORD _tmain(DWORD argc, LPTSTR * argv[]) {</code></p>
     <p><code> DWORD tstatus, nthread, ithread, goal, thid;</code></p>
     <p><code> HANDLE *producer_th, *consumer_th, transmitter_th, receiver_th;</code></p>
     <p><code> THARG *producer_arg, *consumer_arg;</code></p>
     <p><code> nthread = atoi(argv[1]);</code></p>
     <p><code> goal = atoi(argv[2]);</code></p>
     <p><code> producer_th = malloc(nthread * sizeof(HANDLE));</code></p>
     <p><code> producer_arg = calloc(nthread, sizeof(THARG));</code></p>
     <p><code> consumer_th = malloc(nthread * sizeof(HANDLE));</code></p>
     <p><code> consumer_arg = calloc(nthread, sizeof(THARG));</code></p>
     <p><code> q_initialize(&amp;p2tq, sizeof(msg_block_t), P2T_QLEN); </code></p>
     <p><code> q_initialize(&amp;t2rq, sizeof(t2r_msg_t), T2R_QLEN);</code></p>
     <p><code> /* Распределить ресурсы, инициализировать очереди "принимающий поток/потребитель" для каждого потребителя. */</code></p>
     <p><code> r2cq_array = calloc(nthread, sizeof(queue_t));</code></p>
     <p><code> for (ithread = 0; ithread &lt; nthread; ithread++) {</code></p>
     <p><code>  /* Инициализировать очередь r2с для потока данного потребителя. */</code></p>
     <p><code>  q_initialize(&amp;r2cq_array[ithread], sizeof(msg_block_t), R2C_QLEN);</code></p>
     <p><code>  /* Заполнить аргументы потока. */</code></p>
     <p><code>  consumer_arg[ithread].thread_number = ithread;</code></p>
     <p><code>  consumer_arg[ithread].work_goal = goal;</code></p>
     <p><code>  consumer_arg[ithread].work_done = 0;</code></p>
     <p><code>  consumer_th[ithread] = (HANDLE)_beginthreadex(NULL, 0, consumer, (PVOID)&amp;consumer_arg[ithread], 0, &amp;thid);</code></p>
     <p><code>  producer_arg[ithread].thread_number = ithread;</code></p>
     <p><code>  producer_arg[ithread].work_goal = goal;</code></p>
     <p><code>  producer_arg[ithread].work_done = 0;</code></p>
     <p><code>  producer_th[ithread] = (HANDLE)_beginthreadex(NULL, 0, producer, (PVOID)&amp;producer_arg[ithread], 0, &amp;thid);</code></p>
     <p><code> }</code></p>
     <p><code> transraitter_th = (HANDLE)_beginthreadex(NULL, 0, transmitter, NULL, 0, &amp;thid);</code></p>
     <p><code> receiver_th = (HANDLE)_beginthreadex (NULL, 0, receiver, NULL, 0, &amp;thid);</code></p>
     <p><code> _tprintf(_T("ХОЗЯИН: Выполняются все потоки\n"));</code></p>
     <p><code> /* Ждать завершения потоков производителя. */ </code></p>
     <p><code> for (ithread = 0; ithread &lt; nthread; ithread++) {</code></p>
     <p><code>  WaitForSingleObject(producer_th[ithread], INFINITE);</code></p>
     <p><code>  _tprintf(_T("ХОЗЯИН: производитель %d выработал %d единичных сообщений\n"), ithread, producer_arg[ithread].work_done);</code></p>
     <p><code> }</code></p>
     <p><code> /* Производители завершили работу. */</code></p>
     <p><code> _tprintf(_T("ХОЗЯИН: Все потоки производителя выполнили свою работу.\n"));</code></p>
     <p><code> /* Ждать завершения потоков потребителя. */</code></p>
     <p><code> for (ithread = 0; ithread &lt; nthread; ithread++) {</code></p>
     <p><code>  WaitForSingleObject(consumer_th[ithread], INFINITE);</code></p>
     <p><code>  _tprintf(_T("ХОЗЯИН: потребитель %d принял %d одиночных сообщений\n"), ithread, consumer_arg[ithread].work_done);</code></p>
     <p><code> }</code></p>
     <p><code> _tprintf(_T("ХОЗЯИН: Все потоки потребителя выполнили свою работу.\n"));</code></p>
     <p><code> ShutDown = 1; /* Установить флаг завершения работы. */</code></p>
     <p><code> /* Завершить выполнение и перейти в состояние ожидания передающих и принимающих потоков. */</code></p>
     <p><code> /* Эта процедура завершения работает нормально, поскольку и передающий,*/</code></p>
     <p><code> /* и принимающий потоки не владеют иными ресурсами, кроме мьютекса, */</code></p>
     <p><code> /* которые они могли бы покинуть по завершении выполнения, не уступив прав владения ими. Можете ли вы улучшить эту процедуру? */ </code></p>
     <p><code> TerminateThread(transmitter_th, 0);</code></p>
     <p><code> TerminateThread(receiver_th, 0);</code></p>
     <p><code> WaitForSingleObject(transmitter_th, INFINITE);</code></p>
     <p><code> WaitForSingleObject(receiver_th, INFINITE);</code></p>
     <p><code> q_destroy(&amp;p2tq);</code></p>
     <p><code> q_destroy(&amp;t2rq);</code></p>
     <p><code> for (ithread = 0; ithread &lt; nthread; ithread++) q_destroy(&amp;r2cq_array [ithread]);</code></p>
     <p><code> free(r2cq_array);</code></p>
     <p><code> free(producer_th);</code></p>
     <p><code> free(consumer_th);</code></p>
     <p><code> free(producer_arg);</code></p>
     <p><code> free(consumer_arg);</code></p>
     <p><code> _tprintf(_T("Система завершила работу. Останов системы\n"));</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>DWORD WINAPI producer(PVOID arg) {</code></p>
     <p><code> THARG * parg;</code></p>
     <p><code> DWORD ithread, tstatus;</code></p>
     <p><code> msg_block_t msg;</code></p>
     <p><code> parg = (THARG *)arg;</code></p>
     <p><code> ithread = parg-&gt;thread_number;</code></p>
     <p><code> while (parg-&gt;work_done &lt; parg-&gt;work_goal) {</code></p>
     <p><code>  /* Вырабатывать единичные сообщения, пока их общее количество */</code></p>
     <p><code>  /* не станет равным "goal". */</code></p>
     <p><code>  /* Сообщения снабжаются адресами отправителя и адресата, которые в */</code></p>
     <p><code>  /* нашем примере одинаковы для всех сообщений, но в общем случае <emphasis>*/</emphasis></code></p>
     <p><code><emphasis>  /*</emphasis> могут быть различными. */</code></p>
     <p><code>  delay_cpu(DELAY_COUNT * rand() / RAND_MAX);</code></p>
     <p><code>  message_fill(&amp;msg, ithread, ithread, parg-&gt;work_done);</code></p>
     <p><code>  /* Поместить сообщение в очередь. */</code></p>
     <p><code>  tstatus = q_put(&amp;p2tq, &amp;msg, sizeof(msg), INFINITE);</code></p>
     <p><code>  parg-&gt;work_done++;</code></p>
     <p><code> }</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>DWORD WINAPI transmitter(PVOID arg) {</code></p>
     <p><code> /* Получись несколько сообщений от производителя, объединяя их в одно*/</code></p>
     <p><code> /* составное сообщение, предназначенное для принимающего потока. */</code></p>
     <p><code> DWORD tstatus, im;</code></p>
     <p><code> t2r_msg_t t2r_msg = {0};</code></p>
     <p><code> msg_block_t p2t_msg;</code></p>
     <p><code> while (!ShutDown) {</code></p>
     <p><code>  t2r_msg.num_msgs = 0;</code></p>
     <p><code>  /* Упаковать сообщения для передачи принимающему потоку. */</code></p>
     <p><code>  for (im = 0; im &lt; TBLOCK_SIZE; im++) {</code></p>
     <p><code>   tstatus = q_get(&amp;p2tq, &amp;p2t_msg, sizeof(p2t_msg), INFINITE); </code></p>
     <p><code>   if (tstatus != 0) break;</code></p>
     <p><code>   memcpy(&amp;t2r_msg.messages[im], &amp;p2t_msg, sizeof(p2t_msg));</code></p>
     <p><code>   t2r_rasg.num_msgs++;</code></p>
     <p><code>  }</code></p>
     <p><code>  tstatus = q_put(&amp;t2rq, &amp;t2r_msg, sizeof(t2r_msg), INFINITE);</code></p>
     <p><code>  if (tstatus != 0) return tstatus; </code></p>
     <p><code> }</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>DWORD WINAPI receiver(PVOID arg) {</code></p>
     <p><code> /* Получить составные сообщения от передающего потока; распаковать */</code></p>
     <p><code> /* их и передать соответствующему потребителю. */</code></p>
     <p><code> DWORD tstatus, im, ic;</code></p>
     <p><code> t2r_msg_t t2r_msg;</code></p>
     <p><code> msg_block_t r2c_msg;</code></p>
     <p><code> while (!ShutDown) {</code></p>
     <p><code>  tstatus = q_get(&amp;t2rq, &amp;t2r_msg, sizeof(t2r_msg), INFINITE);</code></p>
     <p><code>  if (tstatus != 0) return tstatus;</code></p>
     <p><code>  /* Распределить сообщения между соответствующими потребителями. */</code></p>
     <p><code>  for (im = 0; im &lt; t2r_msg.num_msgs; im++) {</code></p>
     <p><code>   memcpy(&amp;r2c_msg, &amp;t2r_msg.messages[im], sizeof(r2c_msg));</code></p>
     <p><code>   ic = r2c_msg.destination; /* Конечный потребитель. */</code></p>
     <p><code>   tstatus = q_put(&amp;r2cq_array[ic], &amp;r2c_msg, sizeof(r2c_msg), INFINITE);</code></p>
     <p><code>   if (tstatus != 0) return tstatus;</code></p>
     <p><code>  }</code></p>
     <p><code> }</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>DWORD WINAPI consumer(PVOID arg) {</code></p>
     <p><code> THARG * carg;</code></p>
     <p><code> DWORD tstatus, ithread;</code></p>
     <p><code> msg_block_t msg;</code></p>
     <p><code> queue_t *pr2cq;</code></p>
     <p><code> carg = (THARG *)arg;</code></p>
     <p><code> ithread = carg-&gt;thread_number;</code></p>
     <p><code> carg = (THARG *)arg;</code></p>
     <p><code> pr2cq = &amp;r2cq_array[ithread];</code></p>
     <p><code> while (carg-&gt;work_done &lt; carg-&gt;work_goal) {</code></p>
     <p><code>  /* Получить и отобразить (необязательно — не показано) сообщения. */</code></p>
     <p><code>  tstatus = q_get(pr2cq, &amp;msg, sizeof(msg), INFINITE);</code></p>
     <p><code>  if (tstatus != 0) return tstatus;</code></p>
     <p><code>  carg-&gt;work_done++;</code></p>
     <p><code> }</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code> </p>
    </section>
    <section>
     <title>
      <p>Комментарии по поводу многоступенчатого конвейера</p>
     </title>
     <p>Данная реализация характеризуется некоторыми особенностями, суть которых частично отражена в комментариях, включенных в листинг программы. На эти же особенности обращают ваше внимание и упражнения 10.6, 10.7 и 10.10.</p>
     <p>• Значительные возражения вызывает способ, используемый основным потоком для завершения выполнения передающего и принимающего потоков. Лучшим решением было бы использование конечных интервалов ожидания во внутренних циклах передатчика и приемника и прекращение работы после того, как будет установлен соответствующий глобальный флаг. Другой возможный подход заключается в отмене выполнения потоков, как описано далее в этой главе.</p>
     <p>• Обратите внимание на существование симметрии между передающим и принимающим потоками. Как и при реализации очереди, это обстоятельство упрощает проектирование, отладку и сопровождение программы.</p>
     <p>• Реализация не сбалансирована в смысле согласования скорости генерации сообщений, емкости конвейера и коэффициента блокирования "передатчик/приемник".</p>
     <p>• В данной реализации (программа 10.4) для защиты очередей используются мьютексы. Результаты экспериментов с объектами CRITICAL_SECTION не позволили обнаружить сколько-нибудь заметного ускорения работы программы на однопроцессорной системе (см. приложение В). CS-версия программы, ThreeStageCS, находится на Web-сайте. Аналогичным образом вела себя программа и после того, как в ней была использована функции SignalObjectAndWait.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Асинхронные вызовы процедур</p>
    </title>
    <p>Основное возражение, которое можно предъявить к программе ThreeSage.c (программа 10.5) в ее нынешнем виде, касается прекращения выполнения передающего и принимающего потоков с помощью функции TerminateThread. В комментариях, включенных в код, вам предлагается подумать над более элегантным способом завершения выполнения потоков, который обеспечивал бы корректное прекращение работы программы и освобождение ресурсов.</p>
    <p>Другой нерешенной проблемой является отсутствие общего метода (не считая использования функции TerminateThread), который обеспечивал бы отправку сигнала определенному потоку или инициировал его выполнение. События могут посылать сигналы одному потоку, ожидающему наступления автоматически сбрасываемого события, или всем потокам, ожидающим наступления вручную сбрасываемого события, но невозможно добиться того, чтобы сигнал был получен определенным потоком. Используемое до сих пор решение сводилось к тому, что пробуждались все ожидающие потоки, которые самостоятельно определяли, могут ли они теперь продолжить свое выполнение. Иногда привлекается альтернативное решение, суть которого состоит в назначении событий определенным потокам, так что сигнализирующий поток может определять, объект какого события следует перевести в сигнальное состояние одной из функций SetEvent или PulseEvent.</p>
    <p>Обе эти проблемы решаются путем использования объектов асинхронного вызова процедур (Asynchronous Procedure Call, АРС). События развиваются в следующей последовательности, причем рабочий или целевой потоки должны управляться главным потоком.</p>
    <p>• Главный поток указывает АРС-функцию данной целевого потока путем помещения объекта АРС в очередь АРС данного потока. В очередь могут быть помещены несколько АРС.</p>
    <p>• Целевой поток переходит в состояние дежурного ожидания (alertable wait state), обеспечивающее возможность безопасного выполнения потоком АРС. Порядок первых двух шагов безразличен, поэтому о возникновении условий состязательности можно не беспокоиться.</p>
    <p>• Указанный поток, находящийся в состоянии ожидания, выполняет все АРС, находящиеся в очереди.</p>
    <p>• АРС могут выполнять любые нужные действия, например, освобождать ресурсы или генерировать исключения. Благодаря этому главный поток может инициировать возбуждение исключения в целевом потоке, хотя само исключение не произойдет до тех пор, пока целевой поток не перейдет в состояние дежурного ожидания.</p>
    <p>Выполнение АРС является асинхронным в том смысле, что АРС может быть помещен в очередь целевого потока в любой момент, но само выполнение является синхронизированным в том смысле, что это может произойти лишь тогда, когда целевой поток входит в состояние дежурного ожидания.</p>
    <p>Состояния дежурного ожидания будут вновь обсуждаться в главе 14, посвященной асинхронному вводу/выводу.</p>
    <p>Описания необходимых функций и примеры их использования в другом варианте программы ThreeStage приводятся в следующих разделах. Проект для построения новой версии программы (ThreeStageCancel) и соответствующий исходный код (ThreeStageCancel. с) находятся на Web-сайте книги.</p>
   </section>
   <section>
    <title>
     <p>Очередизация асинхронных вызовов процедур</p>
    </title>
    <section>
     <p>Один поток (главный) помещает АРС в очередь целевого потока с помощью функции QueueUserAPC: </p>
     <cite>
      <p><code>DWORD QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, DWORD dwData)</code></p>
     </cite>
     <p>hThread — дескриптор целевого потока. dwData — аргумент, который будет передан функции АРС при ее выполнении и может являться кодом завершения или сообщать функции иную информацию.</p>
     <p>В основной функции программы ThreeStageCancel.с (сравните с программой 10.5) вызовы TerminateThread заменяются вызовами QueueUserAPC следующим образом:</p>
     <p><code>// TerminateThread(transmitter_th, 0) ; заменить на АРС </code></p>
     <p><code>// TerminateThread(receiver_th, 0); заменить на АРС </code></p>
     <p><code>tstatus = QueueUserAPC(ShutDownTransmitter, transmitter_th, 1); </code></p>
     <p><code>if (tstatus == 0) ReportError(…);</code></p>
     <p><code>tstatus = QueueUserAPC(ShutDownReceiver, receiver_th, 2); </code></p>
     <p><code>if (tstatus == 0) ReportError (…);</code></p>
     <p>Функция QueueUserAPC в случае успешного ее завершения возвращает ненулевое значение, иначе — нуль. В то же время, функция GetLastError () не возвращает никакого полезного значения, и поэтому при вызове функции ReportError не требуется задавать текст сообщения об ошибке (значением последнего аргумента является FALSE).</p>
     <p>pfnAPC — указатель на фактическую функцию, вызываемую целевым потоком, как показывает следующий фрагмент, взятый из программы ThreeStageCancel. с:</p>
     <p><code>/* АРС для завершения выполнения потребителя. */ </code></p>
     <p><code>void WINAPI ShutDownReceiver(DWORD n) {</code></p>
     <p><code> printf("Внутри ShutDownReceiver. %d\n", n);</code></p>
     <p><code> /* Освободить все ресурсы (в данном примере отсутствуют). */</code></p>
     <p><code> return; </code></p>
     <p><code>}</code></p>
     <p>Функция ShutDownTransmitter аналогична вышеприведенной, отличаясь от нее только текстом сообщения. Сразу трудно понять, каким образом эта функция, которая, казалось бы, не выполняет никаких существенных операций, может инициировать прекращение выполнения целевого принимающего потока. Соответствующие пояснения приводятся далее в этой главе.</p>
    </section>
    <section>
     <title>
      <p>АРС и упущенные сигналы</p>
     </title>
     <p>АРС, выполняемые в режиме ядра (используются в операциях асинхронного ввода/вывода), могут немедленно выводить ожидающий поток из состояния ожидания, что может стать причиной потери сигналов PulseEvent. В связи с этим в документации можно встретить советы, в которых функции PulseEvent рекомендуется не использовать, хотя, как было продемонстрировано в данной главе, они могут и приносить пользу. Применение функции PulseEvent в наших примерах было вполне безопасным, поскольку АРС, выполняемые в режиме ядра, в них не используются. Кроме того, применение функции SignalObjectAndWait и тестирование возвращаемого ею значения обеспечивает достаточно надежную защиту от подобных потерь сигналов. Наконец, если вы опасаетесь, что это все-таки может случиться, просто включайте указание конечного интервала ожидания в соответствующие вызовы функций ожидания.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Состояния дежурного ожидания</p>
    </title>
    <p>Во всех предыдущих примерах значение параметра bAlertable, являющегося последним параметром функции SignalObjectAndWait, полагалось равным FALSE. Используя вместо него значение TRUE, мы указываем, что ожидание должно быть, как говорят, <emphasis>дежурным</emphasis> (alertable), и тогда после выполнения функции поток перейдет в состояние дежурного ожидания. В этом состоянии поток ведет себя следующим образом:</p>
    <p>• Если один или более АРС помещаются в очередь потока (указанного в качестве целевого при вызове функции QueueUserAPC) еще до того, как либо объект, указываемый дескриптором hObjectToWaitOn (обычно таким объектом является событие), перейдет в сигнальное состояние, либо истечет интервал ожидания, то все эти потоки выполнятся (при этом не гарантируется какой-то определенный порядок их выполнения), а функция SignalObjectAndWait завершит выполнение, возвращая значение WAIT_IO_COMPLETED.</p>
    <p>• Если АРС в очередь не помещались, то функция SignalObjectAndWait ведет себя обычным образом, то есть ожидает перехода объекта в сигнальное состояние или истечения интервала ожидания.</p>
    <p>Состояния дежурного ожидания будут вновь использоваться нами при выполнении операций асинхронного ввода/вывода (глава 14); именно в связи с этими операциями и получило свое название значение WAIT_IO_COMPLETED. В состояние дежурного ожидания потока можно переводить также с помощью функций WaitForSingleObjectEx, WaitForMultipleObjectsEx и SleepEx, которые оказываются полезными и при выполнении операций асинхронного ввода/вывода.</p>
    <p>Теперь можно изменить функции q_get и q_put (см. программу 10.4) таким образом, чтобы завершение работы программы после выполнения АРС было корректным, хотя АРС-функция и не выполняет никаких иных действий, кроме вывода сообщения и возврата из функции. Все, что в данном случае требуется — это организовать вход в состояние дежурного ожидания и проверить значение, возвращаемое функцией SignalObjectAndWait, как показано в приведенной ниже видоизмененной версии функции q_get (см. файл QueueObjCancel.с, находящийся на Web-сайте).</p>
    <subtitle>Программа 10.6. Модифицированная функция q_get, обеспечивающая корректное завершение выполнения потоков </subtitle>
    <p><code>DWORD q_put(queue_t *q, PVOID msg, DWORD msize, DWORD MaxWait) {</code></p>
    <p><code> BOOL Cancelled = FALSE;</code></p>
    <p><code> if (q_destroyed(q)) return 1;</code></p>
    <p><code> WaitForSingleObject(q-&gt;q_guard, INFINITE);</code></p>
    <p><code> while (q_full(q) &amp;&amp; !Cancelled) {</code></p>
    <p><code>  if (SignalObjectAndWait(q-&gt;q_guard, q-&gt;q_nf, INFINITE, TRUE) == WAIT_IO_COMPLETION) {</code></p>
    <p><code>   Cancelled = TRUE;</code></p>
    <p><code>   continue;</code></p>
    <p><code>  }</code></p>
    <p><code>  WaitForSingleObject(q-&gt;q_guard, INFINITE);</code></p>
    <p><code> }</code></p>
    <p><code> /* Поместить сообщение в очередь. */</code></p>
    <p><code> if (!Cancelled) {</code></p>
    <p><code>  q_remove(q, msg, msize);</code></p>
    <p><code>  /* Сигнализировать о том, что очередь не заполнена, поскольку мы удалили сообщение. */</code></p>
    <p><code>  PulseEvent(q-&gt;q_nf);</code></p>
    <p><code>  ReleaseMutex(q-&gt;q_guard);</code></p>
    <p><code> }</code></p>
    <p><code> return Cancelled ? WAIT_TIMEOUT : 0; </code></p>
    <p><code>}</code></p>
    <p>В качестве функции АРС могут выступать и функция ShutDownReceiver, и функция ShutDownTransmitter, поскольку приемник и передатчик используют как функцию q_get, так и функцию q_put. Если требуется, чтобы функциям завершения было известно, из какого потока они выполняются, применяйте различные значения для аргументов функций АРС, которые передаются третьим аргументом функции QueueUserAPC во фрагменте кода, предшествующем программе 10.6.</p>
    <p>Чтобы обеспечить согласованность с предыдущими версиями программы, в качестве кода завершения следует использовать значение WAIT_TIMEOUT.</p>
    <p>В качестве альтернативного варианта вместо проверки совпадения возвращаемого значения со значением WAIT_IO_COMPLETION можно предусмотреть генерацию исключения функциями завершения и поместить тело функции q_put в try-блок, дополнив программу обработчиком исключений. </p>
   </section>
   <section>
    <title>
     <p>Безопасная отмена выполнения потоков</p>
    </title>
    <p>Обсуждение предыдущего примера продемонстрировало, как безопасно отменить выполнение целевого потока, который использует состояния дежурного ожидания. Несмотря на использование АРС, такую отмену выполнения иногда называют <emphasis>синхронной отменой</emphasis> (synchronous cancellation), поскольку отмена выполнения, которую инициировал вызов функции QueueUserAPC главным потоком, сможет осуществиться лишь тогда, когда целевой поток достигнет безопасного состояния дежурного ожидания.</p>
    <p>Синхронная отмена выполнения требует участия в этом целевого потока, которая время от времени должна предоставлять возможность прекратить ее выполнение. Естественный способ вхождения в состояние дежурного ожидания предоставляют функции ожидания событий, поскольку в процессе прекращения работы системы объект события может не перейти вновь в сигнальное состояние. Ожидание мьютексов также можно выполнять в дежурном режиме, чтобы учесть те случаи, когда поток ожидает ресурса, который, возможно, не будет вновь доступным. Этот метод, например, может использоваться главным потоком для разрушения взаимной блокировки потоков.</p>
    <p><emphasis>Асинхронная отмена выполнения потоков</emphasis> (asynchronous thread cancellation) может применяться в тех случаях, когда сигнал должен посылаться потоку, который выполняет интенсивные вычисления и находится в состоянии ожидания ввода/вывода или событий исключительно редко, если это вообще происходит. Возможность асинхронной отмены выполнения потоков в Windows отсутствует, хотя и существуют методики, использующие зависящий от типа процессора код, которые позволяют прерывать выполнение определенного потока.</p>
   </section>
   <section>
    <title>
     <p>Создание переносимых приложений с использованием потоков Pthreads</p>
    </title>
    <p>Потоки Pthreads уже неоднократно упоминались нами в качестве альтернативной модели многопоточного программирования и синхронизации, доступной в UNIX, Linux и других системах, не принадлежащих семейству Windows. Существует библиотека Windows Pthreads с открытым исходным кодом, используя которую можно создавать переносимые многопоточные приложения, способные выполняться на самых различных системах. Более подробное обсуждение этого вопроса вы найдете на Web-сайте книги. Указанная библиотека с открытым исходным кодом применяется в проекте ThreeStagePthreads, в котором также предоставляется соответствующая ссылка на сайт загрузки. </p>
   </section>
   <section>
    <title>
     <p>Стеки потоков и допустимые количества потоков</p>
    </title>
    <p>Следует сделать еще два предостережения. Во-первых, подумайте о размере стека, который по умолчанию составляет 1 Мбайт. В большинстве случаев этого будет вполне достаточно, но если существуют какие-либо сомнения на сей счет, оцените максимальный объем стекового пространства, которое требуется для каждого потока с учетом всех библиотечных и рекурсивных функций, которые вызываются потоком. Переполнение стека может привести к порче памяти или вызвать исключение.</p>
    <p>Во-вторых, использование большого количества потоков с большими размерами стеков потребует больших объемов виртуальной памяти для их обработки и может оказать отрицательное влияние на процессы страничного обмена и состояние файла подкачки. Так, использовать свыше 1000 потоков в некоторых из примеров, приведенных в этой и последующей главах, было бы неразумно. При размере стека 1 Мбайт на один поток для этого потребовалось бы виртуальное адресное пространство объемом 1 Гбайт. Соответствующие меры предосторожности включают тщательное планирование размеров стеков, использование портов завершения ввода/вывода и мультиплексирование операций в пределах одного потока.</p>
   </section>
   <section>
    <title>
     <p>Рекомендации по проектированию, отладке и тестированию программ</p>
    </title>
    <p>Рискуя дать совет, противоречащий высказываниям во многих других книгах и технических статьях, в которых основной упор делается на тестировании и уже затем рассматривается все остальное, лично я порекомендовал бы вам распределить свои усилия таким образом, чтобы нашлось время для ознакомления с особенностями проектирования, реализации и использования известных моделей программирования. Лучший метод отладки заключается, прежде всего, в недопущении ошибок; разумеется, такие советы легче давать, чем им следовать. Тем не менее, когда начинают проявляться программные дефекты — а это происходит всегда – наиболее эффективным методом обнаружения и исправления основных причин дефектов является тщательное исследование кода в сочетании с отладкой.</p>
    <p>Не возлагайте слишком большие надежды на тестирование программ, ибо каким бы тщательным и обширным оно ни было, многие серьезные дефекты от вас все равно ускользнут. Тестирование способно лишь выявлять дефекты; оно не может служить доказательством отсутствия дефектов и указывает лишь на их симптомы, а не на причины, которые их породили. Для наглядности могу сослаться на личный опыт, приведя в качестве примера версию программы, включающую функцию ожидания сложного семафора, построенную на основе модели CV, в которой конечный интервал ожидания не использовался. Дефект, который мог приводить к блокированию потока на неопределенное время, никак не проявлял себя на протяжении года, пока, в конечном счете, что-то пошло не так, как надо. Мне удалось обнаружить ошибку путем простого просмотра кода, благодаря пониманию принципов, лежащих в основе работы модели переменных условий.</p>
    <p>Не следует переоценивать и помощь, которую вам может оказать отладка, поскольку отладчики изменяют временное поведение программы, маскируя возникновение условий состязательности, то есть именно то, что вы хотели бы исследовать. Так, вряд ли можно ожидать, что с помощью отладчика вам удастся выявить проблемы, обусловленные неправильным выбором типа события (автоматически сбрасываемым или сбрасываемым вручную) или функции (SetEvent или PulseEvent). Всегда тщательно продумывайте, чего именно вы хотите добиться, применяя те или иные средства.</p>
    <p>В заключение следует подчеркнуть, что тестирование программ с использованием как можно более широкого круга платформ, включая SMP, составляет важнейшую часть любого проекта, целью которого является разработка многопоточного программного обеспечения.</p>
   </section>
   <section>
    <title>
     <p>Как избежать создания некорректного программного кода</p>
    </title>
    <p>Каждая ошибка, не допущенная вами в исходном коде, — это, прежде всего, еще одна сэкономленная ошибка, которую вам не придется отыскивать на стадии отладки программы или в процессе проверки работоспособности ее завершенной версии. Ниже приведены некоторые рекомендации, большинство из которых взяты, хотя и в перефразированном виде, из [6].</p>
    <p>• <strong>Не полагайтесь на инерционность потоков. </strong>Потоки асинхронны, но мы, например, часто предполагаем, что после создания родительским потоком одного или нескольких дочерних потоков он продолжает свое выполнение. В основе таких предположений лежит допущение об "инерционных" свойствах родительского потока, благодаря которым он, якобы, будет выполняться вплоть до начала выполнения дочерних потоков. Предположения подобного рода особенно опасны в случае SMP-систем, тем не менее, они могут привести к возникновению проблем и в случае однопроцессорных систем.</p>
    <p>• <strong>Никогда не делайте ставок на состязании потоков. </strong>Об очередности выполнения потоков практически никогда нельзя сказать ничего определенного. В программе должно предполагаться, что любой готовый к выполнению поток может быть запущен в любой момент и что любой выполняющийся поток в любой момент может быть вытеснен. Никакого упорядочения выполнения потоков не существует, если только вы специально об этом не позаботились. </p>
    <p>• <strong>Не следует путать планирование выполнения с синхронизацией. </strong>Стратегии планирования задач и назначения приоритетов не в состоянии обеспечить нужную синхронизацию. Для этого должны использоваться объекты синхронизации.</p>
    <p><strong>• Состязательность за очередность выполнения будет существовать даже при использовании мьютексов для защиты разделяемых данных. </strong>Наличие защиты данных само по себе не может служить гарантией определенной очередности получения доступа к разделяемым данным различными потоками. Например, если один поток добавляет средства на банковский счет, а другой снимает их со счета, то одна только защита счета с помощью мьютекса не сможет гарантировать, что внесение денег на счет всегда будет осуществляться раньше, чем их снятие. В упражнении 10.14 показано, как организовать управление очередностью выполнения потоков.</p>
    <p><strong>• Необходимость кооперирования потоков во избежание взаимной блокировки.</strong> Чтобы гарантировать невозможность взаимоблокировки потоков, вы должны располагать хорошо продуманной иерархией блокировок, которая использовалась бы всеми потоками.</p>
    <p>• <strong>Не допускайте разделения событий предикатами. </strong>В реализациях, использующих переменные условий, каждое событие должно связываться с отдельным предикатом. Кроме того, событие всегда должно использоваться с одним и тем же мьютексом.</p>
    <p><strong>• Остерегайтесь совместного использования стеков и связанного с этим риска порчи памяти. </strong>Никогда не забывайте о том, что при возврате из функции или завершении выполнения потока их локальные области памяти становятся недействительными. Память в области стека потока может использоваться другими потоками, но вы должны быть уверены в том, что первый поток все еще существует.</p>
    <p><strong>• Следите за использованием модификатором класса памяти volatile в необходимых случаях. </strong>Всякий раз, когда возможно изменение разделяемой переменной в одном потоке и обращение к нему в другом, класс памяти, используемой этой переменной, должен быть определен как volatile, что будет гарантировать использование ячеек памяти при сохранении и извлечении этой переменной потоками, а не регистров, специфичных для каждого потока.</p>
    <p>Ниже приводятся некоторые дополнительные рекомендации и мнемонические правила, которые вам могут пригодиться.</p>
    <p>• <strong>Правильно пользуйтесь моделью переменных условий, </strong>проверяя, чтобы два разных мьютекса не использовались с одним и тем же событием. Хорошо изучите модель переменных условий, на которой основана ваша программа. Прежде чем вызывать функцию ожидания перехода переменной условия в сигнальное состояние, убедитесь в выполнении условия, выраженного предикатом. </p>
    <p><strong>• Старайтесь вникнуть в смысл используемых инвариантов и предикатов переменных условий, </strong>даже если они имеют неформальное выражение. Убедитесь в том, что условие, выраженное предикатом, всегда выполняется за пределами критического участка кода.</p>
    <p>• <strong>Стремитесь к упрощению. </strong>Многопоточное программирование уже само по себе является достаточно сложным, чтобы еще дополнительно усложнять его введением трудно воспринимаемых моделей и логики. Если ваша программа становится чрезмерно сложной, постарайтесь оценить, продиктована ли эта сложность действительной необходимостью или же является следствием того, что программа была неудачно спроектирована.</p>
    <p><strong>• Тестируйте программы как на однопроцессорных, так и на многопроцессорных системах, а также на системах с различными тактовыми частотами и другими характеристиками. </strong>Природа некоторых дефектов такова, что на однопроцессорных системах они проявляются лишь в редких случаях или вообще никогда, в то время как на SMP-системах вы их сразу определите, и наоборот. Аналогичным образом, чем шире круг характеристик систем, на которых будет выполняться программа, содержащая дефекты, тем выше вероятность сбоя.</p>
    <p><strong>• Тестирование является необходимой, но не достаточной мерой, которая могла бы гарантировать корректную работу программы. </strong>Известны многочисленные примеры программ, заведомо содержащих дефекты, которые лишь в редких случаях удавалось обнаруживать средствами обычного и даже расширенного тестирования.</p>
    <p>• <strong>Смиритесь! </strong>Как бы вы ни старались следовать этим советам, ошибок в своих программах вам не избежать. Это утверждение справедливо даже в случае однопоточных программ, не говоря уже о многопоточных, которые предоставляют нам гораздо больше разнообразных и интереснейших возможностей создавать себе проблемы.</p>
   </section>
   <section>
    <title>
     <p>За рамками Windows API</p>
    </title>
    <p>В своем рассмотрении мы намеренно ограничились случаем Windows API. Вместе с тем, Microsoft предоставляет дополнительные средства доступа к таким объектам ядра, как потоки. Так, класс ThreadPool, доступный в C++, С# и других языках программирования, позволяет создавать пулы потоков и очереди задач потоков (для этого служит метод QueueUserWorkItem класса ThreadPool).</p>
    <p>Кроме того, Microsoft реализует службу Microsoft Message Queuing (MSMQ), которая предоставляет услуги по передаче сообщений между сетевыми системами. Приведенный в данной главе пример должен был продемонстрировать вам, насколько полезными могут быть универсальные системы очередизации сообщений. MSMQ документирована на Web-сайте компании Microsoft.</p>
   </section>
   <section>
    <title>
     <p>Резюме</p>
    </title>
    <section>
     <p>Разработка многопоточных программ значительно упрощается, если используются хорошо себя зарекомендовавшие, известные модели и методы программирования. В этой главе была продемонстрирована полезность модели переменных условий и решен ряд сравнительно сложных, но важных проблем программирования. АРС позволяют одному потоку посылать сигналы другому и вызывать в нем выполнение определенных действий, что позволяет отменять выполнение потоков таким образом, чтобы все потоки в системе имели возможность корректно завершиться.</p>
     <p>Сложность синхронизации и управления потоками объясняется тем, что существует множество путей решения одной и той же задачи, и при выборе метода следует учитывать его сложность и характер влияния, которое он может оказать на производительность. Чтобы проиллюстрировать все многообразие доступных возможностей, пример трехступенчатого конвейера был реализован несколькими отличными друг от друга способами.</p>
     <p>Тщательное продумывание проекта и путей его реализации является предпочтительным способом улучшения качества программы. Возложение чрезмерных надежд на результаты тестирования и отладку без того, чтобы уделить должное внимания деталям, может привести к возникновению серьезных проблем, обнаружить и устранить которые будет очень трудно.</p>
    </section>
    <section>
     <title>
      <p>В следующих главах</p>
     </title>
     <p>В главе 11 показано, как организовать взаимодействие между процессами и потоками, выполняющимися внутри этих процессов, используя именованные каналы (named pipes) и почтовые ящики (mailslots) Windows. В качестве основного примера выбрана клиент-серверная система, в которой для обслуживания запросов клиентов используется пул рабочих потоков. В главе 12 эта же система реализуется с привлечением гнезд Windows Sockets, что делает ее пригодной для использования стандартных протоколов. В обновленной клиент-серверной системе применяются безопасные библиотеки DLL с многопоточной поддержкой, а сервер использует внутрипроцессный сервер (in-process server) на основе DLL.</p>
    </section>
    <section>
     <title>
      <p>Дополнительная литература</p>
     </title>
     <p>Источником большей части информации и советов по программированию, приведенных в конце настоящей главы, послужила книга [6]. Из нее же было взято в переработанном виде и решение на базе объекта барьера, использованное в программах 10.1 и 10.2.</p>
     <p>В статье Дугласа Шмидта (Douglas Schmidt) и Ирфана Пьярали (Irfan Pyarali) "Strategies for Implementing POSIX Condition Variables in Win32" ("Стратегии реализации переменных условий POSIX в Win32") (доступна по адресу http:// www.es.wustl.edu/~schmidt/win32-cv-1.html), обсуждается ограниченность событий Win32 (Windows) и эмуляция переменных условий, а также дан глубокий анализ и оценка нескольких подходов. Вместе с тем, этот материал был написан еще до появления функции SignalObjectAndWait, и поэтому большое внимание в статье уделяется тому, как избежать потери сигналов. Чтение этой статьи позволит вам по достоинству оценить возможности новых функций. В другой статье тех же авторов (http://www.cs.wustl.edu/~schmidt/win32-cv-2.html) рассматривается создание объектно-ориентированных оболочек вокруг объектов синхронизации Windows, позволяющих добиться независимости интерфейса синхронизации от платформы. Основанная на работе Шмидта и Пьярали реализация, в которой используются потоки Pthreads, доступна по адресу http://sources.redhat.com/pthreads-win32/.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Упражнения</p>
    </title>
    <p>10.1. Переработайте программу 10.1, исключив из нее функцию SignalObjectAndWait; для тестирования полученного результата воспользуйтесь Windows 9х.</p>
    <p>10.2. Модифицируйте программу evenpc (программа 8.2), использовав модель переменных условий и обеспечив возможность существования нескольких потребителей. События какого типа потребуются в данном случае?</p>
    <p>10.3. Измените логику работы программы 10.2 таким образом, чтобы объект события переходил в сигнальное состояние только один раз.</p>
    <p>10.4. Замените мьютекс в объекте очереди, который используется в программе 10.2, объектом CS. Какое влияние это изменение оказывает на производительность и пропускную способность программы? Решение находится на Web-сайте книги, а соответствующие экспериментальные данные приведены в приложении В.</p>
    <p>10.5. Для индикации состояний очереди, в которых она не пуста или не заполнена, в программе 10.4 применяется широковещательная модель CV. Будет ли в данном случае работать сигнальная модель CV? Не является ли она даже более предпочтительной в некоторых отношениях? Соответствующие экспериментальные данные приведены в приложении В.</p>
    <p>10.6. Поэкспериментируйте с размерами очереди и величиной коэффициента блокирования "передатчик/приемник" в программе 10.5 для выяснения того, какое влияние оказывают эти факторы на загрузку ЦП, а также производительность и пропускную способность программы.</p>
    <p>10.7. Видоизмените программы 10.3–10.5, обеспечив их соответствие принятым в Windows соглашениям о правилах образования имен, которых мы придерживаемся на протяжении всей книги.</p>
    <p>10.8. <emphasis>Для программистов на</emphasis> C++. Приведенный в программах 10.3 и 10.4 код можно использовать для создания в C++ класса синхронизированной очереди; создайте этот класс и протестируйте его, модифицировав соответствующим образом программу 10.5. Какие из функций должны быть общедоступными, а какие — закрытыми?</p>
    <p>10.9. Исследуйте, как изменятся показатели производительности программы 10.5 после замены мьютексов объектами CRITICAL_SECTIONS.</p>
    <p>10.10. Улучшите программу 10.5, исключив необходимость прекращения выполнения потоков передатчика и приемника. Потоки должны самостоятельно завершать свое выполнение.</p>
    <p>10.11. На web-сайте находится файл multisem.c, который реализует сложный семафор, имитирующий объекты Windows (они имеют имена и атрибуты безопасности, могут разделяться процессами, и для них предусмотрены две модели ожидания), а также файл тестовой программы TestMultiSem.c. Выполните сборку и тестирование этой программы. Как в ней используется модель переменных условий? Повышается ли производительность в результате использования объекта CRITICAL_SECTION? Что здесь выступает в роли инвариантов и предикатов переменных условий?</p>
    <p>10.12. Проиллюстрируйте целесообразность рекомендаций, приведенных в конце настоящей главы, ссылаясь на ошибки, с которыми вам пришлось столкнуться, или ошибки, содержащиеся в версии программы с дефектами, представленной на Web-сайте.</p>
    <p>10.13. Ознакомьтесь со статьей Шмидта и Пьярали "Strategies for Implementing POSIX Condition Variables in Win32" ("Стратегии реализации переменных условий POSIX в Win32") (см. раздел "Дополнительная литература"). Примените их методы анализа равноправия, корректности, сериализации и других программных факторов к моделям переменных условий (которые в указанной статье называются "идиомами" ("idioms")), фигурирующим в настоящей главе. Заметьте, что сами переменные условия в настоящей главе не эмулируются; вместо этого эмулируется их использование, тогда как Шмидт и Пьярали эмулируют переменные условий, используемые в произвольном контексте.</p>
    <p>10.14. Находящиеся на web-сайте проекты batons и batonsmultipleevents демонстрируют альтернативные варианты решения задачи сериализации выполнения потоков. О предпосылках и предшествующих работах других авторов говорится в комментариях, включенных в код. Во втором решении с каждым потоком связывается уникальное событие, что позволяет отслеживать сигнальные состояния отдельных потоков. Для реализации выбран язык C++, что дало возможность воспользоваться средствами стандартной библиотеки шаблонов C++ (Standard Template Library, STL). Проанализируйте, что имеют общего и чем различаются между собой эти два решения и используйте второе из них в качестве средства ознакомления с библиотекой STL. </p>
   </section>
  </section>
  <section>
   <title>
    <p>ГЛАВА 11</p>
    <p>Взаимодействие между процессами</p>
   </title>
   <section>
    <p>В главе 6 было показано, как создавать процессы и управлять ими, тогда как главы 7—10 были посвящены описанию методов управления потоками, которые выполняются внутри процессов, и объектов, обеспечивающих их синхронизацию. Вместе с тем, если не считать использования разделяемой памяти, мы до сих пор не рассмотрели ни одного из методов взаимодействия между процессами.</p>
    <p>Ниже вы ознакомитесь с последовательным межпроцессным взаимодействием (Interprocess Communication, IPC)<a l:href="#n_30" type="note">[30]</a>, в котором используются объекты, подобные файлам. Двумя основными механизмами Windows, реализующими IPC, являются анонимные и именованные каналы, доступ к которым осуществляется с помощью уже известных вам функций ReadFile и WriteFile. Простые анонимные каналы являются символьными и работают в полудуплексном режиме. Эти свойства делают их удобными для перенаправления выходных данных одной программы на вход другой, как это обычно делается в UNIX. В первом примере демонстрируется, как реализовать эту возможность.</p>
    <p>По сравнению с анонимными каналами возможности именованных каналов гораздо богаче. Они являются дуплексными, ориентированы на обмен сообщениями и обеспечивают взаимодействие через сеть. Кроме того, один именованный канал может иметь несколько открытых дескрипторов. В сочетании с удобными, ориентированными на выполнение транзакций функциями эти возможности делают именованные каналы пригодными для создания клиент-серверных систем. Это демонстрируется во втором из приведенных в настоящей главе примере, представляющем многопоточный клиент-серверный командный процессор, моделируемый в соответствии с рис. 7.1, который привлекался для обсуждения потоков. Каждый из потоков сервера управляет взаимодействием с отдельным клиентом, и для каждой пары "поток/клиент" используется отдельный дескриптор, то есть отдельный экземпляр именованного канала.</p>
    <p>Наконец, почтовые ящики обеспечивают широковещательную рассылку сообщений по схеме "один многим", а их использование для расширения возможностей командного процессора демонстрируется в последнем примере.</p>
   </section>
   <section>
    <title>
     <p>Анонимные каналы</p>
    </title>
    <p>Анонимные каналы (anonymous channels) Windows обеспечивают однонаправленное (полудуплексное) посимвольное межпроцессное взаимодействие. Каждый канал имеет два дескриптора: дескриптор чтения (read handle) и дескриптор записи (write handle). Функция, с помощью которой создаются анонимные каналы, имеет следующий прототип:</p>
    <cite>
     <p><code>BOOL CreatePipe(PHANDLE phRead, PHANDLE phWrite, LPSECURITY_ATTRIBUTES lpsa, DWORD cbPipe)</code></p>
    </cite>
    <p>Дескрипторы каналов часто бывают наследуемыми; причины этого станут понятными из приведенного ниже примера. Значение параметра cbPipe, указывающее размер канала в байтах, носит рекомендательный характер, причем значению 0 соответствует размер канала по умолчанию.</p>
    <p>Чтобы канал можно было использовать для IPC, должен существовать еще один процесс, и для этого процесса требуется один из дескрипторов канала. Предположим, например, что родительскому процессу, вызвавшему функцию CreatePipe, необходимо вывести данные, которые нужны дочернему процессу. Тогда возникает вопрос о том, как передать дочернему процессу дескриптор чтения (phRead). Родительский процесс осуществляет это, устанавливая дескриптор стандартного ввода в структуре STARTUPINFO для дочерней процедуры равным *phRead.</p>
    <p>Чтение с использованием дескриптора чтения канала блокируется, если канал пуст. В противном случае в процессе чтения будет воспринято столько байтов, сколько имеется в канале, вплоть до количества, указанного при вызове функции ReadFile. Операция записи в заполненный канал, которая выполняется с использованием буфера в памяти, также будет блокирована.</p>
    <p>Наконец, анонимные каналы обеспечивают только однонаправленное взаимодействие. Для двухстороннего взаимодействия необходимы два канала. </p>
   </section>
   <section>
    <title>
     <p>Пример: перенаправление ввода/вывода с использованием анонимного канала</p>
    </title>
    <p>В программе 11.1 представлен родительский процесс, который создает два процесса из командной строки и соединяет их каналом. Родительский процесс устанавливает канал и осуществляет перенаправление стандартного ввода/вывода. Обратите внимание на то, каким образом задается свойство наследования дескрипторов анонимного канала и как организуется перенаправление стандартного ввода/вывода на два дочерних процесса; эти методики описаны в главе 6.</p>
    <p>Местоположение оператора WriteFile в блоке Program2 на рис. 11.1 справа предполагает, что программа считывает большой объем данных, обрабатывает их, и лишь после этого записывает результаты. Эту запись можно было бы осуществлять и внутри цикла, выводя результаты после каждого считывания.</p>
    <image l:href="#Any2FbImgLoader121"/>
    <p><strong>Рис. 11.1. </strong>Межпроцессное взаимодействие с использованием анонимного канала</p>
    <empty-line/>
    <p>Дескрипторы каналов и потоков должны закрываться при первой же возможности. На рис. 11.1 закрытие дескрипторов не отражено, однако это делается в программе 11.1. Родительский процесс должен закрыть дескриптор устройства стандартного вывода сразу же после создания первого дочернего процесса, чтобы второй процесс мог распознать метку конца файла, когда завершится выполнение первого процесса. В случае существования открытого дескриптора первого процесса второй процесс не смог бы завершиться, поскольку система не обозначила бы конец файла.</p>
    <p>В программе 11.1 используется непривычный синтаксис: две команды, разделенные символом =, обозначающим канал. Использование для этой цели символа вертикальной черты (|) привело бы к возникновению конфликта с системным командным процессором. Рисунок 11.1 является схематическим представлением выполнения следующей команды:</p>
    <p><code>$ pipe Program1 <emphasis>аргументы</emphasis> = Program2 <emphasis>аргументы</emphasis></code></p>
    <p>При использовании средств командного процессора UNIX или Windows соответствующая команда имела бы следующий вид:</p>
    <p><code>$ Program1 <emphasis>аргументы</emphasis> | Program2 <emphasis>аргументы</emphasis></code></p>
    <subtitle>Программа 11.1. pipe: межпроцессное взаимодействие с использованием анонимных каналов </subtitle>
    <p><code>#include "EvryThng.h"</code></p>
    <p><code>int _tmain(int argc, LPTSTR argv[])</code></p>
    <p><code>/* Соединение двух команд с помощью канала в командной строке: pipe команда1 = команда2 */ </code></p>
    <p><code>{</code></p>
    <p><code> DWORD i = 0;</code></p>
    <p><code> HANDLE hReadPipe, hWritePipe;</code></p>
    <p><code> TCHAR Command1[MAX_PATH];</code></p>
    <p><code> SECURITY_ATTRIBUTES PipeSA = /* Для наследуемых дескрипторов. */</code></p>
    <p><code>  {sizeof(SECURITY_ATTRIBUTES), NULL, TRUE};</code></p>
    <p><code> PROCESS_INFORMATION ProcInfo1, ProcInfo2;</code></p>
    <p><code> STARTUPINFO StartInfoCh1, StartInfoCh2;</code></p>
    <p><code> LPTSTR targv = SkipArg(GetCommandLine());</code></p>
    <p><code> GetStartupInfo(&amp;StartInfoCh1);</code></p>
    <p><code> GetStartupInfo(&amp;StartInfoCh2);</code></p>
    <p><code> /* Найти символ "=", разделяющий две команды. */</code></p>
    <p><code> while (*targv != '=' &amp;&amp; *targv != '\0') {</code></p>
    <p><code>  Command1[i] = *targv;</code></p>
    <p><code>  targv++;</code></p>
    <p><code>  i++;</code></p>
    <p><code> }</code></p>
    <p><code> Command1[i] = '\0';</code></p>
    <p><code> /* Пропуск до начала второй команды. */</code></p>
    <p><code> targv = SkipArg(targv);</code></p>
    <p><code> CreatePipe(&amp;hReadPipe, &amp;hWritePipe, &amp;PipeSA, 0);</code></p>
    <p><code> /* Перенаправить стандартный вывод и создать первый процесс. */</code></p>
    <p><code> StartInfoCh1.hStdInput = GetStdHandle(STD_INPUT_HANDLE);</code></p>
    <p><code> StartInfoCh1.hStdError = GetStdHandle(STD_ERROR_HANDLE);</code></p>
    <p><code> StartInfoCh1.hStdOutput = hWritePipe;</code></p>
    <p><code> StartInfoCh1.dwFlags = STARTF_USESTDHANDLES;</code></p>
    <p><code> CreateProcess(NULL, (LPTSTR)Command1, NULL, NULL, TRUE /* Унаследовать дескрипторы. */, 0, NULL, NULL, &amp;StartInfoCh1, &amp;ProcInfo1);</code></p>
    <p><code> CloseHandle(ProcInfo1.hThread);</code></p>
    <p><code> /* Закрыть дескриптор записи канала, поскольку он больше не нужен, чтобы вторая команда могла обнаружить конец файла. */</code></p>
    <p><code> CloseHandle(hWritePipe);</code></p>
    <p><code><emphasis> /*</emphasis> Повторить операции (симметричным образом) для второго процесса. */</code></p>
    <p><code> StartInfoCh2.hStdInput = hReadPipe;</code></p>
    <p><code> StartInfoCh2.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);</code></p>
    <p><code> StartInfoCh2.hStdError = GetStdHandle(STD_ERROR_HANDLE);</code></p>
    <p><code> StartInfoCh2.dwFlags = STARTF_USESTDHANDLES;</code></p>
    <p><code> CreateProcess(NULL, (LPTSTR)targv, NULL, NULL, TRUE, 0, NULL, NULL, &amp;StartInfoCh2, &amp;ProcInfo2);</code></p>
    <p><code> CloseHandle(ProcInfo2.hThread);</code></p>
    <p><code> CloseHandle(hReadPipe);</code></p>
    <p><code> /* Ожидать завершения первого и второго процессов. */</code></p>
    <p><code> WaitForSingleObject(ProcInfo1.hProcess, INFINITE);</code></p>
    <p><code> CloseHandle(ProcInfo1.hProcess);</code></p>
    <p><code> WaitForSingleObject(ProcInfo2.hProcess, INFINITE);</code></p>
    <p><code> CloseHandle(ProcInfo2.hProcess);</code></p>
    <p><code> return 0; </code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>Именованные каналы</p>
    </title>
    <section>
     <p>Именованные каналы (named pipes) предлагают ряд возможностей, которые делают их полезными в качестве универсального механизма реализации приложений на основе IPC, включая приложения, требующие сетевого доступа к файлам, и клиент-серверные системы<a l:href="#n_31" type="note">[31]</a>, хотя для реализации простых вариантов IPC, ориентированных на байтовые потоки, как в предыдущем примере, в котором взаимодействие процессов ограничивается рамками одной системы, анонимных каналов вам будет вполне достаточно. К числу упомянутых возможностей (часть которых обеспечивается дополнительно) относятся следующие:</p>
     <p>• Именованные каналы ориентированы на обмен сообщениями, поэтому процесс, выполняющий чтение, может считывать сообщения переменной длины именно в том виде, в каком они были посланы процессом, выполняющим запись.</p>
     <p>• Именованные каналы являются двунаправленными, что позволяет осуществлять обмен сообщениями между двумя процессами посредством единственного канала.</p>
     <p>• Допускается существование нескольких независимых экземпляров канала, имеющих одинаковые имена. Например, с единственной серверной системой могут связываться одновременно несколько клиентов, использующих каналы с одним и тем же именем. Каждый клиент может иметь собственный экземпляр именованного канала, и сервер может использовать этот же канал для отправки ответа клиенту.</p>
     <p>• Каждая из систем, подключенных к сети, может обратиться к каналу, используя его имя. Взаимодействие посредством именованного канала осуществляется одинаковым образом для процессов, выполняющихся как на одной и той же, так и на разных машинах.</p>
     <p>• Имеется несколько вспомогательных и связных функций, упрощающих обслуживание взаимодействия "запрос/ответ" и клиент-серверных соединений.</p>
     <p>Как правило, именованные каналы являются более предпочтительными по сравнению с анонимными, хотя программа 11.1 и рис. 11.1 и иллюстрируют ситуацию, в которой анонимные каналы оказываются исключительно полезными. Во всех случаях, когда требуется, чтобы канал связи был двунаправленным, ориентированным на обмен сообщениями или доступным для нескольких клиентских процессов, следует применять именованные каналы. Попытки реализации последующих примеров с использованием анонимных каналов натолкнулись бы на значительные трудности.</p>
    </section>
    <section>
     <title>
      <p>Использование именованных каналов</p>
     </title>
     <p>Функция CreateNamedPipe создает первый экземпляр именованного канала и возвращает дескриптор. При вызове этой функции указывается также максимально допустимое количество экземпляров каналов, а следовательно, и количество клиентов, одновременная поддержка которых может быть обеспечена.</p>
     <p>Как правило, создающий процесс рассматривается в качестве <emphasis>сервера. Клиентские процессы,</emphasis> которые могут выполняться и на других системах, открывают канал с помощью функции CreateFile.</p>
     <p>На рис. 11.2 в иллюстративной форме представлены отношения "клиент/сервер", а также псевдокод, отражающий одну из возможных схем применения именованных каналов. Обратите внимание, что сервер создает множество экземпляров одного и того же канала, каждый из которых обеспечивает поддержку одного клиента. Кроме того, для каждого экземпляра именованного канала сервер создает поток, так что для каждого клиента существует выделенный поток и экземпляр именованного канала. Следовательно, рис. 11.2 показывает, как реализовать модель многопоточного сервера, впервые представленную на рис. 7.1.</p>
     <image l:href="#Any2FbImgLoader122"/>
     <p><strong>Рис. 11.2</strong>. Взаимодействие клиентов с сервером через именованные каналы</p>
    </section>
    <section>
     <title>
      <p>Создание именованных каналов</p>
     </title>
     <p>Серверами именованных каналов могут быть только системы на основе Windows NT (как обычно, здесь имеются в виду версия 4.0 и последующие); системы на базе Windows 9x могут выступать только в роли клиентов.</p>
     <p>Прототип функции CreateNamedPipe представлен ниже.</p>
     <cite>
      <p><code>HANDLE CreateNamedPipe(LPCTSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY ATTRIBUTES lpSecurityAttributes)</code> </p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>lpName — указатель на имя канала, который должен иметь следующую форму:</p>
     <p><code>\\.\pipe\<emphasis>[path]pipename</emphasis></code></p>
     <p>Точка (.) обозначает локальный компьютер; таким образом, создать канал на удаленном компьютере невозможно. </p>
     <p>dwOpenMode — указывает один из следующих флагов:</p>
     <p>• PIPE_ACCESS_DUPLEX — этот флаг эквивалентен комбинации значений GENERIC_READ и GENERIC_WRITE.</p>
     <p>• PIPE_ACCESS_INBOUND — данные могут передаваться только в направлении от клиента к серверу; эквивалентно GENERIC_READ.</p>
     <p>• PIPE_ACCESS_OUTBOUND — этот флаг эквивалентен GENERIC_WRITE.</p>
     <p>При задании режима могут также указываться значения FILE_FLAG_WRITE_THROUGH (не используется с каналами сообщений) и FILE_FLAG_OVERLAPPED (перекрывающиеся операции рассматриваются в главе 14).</p>
     <p>dwPipeMode — имеются три пары взаимоисключающих значений этого параметра. Эти значения указывают, ориентирована ли запись на работу с сообщениями или байтами, ориентировано ли чтение на работу с сообщениями или блоками, и блокируются ли операции чтения.</p>
     <p>• PIPE_TYPE_BYTE и PIPE_TYPE_MESSAGE — указывают, соответственно, должны ли данные записываться в канал как поток байтов или как сообщения. Для всех экземпляров каналов с одинаковыми именами следует использовать одно и то же значение.</p>
     <p>• PIPE_READMODE_BYTE и PIPE_READMODE_MESSAGE — указывают, соответственно, должны ли данные считываться как поток байтов или как сообщения. Значение PIPE_READMODE_MESSAGE требует использования значения PIPE_TYPE_MESSAGE.</p>
     <p>• PIPE_WAIT и PIPE_NOWAIT — определяют, соответственно, будет или не будет блокироваться операция ReadFile. Следует использовать значение PIPE_WAIT, поскольку для обеспечения асинхронного ввода/вывода существуют лучшие способы.</p>
     <p>nMaxInstances — определяет количество экземпляров каналов, а следовательно, и количество одновременно поддерживаемых клиентов. Как показано на рис. 11.2, при каждом вызове функции CreateNamedPipe для данного канала должно использоваться одно и то же значение. Чтобы предоставить ОС возможность самостоятельно определить значение этого параметра на основании доступных системных ресурсов, следует указать значение PIPE_UNLIMITED_INSTANCES.</p>
     <p>nOutBufferSize и nInBufferSize — позволяют указать размеры (в байтах) выходного и входного буферов именованных каналов. Чтобы использовать размеры буферов по умолчанию, укажите значение 0.</p>
     <p>nDefaultTimeOut — длительность интервала ожидания по умолчанию (в миллисекундах) для функции WaitNamedPipe, которая обсуждается в следующем разделе. Эта ситуация, в которой функция, создающая объект, устанавливает интервал ожидания для родственной функции, является уникальной.</p>
     <p>В случае ошибки возвращается значение INVALID_HANDLE_VALUE, поскольку дескрипторы каналов аналогичны дескрипторам файлов. При попытке создания именованного канала под управлением Windows 9x, которая не может выступать в качестве сервера именованных каналов, возвращаемым значением будет NULL, что может стать причиной недоразумений.</p>
     <p>lpSecurityAttributes — имеет тот же смысл, что и в случае любой функции, создающей объект.</p>
     <p>При первом вызове функции CreateNamedPipe происходит создание самого именованного канала, а не просто его экземпляра. Закрытие последнего открытого дескриптора экземпляра именованного канала приводит к уничтожению этого экземпляра (обычно существует по одному дескриптору на каждый экземпляр). Уничтожение последнего экземпляра именованного канала приводит к уничтожению самого канала, в результате чего имя канала становится вновь доступным для повторного использования.</p>
    </section>
    <section>
     <title>
      <p>Подключение клиентов именованных каналов</p>
     </title>
     <p>Как показано на рис. 11.2, для подключения клиента к именованному каналу применяется функция CreateFile, при вызове которой указывается имя именованного канала. Часто клиент и сервер выполняются на одном компьютере, и в этом случае для указания имени канала используется следующая форма:</p>
     <p><code>\\.\pipe\<emphasis>[path]pipename</emphasis></code></p>
     <p>Если сервер находится на другом компьютере, для указания имени канала используется следующая форма:</p>
     <p><code>\\servername\pipe\<emphasis>[path]pipename</emphasis></code></p>
     <p>Использование точки (.) вместо имени локального компьютера в случае, когда сервер является локальным, позволяет значительно сократить время подключения.</p>
    </section>
    <section>
     <title>
      <p>Функции состояния именованных каналов</p>
     </title>
     <p>Предусмотрены две функции, позволяющие получать информацию о состоянии каналов, и еще одна функция, позволяющая устанавливать данные состояния канала. Краткая характеристика этих функций приводится ниже, а одна из этих функций используется в программе 11.2.</p>
     <p>• GetNamedPipeHandleState — возвращает для заданного открытого дескриптора информацию относительно того, работает ли канал в блокируемом или неблокируемом режиме, ориентирован ли он на работу с сообщениями или байтами, каково количество экземпляров канала и тому подобное.</p>
     <p>• SetNamedPipeHandleState — позволяет программе устанавливать атрибуты состояния. Параметр режима (NpMode) передается не по значению, а по адресу, что может стать причиной недоразумений. Применение этой функции демонстрируется в программе 11.2.</p>
     <p>• GetNamedPipeInfo — определяет, принадлежит ли дескриптор экземпляру клиента или сервера, размеры буферов и тому подобное.</p>
    </section>
    <section>
     <title>
      <p>Функции подключения именованных каналов</p>
     </title>
     <p>После создания именованного канала сервер может ожидать подключения клиента (осуществляемого с помощью функции CreateFile или функции CallNamedFile, описанной далее в этой главе), используя для этого функцию ConnectNamedPipe, которая является серверной функцией лишь в случае Windows NT: </p>
     <cite>
      <p><code>Bool ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped)</code> </p>
     </cite>
     <p>Если параметр lpOverlapped установлен равным NULL, то функция ConnectNamedPipe осуществляет возврат сразу же после установления соединения с клиентом. В случае успешного выполнения функции возвращаемым значением является TRUE. Если же подключение клиента происходит в течение промежутка времени между вызовами сервером функций CreateNamedPipe и ConnectNamed-Pipe, то возвращаемым значением будет FALSE. В этом случае функция GetLastError вернет значение ERROR_PIPE_CONNECTED.</p>
     <p>После возврата из функции ConnectNamedPipe сервер может выполнять чтение запросов с помощью функции ReadFile и запись ответов посредством функции WriteFile. Наконец, сервер должен вызвать функцию DisconnectNamedPipe, чтобы освободить дескриптор (экземпляра канала) для соединения с другим возможным клиентом.</p>
     <p>Последняя функция, WaitNamedPipe, используется клиентами для синхронизации соединений с сервером. Функция осуществляет успешный возврат, когда на сервере имеется незавершенный вызов функции ConnectNamedPipe, указывающий на наличие доступного экземпляра именованного канала. Используя WaitNamedPipe, клиент имеет возможность убедиться в том, что сервер готов к образованию соединения, после чего может вызвать функцию CreateFile. Вместе с тем, вызов клиентом функции CreateFile может завершиться ошибкой, если в это же время другой клиент открывает экземпляр именованного канала или дескриптор экземпляра закрывается сервером. При этом неудачного завершения вызванной сервером функции ConnectNamedPipe не произойдет. Заметьте, что для функции WaitNamedPipe предусмотрен интервал ожидания, который, если он указан, отменяет значение интервала ожидания, заданного при вызове серверной функции CreateNamedPipe.</p>
    </section>
    <section>
     <title>
      <p>Подключение клиентов и серверов именованных каналов</p>
     </title>
     <p>Операции по подключению клиентов и серверов к именованным каналам выполняются в описанном ниже порядке. Сначала мы рассмотрим последовательность операций, выполняемых сервером, при помощи которых сервер создает соединение с клиентом, взаимодействует с клиентом до тех пор, пока тот не разорвет соединение (вынуждая функцию ReadFile вернуть значение FALSE), разрывает соединение на стороне сервера, а затем образует соединение с другим клиентом:</p>
     <p><code>/* Последовательность операций при создании соединения с использованием именованного канала для сервера. */ </code></p>
     <p><code>hNp = CreateNamedPipe("\\\\.\\pipe\\my_pipe", …);</code></p>
     <p><code>while (… /* Цикл продолжается вплоть до завершения работы сервера.*/) {</code></p>
     <p><code> ConnectNamedPipe(hNp, NULL);</code></p>
     <p><code> while (ReadFile(hNp, Request, …) {</code></p>
     <p><code>  …</code></p>
     <p><code>  WriteFile(hNp, Response, …);</code></p>
     <p><code> }</code></p>
     <p><code> DisconnectNamedPipe(hNp);</code></p>
     <p><code>} </code></p>
     <p><code>CloseHandle(hNp);</code></p>
     <p>Перейдем к рассмотрению последовательности операций, выполняемых клиентом, в которой клиент прекращает выполнение после завершения работы, давая возможность подключиться к тому же экземпляру именованного канала другому клиенту. Как показано ниже, клиент может соединиться с сервером в сети, если ему известно сетевое имя сервера (ServerName):</p>
     <p><code>/* Последовательность операций при создании соединения с использованием именованного канала для клиента. */ </code></p>
     <p><code>WaitNamedPipe("\\\\ServerName\\pipe\\my_pipe", NMPWAIT_WAIT_FOREVER);</code></p>
     <p><code>hNp = CreateFile("\\\\ServerName\\pipe\\my_pipe", …); </code></p>
     <p><code>while (…/*Цикл выполняется до тех пор, пока не прекратятся запросы.*/ {</code></p>
     <p><code> WriteFile(hNp, Request, …);</code></p>
     <p><code> …</code></p>
     <p><code> ReadFile(hNp, Response); </code></p>
     <p><code>} </code></p>
     <p><code>CloseHandle (hNp); /* Разорвать соединение с сервером. */</code></p>
     <p>Обратите внимание, что клиент и сервер состязаются за ресурсы. Прежде всего, клиентский вызов функции WaitNamedPipe завершится ошибкой, если именованный канал к этому моменту еще не был создан сервером; для краткости тестирование успешности выполнения в нашем примере опущено, однако оно включено в примеры программ, доступные на Web-сайте. Далее, в редких случаях вызов CreateFile может быть выполнен еще до того, как сервер вызовет функцию ConnectNamedPipe. В этом случае функция ConnectNamedPipe вернет серверу значение FALSE, однако взаимодействия посредством именованного канала по-прежнему будет функционировать надлежащим образом. </p>
     <p>Экземпляр именованного канала является глобальным ресурсом, поэтому, когда клиент разрывает соединение с сервером, к нему может подключиться другой клиент.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Функции транзакций именованных каналов</p>
    </title>
    <section>
     <p>На рис. 11.2 показана типичная конфигурация клиента, в которой клиент выполняет следующие операции:</p>
     <p>• Открывает экземпляр канала, создавая долговременное соединение с сервером и занимая экземпляр канала.</p>
     <p>• Периодически посылает запросы и ожидает получения ответов.</p>
     <p>• Закрывает соединение.</p>
     <p>Встречающуюся здесь последовательность вызовов функций WriteFile и ReadFile можно рассматривать как единую клиентскую транзакцию, и Windows предоставляет соответствующую функцию для каналов сообщений: </p>
     <cite>
      <p><code>BOOL TransactNamedPipe(HANDLE hNamedPipe, LPVOID lpWriteBuf, DWORD cbWriteBuf, LPVOID lpReadBuf, DWORD cbReadBuf, LPDWORD lpcbRead, LPOVERLAPPED lpOverlapped)</code> </p>
     </cite>
     <p>Смысл всех параметров здесь должен быть ясен, поскольку данная функция сочетает в себе функции WriteFile и ReadFile, применяемые к дескриптору именованного канала. Указываются как выходной, так и входной буфер, а разыменованный указатель lpcbRead предоставляет размер сообщения. Перекрывающиеся операции (глава 14) возможны, однако в более типичных случаях функция ожидает ответа.</p>
     <p>Функция TransactNamedPipe удобна в использовании, однако, как показывает рис. 11.2, она требует создания постоянного соединения, что ограничивает число возможных клиентов<a l:href="#n_32" type="note">[32]</a>.</p>
     <p>Ниже приводится прототип второй клиентской вспомогательной функции.  </p>
     <cite>
      <p><code>BOOL CallNamedPipe(LPCTSTR lpPipeName, LPVOID lpWriteBuf, DWORD cbWriteBuf, LPVOID lpReadBuf, DWORD cbReadBuf, LPDWORD lpcbRead, DWORD dwTimeOut)</code> </p>
     </cite>
     <p>Функция CallNamedPipe не требует образования постоянного соединения; вместо этого она создает временное соединение, объединяя в себе выполнение следующей последовательности операций:</p>
     <p><code>CreateFile</code></p>
     <p><code>WriteFile</code></p>
     <p><code>ReadFile</code></p>
     <p><code>CloseHandle</code></p>
     <p>Преимуществом такого способа является лучшее использование канала за счет снижения накладных расходов системных ресурсов на один запрос.</p>
     <p>Смысл параметров этой функции тот же, что и в случае функции TransactNamedPipe, если не считать того, что вместо дескриптора для указания канала используется его имя. Функция CallNamedPipe выполняется синхронном режиме (отсутствует структура OVERLAPPED). Указываемая при ее вызове длительность периода ожидания (dwTimeOut) (в миллисекундах) относится к соединению, а не транзакции. Параметр dwTimeOut имеет три специальных значения:</p>
     <p>• NMPWAIT_NOWAIT</p>
     <p>• NMPWAIT_WAIT_FOREVER</p>
     <p>• NMPWAIT_USE_DEFAULT_WAIT, которое приводит к использованию интервала ожидания по умолчанию, заданного в вызове функции CreateNamedPipe.</p>
    </section>
    <section>
     <title>
      <p>Определение наличия сообщений в именованных каналах</p>
     </title>
     <p>В дополнение к возможности чтения данных из именованного канала с помощью функции ReadFile можно также определить, имеются ли в канале фактические сообщения, используя для этого функцию PeekNamedPipe. Это средство может быть использовано для опроса именованного канала (неэффективная операция), определения размера сообщения, чтобы распределить память для буфера перед выполнением чтения, или просмотра поступающих сообщений с целью назначения им приоритетов для последующей обработки. </p>
     <cite>
      <p><code>BOOL PeekNamedPipe(HANDLE hPipe, LPVOID lpBuffer, DWORD cbBuffer, LPDWORD lpcbRead, LPDWORD lpcbAvail, LPDWORD lpcbMessage) </code></p>
     </cite>
     <p>Функция PeekNamedPipe обеспечивает считывание любого байта или сообщения из канала без их удаления, но ее невозможно блокировать, и она осуществляет возврат сразу же по завершении выполнения.</p>
     <p>Чтобы определить, имеются ли в канале данные, необходимо проверить значение *lpcbAvail; если данные в канале присутствуют, оно должно быть больше 0. В этом случае параметры lpBuffer и lpcbRead могут иметь значения NULL. Если же буфер определен параметрами lpBuffer и cbBuffer, то значение *lpcbMessage укажет вам, остается ли еще некоторое количество байтов сообщений, которые не умещаются в буфере, что позволяет распределять буфер большего размера, прежде чем осуществлять чтение из именованного канала. Для канала, работающего в режиме считывания байтов, это значение равно 0.</p>
     <p>Следует помнить, что функция PeekNamedPipe осуществляет чтение, не уничтожая данные, и поэтому для удаления сообщений или байтовых данных из канала требуется последующее применение функции ReadFile. </p>
     <cite>
      <p>Каналы UNIX FIFO аналогичны именованным каналам и, таким образом, обеспечивают взаимодействие не связанных между собой процессов. Однако по сравнению с именованными каналами Windows их возможности являются несколько ограниченными:</p>
      <p>• Каналы FIFO являются полудуплексными.</p>
      <p>• Каналы FIFO действуют только в пределах одного компьютера.</p>
      <p>• Каналы FIFO ориентированы на работу с байтами, поэтому в клиент-серверных приложениях проще всего использовать записи фиксированной длины. Тем не менее, отдельные операции чтения и записи являются атомарными.</p>
      <p>Сервер, на котором применяется это средство, должен использовать для каждого ответа клиентам отдельный канал FIFO, хотя все клиенты могут посылать запросы по одному и тому же известному каналу. В соответствии с общепринятой практикой клиенты включают имя канала FIFO в запрос соединения.</p>
      <p>Функция UNIX mkfifo является ограниченной версией функции CreateNamedFile.</p>
      <p>Если клиенты и сервер должны находиться в сети, используйте сокеты или аналогичный механизм транспортировки сетевых сообщений. Сокеты работают в дуплексном режиме, однако требуют использования отдельного соединения для каждого клиента. </p>
     </cite>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: клиент-серверный процессор командной строки</p>
    </title>
    <p>Теперь мы располагаем всем необходимым для построения клиент-серверной системы, работающей с запросами и ответами. В данном примере будет представлен сервер командной строки, выполняющий команду по требованию клиента. Система характеризуется следующими особенностями:</p>
    <p>• С сервером могут взаимодействовать несколько клиентов.</p>
    <p>• Клиенты могут находиться на различных системах в сети, хотя допускается и их расположение на компьютере сервера.</p>
    <p>• Сервер является многопоточным, причем каждому именованному каналу назначается отдельный поток. Это означает, что существует пул потоков (thread pool), в который входят рабочие потоки, готовые к использованию подключающимися клиентами. Рабочие потоки предоставляются клиентам посредством экземпляра именованного канала, который система выделяет клиенту.</p>
    <p>• Отдельные потоки сервера в каждый момент времени обрабатывают один запрос, что упрощает управление параллелизмом их выполнения. Каждый из потоков самостоятельно обрабатывает свои запросы. Тем не менее, требуется предпринимать обычные меры предосторожности на тот случай, если несколько различных потоков сервера пытаются получить доступ к одному и тому же файлу или иному ресурсу.</p>
    <p>В программе 11.2 представлен однопоточной клиент, а в программе 11.3 — его сервер. Сервер соответствует модели, представленной на рисунках 7.1 и 11.2. Запросом клиента является обычная командная строка. Ответом сервера является результирующий вывод, который посылается в виде нескольких сообщений. Кроме того, в программе используется находящийся на Web-сайте заголовочный файл ClntSrvr.h, в котором определены структуры данных запроса и ответа, а также имена каналов клиента и сервера.</p>
    <p>В программе 11.2 клиент вызывает функцию LocateServer, которая находит имя канала сервера. Функция LocateServer использует почтовый ящик (mailslot), описанный в одном из последующих разделов и представленный в программе 11.5.</p>
    <p>В объявлениях записей имеются поля длины, тип которых определен как DWORD32; это сделано для того, чтобы программы, получая возможность их последующего перенесения на платформу Win64, могли взаимодействовать с серверами и клиентами, выполняющимися под управлением любой системы Windows.</p>
    <subtitle>Программа 11.2. clientNP: клиент, ориентированный на соединение посредством именованного канала </subtitle>
    <p><code>/* Глава 11. Клиент-серверная система. ВЕРСИЯ КЛИЕНТА.</code></p>
    <p><code>   clientNP — клиент, ориентированный на установку соединения. */ </code></p>
    <p><code>/* Выполнить командную строку (на сервере); отобразить ответ. */</code></p>
    <p><code>/* Клиент создает долговременное соединение с сервером (захватывая */</code></p>
    <p><code>/* экземпляр канала) и выводит приглашение пользователю для ввода команд.*/</code></p>
    <empty-line/>
    <p><code>#include "EvryThng.h"</code></p>
    <p><code>#include "ClntSrvr.h" /* Определяет структуры записей запроса и ответа. */</code></p>
    <empty-line/>
    <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> HANDLE hNamedPipe = INVALID_HANDLE_VALUE;</code></p>
    <p><code> TCHAR PromptMsg[] = _T("\nВведите команду: ");</code></p>
    <p><code> TCHAR QuitMsg[] = _T("$Quit");</code></p>
    <p><code> TCHAR ServerPipeName[MAX_PATH];</code></p>
    <p><code> REQUEST Request; /* См. файл ClntSrvr.h. */</code></p>
    <p><code> RESPONSE Response; /* См. файл ClntSrvr.h. */</code></p>
    <p><code> DWORD nRead, nWrite, NpMode = PIPE_READMODE_MESSAGE | PIPE_WAIT;</code></p>
    <p><code> LocateServer(ServerPipeName);</code></p>
    <p><code> /* Ожидать появления экземпляра именованного канала и "вступить в борьбу" за право его открытия. */</code></p>
    <p><code> while (INVALID_HANDLE_VALUE == hNamedPipe) {</code></p>
    <p><code>  WaitNamedPipe(ServerPipeName, NMPWAIT_WAIT_FOREVER);</code></p>
    <p><code>  hNamedPipe = CreateFile(ServerPipeName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);</code></p>
    <p><code> }</code></p>
    <p><code> /* Задать блокирование дескриптора именованного канала; режим сообщений.*/</code></p>
    <p><code> SetNamedPipeHandleState(hNamedPipe, &amp;NpMode, NULL, NULL);</code></p>
    <p><code> /* Вывести приглашение пользователю для ввода команд. Завершить выполнение по получении команды "$quit." */</code></p>
    <p><code> while (ConsolePrompt(PromptMsg, Request.Record, MAX_RQRS_LEN, TRUE) &amp;&amp; (_tcscmp(Request.Record, QuitMsg) != 0)) {</code></p>
    <p><code>  WriteFile(hNamedPipe, &amp;Request, RQ_SIZE, &amp;nWrite, NULL);</code></p>
    <p><code>  /* Считать каждый ответ и направить его на стандартный вывод.</code></p>
    <p><code>      Response.Status = 0 означает "конец ответного сообщения." */</code></p>
    <p><code>  while (ReadFile(hNamedPipe, &amp;Response, RS_SIZE, &amp;nRead, NULL) &amp;&amp; (Response.Status == 0)) _tprintf(_T("%s"), Response.Record);</code></p>
    <p><code> }</code></p>
    <p><code> _tprintf(_T("Получена команда завершения работы. Соединение разрывается."));</code></p>
    <p><code> CloseHandle(hNamedPipe);</code></p>
    <p><code> return 0; </code></p>
    <p><code>}</code></p>
    <p>Программа 11.3 — это серверная программа, включающая функцию потока сервера, которая обрабатывает запросы, генерируемые с помощью программы 11.2. Кроме того, сервер создает "широковещательный серверный поток" ("server broadcast thread") (см. программу 11.4), который используется для широковещательной рассылки имени своего канала всем клиентам, желающим подключиться, посредством почтового ящика. В программе 11.2 вызывается функция LocateServer, представленная в программе 11.5, которая считывает информацию, отправленную данным процессом. Почтовые ящики описываются далее в настоящей главе.</p>
    <p>Хотя соответствующий код и не включен в программу 11.4, в ней предусмотрена возможность защиты сервером (представлен на Web-сайте) своего именованного канала с целью предотвращения доступа к нему клиентов, не имеющих должных полномочий. Вопросы безопасности объектов рассматриваются в главе 15, где будет также показано, как использовать указанную возможность.</p>
    <subtitle>Программа 11.3. serverNP: многопоточный сервер именованного канала </subtitle>
    <p><code>/* Глава 11. ServerNP. */</code></p>
    <p><code>/* Многопоточный сервер командной строки. Версия на основе именованных каналов. */</code></p>
    <empty-line/>
    <p><code>#include "EvryThng.h"</code></p>
    <p><code>#include "ClntSrvr.h" /* Определения сообщений запроса и ответа. */</code></p>
    <empty-line/>
    <p><code>typedef struct { /* Аргумент серверного потока. */</code></p>
    <p><code> HANDLE hNamedPipe; /* Экземпляр именованного канала. */</code></p>
    <p><code> DWORD ThreadNo;</code></p>
    <p><code> TCHAR TmpFileName[MAX_PATH]; /* Имя временного файла. */</code></p>
    <p><code>} THREAD_ARG;</code></p>
    <empty-line/>
    <p><code>typedef THREAD_ARG *LPTHREAD_ARG;</code></p>
    <p><code>volatile static BOOL ShutDown = FALSE;</code></p>
    <p><code>static DWORD WINAPI Server(LPTHREAD_ARG);</code></p>
    <p><code>static DWORD WINAPI Connect(LPTHREAD_ARG);</code></p>
    <p><code>static DWORD WINAPI ServerBroadcast(LPLONG);</code></p>
    <p><code>static BOOL WINAPI Handler(DWORD);</code></p>
    <p><code>static TCHAR ShutRqst[] = _T("$ShutDownServer");</code></p>
    <empty-line/>
    <p><code>_tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> /* Определение MAX_CLIENTS содержится в файле ClntSrvr.h. */</code></p>
    <p><code> HANDLE hNp, hMonitor, hSrvrThread[MAXCLIENTS];</code></p>
    <p><code> DWORD iNp, MonitorId, ThreadId;</code></p>
    <p><code> LPSECURITY_ATTRIBUTES pNPSA = NULL;</code></p>
    <p><code> THREAD_ARG ThArgs[MAXCLIENTS];</code></p>
    <p><code> /* Обработчик управляющих сигналов консоли, используемый для остановки сервера. */</code></p>
    <p><code> SetConsoleCtrlHandler(Handler, TRUE);</code></p>
    <p><code> /* Периодически создавать имя широковещательного канала потока. */</code></p>
    <p><code> hMonitor = (HANDLE)_beginthreadex(NULL, 0, ServerBroadcast, NULL, 0, &amp;MonitorId);</code></p>
    <p><code> /* Создать экземпляр канала и временный файл для каждого серверного потока. */</code></p>
    <p><code> for (iNp = 0; iNp &lt; MAX_CLIENTS; iNp++) {</code></p>
    <p><code>  hNp = CreateNamedPipe(SERVER_PIPE, PIPE_ACCESS_DUPLEX, PIPE_READMODE_MESSAGE | PIPE_TYPE_MESSAGE | PIPE_WAIT, MAXCLIENTS, 0, 0, INFINITE, pNPSA);</code></p>
    <p><code>  ThArgs[iNp].hNamedPipe = hNp;</code></p>
    <p><code>  ThArgs[iNp].ThreadNo = iNp;</code></p>
    <p><code>  GetTempFileName(_T("."), _T("CLP"), 0, ThArgs[iNp].TmpFileName);</code></p>
    <p><code>  hSrvrThread[iNp] = (HANDLE)_beginthreadex(NULL, 0, Server, &amp;ThArgs[iNp], 0, &amp;ThreadId);</code></p>
    <p><code> }</code></p>
    <p><code> /* Ждать завершения выполнения всех потоков. */</code></p>
    <p><code> WaitForMultipleObjects(MAXCLIENTS, hSrvrThread, TRUE, INFINITE);</code></p>
    <p><code> WaitForSingleObject(hMonitor, INFINITE);</code></p>
    <p><code> CloseHandle(hMonitor);</code></p>
    <p><code> for (iNp = 0; iNp &lt; MAXCLIENTS; iNp++) {</code></p>
    <p><code>  /* Закрыть дескрипторы канала и удалить временные файлы. */</code></p>
    <p><code>  CloseHandle(hSrvrThread[iNp]);</code></p>
    <p><code>  DeleteFile(ThArgs[iNp].TmpFileName);</code></p>
    <p><code> }</code></p>
    <p><code> _tprintf(_T("Серверный процесс завершил выполнение.\n"));</code></p>
    <p><code> return 0; </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>static DWORD WINAPI Server(LPTHREAD_ARG pThArg)</code></p>
    <p><code>/* Функция потока сервера; по одной для каждого потенциального клиента. */</code></p>
    <p><code>{</code></p>
    <p><code> HANDLE hNamedPipe, hTmpFile = INVALID_HANDLE_VALUE, hConTh, hClient;</code></p>
    <p><code> DWORD nXfer, ConThId, ConThStatus;</code></p>
    <p><code> STARTUPINFO StartInfoCh;</code></p>
    <p><code> SECURITY_ATTRIBUTES TempSA = {sizeof(SECURITY_ATTRIBUTES), NULL, TRUE};</code></p>
    <p><code> PROCESS_INFORMATION ProcInfo;</code></p>
    <p><code> FILE *fp;</code></p>
    <p><code> REQUEST Request;</code></p>
    <p><code> RESPONSE Response;</code></p>
    <p><code> GetStartupInfo(&amp;StartInfoCh);</code></p>
    <p><code> hNamedPipe = pThArg-&gt;hNamedPipe;</code></p>
    <p><code> hTmpFile = CreateFile(pThArg-&gt;TmpFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, &amp;TempSA, CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY, NULL);</code></p>
    <p><code> while (!ShutDown) { /* Цикл соединений. */</code></p>
    <p><code>  /* Создать поток соединения; ждать его завершения. */</code></p>
    <p><code>  hConTh = (HANDLE)_beginthreadex(NULL, 0, Connect, pThArg, 0, &amp;ConThId);</code></p>
    <p><code>  /* Ожидание соединения с клиентом и проверка флага завершения работы.*/</code></p>
    <p><code>  while (!ShutDown &amp;&amp; WaitForSingleObject(hConTh, CS_TIMEOUT) == WAIT_TIMEOUT) { /* Пустое тело цикла. */ }; </code></p>
    <p><code>  CloseHandle(hConTh);</code></p>
    <p><code>  if (ShutDown) continue; /*Флаг может быть установлен любым потоком.*/</code></p>
    <p><code>  /* Соединение существует. */</code></p>
    <p><code>  while (!ShutDown &amp;&amp; ReadFile(hNamedPipe, &amp;Request, RQ_SIZE, &amp;nXfer, NULL)) {</code></p>
    <p><code>   /* Получать новые команды до отсоединения клиента. */</code></p>
    <p><code>   ShutDown = ShutDown || (_tcscmp(Request.Record, ShutRqst) == 0);</code></p>
    <p><code>   if (ShutDown) continue; /* Проверяется на каждой итерации. */</code></p>
    <p><code>   /* Создать процесс для выполнения команды. */</code></p>
    <p><code>   StartInfoCh.hStdOutput = hTmpFile;</code></p>
    <p><code>   StartInfoCh.hStdError = hTmpFile;</code></p>
    <p><code>   StartInfoCh.hStdInput = GetStdHandle(STD_INPUT_HANDLE);</code></p>
    <p><code>   StartInfoCh.dwFlags = STARTF_USESTDHANDLES;</code></p>
    <p><code>   CreateProcess(NULL, Request.Record, NULL, NULL, TRUE, /* Унаследовать дескрипторы. */</code></p>
    <p><code>    0, NULL, NULL, &amp;StartInfoCh, &amp;ProcInfo);</code></p>
    <p><code>   /* Выполняется процесс сервера. */</code></p>
    <p><code>   CloseHandle(ProcInfo.hThread);</code></p>
    <p><code>   WaitForSingleObject(ProcInfo.hProcess, INFINITE);</code></p>
    <p><code>   CloseHandle(ProcInfo.hProcess);</code></p>
    <p><code>   /* Отвечать по одной строке за один раз. Здесь удобно использовать функции библиотеки С для работы со строками. */</code></p>
    <p><code>   fp = _tfopen(pThArg-&gt;TmpFileName, _T("r"));</code></p>
    <p><code>   Response.Status = 0;</code></p>
    <p><code>   while(_fgetts(Response.Record, MAX_RQRS_LEN, fp) != NULL) WriteFile(hNamedPipe, &amp;Response, RS_SIZE, &amp;nXfer, NULL);</code></p>
    <p><code>   FlushFileBuffers(hNamedPipe);</code></p>
    <p><code>   fclose(fp);</code></p>
    <p><code>   /* Уничтожить содержимое временного файла. */</code></p>
    <p><code>   SetFilePointer(hTmpFile, 0, NULL, FILE_BEGIN);</code></p>
    <p><code>   SetEndOfFile(hTmpFile);</code></p>
    <p><code>   /* Отправить признак конца ответа. */</code></p>
    <p><code>   Response.Status = 1;</code></p>
    <p><code>   strcpy(Response.Record, "");</code></p>
    <p><code>   WriteFile(hNamedPipe, &amp;Response, RS_SIZE, &amp;nXfer, NULL);</code></p>
    <p><code>  }</code></p>
    <p><code>  /* Конец основного командного цикла. Получить следующую команду. */</code></p>
    <p><code>  /* Принудительно завершить выполнение потока, если он все еще активен.*/</code></p>
    <p><code>  GetExitCodeThread(hConTh, &amp;ConThStatus);</code></p>
    <p><code>  if (ConThStatus == STILL_ACTIVE) {</code></p>
    <p><code>   hClient = CreateFile(SERVER_PIPE, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN EXISTING, FILE ATTRIBUTE NORMAL, NULL); </code></p>
    <p><code>   if (hClient != INVALID_HANDLE_VALUE) CloseHandle (hClient);</code></p>
    <p><code>   WaitForSingleObject (hConTh, INFINITE);</code></p>
    <p><code>  }</code></p>
    <p><code>  /* Клиент отсоединился или имеется запрос останова. */</code></p>
    <p><code>  FlushFileBuffers(hNamedPipe);</code></p>
    <p><code>  DisconnectNamedPipe(hNamedPipe);</code></p>
    <p><code> }</code></p>
    <p><code> /* Конец командного цикла. Освободить ресурсы; выйти из потока. */</code></p>
    <p><code> if (hTmpFile != INVALID_HANDLE_VALUE) CloseHandle(hTmpFile);</code></p>
    <p><code> DeleteFile(pThArg-&gt;TmpFileName);</code></p>
    <p><code> _tprintf(_T("Выход из потока номер %d\n"), pThArg-&gt;ThreadNo);</code></p>
    <p><code> _endthreadex(0); </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>static DWORD WINAPI Connect(LPTHREAD_ARG pThArg) {</code></p>
    <p><code> /* Поток соединения разрешает серверу опрос флага ShutDown. */</code></p>
    <p><code> ConnectNamedPipe(pThArg-&gt;hNamedPipe, NULL);</code></p>
    <p><code> _endthreadex(0);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>BOOL WINAPI Handler(DWORD CtrlEvent) {</code></p>
    <p><code> /* Завершить работу системы. */</code></p>
    <p><code> ShutDown = TRUE;</code></p>
    <p><code> return TRUE; </code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>Комментарии по поводу клиент-серверного процессора командной строки</p>
    </title>
    <p>Данное решение характеризуется рядом особенностей и ограничений, которые будут обсуждаться в последующих главах.</p>
    <p>• Соединяться с сервером и выполнять параллельные запросы могут сразу несколько серверов; каждому клиенту назначается серверный (или рабочий) поток, выделяемый из пула потоков.</p>
    <p>• Сервер и клиенты могут выполняться либо в ответ на отдельные подсказки командной строки, либо под управлением программы JobShell (программа 6.3).</p>
    <p>• Если во время попыток клиента соединиться с сервером все экземпляры именованного канала оказываются задействованными, то новый клиент будет находиться в состоянии ожидания до тех пор, пока другой клиент не разорвет соединение в ответ на получение команды $Quit, тем самым делая его доступным для ожидающего клиента. Возможны ситуации, когда сразу несколько новых клиентов будут одновременно пытаться создать соединение с сервером, соревнуясь между собой за право открытия доступного экземпляра; потоки, проигравшие в этой конкурентной борьбе, будут вынуждены вновь перейти в состояние ожидания.</p>
    <p>• Каждый серверный поток выполняет синхронные операции ввода/вывода, но одни из этих потоков могут обрабатывать запросы, в то время как другие — ожидать соединения или поступления клиентских запросов.</p>
    <p>• С учетом ограничений, свойственных именованным каналам, о чем говорилось ранее в этой главе, расширение программы на случай сетевых клиентов не составляет труда. Для этого достаточно заменить имена каналов в заголовочном файле или добавить параметр, указывающий имя сервера в командной строке клиента.</p>
    <p>• Каждый рабочий поток сервера создает простой поток, осуществляющий соединение, который вызывает функцию ConnectNamedPipe и завершает выполнение сразу же после подключения клиента. Это позволяет организовать ожидание дескриптора потока соединения рабочим потоком с использованием конечного интервала ожидания и периодическое тестирование глобального флага завершения работы (ShutDown). Если бы рабочие потоки блокировались при выполнении функции ConnectNamedPipe, они не могли бы тестировать этот флаг, и сервер не мог бы завершить работу. По этой причине поток сервера осуществляет вызов CreateFile, используя дескриптор именованного канала, чтобы заставить поток соединения возобновиться и завершить выполнение. Альтернативным вариантом было бы использование асинхронного ввода/вывода (глава 14), что дало бы возможность связать событие с вызовом функции ConnectNamedPipe. Другие возможные варианты реализации и дополнительная информация предоставляются в комментариях к исходному тексту программы, размещенному на Web-сайте книги. Без этого решения потоки соединения могли бы никогда не завершить работу самостоятельно, что привело бы к утечке ресурсов в DLL. Этот вопрос обсуждается в главе 12.</p>
    <p>• Существует ряд благоприятных предпосылок для усовершенствования данной системы. Например, можно предусмотреть опцию выполнения внутрипроцессного сервера (in-process server), используя библиотеку DLL, которая реализует некоторые из команд. Это усовершенствование вводится в программу в главе 12.</p>
    <p>• Количество серверных потоков ограничивается при вызове функции WaitForMultipleObjects в основном потоке. Хотя это ограничение легко преодолимо, в данном случае система не обладает истинной масштабируемостью; как было показано в главе 10, чрезмерное увеличение количества потоков может оказать отрицательное влияние на производительность. В главе 14 для решения этой проблемы используются порты асинхронного ввода/вывода.</p>
   </section>
   <section>
    <title>
     <p>Почтовые ящики</p>
    </title>
    <section>
     <p>Как и именованные каналы, почтовые ящики (mailslots) Windows снабжаются именами, которые могут быть использованы для обеспечения взаимодействия между независимыми каналами. Почтовые ящики представляют собой широковещательный механизм, основанный на дейтаграммах (описаны в главе 12), и ведут себя иначе по сравнению с именованными каналами, что делает их весьма полезными в ряде ограниченных ситуаций, которые, тем не менее, представляют большой интерес. Из наиболее важных свойств почтовых ящиков можно отметить следующие:</p>
     <p>• Почтовые ящики являются однонаправленными.</p>
     <p>• С одним почтовым ящиком могут быть связаны несколько записывающих программ (writers) и несколько считывающих программ (readers), но они часто связаны между собой отношениями "один ко многим" в той или иной форме.</p>
     <p>• Записывающей программе (клиенту) не известно достоверно, все ли, только некоторые или какая-то одна из программ считывания (сервер) получили сообщение.</p>
     <p>• Почтовые ящики могут находиться в любом месте сети.</p>
     <p>• Размер сообщений ограничен.</p>
     <p>Использование почтовых ящиков требует выполнения следующих операций:</p>
     <p>• Каждый сервер создает дескриптор почтового ящика с помощью функции CreateMailSlot.</p>
     <p>• После этого сервер ожидает получения почтового сообщения, используя функцию ReadFile.</p>
     <p>• Клиент, обладающий только правами записи, должен открыть почтовый ящик, вызвав функцию CreateFile, и записать сообщения, используя функцию WriteFile. В случае отсутствия ожидающих программ считывания попытка открытия почтового ящика завершится ошибкой (наподобие "имя не найдено").</p>
     <p>Сообщение клиента может быть прочитано <emphasis>всеми</emphasis> серверами; все серверы получают одно и то же сообщение.</p>
     <p>Существует еще одна возможность. В вызове функции CreateFile клиент может указать имя почтового ящика в следующем виде:</p>
     <p><code>\\*\mailslot\mailslotname</code></p>
     <p>При этом символ звездочки (*) действует в качестве группового символа (wildcard), и клиент может обнаружить любой сервер в пределах <emphasis>имени домена —</emphasis> группы систем, объединенных общим именем, которое назначается администратором сети. </p>
    </section>
    <section>
     <title>
      <p>Использование почтовых ящиков</p>
     </title>
     <p>Рассмотренный перед этим клиент-серверный процессор командной строки предполагает несколько возможных способов его использования. Рассмотрим один из сценариев, в котором решается задача обнаружения сервера в только что упомянутой клиент-серверной системе (программы 11.2 и 11.3).</p>
     <p><emphasis>Сервер приложения</emphasis> (application server), действуя в качестве <emphasis>почтового клиента</emphasis> (mailslot client), периодически осуществляет широковещательную рассылку своего имени и имени именованного канала. Любой <emphasis>клиент приложения</emphasis> (application client), которому требуется найти сервер, может получить это имя, действуя в качестве <emphasis>сервера почтовых ящиков</emphasis> (mailslot server). Аналогичным образом сервер командной строки может периодически осуществлять широковещательную рассылку своего состояния, включая информацию о коэффициенте использования, клиентам. Это соответствует ситуации, в которой имеется одна записывающая программа (почтовый клиент) и несколько считывающих программ (почтовых серверов). Если бы почтовых клиентов (то есть серверов приложения) было несколько, то ситуация описывалась бы отношением типа "многие ко многим".</p>
     <p>Возможен и другой вариант, когда одна считывающая программа получает сообщения от многочисленных записывающих программ, которые, например, предоставляют информацию о своем состоянии. Этот вариант, соответствующий, например, электронной доске объявлений, оправдывает использование термина <emphasis>почтовый ящик.</emphasis> Оба описанных варианта использования — широковещательная рассылка имени и информации о состоянии — могут быть объединены, чтобы клиент мог выбирать наиболее подходящий сервер.</p>
     <p>Обмен ролями терминов <emphasis>клиент</emphasis> и <emphasis>сервер</emphasis> в данном контексте может несколько сбивать с толку, однако заметьте, что сервер именованного канала и почтовый сервер выполняют вызовы функций CreateNamedPipe (или CreateMailSlot), тогда как клиент (именованного канала или почтового ящика) создает соединение, используя функцию CreateFile. Кроме того, в обоих случаях первый вызов функции WriteFile выполняется клиентом, а первый вызов функции ReadFile выполняется сервером.</p>
     <p>Использование почтовых ящиков в соответствии с первым из описанных возможных вариантов иллюстрируется на рис. 11.3.</p>
    </section>
    <section>
     <title>
      <p>Создание и открытие почтового ящика</p>
     </title>
     <p>Для создания почтового ящика и получения дескриптора, который можно будет использовать в операциях ReadFile, почтовые серверы (программы считывания) вызывают функцию CreateMailslot. На одном компьютере может находиться только один почтовый ящик с данным именем, но один и тот же почтовый ящик может использоваться несколькими системами в сети, что обеспечивает возможность работы с ним нескольких программ считывания. </p>
     <image l:href="#Any2FbImgLoader126"/>
     <p><strong>Рис. 11.3.</strong> Использование клиентами почтового ящика для обнаружения сервера</p>
     <empty-line/>
     <cite>
      <p><code>HANDLE CreateMailslot(LPCTSTR lpName, DWORD cbMaxMsg, DWORD dwReadTimeout, LPSECURITY_ATTRIBUTES lpsa) </code></p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>lpName — указатель на строку с именем почтового ящика, которое должно иметь следующий вид:</p>
     <p><code>\\.\mailslot\[путь]<emphasis>имя</emphasis></code></p>
     <p>Имя должно быть уникальным. Точка (.) указывает на то, что почтовый ящик создается на локальном компьютере.</p>
     <p>cbMaxMsg — максимальный размер сообщения (в байтах), которые может записывать клиент. Значению 0 соответствует отсутствие ограничений.</p>
     <p>dwReadTimeOut — длительность интервала ожидания (в миллисекундах) для операции чтения. Значению 0 соответствует немедленный возврат, а значению MAILSLOT_WAIT_FOREVER — неопределенный период ожидания (который может длиться сколь угодно долго). </p>
     <p>Во время открытия почтового ящика с помощью функции CreateFile клиент (записывающая программа) может указывать его имя в следующем виде:</p>
     <p>• \\ .\mailslot\ [путь]имя — определяет локальный почтовый ящик. <emphasis>Примечание.</emphasis> В Windows 95 длина имени ограничена 11 символами.</p>
     <p>• \\имя_компьютера\mailslot\[путь]имя — определяет почтовый ящик, расположенный на компьютере с заданным именем.</p>
     <p>• \\имя_домена\mailslot\[путь]имя — определяет все почтовые ящики с данным именем, расположенные на компьютерах, принадлежащих данному домену. В этом случае максимальный размер сообщения составляет 424 байта.</p>
     <p>• \\*\mailslot\[путь]имя — определяет все почтовые ящики с данным именем, расположенные на компьютерах, принадлежащих главному домену системы. В этом случае максимальный размер сообщения составляет 424 байта.</p>
     <p>Наконец, клиент должен указывать флаг FILE_SHARE_READ. Функции GetMailslotInfo и SetMailslotInfо похожи на свои аналоги, работающие с именованными каналами.</p>
     <cite>
      <p>Средства, сопоставимые с почтовыми ящиками, в UNIX отсутствуют. Однако для этой цели могут быть использованы широковещательные (broadcast) или групповые (multicast) дейтаграммы протокола TCP/IP.</p>
     </cite>
    </section>
   </section>
   <section>
    <title>
     <p>Создание, подключение и именование каналов и почтовых ящиков</p>
    </title>
    <p>В табл. 11.1 сведены все допустимые формы имен каналов, которые могут использоваться клиентами и серверами приложения. Здесь же перечислены все функции, которые следует использовать для создания именованных каналов и соединения с ними.</p>
    <p>Аналогичная информация для почтовых ящиков приведена в табл. 11.2. Вспомните, что почтовый клиент (или сервер) не обязательно должен выполняться тем же процессом или даже на той же системе, что и клиент (или сервер) приложения.</p>
    <empty-line/>
    <p>Таблица 11.1. Именованные каналы: создание, подключение и именование  </p>
    <table>
     <tr align="left">
      <th align="left" valign="top"/>
      <th align="left" valign="top">Клиент приложения</th>
      <th align="left" valign="top">Сервер приложения</th>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>Дескриптор именованного канала или соединение</strong></td>
      <td align="left" valign="top">CreateFile CallNamedPipe TransactNamedPipe</td>
      <td align="left" valign="top">CreateNamedPipe</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>Имя канала</strong></td>
      <td align="left" valign="top">\\.\имя канала (канал является локальным) \\имя системы\имя канала (канал является локальным или удаленным)</td>
      <td align="left" valign="top">\\.\имя канала (канал создается локальным)</td>
     </tr>
    </table>
    <p>Таблица 11.2. Почтовые ящики: создание, подключение и именование  </p>
    <table>
     <tr align="left">
      <th align="left" valign="top"/>
      <th align="left" valign="top">Почтовый клиент </th>
      <th align="left" valign="top">Почтовый сервер</th>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>Дескриптор почтового ящика </strong></td>
      <td align="left" valign="top">CreateFile </td>
      <td align="left" valign="top">CreateMailslot</td>
     </tr>
     <tr align="left">
      <td align="left" valign="top"><strong>Имя почтового ящика</strong></td>
      <td align="left" valign="top">\\.\имя почтового ящика (почтовый ящик является локальным) \\имя системы\имя почтового ящика (почтовый ящик располагается на указанной удаленной системе) \\*\имя почтового ящика (все почтовые ящики, имеющие одно и то же указанное имя)</td>
      <td align="left" valign="top">\\.\имя почтового ящика (почтовый ящик создается локальным)</td>
     </tr>
    </table>
   </section>
   <section>
    <title>
     <p>Пример: сервер, обнаруживаемый клиентами</p>
    </title>
    <p>Программа 11.4 представляет функцию потока, которую сервер командной строки (программа 11.3), <emphasis>выступающий в роли почтового клиента,</emphasis> использует для широковещательной рассылки имени своего канала ожидающим клиентам. Возможно существование нескольких серверов с различными характеристиками и именами каналов, и клиенты получают их имена, используя почтовый ящик с известным именем. Эта функция запускается как поток программой 11.3.</p>
    <cite>
     <p><strong>Примечание</strong></p>
     <p>На практике многие клиент-серверные системы инвертируют используемую здесь логику поиска. Суть альтернативного варианта заключается в том, что клиент приложения действует и как почтовый клиент, осуществляя широковещательную рассылку сообщений, требующих, чтобы сервер ответил с использованием указанного именованного канала (имя канала определяется клиентом и включается в сообщение). Затем сервер приложения, действующий в качестве почтового сервера, считывает запрос и создает соединение с использованием указанного именованного канала.</p>
    </cite>
    <subtitle>Программа 11.4. SrvrBcst: функция потока почтового клиента </subtitle>
    <p><code>static DWORD WINAPI ServerBroadcast(LPLONG pNull) {</code></p>
    <p><code> MS_MESSAGE MsNotify;</code></p>
    <p><code> DWORD nXfer;</code></p>
    <p><code> HANDLE hMsFile;</code></p>
    <p><code> /*Открыть почтовый ящик для записывающей программы почтового "клиента"*/</code></p>
    <p><code> while (!ShutDown) { /* Цикл выполняется до тех пор, пока имеются серверные потоки. */</code></p>
    <p><code>  /* Ждать, пока другой клиент не откроет почтовый ящик. */</code></p>
    <p><code>  Sleep(CS_TIMEOUT);</code></p>
    <p><code>  hMsFile = CreateFile(MS_CLTNAME, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN EXISTING, FILE ATTRIBUTE NORMAL, NULL); </code></p>
    <p><code>  if (hMsFile == INVALID_HANDLE_VALUE) continue;</code></p>
    <p><code>  /* Отправить сообщение в почтовый ящик. */</code></p>
    <p><code>  MsNotify.msStatus = 0;</code></p>
    <p><code>  MsNotify.msUtilization = 0;</code></p>
    <p><code>  _tcscpy(MsNotify.msName, SERVER_PIPE);</code></p>
    <p><code>  if (WriteFile(hMsFile, &amp;MsNotify, MSM_SIZE, &amp;nXfer, NULL)) ReportError(_T("Ошибка записи почтового сервера."), 13, TRUE);</code></p>
    <p><code>  CloseHandle(hMsFile);</code></p>
    <p><code> }</code></p>
    <p><code> _tprintf(_T("Закрытие контролирующего потока.\n"));</code></p>
    <p><code> _endthreadex(0);</code></p>
    <p><code> return 0; </code></p>
    <p><code>}</code> </p>
    <p>В программе 11.5 представлена функция, которая вызывается клиентом (см. программу 11.2) для обнаружения сервера.</p>
    <subtitle>Программа 11.5. LocSrvr: почтовый сервер </subtitle>
    <p><code>/* Глава 11. LocSrver.c */</code></p>
    <p><code>/* Найти сервер путем считывания информации из почтового ящика, используемого для широковещательной рассылки имен серверов. */</code></p>
    <empty-line/>
    <p><code>#include "EvryThng.h"</code></p>
    <p><code>#include "ClntSrvr.h" /* Определяет имя почтового ящика. */</code></p>
    <empty-line/>
    <p><code>BOOL LocateServer(LPTSTR pPipeName) {</code></p>
    <p><code> HANDLE MsFile;</code></p>
    <p><code> MS_MESSAGE ServerMsg;</code></p>
    <p><code> BOOL Found = FALSE;</code></p>
    <p><code> DWORD cbRead;</code></p>
    <p><code> MsFile = CreateMailslot(MS_SRVNAME, 0, CS_TIMEOUT, NULL);</code></p>
    <p><code> while (!Found) {</code></p>
    <p><code>  _tprintf(_T("Поиск сервера.\n"));</code></p>
    <p><code>  Found = ReadFile(MsFile, &amp;ServerMsg, MSM_SIZE, &amp;cbRead, NULL);</code></p>
    <p><code> }</code></p>
    <p><code> _tprintf(_T("Сервер найден.\n"));</code></p>
    <p><code> CloseHandle(MsFile);</code></p>
    <p><code> /* Имя канала сервера. */</code></p>
    <p><code> _tcscpy(pPipeName, ServerMsg.msName);</code></p>
    <p><code> return TRUE;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>Комментарии по поводу многопоточных моделей</p>
    </title>
    <p>Для описания методов проектирования многопоточных программ используются такие термины, как <emphasis>пул потоков</emphasis> (thread pool), <emphasis>симметричные потоки</emphasis> (symmetric threads) и <emphasis>асимметричная потоковая организация программ</emphasis> (asymmetric threading), а мы при создании примеров использовали модель "хозяин/рабочий", именованные каналы и другие классические модели организации многопоточного выполнения программ.</p>
    <p>В этом разделе дано краткое объяснение некоторых полезных описательных терминов, которые являются неотъемлемой частью объектно-ориентированной технологии, основанной на разработанной компанией Microsoft модели компонентных объектов (Component Object Model, СОМ; см. [3]): однопоточная модель (single threading), модель апартаментных потоков (apartment model) и модель свободных потоков (free threading). В СОМ эти модели реализуются за счет использования функций Windows, предназначенных для управления потоками и синхронизации их выполнения. Каждая из перечисленных моделей обладает отличными от других характеристиками производительности и предъявляет свои требования к синхронизации.</p>
    <p>• Пул потоков — это совокупность потоков, доступных для использования по мере необходимости. С помощью рис. 7.1 и программы 11.3 иллюстрируется пул потоков, которые могут назначаться новым клиентам, подключающимся к соответствующему именованному каналу. При отсоединении клиента поток возвращается в пул.</p>
    <p>• Потоковая модель является симметричной, если группа потоков выполняют одну и ту же задачу с использованием одной и той же функции потока. Симметричные потоки используются в программе grepMT (программа 7.1): все потоки выполняют один и тот же код поиска шаблона. Обратите внимание, что эти потоки не образуют пула; каждый из них создается для выполнения определенной задачи и завершается сразу же после того, как задача выполнена. Пул симметричных потоков создается в программе 11.3.</p>
    <p>• Потоковая модель является асимметричной, если различные потоки выполняют различные задачи с использованием различных функций потока. Так, функция потока широковещательной рассылки сообщений, представленная на рис. 7.1 и реализованная в программе 11.4, и функция сервера соответствуют модели асимметричных потоков.</p>
    <p>• В соответствии с терминологией СОМ объект является однопоточным, если доступ к нему может получать только один поток. Это означает, что доступ к такому объекту сериализуется. В случае сервера базы данных таким объектом будет сама база данных. В примерах, приведенных в настоящей главе, многопоточная модель используется для организации доступа к объекту, в качестве которого могут рассматриваться программы и файлы, расположенные на компьютере сервера. </p>
    <p>• В соответствии с терминологией СОМ об апартаментной модели следует говорить тогда, когда для каждого экземпляра объекта назначается отдельный поток. Так, отдельные потоки могут назначаться для осуществления доступа к разным базам данных или частям базы данных. Доступ к объекту сериализуется с помощью единственного потока.</p>
    <p>• Объект, соответствующий модели свободных потоков, имеет поток, который обычно назначается ему из пула потоков по запросу. Обсуждавшийся в настоящей главе сервер можно считать сервером со свободными потоками, если соединение рассматривать как запрос. Аналогично, если сервер базы данных поддерживается потоками, то можно говорить о том, что база данных соответствует модели свободных потоков.</p>
    <p>Некоторые программы, например sortMT (программа 7.2), в рамки ни одной из перечисленных моделей точно не укладываются. Вспомните также, что нами уже использовались и другие модели, а именно, модель "хозяин/рабочий", именованные каналы и клиент-серверные модели, применение которых является общепринятым, однако не находит отражения в моделях Microsoft.</p>
    <p>Применение указанных моделей многопоточного программирования оказывается уместным и в главе 12, в которой вводятся внутрипроцессные серверы, и компания Microsoft использует соответствующие термины в некоторой части своей документации. Не забывайте о том, что эти термины определены применительно к СОМ-объектам; предыдущее обсуждение показало, как использовать их в более широком контексте. СОМ — это слишком большой и сложный предмет, чтобы мы могли полностью описать его в данной книге. В списке литературы, приведены некоторые ссылки, которыми вы можете воспользоваться для получения более подробных сведений по этому вопросу.</p>
   </section>
   <section>
    <title>
     <p>Резюме</p>
    </title>
    <section>
     <p>Каналы и почтовые ящики Windows, доступ к которым осуществляется с помощью операций файлового ввода/вывода, обеспечивают поточное межпроцессное и сетевое взаимодействие. В примерах продемонстрировано, как организовать передачу данных из одного процесса в другой при помощи каналов и как построить простую многопоточную клиент-серверную систему. Кроме того, каналы обеспечивают дополнительную возможность синхронизации потоков, поскольку считывающий поток блокируется до тех пор, пока другой поток не выполнит запись в канал.</p>
    </section>
    <section>
     <title>
      <p>В следующих главах</p>
     </title>
     <p>В главе 12 для осуществления межпроцессного и сетевого взаимодействия вместо оригинальных механизмов Windows привлечены стандартные механизмы. Прежний вариант клиент-серверной системы переработан с использованием стандартных методов и дополнительно усовершенствован за счет некоторого улучшения серверной части.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Упражнения</p>
    </title>
    <p>11.1. Проведите эксперименты с целью проверки справедливости приведенных ранее утверждений относительно повышения производительности, обеспечиваемого использованием функции TransactNamedPipe. Для этого вам придется внести в существующий код сервера некоторые изменения. Кроме того, сопоставьте полученные результаты с теми, к которым приводит текущая реализация.</p>
    <p>11.2. Воспользуйтесь программой JobShell из главы 6 для запуска сервера и нескольких клиентов, причем каждый из клиентов должен создаваться в режиме "отсоединения". Для завершения работы остановите сервер путем посылки управляющего сигнала консоли с помощью команды kill. Имеются ли у вас какие-либо соображения по поводу улучшения логики закрытия программы serverNP, чтобы подключенный серверный поток мог проверять флаг завершения работы, будучи блокированным в ожидании запроса клиента? <emphasis>Подсказка.</emphasis> Создайте считывающий поток, аналогичный потоку соединения.</p>
    <p>11.3. Усовершенствуйте сервер таким образом, чтобы имя его канала задавалось в виде аргумента в командной строке. Организуйте несколько серверных процессов с различными именами каналов, используя программу управления заданиями из главы 6. Убедитесь в том, что одновременно несколько клиентов получают доступ к этой многопроцессной серверной системе.</p>
    <p>11.4. Запустите клиент и сервер на различных системах, чтобы проверить их работу в условиях сети. Измените программу SrvrBcst (программа 11.4) таким образом, чтобы она включала имя компьютера сервера в имя канала. Кроме того, видоизмените имя почтового ящика, используемого в программе 11.4.</p>
    <p>11.5. Модифицируйте сервер таким образом, чтобы можно было измерить степень его загрузки (иными словами, чтобы можно было определить, какая доля использованного времени приходится на сервер). Организуйте накопление данных, касающихся производительности, и передачу этой информации клиенту в ответ на его запрос. Для этой цели можно использовать поле Request.Command.</p>
    <p>11.6. Усовершенствуйте программы, предназначенные для обнаружения сервера, таким образом, чтобы поиск сервера клиентом осуществлялся с наименьшей степенью загрузки.</p>
    <p>11.7. Усовершенствуйте сервер таким образом, чтобы запрос включал в себя рабочий каталог. Сервер должен устанавливать свой рабочий каталог, выполнять команду, а затем восстанавливать рабочий каталог до прежнего значения. <emphasis>Предостережение.</emphasis> Серверный поток не должен устанавливать рабочий каталог процесса; вместо этого каждый поток должен поддерживать строку, представляющую его рабочий каталог, и присоединять эту строку в начало соответствующих путей доступа. </p>
    <p>11.8. Программа serverNP спроектирована таким образом, что она выполняется как сервер в течение неопределенного времени, давая клиентам возможность подключаться, получать услуги и разрывать соединение. Очень важно, чтобы при отключении клиента сервер освобождал все соответствующие ресурсы, например, память, дескрипторы файлов или потоков. Если это не делается, то в результате утечки ресурсов системные ресурсы, в конце концов, исчерпаются, что приведет аварийному завершению работы сервера с возможным предшествующим ухудшением показателей производительности. Тщательно проверьте код программы serverNP, чтобы убедиться в отсутствии утечки ресурсов, и в случае необходимости внесите необходимые исправления. (Просьба информировать автора обо всех обнаруженных ошибках, используя указанный в предисловии адрес электронной почты.) <emphasis>Примечание.</emphasis> Утечка ресурсов является весьма распространенным серьезным дефектом многих промышленных систем. Никакие попытки вывода изделия на уровень "промышленных стандартов" нельзя считать успешными, если указанной проблеме не было уделено должного внимания.</p>
    <p>11.9. <emphasis>Расширенное упражнение.</emphasis> Объекты синхронизации могут использоваться для синхронизации потоков, выполняющихся в различных процессах на одной и той же машине, но с их помощью нельзя синхронизировать потоки процессов, которые выполняются на разных машинах. Используя именованные каналы и почтовые ящики, создайте эмулированные мьютексы, события и семафоры, чтобы преодолеть это ограничение. </p>
   </section>
  </section>
  <section>
   <title>
    <p>ГЛАВА 12</p>
    <p>Сетевое программирование с помощью сокетов Windows</p>
   </title>
   <section>
    <p>Именованные каналы пригодны для организации межпроцессного взаимодействия как в случае процессов, выполняющихся на одной и той же системе, так и в случае процессов, выполняющихся на компьютерах, связанных друг с другом локальной или глобальной сетью. Эти возможности были продемонстрированы на примере клиент-серверной системы, разработанной в главе 11, начиная с программы 11.2.</p>
    <p>Однако как именованные каналы, так и почтовые ящики (в отношении которых для простоты мы будем использовать далее общий термин — "именованные каналы", если различия между ними не будут играть существенной роли) обладают тем недостатком, что они не являются промышленным стандартом. Это обстоятельство усложняет перенос программ наподобие тех, которые рассматривались в главе 11, в системы, не принадлежащие семейству Windows, хотя именованные каналы не зависят от протоколов и могут выполняться поверх многих стандартных промышленных протоколов, например TCP/IP.</p>
    <p>Возможность взаимодействия с другими системами обеспечивается в Windows поддержкой сокетов (sockets) Windows Sockets — совместимого и почти точного аналога сокетов Berkeley Sockets, де-факто играющих роль промышленного стандарта. В этой главе использование API Windows Sockets (или "Winsock") показано на примере модифицированной клиент-серверной системы из главы 11. Результирующая система способна функционировать в глобальных сетях, использующих протокол TCP/IP, что, например, позволяет серверу принимать запросы от клиентов UNIX или каких-либо других, отличных от Windows систем.</p>
    <p><emphasis>Читатели, знакомые с интерфейсом Berkeley Sockets, при желании могут сразу же перейти непосредственно к рассмотрению примеров, в которых не только используются сокеты, но также вводятся новые возможности сервера и демонстрируются дополнительные методы работы с библиотеками, обеспечивающими безопасную многопоточную поддержку.</emphasis></p>
    <p>Привлекая средства обеспечения взаимодействия между разнородными системами, ориентированные на стандарты, интерфейс Winsock открывает перед программистами возможность доступа к высокоуровневым протоколам и приложениям, таким как ftp, http, RPC и СОМ, которые в совокупности предоставляют богатый набор высокоуровневых моделей, обеспечивающих поддержку межпроцессного сетевого взаимодействия для систем с различной архитектурой.</p>
    <p>В данной главе указанная клиент-серверная система используется в качестве механизма демонстрации интерфейса Winsock, и в процессе того, как сервер будет модифицироваться, в него будут добавляться новые интересные возможности. В частности, нами будут впервые использованы <emphasis>точки входа DLL</emphasis> (глава 5) и <emphasis>внутрипроцессные серверы DLL.</emphasis> (Эти новые средства можно было включить уже в первоначальную версию программы в главе 11, однако это отвлекло бы ваше внимание от разработки основной архитектуры системы.) Наконец, дополнительные примеры покажут вам, как создаются безопасные реентерабельные многопоточные библиотеки.</p>
    <p>Поскольку интерфейс Winsock должен соответствовать промышленным стандартам, принятые в нем соглашения о правилах присвоения имен и стилях программирования несколько отличаются от тех, с которыми мы сталкивались в процессе работы с описанными ранее функциями Windows. Строго говоря, Winsock API не является частью Win32/64. Кроме того, Winsock предоставляет дополнительные функции, не подчиняющиеся стандартам; эти функции используются лишь в случае крайней необходимости. Среди других преимуществ, обеспечиваемых Winsock, следует отметить улучшенную переносимость результирующих программ на другие системы.</p>
   </section>
   <section>
    <title>
     <p>Сокеты Windows</p>
    </title>
    <section>
     <p>Winsock API разрабатывался как расширение Berkley Sockets API для среды Windows и поэтому поддерживается всеми системами Windows. К преимуществам Winsock можно отнести следующее:</p>
     <p>• Перенос уже имеющегося кода, написанного для Berkeley Sockets API, осуществляется непосредственно.</p>
     <p>• Системы Windows легко встраиваются в сети, использующие как версию IPv4 протокола TCP/IP, так и постепенно распространяющуюся версию IPv6. Помимо всего остального, версия IPv6 допускает использование более длинных IP-адресов, преодолевая существующий 4-байтовый адресный барьер версии IPv4.</p>
     <p>• Сокеты могут использоваться совместно с перекрывающимся вводом/выводом Windows (глава 14), что, помимо всего прочего, обеспечивает возможность масштабирования серверов при увеличении количества активных клиентов.</p>
     <p>• Сокеты можно рассматривать как дескрипторы (типа HANDLE) файлов при использовании функций ReadFile и WriteFile и, с некоторыми ограничениями, при использовании других функций, точно так же, как в качестве дескрипторов файлов сокеты применяются в UNIX. Эта возможность оказывается удобной в тех случаях, когда требуется использование асинхронного ввода/вывода и портов завершения ввода/вывода.</p>
     <p>• Существуют также дополнительные, непереносимые расширения.</p>
    </section>
    <section>
     <title>
      <p>Инициализация Winsock</p>
     </title>
     <p>Winsock API поддерживается библиотекой DLL (WS2_32.DLL), для получения доступа к которой следует подключить к программе библиотеку WS_232.LIB. Эту DLL следует инициализировать с помощью нестандартной, специфической для Winsock функции WSAStartup, которая должна быть первой из функций Winsock, вызываемых программой. Когда необходимость в использовании функциональных возможностей Winsock отпадает, следует вызывать функцию WSACleanup. <emphasis>Примечание.</emphasis> Префикс WSA означает "Windows Sockets asynchronous …" ("Асинхронный Windows Sockets …"). Средства асинхронного режима Winsock нами здесь не используются, поскольку при возникновении необходимости в выполнении асинхронных операций мы можем и будем использовать потоки.</p>
     <p>Хотя функции WSAStartup и WSACleanup необходимо вызывать в обязательном порядке, вполне возможно, что они будут единственными нестандартными функциями, с которыми вам придется иметь дело. Распространенной практикой является применение директив препроцессора #ifdef для проверки значения символической константы _WIN32 (обычно определяется Visual C++ на стадии компиляции), в результате чего функции WSA будут вызываться только тогда, когда вы работаете в Windows). Разумеется, такой подход предполагает, что остальная часть кода не зависит от платформы.</p>
     <cite>
      <p><code>int WSAStartup(WORD wVersionRequired, LPWSADATA ipWSAData);</code></p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>wVersionRequired — указывает старший номер версии библиотеки DLL, который вам требуется и который вы можете использовать. Как правило, версии 1.1 вполне достаточно для того, чтобы обеспечить любое взаимодействие с другими системами, в котором у вас может возникнуть необходимость. Тем не менее, во всех системах Windows, включая Windows 9x, доступна версия Winsock 2.0, которая и используется в приведенных ниже примерах. Версия 1.1 считается устаревшей и постепенно выходит из употребления. </p>
     <p>Функция возвращает ненулевое значение, если запрошенная вами версия данной DLL не поддерживается.</p>
     <p>Младший байт параметра wVersionRequired указывает основной номер версии, а старший байт — дополнительный. Обычно используют макрос MAKEWORD; таким образом, выражение MAKEWORD (2,0) представляет версию 2.0.</p>
     <p>ipWSAData — указатель на структуру WSADATA, которая возвращает информацию о конфигурации DLL, включая старший доступный номер версии. О том, как интерпретировать ее содержимое, вы можете прочитать в материалах оперативной справки Visual Studio.</p>
     <p>Чтобы получить более подробную информацию об ошибках, можно воспользоваться функцией WSAGetLastError, но для этой цели подходит также функция GetLastError, а также функция ReportError, разработанная в главе 2.</p>
     <p>По окончании работы программы, а также в тех случаях, когда необходимости в использовании сокетов больше нет, следует вызывать функцию WSACleanup, чтобы библиотека WS_32.DLL, обслуживающая сокеты, могла освободить ресурсы, распределенные для этого процесса.</p>
    </section>
    <section>
     <title>
      <p>Создание сокета</p>
     </title>
     <p>Инициализировав Winsock DLL, вы можете использовать стандартные (Berkeley Sockets) функции для создания сокетов и соединений, обеспечивающих взаимодействие серверов с клиентами или взаимодействие равноправных узлов сети между собой.</p>
     <p>Используемый в Winsock тип данных SOCKET аналогичен типу данных HANDLE в Windows, и его даже можно применять совместно с функцией ReadFile и другими функциями Windows, требующими использования дескрипторов типа HANDLE. Для создания (или открытия) сокета служит функция socket. </p>
     <cite>
      <p><code>SOCKET socket(int af, int type, int protocol);</code> </p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>Тип данных SOCKET фактически определяется как тип данных int, потому код UNIX остается переносимым, не требуя привлечения типов данных Windows.</p>
     <p>af — обозначает семейство адресов, или протокол; для указания протокола IP (компонент протокола TCP/IP, отвечающий за протокол Internet) следует использовать значение PF_INET (или AF_INET, которое имеет то же самое числовое значение, но обычно используется при вызове функции bind).</p>
     <p>type — указывает тип взаимодействия: ориентированное на установку соединения (connection-oriented communication), или потоковое (SOCK_STREAM), и дейтаграммное (datagram communication) (SOCK_DGRAM), что в определенной степени сопоставимо соответственно с именованными каналами и почтовыми ящиками. </p>
     <p>protocol — является излишним, если параметр af установлен равным AF_INET; используйте значение 0.</p>
     <p>В случае неудачного завершения функция socket возвращает значение INVALID_SOCKET.</p>
     <p>Winsock можно использовать совместно с протоколами, отличными от TCP/IP, указывая различные значения параметра protocol; мы же будем использовать только протокол TCP/IP.</p>
     <p>Как и в случае всех остальных стандартных функций, имя функции socket не должно содержать прописных букв. Это является отходом от соглашений, принятых в Windows, и продиктовано необходимостью соблюдения промышленных стандартов.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Серверные функции сокета</p>
    </title>
    <section>
     <p>В нижеследующем обсуждении под <emphasis>сервером</emphasis> будет пониматься процесс, который принимает запросы на образование соединения через заданный порт. Несмотря на то что сокеты, подобно именованным каналам, могут использоваться для создания соединений между равноправными узлами сети, введение указанного различия между узлами является весьма удобным и отражает различия в способах, используемых обеими системами для соединения друг с другом.</p>
     <p>Если не оговорено иное, типом сокетов в наших примерах всегда будет SOCK_STREAM. Сокеты типа SOCK_DGRAM рассматривается далее в этой главе.</p>
    </section>
    <section>
     <title>
      <p>Связывание сокета</p>
     </title>
     <p>Следующий шаг заключается в привязке сокета к его адресу и <emphasis>конечной точке</emphasis> (endpoint) (направление канала связи от приложения к службе). Вызов socket, за которым следует вызов bind, аналогичен созданию именованного канала. Однако не существует имен, используя которые можно было бы различать сокеты данного компьютера. Вместо этого в качестве конечной точки службы используется <emphasis>номер порта</emphasis> (port number). Любой заданный сервер может иметь несколько конечных точек. Прототип функции bind приводится ниже. </p>
     <cite>
      <p><code>int bind(SOCKET s, const struct sockaddr *saddr, int namelen);</code></p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>s — несвязанный сокет, возвращенный функцией socket.</p>
     <p>saddr — заполняется перед вызовом и задает протокол и специфическую для протокола информацию, как описано ниже. Кроме всего прочего, в этой структуре содержится номер порта. </p>
     <p>namelen — присвойте значение sizeof (sockaddr).</p>
     <p>В случае успешного выполнения функция возвращает значение 0, иначе SOCKET_ERROR. Структура sockaddr определяется следующим образом: </p>
     <cite>
      <p><code>struct sockaddr {</code></p>
      <p><code> u_short sa_family;</code></p>
      <p><code> char sa_data[14] ;</code></p>
      <p><code>}; </code></p>
      <p><code>typedef struct sockaddr SOCKADDR, *PSOCKADDR;</code> </p>
     </cite>
     <p>Первый член этой структуры, sa_family, обозначает протокол. Второй член, sa_data, зависит от протокола. Internet-версией структуры sa_data является структура sockaddr_in: </p>
     <cite>
      <p><code>struct sockaddr_in {</code></p>
      <p><code> short sin_family; /* AF_INET */</code></p>
      <p><code> u_short sin_port;</code></p>
      <p><code> struct in_addr sin_addr; /* 4-байтовый IP-адрес */</code></p>
      <p><code> char sin_zero[8]; </code></p>
      <p><code>};</code></p>
      <p><code>typedef struct sockaddr_in SOCKADDR_IN, *PSOCKADDR IN;</code> </p>
     </cite>
     <p>Обратите внимание на использование типа данных short integer для номера порта. Кроме того, номер порта и иная информация должны храниться с соблюдением подходящего порядка следования байтов, при котором старший байт помещается в крайней позиции справа (big-endian), чтобы обеспечивалась двоичная совместимость с другими системами. В структуре sin_addr содержится подструктура s_addr, заполняемая уже знакомым нам 4-байтовым IP-адресом, например 127.0.0.1, указывающим систему, чей запрос на образование соединения должен быть принят. Обычно удовлетворяются запросы любых систем, в связи с чем следует использовать значение INADDR_ANY, хотя этот символический параметр должен быть преобразован к корректному формату, как показано в приведенном ниже фрагменте кода.</p>
     <p>Для преобразования текстовой строки с IP-адресом к требуемому формату можно использовать функцию inet_addr, поэтому член sin_addr.s_addr переменной sockaddr_in инициализируется следующим образом:</p>
     <p><code>sa.sin_addr.s_addr = inet_addr("192 .13.12.1");</code></p>
     <p>О связанном сокете, для которого определены протокол, номер порта и IP-адрес, иногда говорят как об <emphasis>именованном сокете</emphasis> (named socket). </p>
    </section>
    <section>
     <title>
      <p>Перевод связанного сокета в состояние прослушивания</p>
     </title>
     <p>Функция listen делает сервер доступным для образования соединения с клиентом. Аналогичной функции для именованных каналов не существует. </p>
     <cite>
      <p><code>int listen(SOCKET s, int nQueueSize);</code> </p>
     </cite>
     <p>Параметр nQueueSize указывает число запросов на соединение, которые вы намерены помещать в очередь сокета. В версии Winsock 2.0 значение этого параметра не имеет ограничения сверху, но в версии 1.1 оно ограничено предельным значением SOMAXCON (равным 5).</p>
    </section>
    <section>
     <title>
      <p>Прием клиентских запросов соединения</p>
     </title>
     <p>Наконец, сервер может ожидать соединения с клиентом, используя функцию accept, возвращающую новый подключенный сокет, который будет использоваться в операциях ввода/вывода. Заметьте, что исходный сокет, который теперь находится в состоянии прослушивания (listening state), используется исключительно в качестве параметра функции accept, а не для непосредственного участия в операциях ввода/вывода.</p>
     <p>Функция accept блокируется до тех пор, пока от клиента не поступит запрос соединения, после чего она возвращает новый сокет ввода/вывода. Хотя рассмотрение этого и выходит за рамки данной книги, возможно создание неблокирующихся сокетов, а в сервере (программа 12.2) для приема запроса используется отдельный поток, что позволяет создавать также неблокирующиеся серверы. </p>
     <cite>
      <p><code>SOCKET accept(SOCKET s, LPSOCKADDR lpAddr, LPINT lpAddrLen);</code> </p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>s — прослушивающий сокет. Чтобы перевести сокет в состояние прослушивания, необходимо предварительно вызвать функции socket, bind и listen.</p>
     <p>lpAddr — указатель на структуру sockaddr_in, предоставляющую адрес клиентской системы.</p>
     <p>lpAddrLen — указатель на переменную, которая будет содержать размер возвращенной структуры sockaddr_in. Перед вызовом функции accept эта переменная должна быть инициализирована значением sizeof(struct sockaddr_in). </p>
    </section>
    <section>
     <title>
      <p>Отключение и закрытие сокетов</p>
     </title>
     <p>Для отключения сокетов применяется функция shutdown(s, how). Аргумент how может принимать одно из двух значений: 1, указывающее на то, что соединение может быть разорвано только для посылки сообщений, и 2, соответствующее разрыву соединения как для посылки, так и для приема сообщений. Функция shutdown не освобождает ресурсы, связанные с сокетом, но гарантирует завершение посылки и приема всех данных до закрытия сокета. Тем не менее, после вызова функции shutdown приложение уже не должно использовать этот сокет.</p>
     <p>Когда работа с сокетом закончена, его следует закрыть, вызвав функцию closesocket(SOCKET s). Сначала сервер закрывает сокет, созданный функцией accept, а не прослушивающий сокет, созданный с помощью функции socket. Сервер должен закрывать прослушивающий сокет только тогда, когда завершает работу или прекращает принимать клиентские запросы соединения. Даже если вы работаете с сокетом как с дескриптором типа HANDLE и используете функции ReadFile и WriteFile, уничтожить сокет одним только вызовом функции CloseHandle вам не удастся; для этого следует использовать функцию closesocket.</p>
    </section>
    <section>
     <title>
      <p>Пример: подготовка и получение клиентских запросов соединения</p>
     </title>
     <p>Ниже приводится фрагмент кода, показывающий, как создать сокет и организовать прием клиентских запросов соединения.</p>
     <p>В этом примере используются две стандартные функции: htons ("host to network short" — "ближняя связь") и htonl ("host to network long" — "дальняя связь"), которые преобразуют целые числа к форме с обратным порядком байтов, требуемой протоколом IP.</p>
     <p>Номером порта сервера может быть любое число из диапазона, допустимого для целых чисел типа short integer, но для определенных пользователем служб обычно используются числа в диапазоне 1025—5000. Порты с меньшими номерами зарезервированы для таких известных служб, как telnet или ftp, в то время как порты с большими номерами предполагаются для использования других стандартных служб.</p>
     <p><code>struct sockaddr_in SrvSAddr; /* Адресная структура сервера. */</code></p>
     <p><code>struct sockaddr_in ConnectAddr; </code></p>
     <p><code>SOCKET SrvSock, sockio;</code></p>
     <p><code>…</code></p>
     <p><code>SrvSock = socket(AF_INET, SOCK_STREAM, 0);</code></p>
     <p><code>SrvSAddr.sin_family = AF_INET; </code></p>
     <p><code>SrvSAddr.sin_addr.s_addr = htonl(INADDR_ANY); </code></p>
     <p><code>SrvSAddr.sin_port = htons(SERVER_PORT); </code></p>
     <p><code>bind(SrvSock, (struct sockaddr *)&amp;SrvSAddr, sizeof SrvSAddr); </code></p>
     <p><code>listen(SrvSock, 5); </code></p>
     <p><code>AddrLen = sizeof(ConnectAddr); </code></p>
     <p><code>sockio = accept(SrvSock, (struct sockaddr *) &amp;ConnectAddr, &amp;AddrLen); </code></p>
     <p><code>… Получение запросов и отправка ответов … </code></p>
     <p><code>shutdown(sockio); </code></p>
     <p><code>closesocket(sockio);</code></p>
    </section>
   </section>
   <section>
    <title>
     <p>Клиентские функции сокета</p>
    </title>
    <section>
     <p>Клиентская станция, которая желает установить соединение с сервером, также должна создать сокет, вызвав функцию socket. Следующий шаг заключается в установке соединения сервером, а, кроме того, необходимо указать номер порта, адрес хоста и другую информацию. Имеется только одна дополнительная функция – connect.</p>
    </section>
    <section>
     <title>
      <p>Установление клиентского соединения с сервером</p>
     </title>
     <p>Если имеется сервер с сокетом в режиме прослушивания, клиент может соединиться с ним при помощи функции connect. </p>
     <cite>
      <p><code>int connect(SOCKET s, LPSOCKADDR lpName, int nNameLen);</code> </p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>s — сокет, созданный с использованием функции socket.</p>
     <p>lpName — указатель на структуру sockaddr_in, инициализированную значениями номера порта и IP-адреса системы с сокетом, связанным с указанным портом, который находится в состоянии прослушивания.</p>
     <p>Инициализируйте nNameLen значением sizeof (struct sockaddr_in).</p>
     <p>Возвращаемое значение 0 указывает на успешное завершение функции, тогда как значение SOCKET_ERROR указывает на ошибку, которая, в частности, может быть обусловлена отсутствием прослушивающего сокета по указанному адресу.</p>
     <p>Сокет s не обязательно должен быть связанным с портом до вызова функции connect, хотя это и может иметь место. При необходимости система распределяет порт и определяет протокол.</p>
    </section>
    <section>
     <title>
      <p>Пример: подключение клиента к серверу</p>
     </title>
     <p>Показанный ниже фрагмент кода обеспечивает соединение клиента с сервером. Для этого нужны только два вызова функций, но адресная структура должна быть инициализирована до вызова функции connect. Проверка возможных ошибок здесь отсутствует, но в реальные программы она должна включаться. В примере предполагается, что IP-адрес (текстовая строка наподобие "192.76.33.4") задается в аргументе argv[1] командной строки.</p>
     <p><code>SOCKET ClientSock;</code></p>
     <p><code>…</code></p>
     <p><code>ClientSock = socket(AF_INET, SOCK_STREAM, 0); </code></p>
     <p><code>memset(&amp;ClientSAddr, 0, sizeof(ClientSAddr)); </code></p>
     <p><code>ClientSAddr.sin_family = AF_INET; </code></p>
     <p><code>ClientSAddr.sin_addr.s_addr = inet_addr(argv[1]); </code></p>
     <p><code>ClientSAddr.sin_port = htons(SERVER_PORT); </code></p>
     <p><code>ConVal = connect(ClientSock, (struct sockaddr *)&amp;ClientSAddr, sizeof(ClientSAddr));</code></p>
    </section>
    <section>
     <title>
      <p>Отправка и получение данных</p>
     </title>
     <p>Программы, использующие сокеты, обмениваются данными с помощью функций send и recv, прототипы которых почти совпадают (перед указателем буфера функции send помещается модификатор const). Ниже представлен только прототип функции send. </p>
     <cite>
      <p><code>int send(SOCKET s, const char * lpBuffer, int nBufferLen, int nFlags); </code></p>
     </cite>
     <p>Возвращаемым значением является число фактически переданных байтов. Значение SOCKET_ERROR указывает на ошибку.</p>
     <p>nFlags — может использоваться для обозначения степени срочности сообщений (например, экстренных сообщений), а значение MSG_PEEK позволяет просматривать получаемые данные без их считывания.</p>
     <p>Самое главное, что вы должны запомнить — это то, что функции send и recv <emphasis>не являются атомарными</emphasis> (atomic), и поэтому нет никакой гарантии, что затребованные данные будут действительно отправлены или получены. Передача "коротких" сообщений ("short sends") встречается крайне редко, хотя и возможна, что справедливо и по отношению к приему "коротких" сообщений ("short receives"). Понятие сообщения в том смысле, который оно имело в случае именованных каналов, здесь отсутствует, и поэтому вы должны проверять возвращаемое значение и повторно отправлять или принимать данные до тех пор, пока все они не будут переданы.</p>
     <p>С сокетами могут использоваться также функции ReadFile и WriteFile, только в этом случае при вызове функции необходимо привести сокет к типу HANDLE. </p>
    </section>
   </section>
   <section>
    <title>
     <p>Сравнение именованных каналов и сокетов</p>
    </title>
    <section>
     <p>Именованные каналы, описанные в главе 11, очень похожи на сокеты, но в способах их использования имеются значительные различия.</p>
     <p>• Именованные каналы могут быть ориентированными на работу с сообщениями, что значительно упрощает программы.</p>
     <p>• Именованные каналы требуют использования функций ReadFile и WriteFile, в то время как сокеты могут обращаться также к функциям send и recv.</p>
     <p>• В отличие от именованных каналов сокеты настолько гибки, что предоставляют пользователям возможность выбрать протокол для использования с сокетом, например, TCP или UDP. Кроме того, пользователь имеет возможность выбирать протокол на основании характера предоставляемой услуги или иных факторов.</p>
     <p>• Сокеты основаны на промышленном стандарте, что обеспечивает их совместимость с системами, отличными от Windows.</p>
     <p>Имеются также различия в моделях программирования сервера и клиента.</p>
    </section>
    <section>
     <title>
      <p>Сравнение серверов именованных каналов и сокетов</p>
     </title>
     <p>Установка соединения с несколькими клиентами при использовании сокетов требует выполнения повторных вызовов функции accept. Каждый из вызовов возвращает очередной подключенный сокет. По сравнению с именованными каналами имеются следующие отличия:</p>
     <p>• В случае именованных каналов требуется, чтобы каждый экземпляр именованного канала и дескриптор типа HANDLE создавались с помощью функции CreateNamedPipe, тогда как для создания экземпляров сокетов применяется функция accept.</p>
     <p>• Допустимое количество клиентских сокетов ничем не ограничено (функция listen ограничивает лишь количество клиентов, помещаемых в очередь), в то время как количество экземпляров именованных каналов, в зависимости от того, что было указано при первом вызове функции CreateNamedPipe, может быть ограниченным.</p>
     <p>• Не существует вспомогательных функций для работы с сокетами, аналогичных функции TransactNamedPipe.</p>
     <p>• Именованные каналы не имеют портов с явно заданными номерами и различаются по именам. </p>
     <p>В случае сервера именованных каналов получение пригодного для работы дескриптора типа HANDLE требует вызова двух функций (CreateNamedPipe и ConnectNamedPipe), тогда как сервер сокета требует вызова четырех функций (socket, bind, listen и accept).</p>
    </section>
    <section>
     <title>
      <p>Сравнение клиентов именованных каналов и сокетов</p>
     </title>
     <p>В случае именованных каналов необходимо последовательно вызывать функции WaitNamedPipe и CreateFile. Если же используются сокеты, этот порядок вызовов обращается, поскольку можно считать, что функция socket создает сокет, а функция connect — блокирует.</p>
     <p>Дополнительное отличие состоит в том, что функция connect является функцией клиента сокета, в то время как функция ConnectNamedPipe используется сервером именованного канала.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: функция приема сообщений в случае сокета</p>
    </title>
    <p>Часто оказывается удобным отправлять и получать сообщения в виде единых блоков. Как было показано в главе 11, каналы позволяют это сделать. Однако в случае сокетов требуется создание заголовка, содержащего размер сообщения, за которым следует само сообщение. Для приема таких сообщений предназначена функция ReceiveMessage, которая будет использоваться в примерах. То же самое можно сказать и о функции SendMessage, предназначенной для передачи сообщений.</p>
    <p>Обратите внимание, что сообщение принимается в виде двух частей: заголовка и содержимого. Ниже мы предполагаем, что пользовательскому типу MESSAGE соответствует 4-байтовый заголовок. Но даже для 4-байтового заголовка требуются повторные вызовы функции recv, чтобы гарантировать его полное считывание, поскольку функция recv не является атомарной.</p>
    <cite>
     <p><strong>Примечание, относящееся к Win64</strong></p>
     <p>В качестве типа переменных, используемых для хранения размера сообщения, выбран тип данных фиксированной точности LONG32, которого будет вполне достаточно для размещения значений параметра размера, включаемого в сообщения при взаимодействии с системами, отличными от Windows, и который годится для возможной последующей перекомпиляции программы для ее использования на платформе Win64 (см. главу 16).</p>
    </cite>
    <p><code>DWORD ReceiveMessage (MESSAGE *pMsg, SOCKET sd) {</code></p>
    <p><code> /* Сообщение состоит из 4-байтового поля размера сообщения, за которым следует собственно содержимое. */ </code></p>
    <p><code> DWORD Disconnect = 0;</code></p>
    <p><code> LONG32 nRemainRecv, nXfer;</code></p>
    <p><code> LPBYTE pBuffer;</code></p>
    <p><code> /* Считать сообщение. */</code></p>
    <p><code> /* Сначала считывается заголовок, а затем содержимое. */</code></p>
    <p><code> nRemainRecv = 4; /* Размер поля заголовка. */</code></p>
    <p><code> pBuffer = (LPBYTE)pMsg; /* recv может не передать все запрошенные байты. */</code></p>
    <p><code> while (nRemainRecv &gt; 0 &amp;&amp; !Disconnect) {</code></p>
    <p><code>  nXfer = recv(sd, pBuffer, nRemainRecv, 0);</code></p>
    <p><code>  Disconnect = (nXfer == 0);</code></p>
    <p><code>  nRemainRecv –=nXfer;</code></p>
    <p><code>  pBuffer += nXfer;</code></p>
    <p><code> }</code></p>
    <p><code> /* Считать содержимое сообщения. */</code></p>
    <p><code> nRemainRecv = pMsg-&gt;RqLen;</code></p>
    <p><code> while (nRemainRecv &gt; 0 &amp;&amp; !Disconnect) {</code></p>
    <p><code>  nXfer = recv(sd, pBuffer, nRemainRecv, 0);</code></p>
    <p><code>  Disconnect = (nXfer == 0);</code></p>
    <p><code>  nRemainRecv –=nXfer;</code></p>
    <p><code>  pBuffer += nXfer;</code></p>
    <p><code> }</code></p>
    <p><code> return Disconnect; </code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>Пример: клиент на основе сокета</p>
    </title>
    <p>Программа 12.1 представляет собой переработанный вариант клиентской программы clientNP (программа 11.2), которая использовалась в случае именованных каналов. Преобразование программы осуществляется самым непосредственным образом и требует лишь некоторых пояснений.</p>
    <p>• Вместо обнаружения сервера с помощью почтовых ящиков пользователь вводит IP-адрес сервера в командной строке. Если IP-адрес не указан, используется заданный по умолчанию адрес 127.0.0.1, соответствующий локальной системе.</p>
    <p>• Для отправки и приема сообщений применяются функции, например, ReceiveMessage, которые здесь не представлены.</p>
    <p>• Номер порта, SERVER_PORT, определен в заголовочном файле ClntSrvr.h.</p>
    <p>Хотя код написан для выполнения под управлением Windows, единственная зависимость от Windows связана с использованием вызовов функций, имеющих префикс WSA.</p>
    <subtitle>Программа 12.1. clientSK: клиент на основе сокетов </subtitle>
    <p><code>/* Глава 12. clientSK.с */</code></p>
    <p><code>/* Однопоточный клиент командной строки. */</code></p>
    <p><code>/* ВЕРСИЯ НА ОСНОВЕ WINDOWS SOCKETS. */</code></p>
    <p><code>/* Считывает последовательность команд для пересылки серверному процессу*/</code></p>
    <p><code>/* через соединение с сокетом. Дожидается ответа и отображает его. */</code></p>
    <empty-line/>
    <p><code>#define _NOEXCLUSIONS /* Требуется для включения определений сокета. */</code></p>
    <p><code>#include "EvryThng.h"</code></p>
    <p><code>#include "ClntSrvr.h" /* Определяет структуры записей запроса и ответа. */</code></p>
    <empty-line/>
    <p><code>/* Функции сообщения для обслуживания запросов и ответов. */</code></p>
    <p><code>/* Кроме того, ReceiveResponseMessage отображает полученные сообщения. */</code></p>
    <p><code>static DWORD SendRequestMessage(REQUEST *, SOCKET);</code></p>
    <p><code>static DWORD ReceiveResponseMessage(RESPONSE *, SOCKET);</code></p>
    <p><code>struct sockaddr_in ClientSAddr; /* Адрес сокета клиента. */</code></p>
    <p><code>int _tmain(DWORD argc, LPTSTR argv[]) {</code></p>
    <p><code> SOCKET ClientSock = INVALID_SOCKET;</code></p>
    <p><code> REQUEST Request; /* См. ClntSrvr.h. */</code></p>
    <p><code> RESPONSE Response; /* См. ClntSrvr.h. */</code></p>
    <p><code> WSADATA WSStartData; /* Структура данных библиотеки сокета. */</code></p>
    <p><code> BOOL Quit = FALSE;</code></p>
    <p><code> DWORD ConVal, j;</code></p>
    <p><code> TCHAR PromptMsg[] = _T("\nВведите команду&gt; ");</code></p>
    <p><code> TCHAR Req[MAX_RQRS_LEN];</code></p>
    <p><code> TCHAR QuitMsg[] = _T("$Quit");</code></p>
    <p><code> /* Запрос: завершить работу клиента. */</code></p>
    <p><code> TCHAR ShutMsg[] = _T("$ShutDownServer"); /* Остановить все потоки. */</code></p>
    <p><code> CHAR DefaultIPAddr[] = "127.0.0.1"; /* Локальная система. */</code></p>
    <p><code> /* Инициализировать библиотеку WSA; задана версия 2.0, но будет работать и версия 1.1. */</code></p>
    <p><code> WSAStartup(MAKEWORD(2, 0), &amp;WSStartData);</code></p>
    <p><code> /* Подключиться к серверу. */</code></p>
    <p><code> /* Следовать стандартной процедуре вызова последовательности функций socket/connect клиентом. */</code></p>
    <p><code> ClientSock = socket(AF_INET, SOCK_STREAM, 0);</code></p>
    <p><code> memset(&amp;ClientSAddr, 0, sizeof(ClientSAddr));</code></p>
    <p><code> ClientSAddr.sin_family = AF_INET;</code></p>
    <p><code> if (argc &gt;= 2) ClientSAddr.sin_addr.s_addr = inet_addr(argv [1]);</code></p>
    <p><code> else ClientSAddr.sin_addr.s_addr = inet_addr(DefaultIPAddr);</code></p>
    <p><code> ClientSAddr.sin_port = htons(SERVER_PORT);</code></p>
    <p><code> /* Номер порта определен равным 1070. */</code></p>
    <p><code> connect(ClientSock, (struct sockaddr *)&amp;ClientSAddr, sizeof(ClientSAddr));</code></p>
    <p><code> /* Основной цикл для вывода приглашения на ввод команд, посылки запроса и получения ответа. */</code></p>
    <p><code> while (!Quit) {</code></p>
    <p><code>  _tprintf(_T("%s"), PromptMsg);</code></p>
    <p><code>  /* Ввод в формате обобщенных строк, но команда серверу должна указываться в формате ASCII. */</code></p>
    <p><code>  _fgetts(Req, MAX_RQRS_LEN-1, stdin); </code></p>
    <p><code>  for (j = 0; j &lt;= _tcslen(Req) Request.Record[j] = Req[j];</code></p>
    <p><code>  /* Избавиться от символа новой строки в конце строки. */</code></p>
    <p><code>  Request.Record[strlen(Request.Record) – 1] = '\0';</code></p>
    <p><code>  if (strcmp(Request.Record, QuitMsg) == 0 || strcmp(Request.Record, ShutMsg) == 0) Quit = TRUE;</code></p>
    <p><code>  SendRequestMessage(&amp;Request, ClientSock);</code></p>
    <p><code>  ReceiveResponseMessage(&amp;Response, ClientSock);</code></p>
    <p><code> }</code></p>
    <p><code> shutdown(ClientSock, 2); /* Запретить посылку и прием сообщений. */</code></p>
    <p><code> closesocket(ClientSock);</code></p>
    <p><code> WSACleanup();</code></p>
    <p><code> _tprintf(_T("\n****Выход из клиентской программы\n"));</code></p>
    <p><code> return 0; </code></p>
    <p><code>}</code> </p>
   </section>
   <section>
    <title>
     <p>Пример: усовершенствованный сервер на основе сокетов</p>
    </title>
    <section>
     <p>Программа serverSK (программа 12.2) аналогична программе serverNP (программа 11.3), являясь ее видоизмененным и усовершенствованным вариантом.</p>
     <p>• В усовершенствованном варианте программы серверные потоки создаются <emphasis>по требованию</emphasis> (on demand), а не в виде пула потоков фиксированного размера. Каждый раз, когда сервер принимает запрос клиента на соединение, создается серверный рабочий поток, и когда клиент прекращает работу, выполнение потока завершается.</p>
     <p>• Сервер создает отдельный <emphasis>поток приема</emphasis> (accept thread), что позволяет основному потоку опрашивать глобальный флаг завершения работы, пока вызов accept остается блокированным. Хотя сокеты и могут определяться как неблокирующиеся, потоки обеспечивают удобное универсальное решение. Следует отметить, что значительная часть расширенных функциональных возможностей Winsock призвана поддерживать асинхронные операции, тогда как потоки Windows дают возможность воспользоваться более простой и близкой к стандартам функциональностью синхронного режима работы сокетов.</p>
     <p>• За счет некоторого усложнения программы усовершенствовано управление потоками, что позволило обеспечить поддержку состояний каждого потока.</p>
     <p>• Данный сервер поддерживает также <emphasis>внутрипроцессные серверы</emphasis> (in-process servers), что достигается путем загрузки библиотеки DLL во время инициализации. Имя библиотеки DLL задается в командной строке, и серверный поток сначала пытается определить точку входа этой DLL. В случае успеха серверный поток вызывает точку входа DLL; в противном случае сервер создает процесс аналогично тому, как это делалось в программе serverNP. Пример DLL приведен в программе 12.3. Поскольку генерация исключений библиотекой DLL будет приводить к уничтожению всего серверного процесса, вызов функции DLL защищен простым обработчиком исключений.</p>
     <p>При желании можно включить внутрипроцессные серверы и в программу serverNP. Самым большим преимуществом внутрипроцессных серверов является то, что они не требуют никакого контекстного переключения на другие процессы, в результате чего производительность может заметно улучшиться.</p>
     <p>Поскольку в коде сервера использованы специфические для Windows возможности, в частности, возможности управления потоками и некоторые другие, он, в отличие от кода клиента, оказывается привязанным к Windows.</p>
     <subtitle>Программа 12.2. serverSK: сервер на основе сокета с внутрипроцессными серверами </subtitle>
     <p><code>/* Глава 12. Клиент-серверная система. ПРОГРАММА СЕРВЕРА. ВЕРСИЯ НА ОСНОВЕ СОКЕТА. */</code></p>
     <p><code>/* Выполняет указанную в запросе команду и возвращает ответ. */ </code></p>
     <p><code>/* Если удается обнаружить точку входа разделяемой библиотеки, команды */ </code></p>
     <p><code>/* выполняются внутри процесса, в противном случае – вне процесса. */ </code></p>
     <p><code>/* ДОПОЛНИТЕЛЬНАЯ ВОЗМОЖНОСТЬ: argv [1] может содержать имя библиотеки */ </code></p>
     <p><code>/* DLL, поддерживающей внутрипроцессные серверы. */</code></p>
     <empty-line/>
     <p><code>#define _NOEXCLUSIONS </code></p>
     <p><code>#include "EvryThng.h" </code></p>
     <p><code>#include "ClntSrvr.h" /* Определяет структуру записей запроса и ответа. */</code></p>
     <empty-line/>
     <p><code>struct sockaddr_in SrvSAddr;</code></p>
     <p><code>/* Адресная структура сокета сервера. */</code></p>
     <p><code>struct sockaddr_in ConnectSAddr; /* Подключенный сокет. */</code></p>
     <p><code>WSADATA WSStartData; /* Структура данных библиотеки сокета. */</code></p>
     <empty-line/>
     <p><code>typedef struct SERVER_ARG_TAG { /* Аргументы серверного потока. */</code></p>
     <p><code> volatile DWORD number;</code></p>
     <p><code> volatile SOCKET sock;</code></p>
     <p><code> volatile DWORD status;</code></p>
     <p><code> /* Пояснения содержатся в комментариях к основному потоку. */</code></p>
     <p><code> volatile HANDLE srv_thd;</code></p>
     <p><code> HINSTANCE dlhandle; /* Дескриптор разделяемой библиотеки. */ </code></p>
     <p><code>} SERVER_ARG;</code></p>
     <empty-line/>
     <p><code>volatile static ShutFlag = FALSE; </code></p>
     <p><code>static SOCKET SrvSock, ConnectSock; </code></p>
     <p><code>int _tmain(DWORD argc, LPCTSTR argv[]) {</code></p>
     <p><code> /* Прослушивающий и подключенный сокеты сервера. */</code></p>
     <p><code> BOOL Done = FALSE;</code></p>
     <p><code> DWORD ith, tstatus, ThId;</code></p>
     <p><code> SERVER_ARG srv_arg[MAX_CLIENTS];</code></p>
     <p><code> HANDLE hAcceptTh = NULL;</code></p>
     <p><code> HINSTANCE hDll = NULL;  </code></p>
     <p><code> /* Инициализировать библиотеку WSA; задана версия 2.0, но будет работать и версия 1.1. */</code></p>
     <p><code> WSAStartup(MAKEWORD(2, 0), &amp;WSStartData);</code></p>
     <p><code> /* Открыть динамическую библиотеку команд, если ее имя указано в командной строке. */</code></p>
     <p><code> if (argc &gt; 1) hDll = LoadLibrary(argv[1]);</code></p>
     <p><code> /* Инициализировать массив arg потока. */</code></p>
     <p><code> for (ith = 0; ith &lt; MAXCLIENTS; ith++) {</code></p>
     <p><code>  srv_arg[ith].number = ith;</code></p>
     <p><code>  srv_arg[ith].status = 0;</code></p>
     <p><code>  srv_arg[ith].sock = 0;</code></p>
     <p><code>  srv_arg[ith].dlhandle = hDll;</code></p>
     <p><code>  srv_arg[ith].srv_thd = NULL;</code></p>
     <p><code> }</code></p>
     <p><code> /* Следовать стандартной процедуре вызова последовательности функций socket/bind/listen/accept клиентом. */</code></p>
     <p><code> SrvSock = socket(AF_INET, SOCK_STREAM, 0);</code></p>
     <p><code> SrvSAddr.sin_family = AF_INET;</code></p>
     <p><code> SrvSAddr.sin_addr.s_addr = htonl(INADDR_ANY);</code></p>
     <p><code> SrvSAddr.sin_port = htons(SERVER_PORT);</code></p>
     <p><code> bind(SrvSock, (struct sockaddr *)&amp;SrvSAddr, sizeof SrvSAddr);</code></p>
     <p><code> listen(SrvSock, MAX_CLIENTS);</code></p>
     <empty-line/>
     <p><code> /* Основной поток становится потоком прослушивания/соединения/контроля.*/</code></p>
     <p><code> /* Найти пустую ячейку в массиве arg потока сервера. */</code></p>
     <p><code> /* параметр состояния: 0 – ячейка свободна; 1 – поток остановлен; 2 — поток выполняется; 3 – остановлена вся система. */</code></p>
     <p><code> while (!ShutFlag) {</code></p>
     <p><code>  for (ith = 0; ith &lt; MAX_CLIENTS &amp;&amp; !ShutFlag; ) {</code></p>
     <p><code>   if (srv_arg[ith].status==1 || srv_arg[ith].status==3) { /* Выполнение потока завершено либо обычным способом, либо по запросу останова. */</code></p>
     <p><code>    WaitForSingleObject(srv_arg[ith].srv_thd INFINITE);</code></p>
     <p><code>    CloseHandle(srv_arg[ith].srv_tnd);</code></p>
     <p><code>    if (srv_arg[ith].status == 3) ShutFlag = TRUE;</code></p>
     <p><code>    else srv_arg[ith].status = 0;</code></p>
     <p><code>    /* Освободить ячейку данного потока. */</code></p>
     <p><code>   }</code></p>
     <p><code>   if (srv_arg[ith].status == 0 || ShutFlag) break;</code></p>
     <p><code>   ith = (ith + 1) % MAXCLIENTS;</code></p>
     <p><code>   if (ith == 0) Sleep(1000);</code></p>
     <p><code>   /* Прервать цикл опроса. */</code></p>
     <p><code>   /* Альтернативный вариант: использовать событие для генерации сигнала, указывающего на освобождение ячейки. */</code></p>
     <p><code>  }</code></p>
     <p><code>  /* Ожидать попытки соединения через данный сокет. */</code></p>
     <p><code>  /* Отдельный поток для опроса флага завершения ShutFlag. */</code></p>
     <p><code>  hAcceptTh = (HANDLE)_beginthreadex(NULL, 0, AcceptTh, &amp;srv_arg[ith], 0, &amp;ThId); </code></p>
     <p><code>  while (!ShutFlag) {</code></p>
     <p><code>   tstatus = WaitForSingleObject(hAcceptTh, CS_TIMEOUT);</code></p>
     <p><code>   if (tstatus == WAIT_OBJECT_0) break; /* Соединение установлено. */</code></p>
     <p><code>  }</code></p>
     <p><code>  CloseHandle(hAcceptTh);</code></p>
     <p><code>  hAcceptTh = NULL; /* Подготовиться к следующему соединению. */</code></p>
     <p><code> }</code></p>
     <p><code> _tprintf(_T("Остановка сервера. Ожидание завершения всех потоков сервера\n"));</code></p>
     <p><code> /* Завершить принимающий поток, если он все еще выполняется. */</code></p>
     <p><code> /* Более подробная информация об используемой логике завершения */</code></p>
     <p><code> /* работы приведена на Web-сайте книги. */</code></p>
     <p><code> if (hDll != NULL) FreeLibrary(hDll);</code></p>
     <p><code> if (hAcceptTh != NULL) TerminateThread(hAcceptTh, 0);</code></p>
     <p><code> /* Ожидать завершения всех активных потоков сервера. */</code></p>
     <p><code> for (ith = 0; ith &lt; MAXCLIENTS; ith++) if (srv_arg [ith].status != 0) {</code></p>
     <p><code>  WaitForSingleObject(srv_arg[ith].srv_thd, INFINITE);</code></p>
     <p><code>  CloseHandle(srv_arg[ith].srv_thd);</code></p>
     <p><code> }</code></p>
     <p><code> shutdown(SrvSock, 2);</code></p>
     <p><code> closesocket(SrvSock);</code></p>
     <p><code> WSACleanup();</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>static DWORD WINAPI AcceptTh(SERVER_ARG * pThArg) {</code></p>
     <p><code> /* Принимающий поток, который предоставляет основному потоку возможность опроса флага завершения. Кроме того, этот поток создает серверный поток. */ </code></p>
     <p><code> LONG AddrLen, ThId;</code></p>
     <p><code> AddrLen = sizeof(ConnectSAddr);</code></p>
     <p><code> pThArg-&gt;sock = accept(SrvSock, /* Это блокирующий вызов. */</code></p>
     <p><code>  (struct sockaddr *)&amp;ConnectSAddr, &amp;AddrLen);</code></p>
     <p><code> /* Новое соединение. Создать серверный поток. */</code></p>
     <p><code> pThArg-&gt;status = 2;</code></p>
     <p><code> pThArg-&gt;srv_thd = (HANDLE)_beginthreadex (NULL, 0, Server, pThArg, 0, &amp;ThId);</code></p>
     <p><code> return 0; /* Серверный поток продолжает выполняться. */</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>static DWORD WINAPI Server(SERVER_ARG * pThArg) </code></p>
     <p><code>/* Функция серверного потока. Поток создается по требованию. */</code></p>
     <p><code>{</code></p>
     <p><code> /* Каждый поток поддерживает в стеке собственные структуры данных запроса, ответа и регистрационных записей. */</code></p>
     <p><code> /* … Стандартные объявления из serverNP опущены … */</code></p>
     <p><code> SOCKET ConnectSock; </code></p>
     <p><code> int Disconnect = 0, i;</code></p>
     <p><code> int (*dl_addr)(char *, char *);</code></p>
     <p><code> char *ws = " \0\t\n"; /* Пробелы. */</code></p>
     <p><code> GetStartupInfo(&amp;StartInfoCh);</code></p>
     <p><code> ConnectSock = pThArg-&gt;sock;</code></p>
     <p><code> /* Создать имя временного файла. */</code></p>
     <p><code> sprintf(TempFile, "%s%d%s", "ServerTemp", pThArg-&gt;number, ".tmp");</code></p>
     <p><code> while (!Done &amp;&amp; !ShutFlag) { /* Основной командный цикл. */</code></p>
     <p><code>  Disconnect = ReceiveRequestMessage(&amp;Request, ConnectSock);</code></p>
     <p><code>  Done = Disconnect || (strcmp(Request.Record, "$Quit") == 0) || (strcmp(Request.Record, "$ShutDownServer") == 0);</code></p>
     <p><code>  if (Done) continue;</code></p>
     <p><code>  /* Остановить этот поток по получении команды "$Quit" или "$ShutDownServer". */</code></p>
     <p><code>  hTrapFile = CreateFile(TempFile, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, &amp;TempSA, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);</code></p>
     <p><code>  /* Проверка наличия этой команды в DLL. Для упрощения команды */</code></p>
     <p><code>  /* разделяемой библиотеки имеют более высокий приоритет по сравнению */</code></p>
     <p><code>  /* с командами процесса. Прежде всего, необходимо извлечь имя команды.*/</code></p>
     <p><code>  i = strcspn(Request.Record, ws); /* Размер лексемы. */</code></p>
     <p><code>  memcpy(sys_command, Request.Record, i) ;</code></p>
     <p><code>  sys_command[i] = '\0';</code></p>
     <p><code>  dl_addr = NULL; /* Будет установлен в случае успешного выполнения функции GetProcAddress. */</code></p>
     <p><code>  if (pThArg-&gt;dlhandle != NULL) {/* Проверка поддержки "внутрипроцессного" сервера. */</code></p>
     <p><code>   dl_addr = (int (*)(char *, char *))GetProcAddress(pThArg-&gt;dlhandle, sys_command);</code></p>
     <p><code>   if (dl_addr != NULL) __try {</code></p>
     <p><code>    /* Защитить серверный процесс от исключений, возникающих в DLL*/</code></p>
     <p><code>    (*dl_addr)(Request.Record, TempFile);</code></p>
     <p><code>   } __except (EXCEPTION_EXECUTE_HANDLER) {</code></p>
     <p><code>    ReportError(_T("Исключение в DLL"), 0, FALSE);</code></p>
     <p><code>   }</code></p>
     <p><code>  }</code></p>
     <p><code>  if (dl_addr == NULL) { /* Поддержка внутрипроцессного сервера отсутствует. */</code></p>
     <p><code>   /* Создать процесс для выполнения команды. */</code></p>
     <p><code>   /* … То же, что в serverNP … */</code></p>
     <p><code>  }</code></p>
     <p><code>  /* … То же, что в serverNP … */</code></p>
     <p><code> } /* Конец основного командного цикла. Получить следующую команду. */</code></p>
     <p><code> /* Конец командного цикла. Освободить ресурсы; выйти из потока. */ </code></p>
     <p><code> _tprintf(_T("Завершение работы сервера# %d\n"), pThArg-&gt;number);</code></p>
     <p><code> shutdown(ConnectSock, 2);</code></p>
     <p><code> closesocket(ConnectSock);</code></p>
     <p><code> pThArg-&gt;status = 1;</code></p>
     <p><code> if (strcmp(Request.Record, "$ShutDownServer") == 0) {</code></p>
     <p><code>  pThArg-&gt;status = 3;</code></p>
     <p><code>  ShutFlag = TRUE;</code></p>
     <p><code> }</code></p>
     <p><code> return pThArg-&gt;status; </code></p>
     <p><code>}</code> </p>
    </section>
    <section>
     <title>
      <p>Замечания по поводу безопасности</p>
     </title>
     <p>В том виде, как она здесь представлена, данная клиент-серверная система <emphasis>не</emphasis> является безопасной. Если на вашей системе выполняется сервер и кому-то известен номер порта, через который вы работаете, и имя компьютера, то он может атаковать вашу систему. Другой пользователь, запустив клиентскую программу на своем компьютере, сможет выполнить на вашей системе команды, позволяющие, например, удалить или изменить файлы.</p>
     <p>Полное обсуждение методов построения безопасных систем выходит за рамки данной книги. Тем не менее, в главе 15 показано, как обезопасить объекты Windows, а в упражнении 12.14 предлагается воспользоваться протоколом SSL.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Внутрипроцессные серверы</p>
    </title>
    <p>Как ранее уже отмечалось, основное усовершенствование программы serverSK связано с включением в нее внутрипроцессных серверов. В программе 12.3 показано, как написать библиотеку DLL, обеспечивающую услуги подобного рода. В программе представлены две уже известные вам функции — функция, осуществляющая подсчет слов, и функция toupper.</p>
    <p>В соответствии с принятым соглашением первым параметром является командная строка, а вторым — имя выходного файла. Кроме того, следует всегда помнить о том, что функция будет выполняться в том же потоке, что и сервер, и это диктует необходимость соблюдения жестких требований относительно безопасности потоков, включая, но не ограничиваясь только этим, следующее:</p>
    <p>• Функции никоим образом не должны изменять окружение процесса. Например, если одна из функций изменит рабочий каталог, то это окажет воздействие на весь процесс.</p>
    <p>• Аналогично, функции не должны перенаправлять стандартный ввод и вывод.</p>
    <p>• Такие ошибки программирования, как выход индекса или указателя за пределы отведенного диапазона или переполнение стека, могут приводить к порче памяти, относящейся к другому потоку или самому процессу. </p>
    <p>• Утечка ресурсов, возникшая, например, в результате того, что системе не была своевременно возвращена освободившаяся память или не были закрыты дескрипторы, в конечном счете, окажет отрицательное воздействие на работу всей серверной системы.</p>
    <p>Столь жесткие требования не предъявляются к процессам по той причине, что один процесс, как правило, не может нанести ущерб другим процессу, а после того, как процесс завершает свое выполнение, занимаемые им ресурсы автоматически освобождаются. В связи с этим служба, как правило, разрабатывается и отлаживается как поток, и лишь после того, как появится уверенность в надежности ее работы, она преобразуется в DLL.</p>
    <p>В программе 12.3 представлена небольшая библиотека DLL, включающая две функции.</p>
    <subtitle>Программа 12.3. command: пример внутри процессных серверов </subtitle>
    <p><code>/* Глава 12. commands.с. */</code></p>
    <p><code>/* Команды внутрипроцессного сервера для использования в serverSK и так далее. */</code></p>
    <p><code>/* Имеется несколько команд, реализованных в виде библиотек DLLs. */ </code></p>
    <p><code>/* Функция каждой команды принимает два параметра и обеспечивает */ </code></p>
    <p><code>/* безопасное выполнение в многопоточном режиме. Первым параметром */ </code></p>
    <p><code>/* является строка: команда arg1 arg2 … argn */ </code></p>
    <p><code>/* (то есть обычная командная строка), а вторым – имя выходного файла. … */ </code></p>
    <empty-line/>
    <p><code>static void extract_token(int, char *, char *);</code></p>
    <empty-line/>
    <p><code>_declspec(dllexport) </code></p>
    <p><code>int wcip(char * command, char * output_file)</code></p>
    <p><code>/* Счетчик слов; внутрипроцессный. */</code></p>
    <p><code>/* ПРИМЕЧАНИЕ: упрощенная версия; результаты могут отличаться от тех, которые обеспечивает утилита wc. */ </code></p>
    <p><code>{</code></p>
    <p><code> extract_token(1, command, input_file);</code></p>
    <p><code> fin = fopen(input_file, "r");</code></p>
    <p><code> /* … */</code></p>
    <p><code> ch = nw = nc = nl = 0;</code></p>
    <p><code> while ((c = fgetc(fin)) != EOF) {</code></p>
    <p><code>  /* … Стандартный код — для данного примера не является существенным … */ </code></p>
    <p><code> }</code></p>
    <p><code> fclose(fin);</code></p>
    <p><code> /* Записать результаты. */</code></p>
    <p><code> fout = fopen(output_file, "w");</code></p>
    <p><code> if (fout == NULL) return 2;</code></p>
    <p><code> fprintf(fout, " %9d %9d %9d %s\n", nl, nw, nc, input_file);</code></p>
    <p><code> fclose(fout);</code></p>
    <p><code> return 0; </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>_declspec(dllexport)</code></p>
    <p><code>int toupperip(char * command, char * output_file)</code></p>
    <p><code>/* Преобразует входные данные к верхнему регистру; выполняется внутри процесса. */</code></p>
    <p><code>/* Вторая лексема задает входной файл (первая лексема – "toupperip"). */ </code></p>
    <p><code>{</code></p>
    <p><code> /* … */</code></p>
    <p><code> extract_token(1, command, input_file);</code></p>
    <p><code> fin = fopen(input_file, "r");</code></p>
    <p><code> if (fin == NULL) return 1;</code></p>
    <p><code> fout = fopen(output_file, "w");</code></p>
    <p><code> if (fout == NULL) return 2;</code></p>
    <p><code> while ((c = fgetc (fin)) != EOF) {</code></p>
    <p><code>  if (c == '\0') break;</code></p>
    <p><code>  if (isalpha(c)) с = toupper(c);</code></p>
    <p><code>  fputc(c, fout);</code></p>
    <p><code> }</code></p>
    <p><code> fclose(fin);</code></p>
    <p><code> fclose(fout);</code></p>
    <p><code> return 0; </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>static void extract_token(int it, char * command, char * token) {</code></p>
    <p><code> /* Извлекает из "команды" лексему номер "it" (номером первой лексемы */</code></p>
    <p><code> /* является "0"). Результат переходит в "лексему" (token) */</code></p>
    <p><code> /* В качестве разделителей лексем используются пробелы. … */</code></p>
    <p><code> return; </code></p>
    <p><code>}</code> </p>
   </section>
   <section>
    <title>
     <p>Ориентированные на строки сообщения<strong>, точкив хода DLL и TLS</strong></p>
    </title>
    <section>
     <p>Программы serverSK и clientSK взаимодействуют между собой, обмениваясь сообщениями, каждое из которых состоит из 4-байтового заголовка, содержащего размер сообщения, и собственно содержимого. Обычной альтернативой такому подходу служат сообщения, отделяемые друг от друга символами конца строки (или перевода строки).</p>
     <p>Трудность работы с такими сообщениями заключается в том, что длина сообщения заранее не известна, в связи с чем приходится проверять каждый поступающий символ. Однако получение по одному символу за один раз крайне неэффективно, и поэтому символы сохраняются в буфере, содержимое которого может включать один или несколько символов конца строки и составные части одного или нескольких сообщений. <emphasis>При этом в промежутках между вызовами функции получения сообщений необходимо поддерживать неизменным содержимое и состояние буфера.</emphasis> В однопоточной среде для этой цели могут быть использованы ячейки статической памяти, но совместное использование несколькими потоками одной и той же статической переменной невозможно.</p>
     <p>В более общей формулировке, мы сталкиваемся здесь с <emphasis>проблемой сохранения долговременных состояний в многопоточной среде</emphasis> (multithreaded persistent state problem). Эта проблема возникает всякий раз, когда безопасная в отношении многопоточного выполнения функция должна поддерживать сохранение некоторой информации от одного вызова функции к другому. Такая же проблема возникает при работе с функцией strtook, входящей в стандартную библиотеку С, которая предназначена для просмотра строки для последовательного нахождения экземпляров определенной лексемы.</p>
    </section>
    <section>
     <title>
      <p>Решение проблемы долговременных состояний в многопоточной среде</p>
     </title>
     <p>В искомом решении сочетаются несколько компонентов:</p>
     <p>• Библиотека DLL, в которой содержатся функции, обеспечивающие отправку и прием сообщений.</p>
     <p>• Функция, представляющая точку входа в DLL.</p>
     <p>• Локальная область хранения потока (TLS, глава 7). Подключение процесса к библиотеке сопровождается созданием индекса DLL, а отключение — уничтожением. Значение индекса хранится в статическом хранилище, доступ к которому имеют все потоки.</p>
     <p>• Структура, в которой хранится буфер и его текущее состояние. Структура распределяется всякий раз, когда к библиотеке подключается новый поток, и его адрес сохраняется в записи TLS для данного потока. При отсоединении потока от библиотеки память, занимаемая его структурой, освобождается.</p>
     <p>Таким образом, TLS играет роль статического хранилища, и у каждого потока имеется собственная уникальная копия этого хранилища.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: безопасная многопоточная DLL для обмена сообщениями через сокет</p>
    </title>
    <section>
     <p>Программа 12.4 представляет собой DLL, содержащую две функции для обработки символьных строк (в именах которых в данном случае присутствует "CS", от <emphasis>character string</emphasis> — строка символов), или потоковые функции сокета (socket streaming functions): SendCSMessage и ReceiveCSMessage, а также точку входа DllMain (см. главу 5). Указанные две функции играют ту же роль, что и функция ReceiveMessage, а также функции, использованные в программах 12.1 и 12.2, и фактически заменяют их. </p>
     <p>Функция DllMain служит характерным примером решения проблемы долговременных состояний в многопоточной среде и объединяет TLS и библиотеки DLL.</p>
     <p>Освобождать ресурсы при отсоединении потоков (случай DLL_THREAD_DETACH) особенно важно в случае серверной среды; если этого не делать, то ресурсы сервера, в конечном счете, исчерпаются, что может привести к сбоям в его работе или снижению производительности или к тому и другому одновременно.</p>
     <cite>
      <p><strong>Примечание</strong></p>
      <p>Некоторые из иллюстрируемых ниже концепций прямого отношения к сокетам не имеют, но, тем не менее, рассматриваются именно здесь, а не в предыдущих главах, поскольку данный пример предоставляет удобную возможность для иллюстрации методов создания безопасных многопоточных DLL в реалистических условиях.</p>
      <p>Использующие эту DLL коды клиента и сервера, незначительно измененные по сравнению с программами 12.1 и 12.2, доступны на Web-сайте книги.</p>
     </cite>
     <subtitle>Программа 12.4. SendReceiveSKST: безопасная многопоточная DLL </subtitle>
     <p><code>/* SendReceiveSKST.с — DLL многопоточного потокового сокета. */</code></p>
     <p><code>/* В качестве разделителей сообщений используются символы конца */</code></p>
     <p><code>/* строки ('\0'), так что размер сообщения заранее не известен. */</code></p>
     <p><code>/* Поступающие данные буферизуются и сохраняются в промежутках между */</code></p>
     <p><code>/* вызовами функций. */</code></p>
     <p><code>/* Для этой цели используются локальные области хранения потоков */</code></p>
     <p><code>/* (Thread Local Storage, TLS), обеспечивающие каждый из потоков */</code></p>
     <p><code>/* собственным закрытым "статическим хранилищем". */</code></p>
     <empty-line/>
     <p><code>#define _NOEXCLUSIONS </code></p>
     <p><code>#include "EvryThng.h" </code></p>
     <p><code>#include "ClntSrvr.h" /* Определяет записи запроса и ответа. */</code></p>
     <empty-line/>
     <p><code>typedef struct STATIC_BUF_T {</code></p>
     <p><code> /* "static_buf" содержит "static_buf_len" байтов остаточных данных. */</code></p>
     <p><code> /* Символы конца строки (нулевые символы) могут присутствовать, а могут */</code></p>
     <p><code> /* и не присутствовать. */</code></p>
     <p><code> char static_buf[MAX_RQRS_LEN] ;</code></p>
     <p><code> LONG32 static_buf_len;</code></p>
     <p><code>} STATIC_BUF;</code></p>
     <empty-line/>
     <p><code>static DWORD TlsIx = 0; /* Индекс TLS – ДЛЯ КАЖДОГО ПРОЦЕССА СВОЙ ИНДЕКС.*/</code></p>
     <p><code> /* Для однопоточной библиотеки использовались бы следующие определения:</code></p>
     <p><code>  static char static_buf [MAX_RQRS_LEN];</code></p>
     <p><code>  static LONG32 static_buf_len; */</code></p>
     <p><code> /* Основная функция DLL. */</code></p>
     <empty-line/>
     <p><code>BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {</code></p>
     <p><code> STATIC_BUF * pBuf;</code></p>
     <p><code> switch (fdwReason) {</code></p>
     <p><code> case DLL_PROCESS_ATTACH:</code></p>
     <p><code>  TlsIx = TlsAlloc(); </code></p>
     <p><code>  /* Для основного потока подключение отсутствует, поэтому во время подключения процесса необходимо выполнить также операции по подключению потока. */</code></p>
     <p><code> case DLL_THREAD_ATTACH:</code></p>
     <p><code>  /* Указать, что память не была распределена. */</code></p>
     <p><code>  TlsSetValue(TlsIx, NULL);</code></p>
     <p><code>  return TRUE; /* В действительности это значение игнорируется. */</code></p>
     <p><code> case DLL_PROCESS_DETACH:</code></p>
     <p><code>  /* Отсоединить также основной поток. */</code></p>
     <p><code>  pBuf = TlsGetValue(TlsIx);</code></p>
     <p><code>  if (pBuf != NULL) {</code></p>
     <p><code>   free(pBuf);</code></p>
     <p><code>   pBuf = NULL;</code></p>
     <p><code>  }</code></p>
     <p><code>  return TRUE;</code></p>
     <p><code> case DLL_THREAD_DETACH:</code></p>
     <p><code>  pBuf = TlsGetValue(TlsIx);</code></p>
     <p><code>  if (pBuf != NULL) {</code></p>
     <p><code>   free(pBuf);</code></p>
     <p><code>   pBuf = NULL;</code></p>
     <p><code>  }</code></p>
     <p><code>  return TRUE;</code></p>
     <p><code> }</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>_declspec(dllexport) </code></p>
     <p><code>BOOL ReceiveCSMessage(REQUEST *pRequest, SOCKET sd) {</code></p>
     <p><code> /* Возвращаемое значение TRUE указывает на ошибку или отсоединение. */</code></p>
     <p><code> BOOL Disconnect = FALSE;</code></p>
     <p><code> LONG32 nRemainRecv = 0, nXfer, k; /* Должны быть целыми со знаком. */</code></p>
     <p><code> LPSTR pBuffer, message;</code></p>
     <p><code> CHAR TempBuf[MAX_RQRS_LEN + 1];</code></p>
     <p><code> STATIC_BUF *p;</code></p>
     <p><code> p = (STATIC_BUF *)TlsGetValue(TlsIx);</code></p>
     <p><code> if (p == NULL) { /* Инициализация при первом вызове. */</code></p>
     <p><code>  /* Распределять это хранилище будут только те потоки, которым оно */</code></p>
     <p><code>  /* необходимо. Другие типы потоков могут использовать TLS для иных целей. */</code></p>
     <p><code>  р = malloc(sizeof(STATIC_BUF));</code></p>
     <p><code>  TlsSetValue(TlsIx, p);</code></p>
     <p><code>  if (p == NULL) return TRUE; /* Ошибка. */</code></p>
     <p><code>  p-&gt;static_buf_len = 0; /* Инициализировать состояние. */</code></p>
     <p><code> }</code></p>
     <p><code> message = pRequest-&gt;Record;</code></p>
     <p><code> /* Считать до символа новой строки, оставляя остаточные данные в статическом буфере. */</code></p>
     <p><code> for (k = 0; k &lt; p-&gt;static_buf_len &amp;&amp; p-&gt;static_buf[k] != '\0'; k++) { </code></p>
     <p><code>  message[k] = p-&gt;static_buf[k];</code></p>
     <p><code> } /* k – количество переданных символов. */</code></p>
     <p><code> if (k &lt; p-&gt;static_buf_len) { /* В статическом буфере обнаружен нулевой символ. */</code></p>
     <p><code>  message[k] = '\0';</code></p>
     <p><code>  p-&gt;static_buf_len –= (k + 1); /* Скорректировать состояние статического буфера. */</code></p>
     <p><code>  memcpy(p-&gt;static_buf, &amp;(p-&gt;static_buf[k + 1]), p-&gt;static_buf_len);</code></p>
     <p><code>  return FALSE; /* Входные данные сокета не требуются. */</code></p>
     <p><code> }</code></p>
     <empty-line/>
     <p><code> /* Передан весь статический буфер. Признак конца строки не обнаружен.*/</code></p>
     <p><code> nRemainRecv = sizeof(TempBuf) – 1 – p-&gt;static_buf_len;</code></p>
     <p><code> pBuffer = message + p-&gt;static_buf_len;</code></p>
     <p><code> p-&gt;static_buf_len = 0;</code></p>
     <p><code> while (nRemainRecv &gt; 0 &amp;&amp; !Disconnect) {</code></p>
     <p><code>  nXfer = recv(sd, TempBuf, nRemainRecv, 0);</code></p>
     <p><code>  if (nXfer &lt;= 0) {</code></p>
     <p><code>   Disconnect = TRUE;</code></p>
     <p><code>   continue;</code></p>
     <p><code>  }</code></p>
     <p><code>  nRemainRecv –= nXfer;</code></p>
     <p><code>  /* Передать в целевое сообщение все символы вплоть до нулевого, если таковой имеется. */</code></p>
     <p><code>  for (k =0; k &lt; nXfer &amp;&amp; TempBuf[k] != '\0'; k++) {</code></p>
     <p><code>   *pBuffer = TempBuf[k];</code></p>
     <p><code>   pBuffer++;</code></p>
     <p><code>  }</code></p>
     <p><code>  if (k &gt;= nXfer) { /*Признак конца строки не обнаружен, читать дальше*/</code></p>
     <p><code>   nRemainRecv –= nXfer;</code></p>
     <p><code>  } else { /* Обнаружен признак конца строки. */</code></p>
     <p><code>   *pBuffer = '\0';</code></p>
     <p><code>   nRemainRecv = 0;</code></p>
     <p><code>   memcpy(p-&gt;static_buf, &amp;TempBuf[k + 1], nXfer – k – 1);</code></p>
     <p><code>   p-&gt;static_buf_len = nXfer – k – 1;</code></p>
     <p><code>  }</code></p>
     <p><code> }</code></p>
     <p><code> return Disconnect;</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>_declspec(dllexport)</code></p>
     <p><code>BOOL SendCSMessage(RESPONSE *pResponse, SOCKET sd) {</code></p>
     <p><code> /* Послать запрос серверу в сокет sd. */</code></p>
     <p><code> BOOL Disconnect = FALSE;</code></p>
     <p><code> LONG32 nRemainSend, nXfer;</code></p>
     <p><code> LPSTR pBuffer; </code></p>
     <p><code> pBuffer = pResponse-&gt;Record;</code></p>
     <p><code> nRemainSend = strlen(pBuffer) + 1;</code></p>
     <p><code> while (nRemainSend &gt; 0 &amp;&amp; !Disconnect) {</code></p>
     <p><code>  /* Отправка еще не гарантирует, что будет отослано все сообщение. */</code></p>
     <p><code>  nXfer = send(sd, pBuffer, nRemainSend, 0);</code></p>
     <p><code>  if (nXfer &lt;= 0) {</code></p>
     <p><code>   fprintf(stderr, "\nОтключение сервера до посылки запроса завершения");</code></p>
     <p><code>   Disconnect = TRUE;</code></p>
     <p><code>  }</code></p>
     <p><code>  nRemainSend –=nXfer;</code></p>
     <p><code>  pBuffer += nXfer;</code></p>
     <p><code> }</code></p>
     <p><code> return Disconnect; </code></p>
     <p><code>}</code> </p>
    </section>
    <section>
     <title>
      <p>Комментарии по поводу DLL и безопасной многопоточной среды</p>
     </title>
     <p>• Всякий раз, когда создается новый поток, вызывается функция DllMain с опцией DLL_THREAD_ATTACH, но для основного потока отдельного вызова с опцией DLL_THREAD_ATTACH не существует. В случае основного потока должна использоваться опция DLL_PROCESS_ATTACH.</p>
     <p>• Вообще говоря, в том числе и в данном случае (возьмите, например, поток, принимающий сообщения (accept thread)), некоторым потокам распределение памяти может и не требоваться, но DllMain не в состоянии различать отдельные типы потоков. Поэтому на участке кода, соответствующем варианту выбора DLL_THREAD_ATTACH, фактического распределения памяти не происходит; здесь только инициализируется параметр TLS. Распределение памяти осуществляется точкой входа ReceiveCSMessage при первом ее вызове. Благодаря этому собственная память выделяется только тем потокам, которые в этом действительно нуждаются, и различные типы потоков получают ровно столько ресурсов, сколько им требуется.</p>
     <p>• Хотя рассматриваемая библиотека DLL и обеспечивает безопасную многопоточную поддержку, любой поток в каждый момент времени может работать только с одним сокетом, поскольку долговременные состояния ассоциируются не с сокетами, а с потоками. Этот момент учитывается в следующем примере.</p>
     <p>• Исходным кодом DLL, размещенным на Web-сайте, предусмотрен вывод общего количества вызовов DllMain в соответствии с их типами.</p>
     <p>• Даже при таком решении существует риск утечки ресурсов. Некоторые потоки, например поток приема сообщений, могут вообще не завершаться, и поэтому не будут отсоединены от библиотеки DLL. Для остающихся активных потоков функция ExitProcess вызовет DllMain с опцией DLL_PROCESS_DETACH, а не DLL_THREAD_DETACH. В данном случае никаких проблем не возникает, поскольку поток приема сообщений никаких ресурсов не распределяет, а освобождение памяти происходит по завершении процесса. Однако, проблемы возможны в тех случаях, когда потоки распределяют такие ресурсы, как временные файлы. Поэтому окончательное решение должно предусматривать создание глобально доступного списка ресурсов. Тогда участок кода, соответствующий опции DLL_PROCESS_DETACH, мог бы взять на себя просмотр этого списка и освобождение ненужных ресурсов.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: альтернативная стратегия создания безопасных библиотек DLL с много поточной поддержкой</p>
    </title>
    <p>Хотя программа 12.4 и демонстрирует пример типичного объединения TLS и DllMain для создания библиотек, обеспечивающих безопасное многопоточное выполнение, в ней имеется одно слабое место, о котором говорится в комментариях к предыдущему разделу. В частности, "состояние" ассоциируется не с сокетом, а с потоком, поэтому в каждый момент времени любой поток может работать только с одним сокетом.</p>
    <p>Эффективной альтернативой безопасной библиотеке функций является создание структуры, выступающей в качестве своего рода дескриптора, передаваемого при каждом вызове функции. Тогда состояние можно было бы хранить в этой структуре. Во многих системах на основе UNIX эта методика используется для создания безопасных библиотек С, обеспечивающих многопоточную поддержку. Основной недостаток такого подхода заключается в том, что для указания структуры состояния требуется вводить дополнительный параметр при вызове функции.</p>
    <p>Программа 12.5 является видоизмененным вариантом программы 12.4. Заметьте, что DllMain теперь не требуется, но появились две новые функции, предназначенные для инициализации и освобождения ресурсов структуры состояния. Для функций send и receive потребовались лишь самые минимальные изменения. Соответствующая программа сервера, serverSKHA, доступна на Web-сайте книги и содержит лишь незначительные изменения, обеспечивающие создание и закрытие дескриптора сокета (НА означает "handle" — дескриптор).</p>
    <subtitle>Программа 12.5. SendReceiveSKHA: безопасная многопоточная DLL со структурой состояния</subtitle>
    <p><code>/* SendReceiveSKHA.с – многопоточный потоковый сокет. */</code></p>
    <p><code>/* Данная программа представляет собой модифицированную версию программы*/ </code></p>
    <p><code>/* SendReceiveSKST.c, которая иллюстрирует другую методику, основанную */ </code></p>
    <p><code>/* на безопасной библиотеке с многопоточной поддержкой. */ </code></p>
    <p><code>/* Состояние сохраняется не в TLS, а в структуре состояния, напоминающей*/</code></p>
    <p><code>/* дескриптор HANDLE. Благодаря этому поток может использовать сразу */</code></p>
    <p><code>/* несколько сокетов. Сообщения разделяются символами конца строки ('\0')*/</code></p>
    <p><code>#define _NOEXCLUSIONS</code></p>
    <p><code>#include "EvryThng.h"</code></p>
    <p><code>#include "ClntSrvr.h " /* Определяет записи запроса и ответа. */</code></p>
    <empty-line/>
    <p><code>typedef struct SOCKET_HANDLE_T {</code></p>
    <p><code> /* Текущее состояние сокета в структуре "handle". */</code></p>
    <p><code> /* Структура содержит "static_buf_len" символов остаточных данных. */</code></p>
    <p><code> /* Символы конца строки (нулевые символы) могут присутствовать, */</code></p>
    <p><code> /* а могут и не присутствовать. */</code></p>
    <p><code> SOCKET sk; /* Сокет, связанный с указанной структурой "handle". */</code></p>
    <p><code> char static_buf[MAX_RQRS_LEN];</code></p>
    <p><code> LONG32 static_buf_len; </code></p>
    <p><code>} SOCKET_HANDLE, * PSOCKET_HANDLE;</code></p>
    <empty-line/>
    <p><code>/* Функции для создания и закрытия "дескрипторов потоковых сокетов". */</code></p>
    <p><code>_declspec(dllexport)</code></p>
    <p><code>PVOID CreateCSSocketHandle(SOCKET s) {</code></p>
    <p><code> PVOID p;</code></p>
    <p><code> PSOCKET_HANDLE ps;</code></p>
    <p><code> p = malloc(sizeof(SOCKET_HANDLE));</code></p>
    <p><code> if (p == NULL) return NULL;</code></p>
    <p><code> ps = (PSOCKET_HANDLE)p;</code></p>
    <p><code> ps-&gt;sk = s;</code></p>
    <p><code> ps-&gt;static_buf_len = 0; /* Инициализировать состояние буфера. */</code></p>
    <p><code> return p; </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>_declspec(dllexport)</code></p>
    <p><code>BOOL CloseCSSocketHandle(PVOID p) {</code></p>
    <p><code> if (p == NULL) return FALSE;</code></p>
    <p><code> free(p);</code></p>
    <p><code> return TRUE;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>_declspec(dllexport)</code></p>
    <p><code>BOOL ReceiveCSMessage(REQUEST *pRequest, PVOID sh)</code></p>
    <p><code>/* Тип PVOID используется для того, чтобы избежать включения */</code></p>
    <p><code>/* в вызывающую программу определения структуры SOCKET_HANDLE. */</code></p>
    <p><code>{</code></p>
    <p><code> /* Возвращаемое значение TRUE указывает на ошибку или отсоединение. … */</code></p>
    <p><code> PSOCKET_HANDLE p;</code></p>
    <p><code> SOCKET sd;</code></p>
    <p><code> р = (PSOCKET_HANDLE)sh;</code></p>
    <p><code> if (p == NULL) return FALSE;</code></p>
    <p><code> sd = p-&gt;sk; </code></p>
    <p><code> /* Этим исчерпываются все отличия от SendReceiveSKST! … */</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>_declspec(dllexport)</code></p>
    <p><code>BOOL SendCSMessage(RESPONSE *pResponse, PVOID sh) {</code></p>
    <p><code> /* Послать запрос серверу в сокет sd. … */</code></p>
    <p><code> SOCKET sd;</code></p>
    <p><code> PSOCKET_HANDLE p;</code></p>
    <p><code> p = (PSOCKET_HANDLE)sh;</code></p>
    <p><code> if (p == NULL) return FALSE;</code></p>
    <p><code> sd = p-&gt;sk;</code></p>
    <p><code> /* Этим исчерпываются все отличия от SendReceiveSKST! … */ </code></p>
    <p><code>}</code> </p>
   </section>
   <section>
    <title>
     <p>Дейтаграммы</p>
    </title>
    <section>
     <p>Дейтаграммы аналогичны почтовым ящикам и используются при сходных обстоятельствах. Соединение между отправителем и получателем отсутствует, а получателей может быть несколько. Ни почтовые ящики, ни дейтаграммы не гарантируют доставку данных получателю, а последовательные сообщения не обязательно будут получены в той же очередности, в которой они были отправлены.</p>
     <p>Первым шагом при использовании дейтаграмм является создание сокета посредством вызова функции socket с указанием значения SOCK_DGRAM в поле type.</p>
     <p>Далее необходимо использовать функции sendto и recvfrom, которые принимают те же аргументы, что и функции send и recv, но имеют по два дополнительных аргумента, относящихся к станции-партнеру. Так, функция sendto имеет следующий прототип:</p>
     <cite>
      <p><code>int sendto(SOCKET s, LPSTR lpBuffer, int nBufferLen, int nFlags, LPSOCKADDR lpAddr, int nAddrLen);</code> </p>
     </cite>
     <p>lpAddr — указывает на адресную структуру, в которой вы можете задать имя конкретной системы и номер порта или же указать на необходимость рассылки дейтаграммы заданной совокупности систем.</p>
     <p>Используя функцию recvfrom, вы указываете систему или системы (возможно, все), от которых вы хотите принимать дейтаграммы. </p>
    </section>
    <section>
     <title>
      <p>Использование дейтаграмм для удаленного вызова процедур</p>
     </title>
     <p>Обычно дейтаграммы применяются для реализации RPC. По сути дела, в самых распространенных ситуациях клиент посылает запрос серверу, используя дейтаграммы. Поскольку доставка запроса не гарантируется, клиент должен повторно передать запрос, если по истечении заданного периода ожидания ответ от сервера (для посылки которого также используются дейтаграммы) не получен. Сервер должен быть готов к тому, что один и тот же запрос может направляться ему несколько раз.</p>
     <p>Важно отметить, что ни клиенту, ни серверу RPC служебные сигналы, которые, например, необходимы при образовании соединения через потоковый сокет, не требуются; вместо этого они связываются друг с другом посредством запросов и ответов. В качестве дополнительной возможности RPC может гарантировать надежность взаимодействия путем повторной передачи запросов по истечении периода ожидания, что упрощает разработку приложений. Выражаясь иначе, часто говорят о том, что клиент и сервер RPC <emphasis>не имеют состояния</emphasis> (они не хранят никакой информации относительно состояния текущего запроса или запросов, на которые еще не получен ответ). Отсюда следует, что результат обработки на сервере множества идентичных клиентских запросов будет тем же, что и результат обработки одиночного запроса. Это также значительно упрощает проектирование приложений и реализацию их логики.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Сравнение Berkeley Sockets и Windows Sockets</p>
    </title>
    <p>Программы, использующие стандартные вызовы Berkeley Sockets, будут работать и с Windows Sockets, если вы учтете следующие важные моменты:</p>
    <p>• Для инициализации Winsock DLL вы должны вызвать функцию WSAStartup.</p>
    <p>• Для закрытия сокета вы должны использовать не функцию close (которая является переносимой), а функцию closesocket (которая таковой не является).</p>
    <p>• Для закрытия библиотеки DLL вы должны вызвать функцию WSACleanup.</p>
    <p>При желании вы можете использовать типы данных Windows, например, SOCKET и LONG вместо int, как было сделано в этой главе. Программы 12.1 и 12.2 были перенесены из UNIX, и для этого потребовались самые минимальные усилия. Вместе с тем, потребовалось модифицировать DLL и разделы, осуществляющие управление процессами. В упражнении 12.13 вам предлагается перенести эти две программы обратно в UNIX.</p>
   </section>
   <section>
    <title>
     <p>Перекрывающийся ввод/вывод с использованием Windows Sockets</p>
    </title>
    <p>В главе 14 описывается асинхронный ввод/вывод, позволяющий потоку продолжать свое выполнение в процессе выполнения операции ввода/вывода. В той же главе обсуждается и совместное использование сокетов с асинхронным вводом/выводом Windows.</p>
    <p>Большинство задач, связанных с программированием асинхронных операций, можно легко решить, применяя однотипный подход с использованием потоков. Так, в программе serverSK вместо неблокирующегося сокета используется принимающий поток (accept thread). Тем не менее, порты завершения ввода/вывода, связанные с асинхронным вводом/выводом, играют важную роль в обеспечении масштабируемости в случае большого количества клиентов. Эта тема также рассматривается в главе 14.</p>
   </section>
   <section>
    <title>
     <p>Windows Sockets 2</p>
    </title>
    <p>Версия Windows Sockets 2 вводит новые сферы функциональности и доступна на всех системах Windows, хотя системы Windows 9x требуют установки пакета обновления. В примерах использована версия 2.0, но можно применять и версию 1.1, если требуется совместимость с необновленными системами Windows 9х. Кроме того, возможностей версии 1.1 в большинстве случаев вам будет вполне достаточно. Версия Windows Sockets 2.0 обеспечивает, в частности, следующие возможности:</p>
    <p>• Стандартизованная поддержка перекрывающегося ввода/вывода (см. главу 14). Эту возможность можно считать самым важным усовершенствованием.</p>
    <p>• Фрагментированный ввод/вывод (scatter/gather I/O) (при посылке и получении данных используются буферы, расположенные в памяти вразброс).</p>
    <p>• Возможность запрашивать качество обслуживания (скорость и надежность передачи информации).</p>
    <p>• Возможность групповой организации сокетов. Допускается конфигурирование качества обслуживания группы сокетов, поэтому можно не делать этого для каждого сокета по отдельности. Кроме того, входящим в группу сокетам можно назначать приоритеты.</p>
    <p>• Имеется возможность совмещения передачи прямых и обратных пакетов с запросами соединения (piggybacking).</p>
    <p>• Создание многоточечных соединений (multipoint connections) (сопоставимо с подключениями по типу конференц-связи).</p>
   </section>
   <section>
    <title>
     <p>Резюме</p>
    </title>
    <section>
     <p>Интерфейс Windows Sockets предоставляет возможность использования API, отвечающего требованиям промышленного стандарта, что гарантирует работу ваших программ на различном оборудовании и почти полную переносимость на уровне исходного кода. Winsock способен поддержать практически любой сетевой протокол, однако в большинстве случаев применяется протокол TCP/IP.</p>
     <p>Winsock сопоставим с именованными каналами (и почтовыми ящиками) как в отношении функциональных возможностей, так и в отношении производительности, в наибольшей степени проявляя свои преимущества в тех случаях, когда на первый план выступают вопросы совместимости и переносимости программного обеспечения. Имейте в виду, что сокеты ввода/вывода не являются атомарными, поэтому необходимо специально заботиться о том, чтобы сообщения передавались полностью.</p>
     <p>В этой главе были изложены наиболее существенные сведения о Winsock, которых достаточно для построения работоспособной системы. Вместе с тем, за рамками нашего рассмотрения осталось очень многое, в том числе и применение Winsock в асинхронных операциях; для получения более подробной информации по этому вопросу обратитесь к источникам, указанным в разделе "Дополнительная литература".</p>
     <p>Кроме того, в этой главе были приведены примеры использования библиотек DLL для реализации внутрипроцессных серверов и создания безопасных в отношении многопоточного выполнения библиотек.</p>
    </section>
    <section>
     <title>
      <p>В следующих главах</p>
     </title>
     <p>В главах 11 и 12 было показано, как разрабатывать серверы, отвечающие на запросы клиентов. Серверы, в их различных воплощениях, являются распространенным типом приложений Windows. В главе 13 описываются службы Windows (Windows Services), которые обеспечивают стандартный способ создания серверов и управления ими в виде служб, что дает возможность организовать их запуск, остановку и мониторинг в автоматическом режиме. В главе 13 показано, как превратить сервер в управляемую службу.</p>
    </section>
    <section>
     <title>
      <p>Дополнительная литература</p>
     </title>
     <subtitle><emphasis>Windows Sockets</emphasis></subtitle>
     <p>Сокетам Windows посвящена книга [28], а также сайт поддержки http://www.sockets.com. Однако указанная книга во многих аспектах устарела, и в ней не используются потоки. Более полезными для многих читателей будут книги, которые упоминаются ниже. </p>
     <subtitle><emphasis>Berkeley Sockets и TCP/IP</emphasis></subtitle>
     <p>В книге [41] рассмотрены не только сокеты, но и многое другое, тогда как в первых двух томах этой серии описаны протоколы и их реализация. Исчерпывающее рассмотрение интересующего нас вопроса содержится в книге [42], которая представляет ценность даже для тех, кто имеет дело с другими семействами ОС. Среди источников, заслуживающих внимания, можно назвать [8] и [12].</p>
    </section>
   </section>
   <section>
    <title>
     <p>Упражнения</p>
    </title>
    <p>12.1. Используя функцию WSAStartup, определите старший и младший номера версий Winsock, поддерживаемые на доступных вам системах.</p>
    <p>12.2. Используйте программу JobShell из главы 6 для запуска сервера и нескольких клиентов, причем каждый клиент должен создаваться с опцией "отсоединения" (-d). Для окончания работы остановите сервер, послав сигнал управляющего события консоли посредством команды kill. Можете ли вы предложить какие-либо улучшения в организации остановки сервера в программе serverSK.</p>
    <p>12.3. Модифицируйте программы клиента и сервера (программы 12.1 и 12.2) таким образом, чтобы для обнаружения сервера использовались дейтаграммы. В качестве отправной точки может быть использовано решение на основе почтового ящика из главы 11.</p>
    <p>12.4. Модифицируйте сервер именованного канала из главы 11 (программа 11.3) таким образом, чтобы в нем использовались не потоки из пула потоков сервера, а потоки, создаваемые по требованию. Вместо предварительного указания максимально допустимого количества экземпляров именованного канала предоставьте системе возможность самостоятельно определять максимальное значение этого параметра.</p>
    <p>12.5. Проведите эксперименты, чтобы определить, действительно ли внутрипроцессные серверы работают быстрее внепроцессных. Для этого, например, может быть использована программа подсчета слов (программа 12.3); имеется исполняемый файл этой программы (wc), а также функция библиотеки DLL, представленная в программе 12.3.</p>
    <p>12.6. Количество клиентов, поддержку которых может обеспечить программа serverSK, ограничивается размером массива аргументов потоков сервера. Модифицируйте программу, сняв это ограничение. Для этого вам потребуется создать структуру данных, позволяющую добавлять и удалять аргументы потоков, а также обеспечить возможность просмотра структуры с целью отслеживания потоков сервера, завершивших выполнение.</p>
    <p>12.7. Разработайте внутрипроцессные серверы другого рода. Например, с этой целью преобразуйте соответствующим образом программу grep (см. главу 6). </p>
    <p>12.8. Усовершенствуйте сервер (программа 12.2) таким образом, чтобы можно было указывать несколько библиотек DLL в командной строке. Если разместить все DLL в памяти невозможно, разработайте стратегию их загрузки и выгрузки.</p>
    <p>12.9. Исследуйте функцию setsockopt и использование опции SO_LINGER. Примените указанную опцию в одном из примеров сервера.</p>
    <p>12.10. Используйте возможности фрагментированного ввода/вывода Windows Sockets 2.0 для упрощения функций отправки и приема сообщений в программах 12.1 и 12.2.</p>
    <p>12.11. Обеспечьте невозможность утечки ресурсов в программе serverSK (за дополнительными разъяснениями обратитесь к упражнению 11.8). Проделайте то же самое с программой serverSKST, которая была модифицирована для использования DLL в программе 12.4.</p>
    <p>12.12. Расширьте возможности обработчика исключений в программе 12.3 таким образом, чтобы он заносил информацию об исключении и типе исключения в конец временного файла, используемого для сохранения результатов работы сервера.</p>
    <p>12.13. <emphasis>Расширенное упражнение (требуется дополнительное оборудование).</emphasis> Если у вас имеется доступ к UNIX-системе, связанной через сеть с Windows-системой, перенесите на UNIX-систему программу clientSK и попытайтесь, получив с ее помощью доступ к программе serverSK, запускать различные Windows-программы. Разумеется, при этом вам придется преобразовать такие типы данных, как DWORD или SOCKET, в другие типы (в данном случае, соответственно, в unsigned int и int). Кроме того, вы должны убедиться в том, что данные, образующие сообщения, передаются в формате с обратным порядком байтов. Для выполнения соответствующих преобразований данных используйте такие функции, как htonl. Наконец, перенесите в UNIX программу serverSK, чтобы Windows-системы могли выполнять команды в UNIX. Преобразуйте вызов DLL в вызовы функций разделяемой библиотеки.</p>
    <p>12.14. Ознакомьтесь с протоколом защищенных сокетов (Secure Sockets Layer, SSL), обратившись к материалам MSDN или источникам, указанным в разделе "Дополнительная литература". Усовершенствуйте программы, применив SSL для обеспечения безопасности связи клиента с сервером.s </p>
   </section>
  </section>
  <section>
   <title>
    <p>ГЛАВА 13</p>
    <p>Windows Services</p>
   </title>
   <section>
    <p>Серверные программы, рассмотренные в главах 11 и 12, являются консольными приложениями, выполняющимися как фоновые задачи. Вообще говоря, эти серверы могут выполняться в течение неопределенно длительного времени, обслуживая многочисленных клиентов по мере того, как те будут подключаться к серверу, посылать запросы, принимать ответы и разрывать соединения. Таким образом, указанные серверы могут работать как службы непрерывного действия, однако, чтобы быть в полной мере эффективными, эти службы должны быть управляемыми.</p>
    <p>Службы Windows Services,<a l:href="#n_33" type="note">[33]</a> известные ранее под названием NT Services, предоставляют все средства управления, необходимые для превращения наших серверов в службы, которые могут активизироваться по команде или во время запуска системы еще до входа в нее пользователей, приостанавливаться, а также возобновлять или прекращать свое выполнение. Службы могут даже осуществлять мониторинг работоспособности самих служб. Информация о службах хранится в системном реестре.</p>
    <p>В конечном счете, любая серверная система наподобие тех, которые были разработаны в главах 11 и 12, должна быть преобразована в службу, особенно в тех случаях, когда она предназначена для использования широким кругом клиентов или внутри организации.</p>
    <p>Windows предоставляет целый ряд служб; в качестве примера можно привести службы telnet, отправки и приема факсимильных сообщений, а также службы управления безопасностью учетных записей и драйверы устройств. Доступ ко всем службам можно получить через пиктограмму Administrative Tools (Администрирование), который находится в окне панели управления.</p>
    <p>Примитивную форму управления сервером можно было наблюдать в приведенной в главе 6 программе JobShell (программа 6.3), которая обеспечивает возможность перевода сервера под управление задачи и его остановку путем посылки сигнала завершения работы. В то же время, службы Windows Services предоставляют гораздо более широкие возможности и отличаются высокой надежностью, как это будет продемонстрировано в данной главе на примере преобразования программы к форме, обеспечивающей управление службами Windows Services.</p>
    <p>В данной главе также показано, как преобразовать существующее консольное приложение в службу Windows, осуществить ее установку, а также организовать мониторинг и управление этой службой. Кроме того, здесь рассматривается ведение журнала учета событий, что обеспечивает регистрацию действий службы.</p>
   </section>
   <section>
    <title>
     <p>Написание программ, реализующихслужбы Windows Services: обзор</p>
    </title>
    <p>Службы Windows выполняются под управлением диспетчера управления службами (Service Control Manager, SCM). Преобразование консольного приложения, такого как serverNP или serverSK, в службу Windows осуществляется в три этапа, после выполнения которых программа переходит под управление SCM.</p>
    <p>1. Создание новой точки входа main(), которая регистрирует службу в SCM, предоставляя точки входа и имена логических служб.</p>
    <p>2. Преобразование прежней функции точки входа main() в функцию <emphasis>ServiceMain</emphasis>(), которая регистрирует обработчик управляющих команд службы и информирует SCM о своем состоянии. Остальная часть кода, по существу, сохраняет прежний вид, хотя и может быть дополнена командами регистрации событий. Имя <emphasis>ServiceMain</emphasis>() является заменителем имени логической службы, причем логических служб может быть несколько.</p>
    <p>3. Написание функции обработчика управляющих команд службы, которая должна предпринимать определенные действия в ответ на команды, поступающие от SCM.</p>
    <p>По мере описания каждого из этих трех этапов будут даваться отдельные разъяснения, касающиеся создания служб, их запуска и управления ими. Более подробные сведения приводятся в последующих разделах, а взаимодействие между отдельными компонентами службы иллюстрируется на рис. 13.1 далее в этой главе.</p>
   </section>
   <section>
    <title>
     <p>Функция main()</p>
    </title>
    <p>Задачей новой функции main(), которая вызывается SCM, является регистрация службы в SCM и запуск диспетчера службы (service control dispatcher). Для этого необходимо вызвать функцию StartServiceControlDispatcher, передав ей имя (имена) и точку (точки) входа одной или нескольких логических служб.</p>
    <cite>
     <p><code>BOOL StartServiceCtrlDispatcher(LPSERVICE_TABLE_ENTRY <emphasis>lpServiceStartTable</emphasis>)</code></p>
    </cite>
    <p>Эта функция принимает единственный аргумент <emphasis>lpServiceStartTable, </emphasis>являющийся адресом массива элементов SERVICE_TABLE_ENTRY, каждый из которых представляет имя и точку входа логической службы. Конец массива обозначается двумя последовательными значениями NULL.</p>
    <p>Функция возвращает значение TRUE, если регистрация службы прошла успешно. Если служба уже выполняется или возникают проблемы с обновлением записей реестра (HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services), функция завершается с ошибками, обработка которых может осуществляться обычным путем.</p>
    <p>Основной поток процесса службы, которая вызывает функцию StartService-ControlDispatcher, связывает поток с SCM. SCM регистрирует службу с вызывающим потоком в качестве потока диспетчера службы. SCM не осуществляет возврата в вызывающий поток до тех пор, пока не завершат выполнение все службы. Заметьте, однако, что фактического запуска логических служб в этот момент не происходит; запуск службы требует вызова функции StartService, которая описывается далее в этой главе.</p>
    <p>Типичная основная программа службы, соответствующая случаю единственной логической службы, представлена в программе 13.1.</p>
    <subtitle>Программа 13.1. main: точка входа main службы </subtitle>
    <p><code>#include "EvryThng.h"</code></p>
    <empty-line/>
    <p><code>void WINAPI ServiceMain(DWORD argc, LPTSTR argv[]);</code></p>
    <empty-line/>
    <p><code>static LPTSTR ServiceName = _T("SocketCommandLineService");</code></p>
    <empty-line/>
    <p><code>/* Главная программа запуска диспетчера службы. */</code></p>
    <p><code>VOID _tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> SERVICE_TABLE_ENTRY DispatchTable[] = {</code></p>
    <p><code>  { ServiceName, ServiceMain },</code></p>
    <p><code>  { NULL, NULL }</code></p>
    <p><code> };</code></p>
    <empty-line/>
    <p><code> if (!StartServiceCtrlDispatcher(DispatchTable)) ReportError(_T("Ошибка при запуске диспетчера службы."), 1, TRUE);</code></p>
    <p><code> /* ServiceMain() начнет выполняться только после того, как ее */</code></p>
    <p><code> /* запустит SCM. Возврат сюда осуществляется только после того, */</code></p>
    <p><code> /* как завершится выполнение всех служб. */</code></p>
    <p><code> return;</code></p>
    <p><code>}</code> </p>
   </section>
   <section>
    <title>
     <p>Функции ServiceMain()</p>
    </title>
    <section>
     <p>Эти функции, которые указываются в таблице диспетчеризации, фигурирующей в программе 13.1, представляют логические службы. По сути, эти функции являются усовершенствованными версиями основной программы, преобразуемой в службу, и каждая логическая служба будет активизироваться в ее собственном потоке SCM. В свою очередь, логическая служба может запускать дополнительные потоки, например, рабочие потоки сервера, которые использовались в программах serverSK и serverNP. Часто внутри службы существует только одна логическая служба. Логическая служба в программе 13.2 получена путем соответствующей адаптации основного сервера из программы 12.2. В то же время, логические службы на основе сокетов и именованных каналов могут выполняться в рамках одной и той же службы Windows, что потребует предоставления основных функций обеих служб.</p>
     <p>Несмотря на то что функция <emphasis>ServiceMain</emphasis>() является адаптированным вариантом функции main() с ее параметрами, представляющими количество аргументов и содержащую их строку, между ними имеется одно незначительное отличие: функция службы должна быть объявлена с типом void, а не иметь возвращаемое значение типа int, как в случае обычной функции main().</p>
     <p>Для регистрации обработчика управляющих команд службы, который представляет собой функцию, вызываемую SCM для осуществления управления службой, требуется дополнительный код.</p>
    </section>
    <section>
     <title>
      <p>Регистрация управляющей программы службы</p>
     </title>
     <p>Обработчик управляющих команд службы, вызываемый SCM, должен обеспечивать управление соответствующей логической службой. Возможности обработчиков такого рода в ограниченном виде иллюстрирует обработчик управляющих сигналов консоли в сервере serverSK, устанавливающий глобальный флаг завершения выполнения. Однако, прежде всего, каждая логическая служба должна немедленно зарегистрировать свой обработчик с помощью функции RegisterServiceCtrlHandlerEx. Вызов этой функции должен помещаться в начало функции <emphasis>ServiceMain</emphasis>() и впоследствии нигде не повторяться. Обработчик вызывается SCM после получения запроса службы. </p>
     <cite>
      <p><code>RegisterServiceCtrlHandlerEx(LPCTSTR lpServiceName, LPHANDLER_FUNCTION_EX lpHandlerProc, LPVOID lpContext)</code> </p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>lpServiceName — определяемое пользователем имя службы, которое предоставляется в соответствующем поле таблицы диспетчеризации, отведенном для данной логической функции.</p>
     <p>lpHandlerProc — адрес функции расширенного обработчика, которая описывается в следующем разделе. Расширенный обработчик был добавлен в NT5, причем функция RegisterServiceCtrlHandlerEx заменяет функцию Register-ServiceCtrlHandler. Следующий параметр также был введен в NT5.</p>
     <p>lpContext — определяемые пользователем данные, передаваемые обработчику. Благодаря этому обработчик может различать ассоциированные с ним службы, которых может быть несколько.</p>
     <p>В случае ошибки возвращаемое функцией значение, которым является объект SEPARARE_STATUS_HANDLE, равно 0, а для анализа ошибок могут быть использованы обычные методы.</p>
    </section>
    <section>
     <title>
      <p>Настройка состояния службы</p>
     </title>
     <p>Теперь, когда управляющая программа зарегистрирована, необходимо сразу же перевести службу в состояние SERVICE_START_PENDING, воспользовавшись для этого функцией SetServiceStatus. Функция SetServiceStatus будет применяться еще в других местах для установки различных значений параметра состояния, информируя SCM о текущем состоянии службы. Описания других возможных состояний службы, характеризуемых значениями параметра состояния, отличными от SERVICE_STATUS_PENDING, приведены в табл. 13.3.</p>
     <p>Обработчик службы должен устанавливать состояние службы при каждом вызове, даже если ее состояние не менялось.</p>
     <p>Далее, любой из потоков службы может в любой момент вызвать функцию SetServiceStatus, чтобы сообщить данные, характеризующие степень выполнения задачи, а также предоставить информацию об ошибках или иную информацию, причем для периодического обновления состояния многие службы часто выделяют отдельный поток. Длительность временного промежутка между вызовами обновления состояния указывается в одном из полей структуры данных, выступающей в качестве параметра. Если в пределах указанного промежутка времени состояние не обновлялось, то SCM может предположить, что произошла ошибка. </p>
     <cite>
      <p><code>BOOL SetServiceStatus(SERVICE_STATUS_HANDLE hServiceStatus, LPSERVICE STATUS lpServiceStatus)</code> </p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>hServiceStatus — дескриптор типа SERVICE_STATUS_HANDLE, возвращенный функцией RegisterCtrlHandlerEx. Поэтому вызову функции SetServiceStatus должен предшествовать вызов функции RegisterCtrlHandlerEx.</p>
     <p>lpServiceStatus — указатель на структуру SERVICE_STATUS, содержащую описание свойств, состояния и возможностей службы.</p>
    </section>
    <section>
     <title>
      <p>Структура SERVICE_STATUS</p>
     </title>
     <p>Ниже приведено определение структуры SERVICE_STATUS. </p>
     <cite>
      <p><code>typedef struct _SERVICE_STATUS {</code></p>
      <p><code> DWORD dwServiceType;</code></p>
      <p><code> DWORD dwCurrentState;</code></p>
      <p><code> DWORD dwControlsAccepted;</code></p>
      <p><code> DWORD dwWin32ExitCode;</code></p>
      <p><code> DWORD dwServiceSpecificExitCode;</code></p>
      <p><code> DWORD dwCheckPoint;</code></p>
      <p><code> DWORD dwWaitHint; </code></p>
      <p><code>} SERVICE_STATUS, *LPSERVICE_STATUS;</code> </p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>dwWin32ExitCode — обычный код завершения потока, используемый логической службой. Служба должна установить этот код равным NO_ERROR в процессе выполнения и при нормальном завершении.</p>
     <p>dwServiceSpecificExitCode — может использоваться в качестве кода завершения, когда ошибка возникает при запуске или остановке службы, но это значение игнорируется, если значение параметра dwWin32ExitCode не было установлено равным ERROR_SERVICE_SPECIFIC_ERROR.</p>
     <p>dwCheckPoint — служба должна периодически увеличивать значение этого параметра для индикации выполнения на всех стадиях, включая стадии инициализации и остановки. Этот параметр не действует и должен устанавливаться равным 0, если служба не находится в состоянии запуска, остановки, паузы и не выполняет никаких длительных операций.</p>
     <p>dwWaitHint — ожидаемая длительность интервалов времени (в миллисекундах) между последовательными вызовами функции SetServiceStatus, осуществляемыми с увеличенным значением параметра dwCheckPoint или измененным значением параметра dwCurrentState. Как уже отмечалось ранее, если на протяжении этого промежутка времени вызова функции SetServiceStatus не происходит, то SCM предполагает, что это вызвано возникновением ошибки.</p>
     <p>Остальные элементы структуры SERVICE_STATUS обсуждаются ниже по отдельности. </p>
     <subtitle><emphasis>Тип службы</emphasis></subtitle>
     <p>Параметр dwServiceType должен иметь одно из значений, описанных в таблице 13.1.</p>
     <p>В наших примерах в качестве типа службы почти всегда будет предполагаться тип SERVICE_WIN32_OWN_PROCESS, но из приведенных в таблице значений видно, что службы могут играть множество различных ролей.</p>
     <empty-line/>
     <p>Таблица 13.1. Типы служб </p>
     <table>
      <tr align="left">
       <th align="left" valign="top">Значение </th>
       <th align="left" valign="top">Описание</th>
      </tr>
      <tr align="left">
       <td align="left" valign="top">SERVICE WIN32 OWN PROCESS</td>
       <td align="left" valign="top">Указывает на службу Windows, выполняющуюся в собственном процессе с собственными ресурсами. <emphasis>Используется в программе 13.2.</emphasis></td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">SERVICE_WIN32_SHARE_PROCESS</td>
       <td align="left" valign="top">Указывает на службу Windows, разделяющую процесс с другими службами, в результате чего несколько служб могут совместно использовать одни и те же ресурсы, переменные окружения и так далее.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">SERVICE_KERNEL_DRIVER</td>
       <td align="left" valign="top">Указывает на драйвер устройства Windows.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">SERVICE_FILE_SYSTEM_DRIVER</td>
       <td align="left" valign="top">Определяет драйвер файловой системы Windows.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">SERVICE_INTERACTIVE_PROCESS</td>
       <td align="left" valign="top">Указывает на процесс службы Windows, который может взаимодействовать с пользователем через рабочий стол.</td>
      </tr>
     </table>
     <subtitle><emphasis>Состояние службы</emphasis></subtitle>
     <p>Значение параметра dwCurrentState указывает на текущее состояние службы. Возможные значения этого параметра перечислены в табл. 13.2.</p>
     <empty-line/>
     <p>Таблица 13.2. Значения параметра состояния службы</p>
     <table>
      <tr align="left">
       <th align="left" valign="top">Значение</th>
       <th align="left" valign="top">Описание</th>
      </tr>
      <tr align="left">
       <td align="left" valign="top">SERVICE_STOPPED</td>
       <td align="left" valign="top">Служба не выполняется.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">SERVICE_START_PENDING</td>
       <td align="left" valign="top">Служба находится на стадии запуска, но пока не готова отвечать на запросы. Например, могут еще не быть запущены рабочие потоки.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">SERVICE_STOP_PENDING</td>
       <td align="left" valign="top">Служба находится на стадии остановки, но еще не завершила своего выполнения. Например, мог быть установлен глобальный флаг завершения, но рабочие потоки еще не успели на это отреагировать.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">SERVICE_RUNNING</td>
       <td align="left" valign="top">Служба выполняется.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">SERVICE CONTINUE_PENDING</td>
       <td align="left" valign="top">Служба переходит в состояние выполнения после нахождения в состоянии паузы.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">SERVICE_PAUSE_PENDING</td>
       <td align="left" valign="top">Служба переходит в состояние паузы, но ее безопасное нахождение в этом состоянии пока не обеспечено.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">SERVICE PAUSED</td>
       <td align="left" valign="top">Служба находится в состоянии паузы.</td>
      </tr>
     </table>
     <subtitle><emphasis>Воспринимаемые управляющие коды</emphasis></subtitle>
     <p>Параметр dwControlsAccepted определяет управляющие коды, которые служба будет воспринимать и обрабатывать с помощью своего обработчика (см. следующий раздел). В табл. 13.3 указаны четыре возможных значения, которые могут объединяться посредством операции поразрядного "или" (|). Версия программы serverSK, которую мы впоследствии разработаем, будет воспринимать лишь три первых значения. Дополнительные значения приведены в разделе MSDN, содержащем описание структуры SERVICE_STATUS.</p>
     <empty-line/>
     <p>Таблица 13.3. Коды, воспринимаемые службой (неполный перечень) </p>
     <table>
      <tr align="left">
       <th align="left" valign="top">Значение</th>
       <th align="left" valign="top">Описание</th>
      </tr>
      <tr align="left">
       <td align="left" valign="top">SERVICE_ACCEPT_STOP</td>
       <td align="left" valign="top">Разрешает посылку команды SERVICE_CONTROL_STOP.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">SERVICE_ACCEPT_PAUSE_CONTINUE</td>
       <td align="left" valign="top">Разрешает посылку команд SERVICE_CONTROL_PAUSE и SERVICE_CONTROL_CONTINUE.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">SERVICE_ACCEPT_SHUTDOWN</td>
       <td align="left" valign="top">Уведомляет службу о прекращении работы системы. Это дает системе возможность послать службе команду SERVICE_CONTROL_SHUTDOWN.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">SERVICE_ACCEPT_PARAMCHANGE</td>
       <td align="left" valign="top">Требуется NT5. Обеспечивает изменение параметров запуска без выполнения самого перезапуска. Соответствующей командой является SERVICE_CONTROL_PARAMCHANGE </td>
      </tr>
     </table>
    </section>
    <section>
     <title>
      <p>Специфический для службы код</p>
     </title>
     <p>После того как обработчик зарегистрирован и для службы установлено состояние SERVICE_START_PENDING, служба может инициализировать себя и вновь установить свое состояние. Если говорить о преобразованной версии serverSK, то сразу же после того, как сокеты будут инициализированы, а сервер готов к работе с клиентами, должно быть установлено состояние SERVICE_RUNNING.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Обработчик управляющих команд службы</p>
    </title>
    <p>Обработчик управляющих команд службы, то есть функция косвенного вызова, определяемая с помощью функции RegisterServiceCtrlHandlerEx, имеет следующий прототип: </p>
    <cite>
     <p><code>DWORD WINAPI HandlerEx(DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext)</code> </p>
    </cite>
    <p>dwControl — обозначает фактическую управляющую команду, поступившую в обработчик от SCM. До появления NT5 и введения функции RegisterServiceCtrlHandlerEx этот параметр был единственным параметром обработчика.</p>
    <p>Всего существует 14 возможных значений параметра dwControl, включая те, которые перечислены в табл. 13.3, хотя некоторые команды поддерживаются только в NT5 или XP. Нас будут интересовать следующие значения, которые используются в примере:</p>
    <p><code>SERVICE_CONTROL_STOP</code></p>
    <p><code>SERVICE_CONTROL_PAUSE</code></p>
    <p><code>SERVICE_CONTROL_CONTINUE</code></p>
    <p><code>SERVICE_CONTROL_INTERROGATE</code></p>
    <p><code>SERVICE_CONTROL_SHUTDOWN</code></p>
    <p>Разрешены также пользовательские значения, определяемые в интервале 128-255, однако нам они не понадобятся.</p>
    <p>dwEventType — обычно принимает значение 0, в то время как ненулевые значения используются для управления устройствами, но рассмотрение этого вопроса выходит за рамки данной книги. Параметр dwEventType определяет дополнительную информацию, которая требуется соответствующим событиям.</p>
    <p>Наконец, lpContext — пользовательские данные, передаваемые в функцию RegisterServiceCtrlHandlerEx во время регистрации обработчика.</p>
    <p>Обработчик активизируется SCM в том же потоке, что и основная программа, и обычно содержит ряд операторов switch, как будет показано в приведенных ниже примерах.</p>
   </section>
   <section>
    <title>
     <p>Пример: "интерфейсная оболочка" службы</p>
    </title>
    <p>Программа 13.2 реализует преобразованный вариант программы serverSK, который мы перед этим обсуждали. Преобразование сервера в службу сопряжено с решением всех ранее описанных задач. После внесения незначительных изменений существующий код сервера помещается в функцию ServiceSpecific. Поэтому представленный ниже код, по сути, является оболочкой (wrapper) существующей программы сервера, точка входа которой main заменена на ServiceSpecifiс.</p>
    <p>Другим дополнением, которое здесь не представлено, но включено в вариант программы, находящийся на Web-сайте книги, является использование журнала службы, поскольку службы часто запускаются без интерактивной консоли, никак себя видимо не проявляя. </p>
    <subtitle>Программа 13.2. SimpleService: оболочка службы </subtitle>
    <p><code>/* Глава 13. serviceSK.c</code></p>
    <p><code>   Преобразование сервера serverSK в службу Windows.</code></p>
    <p><code>   Несмотря на рассмотрение частного случая, оболочка имеет универсальный характер. */</code></p>
    <empty-line/>
    <p><code>#include "EvryThng.h" </code></p>
    <p><code>#include "ClntSrvr.h" </code></p>
    <p><code>#define UPDATE_TIME 1000 /* Интервал обновления – 1 секунда. */</code></p>
    <empty-line/>
    <p><code>VOID LogEvent(LPCTSTR, DWORD, BOOL);</code></p>
    <p><code>void WINAPI ServiceMain(DWORD argc, LPTSTR argv[]);</code></p>
    <p><code>VOID WINAPI ServerCtrlHandlerEx(DWORD; DWORD, LPVOID, LPVOID);</code></p>
    <p><code>void UpdateStatus (int, int); /* Вызывает, функцию SetServiceStatus. */</code></p>
    <p><code>int ServiceSpecific (int, LPTSTR *); /* Ранее программа main. */</code></p>
    <p><code>volatile static BOOL ShutDown = FALSE, PauseFlag = FALSE;</code></p>
    <p><code>static SERVICE_STATUS hServStatus;</code></p>
    <p><code>static SERVICE_STATUS_HANDLE hSStat; /* Дескриптор, используемый при установке состояния. */</code></p>
    <empty-line/>
    <p><code>static LPTSTR ServiceName = _T("SocketCommandLineService");</code></p>
    <p><code>static LPTSTR LogFileName = _T("CommandLineServiceLog.txt");</code></p>
    <empty-line/>
    <p><code>/* Основная процедура, запускающая диспетчер управления службой. */</code></p>
    <p><code>VOID _tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> SERVICE_TABLE_ENTRY DispatchTable[] = {</code></p>
    <p><code>  { ServiceName, ServiceMain }, { NULL, NULL }</code></p>
    <p><code> };</code></p>
    <p><code> StartServiceCtrlDispatcher(DispatchTable);</code></p>
    <p><code> return 0; </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* Точка входа ServiceMain, вызываемая при создании службы. */</code></p>
    <p><code>void WINAPI ServiceMain(DWORD argc, LPTSTR argv[]) {</code></p>
    <p><code> DWORD i, Context = 1;</code></p>
    <p><code> /* Установить текущий каталог и открыть файл журнала, присоединяемый к существующему файлу. */</code></p>
    <p><code> /* Определить все элементы структуры состояния сервера. */</code></p>
    <p><code> hServStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;</code></p>
    <p><code> hServStatus.dwCurrentState = SERVICE_START_PENDING;</code></p>
    <p><code> hServStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN | SERVICE_ACCEPT_PAUSE_CONTINUE;</code></p>
    <p><code> hServStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIF0C_ERROR;</code></p>
    <p><code> hServStatus.dwServiceSpecificExitCode = 0;</code></p>
    <p><code> hServStatus.dwCheckPoint = 0;</code></p>
    <p><code> hServStatus.dwWaitHint = 2 * CS_TIMEOUT;</code></p>
    <p><code> hSStat = RegisterServiceCtrlHandlerEx(ServiceName, ServerCtrlHandler, &amp;Context); </code></p>
    <p><code> SetServiceStatus(hSStat, &amp;hServStatus);</code></p>
    <p><code> /* Запустить специфическую для службы обработку; выполнение типового участка кода завершено. */</code></p>
    <p><code> if (ServiceSpecific(argc, argv) != 0) {</code></p>
    <p><code>  hServStatus.dwCurrentState = SERVICE_STOPPED;</code></p>
    <p><code>  hServStatus.dwServiceSpecificExitCode = 1;</code></p>
    <p><code>  /* Ошибка при инициализации сервера. */</code></p>
    <p><code>  SetServiceStatus(hSStat, &amp;hServStatus);</code></p>
    <p><code>  return;</code></p>
    <p><code> }</code></p>
    <p><code> /* Возврат сюда будет осуществлен лишь после завершения функции ServiceSpecific, указывающего на прекращение работы системы. */</code></p>
    <p><code> UpdateStatus(SERVICE_STOPPED, 0);</code></p>
    <p><code> return;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>void UpdateStatus(int NewStatus, int Check)</code></p>
    <p><code>/* Определить новое состояние и контрольную точку — задается либо истинное значение, либо приращение. */ </code></p>
    <p><code>{</code></p>
    <p><code> if (Check &lt; 0) hServStatus.dwCheckPoint++;</code></p>
    <p><code> else hServStatus.dwCheckPoint = Check;</code></p>
    <p><code> if (NewStatus &gt;= 0) hServStatus.dwCurrentState = NewStatus;</code></p>
    <p><code> SetServiceStatus(hSStat, &amp;hServStatus);</code></p>
    <p><code> return; </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* Функция обработчика, активизируемая SCM для выполнения в том же */</code></p>
    <p><code>/* потоке, что и основная программа. */</code></p>
    <p><code>/* Последние три параметра не используются, так что обработчики, написанные*/</code></p>
    <p><code>/* для версий Windows младше NT5, в этом примере также будут работать. */</code></p>
    <p><code>VOID WINAPI ServerCtrlHandlerEx(DWORD Control, DWORD EventType, LPVOID lpEventData, LPVOID lpContext) {</code></p>
    <p><code> switch (Control) {</code></p>
    <p><code> case SERVICE_CONTROL_SHUTDOWN:</code></p>
    <p><code> case SERVICE_CONTROL_STOP:</code></p>
    <p><code>  ShutDown = TRUE; /* Установить глобальный флаг завершения. */</code></p>
    <p><code>  UpdateStatus(SERVICE_STOP_PENDING, –1);</code></p>
    <p><code>  break;</code></p>
    <p><code> case SERVICE_CONTROL_PAUSE:</code></p>
    <p><code>  PauseFlag = TRUE; /* Периодический опрос. */</code></p>
    <p><code>  break;</code></p>
    <p><code> case SERVICE_CONTROL_CONTINUE:</code></p>
    <p><code>  PauseFlag = FALSE;</code></p>
    <p><code>  break;</code></p>
    <p><code> case SERVICE_CONTROL_INTERROGATE:</code></p>
    <p><code>  break;</code></p>
    <p><code> default:</code></p>
    <p><code>  if (Control &gt; 127 &amp;&amp; Control &lt; 256) /*Пользовательские сигналы.*/ </code></p>
    <p><code>   break;</code></p>
    <p><code> }</code></p>
    <p><code> UpdateStatus(-1, –1); /* Инкрементировать контрольную точку. */</code></p>
    <p><code> return; </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* Эта специфическая для службы функция играет роль функции "main" и вызывается из более общей функции ServiceMain. Вообще говоря, вы можете взять любой сервер, например ServerNP.c, и поместить его код прямо сюда, переименовав функцию "main" в "ServiceSpecific". Однако для кода обновления состояния потребуются некоторые изменения. */</code></p>
    <p><code>int ServiceSpecific(int argc, LPTSTR argv[]) {</code></p>
    <p><code> UpdateStatus(-1, –1); /* Инкрементировать контрольную точку. */</code></p>
    <p><code> /* … Инициализация системы … */</code></p>
    <p><code> /* Обеспечьте периодическое обновление контрольной точки. */</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code> </p>
   </section>
   <section>
    <title>
     <p>Управление службами Windows</p>
    </title>
    <section>
     <p>Следующее, что потребуется сделать после написания кода службы — поместить ее под управление SCM, что позволит запускать и останавливать службу, а также осуществлять любые иные формы управления, какие только могут понадобиться.</p>
     <p>Для этого необходимо выполнить несколько шагов, включая открытие SCM, создание службы под управлением SCM и последующий ее запуск. При этом вы воздействуете не непосредственно на службу, а на SCM, который, в свою очередь, и осуществляет управление заданной службой.</p>
    </section>
    <section>
     <title>
      <p>Открытие SCM</p>
     </title>
     <p>Для создания службы требуется отдельный процесс, выступающий в качестве "администратора" и играющий во многом ту же роль, что и программа JobShell, которая использовалась в главе 6 для запуска задач. Первый шаг состоит в открытии SCM и получении дескриптора, который впоследствии будет использован для создания службы.</p>
     <cite>
      <p><code>SC_HANDLE OpenSCManager(LPCTSTR lpMachineName, LPCTSTR lpDatabaseName, DWORD dwDesiredAccess)</code> </p>
     </cite>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>lpMachineName — указатель на строку с именем сетевого компьютера, на котором установлен SCM, или NULL, если SCM установлен на локальном компьютере.</p>
     <p>lpDatabaseName — обычно принимает значение NULL.</p>
     <p>dwDesiredAccess — обычно указывается значение SC_MANAGER_ALL_ACCESS, соответствующее полным правам доступа, но можно задать и ограничить эти права, о чем более подробно говорится в оперативной справочной системе.</p>
    </section>
    <section>
     <title>
      <p>Создание и удаление службы</p>
     </title>
     <p>Для регистрации службы следует вызвать функцию CreateService: </p>
     <cite>
      <p><code>SC_HANDLE CreateService(SC_HANDLE hSCManager, LPCTSTR lpServiceName, LPCTSTR lpDisplayName, DWORD dwDesiredAccess, DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl, LPCTSTR lpBinaryPathName, LPCTSTR lpLoadOrderGroup, LPDWORD lpdwTagId, LPCTSTR lpDependencies, LPCTSTR lpServiceStartName, LPCTSTR lpPassword);</code> </p>
     </cite>
     <p>Информация о новых службах записывается в следующий раздел реестра:</p>
     <p><code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services</code></p>
     <subtitle><emphasis>Параметры</emphasis></subtitle>
     <p>hSCManager — дескриптор типа SC_HANDLE, полученный через функцию OpenSCManager.</p>
     <p>lpServiceName — имя, используемое при последующих ссылках на службу и являющееся одним из имен логических служб, определенных в диспетчерской таблице при вызове функции StartServiceCtrlDispatcher. Заметьте, что для каждой логической службы используется отдельный вызов CreateService.</p>
     <p>lpDisplayName — имя, которое будет отображаться в реестре в качестве его раздела, а также в административной утилите Services (доступ к которой открывается через пиктограмму Administrative Tools в панели управления). Это имя появится в указанных местах сразу же после успешного завершения функции CreateService. </p>
     <p>dwDesiredAccess — может принимать значение SERVICE_ALL_ACCESS или комбинацию значений GENERIC_READ, GENERIC_WRITE и GENERIC_EXECUTE. Дополнительную информацию вы можете получить, ознакомившись с оперативной справочной документацией.</p>
     <p>dwServiceType — возможные значения перечислены в табл. 13.1.</p>
     <p>dwStartType — указывает способ запуска службы. В наших примерах используется значение SERVICE_DEMAND_START, соответствующее запуску по требованию, тогда как другие значения (SERVICE_BOOT_START и SERVICE_SYSTEM_START) обеспечивают запуск служб драйверов устройств на стадии начальной загрузки или во время загрузки системы, а значение SERVICE_AUTO_START указывает на то, что служба должна быть запущена во время запуска системы.</p>
     <p>lpBinaryPathName — имя исполняемого файла службы; указывать расширение .exe не требуется.</p>
     <p>Другие параметры используются для указания имени учетной записи и пароля, групп, объединяющих несколько служб, а также зависимостей, если существует несколько отдельных служб.</p>
     <p>Конфигурационные параметры существующей службы можно изменить с помощью функции ChangeServiceConfig или, в случае NT5, ChangeService-Config2. Служба идентифицируется по своему дескриптору, и для большинства параметров вы можете указать новые значения. Например, можно предоставить новые значения параметров dwServiceType или dwStartType, но в случае параметра dwAccess это сделать невозможно.</p>
     <p>Доступна также функция OpenService, которая позволяет получить дескриптор именованной службы. Для удаления службы из реестра используется функция DeleteService, а для закрытия дескрипторов SC_HANDLE — функция CloseServiceHandle.</p>
    </section>
    <section>
     <title>
      <p>Запуск службы</p>
     </title>
     <p>Созданная служба сразу не выполняется. Для этого необходимо вызвать функцию ServiceMain(), указав дескриптор, полученный при помощи функции CreateService, а также параметры командной строки argc и argv, ожидаемые основной функцией службы (то есть функцией, указанной в таблице диспетчеризации). </p>
     <cite>
      <p><code>BOOL StartService(SC_HANDLE hService, DWORD argc, LPTSTR argv[])</code> </p>
     </cite>
    </section>
    <section>
     <title>
      <p>Управление службой</p>
     </title>
     <p>Чтобы начать управление службой, вы должны сообщить SCM о необходимости активизации обработчика управляющих команд службы с указанным управляющим кодом. </p>
     <cite>
      <p><code>BOOL ControlService(SC_HANDLE hService, DWORD dwControlCode, LPSERVICE_STATUS lpServStat)</code> </p>
     </cite>
     <p>Параметр dwControlCode, если доступ разрешен, может принимать одно из следующих значений:</p>
     <p><code>SERVICE_CONTROL_STOP</code></p>
     <p><code>SERVICE_CONTROL_PAUSE</code></p>
     <p><code>SERVICE_CONTROL_CONTINUE</code></p>
     <p><code>SERVICE_CONTROL_INTERROGATE</code></p>
     <p><code>SERVICE_CONTROL_SHUTDOWN</code></p>
     <p>или значение, определенное пользователем, лежащее в пределах диапазона 128–255. Эти значения совпадают с теми, которые использовались вместе с флагом dwControl в функции ServerCtrlHandler.</p>
     <p>lpServStat — указатель на структуру SERVICE_STATUS, которая получает текущее состояние. Это та же структура, которая использовалась функцией SetServiceStatus.</p>
    </section>
    <section>
     <title>
      <p>Опрос состояния службы</p>
     </title>
     <p>Для получения структурой SERVICE_STATUS текущего состояния службы используется следующая функция: </p>
     <cite>
      <p><code>BOOL QueryServiceStatus(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus)</code> </p>
     </cite>
    </section>
   </section>
   <section>
    <title>
     <p>Резюме: функционирование и управление службой</p>
    </title>
    <p>На рис. 13.1 показано, каким образом SCM связан со службами и программой управления службами, подобной программе 13.3, которая рассматривается в следующем разделе. В частности, SCM должен зарегистрировать службу, и все команды, предназначенные для службы, должны пропускаться через SCM. </p>
    <image l:href="#Any2FbImgLoader139"/>
    <p><strong>Рис. 13.1. </strong>Управление службами Windows через SCM</p>
   </section>
   <section>
    <title>
     <p><strong>Пример:команднаяоболочкауправленияслужбами</strong></p>
    </title>
    <p>Управление службами часто осуществляется посредством утилит, входящих в группу Administrative Tools, доступ к которым открывается через пиктограмму Services (Службы). Для управления пользовательскими службами можно также использовать оболочку ServiceShell (программа 13.3), представляющую собой видоизмененный вариант программы JobShell из главы 6 (программа 6.3).</p>
    <subtitle>Программа 13.3. ServiceShell: программа управления службами</subtitle>
    <p><code>/* Глава 13. */</code></p>
    <p><code>/* ServiceShell.с. Программа командной оболочки управления службами Windows.</code></p>
    <p><code>   Эта программа является видоизмененным вариантом программы управления задачами из главы 6, но только управляет службами, а не задачами. */</code></p>
    <p><code>/* Поддерживаемые команды:</code></p>
    <p><code>   create — создание службы</code></p>
    <p><code>   delete – удаление службы</code></p>
    <p><code>   start – запуск службы</code></p>
    <p><code>   control – управление службой */</code></p>
    <p><code>#include "EvryThng.h"</code></p>
    <empty-line/>
    <p><code>static SC_HANDLE hScm;</code></p>
    <p><code>static BOOL Debug;</code></p>
    <empty-line/>
    <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> BOOL Exit = FALSE;</code></p>
    <p><code> TCHAR Command[MAX_COMMAND_LINE + 10], *pc;</code></p>
    <p><code> DWORD i, LocArgc; /* Локальный параметр argc. */</code></p>
    <p><code> TCHAR argstr[MAX_ARG][MAX_COMMAND_LINE];</code></p>
    <p><code> LPTSTR pArgs[MAX_ARG];</code></p>
    <p><code> /* Подготовить локальный массив "argv" в виде указателей на строки. */</code></p>
    <p><code> for (i = 0; i &lt; MAX_ARG; i++) pArgs[i] = argstr[i];</code></p>
    <p><code> /* Открыть диспетчер управления службами на локальной машине. */</code></p>
    <p><code> hScm = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);</code></p>
    <p><code> /* Главный цикл обработки команд. */</code></p>
    <p><code> _tprintf(_T("\nУправление службами Windows Services"));</code></p>
    <p><code> while (!Exit) {</code></p>
    <p><code>  _tprintf(_T ("\nSM$"));</code></p>
    <p><code>  _fgetts(Command, MAX_COMMAND_LINE, stdin);</code></p>
    <p><code>  … Как для JobShell …</code></p>
    <p><code>  if (_tcscmp(argstr [0], _T("create")) == 0) {</code></p>
    <p><code>   Create(LocArgc, pArgs, Command);</code></p>
    <p><code>  }</code></p>
    <p><code>  … Аналогичным образом для всех команд …</code></p>
    <p><code> }</code></p>
    <p><code> CloseServiceHandle(hScm);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>int Create(int argc, LPTSTR argv[], LPTSTR Command) {</code></p>
    <p><code> /* Создание новой службы в виде службы, запускаемой "по требованию":</code></p>
    <p><code>    argv[1]: имя службы</code></p>
    <p><code>    argv[2]: отображаемое имя службы</code></p>
    <p><code>    argv[3]: название исполняемого файла */</code></p>
    <p><code> SC_HANDLE hSc;</code></p>
    <p><code> TCHAR CurrentDir[MAX_PATH +1], Executable[MAX_PATH + 1];</code></p>
    <p><code> hSc = CreateService(hScm, argv[1], argv[2], SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS, SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL, Executable, NULL, NULL, NULL, NULL, NULL);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* Удаление службы – argv [1]: имя удаляемой службы. */ </code></p>
    <p><code>int Delete(int argc, LPTSTR argv[], LPTSTR Command) {</code></p>
    <p><code> SC_HANDLE hSc;</code></p>
    <p><code> hSc = OpenService(hScm, argv[1], DELETE);</code></p>
    <p><code> DeleteService(hSc); </code></p>
    <p><code> CloseServiceHandle(hSc);</code></p>
    <p><code> return 0; </code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* Запуск именованной службы - argv [1] : имя запускаемой службы. */</code></p>
    <p><code>int Start(int argc, LPTSTR argv[], LPTSTR Command) {</code></p>
    <p><code> SC_HANDLE hSc;</code></p>
    <p><code> TCHAR WorkingDir[MAX_PATH + 1];</code></p>
    <p><code> LPTSTR pWorkingDir = WorkingDir;</code></p>
    <p><code> LPTSTR argvStart[] = {argv[1], WorkingDir};</code></p>
    <p><code> GetCurrentDirectory(MAX_PATH + 1, WorkingDir);</code></p>
    <p><code> hSc = OpenService(hScm, argv[1], SERVICE_ALL_ACCESS);</code></p>
    <p><code> /* Запустить службу с одним аргументом — именем рабочего каталога. */</code></p>
    <p><code> /* Примечание: по умолчанию имя службы совпадает с именем, */</code></p>
    <p><code> /* связанным с дескриптором hSc посредством функции OpenService. */</code></p>
    <p><code> /* Вместе с тем, функция ServiceMain это не проверяет. */</code></p>
    <p><code> StartService(hSc, 2, argvStart);</code></p>
    <p><code> CloseServiceHandle(hSc);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>/* Управление именованной службой.</code></p>
    <p><code>   argv[1]: имя управляемой службы.</code></p>
    <p><code>   argv[2]: управляющая команда: stop (остановка), pause (пауза), resume (возобновление), interrogate (опрос). */</code></p>
    <p><code>static LPCTSTR Commands[] = {"stop," "pause," "resume," "interrogate," "user"};</code></p>
    <p><code>static DWORD Controls[] = {</code></p>
    <p><code> SERVICE_CONTROL_STOP, SERVICE_CONTROL_PAUSE,</code></p>
    <p><code> SERVICE_CONTROL_CONTINUE, SERVICE_CONTROL_INTERROGATE, 128</code></p>
    <p><code>};</code></p>
    <empty-line/>
    <p><code>int Control(int argc, LPTSTR argv[], LPTSTR Command) {</code></p>
    <p><code> SC_HANDLE hSc;</code></p>
    <p><code> SERVICE_STATUS ServiceStatus;</code></p>
    <p><code> DWORD dwControl, i;</code></p>
    <p><code> BOOL Found = FALSE;</code></p>
    <p><code> for (i= 0; i &lt; sizeof(Controls)/sizeof(DWORD) &amp;&amp; !Found; i++) Found = (_tcscmp(Commands [i], argv[2]) == 0);</code></p>
    <p><code> if (!Found) {</code></p>
    <p><code>  _tprintf(_T("\nНесуществующая команда управления %s"), argv[1]);</code></p>
    <p><code>  return 1;</code></p>
    <p><code> }</code></p>
    <p><code> dwControl = Controls[i – 1];</code></p>
    <p><code> hSc = OpenService(hScm, argv[1], SERVICE_INTERROGATE | SERVICE_PAUSE_CONTINUE | SERVICE_STOP | SERVICE_USER_DEFINED_CONTROL | SERVICE_QUERY_STATUS);</code></p>
    <p><code> ControlService(hSc, dwControl, &amp;ServiceStatus); </code></p>
    <p><code> if (dwControl == SERVICE_CONTROL_INTERROGATE) {</code></p>
    <p><code>  QueryServiceStatus (hSc, &amp;ServiceStatus);</code></p>
    <p><code>  printf(_T("Состояние, полученное при помощи QueryServiceStatus\n"));</code></p>
    <p><code>  printf(_T("Состояние службы\n"));</code></p>
    <p><code>  … Вывести всю остальную информацию о состоянии …</code></p>
    <p><code> }</code></p>
    <p><code> if (hSc != NULL) CloseServiceHandle(hSc);</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code> </p>
   </section>
   <section>
    <title>
     <p>Совместное использование объектов ядра приложениями и службами</p>
    </title>
    <p>Возможны ситуации, в которых служба и приложения разделяют объект ядра. Например, служба может использовать именованный мьютекс для защиты разделяемой области памяти, используемой для обмена данными с приложениями. Более того, в нашем примере также будет применяться разделяемый объект ядра, которым в данном случае является отображение файла.</p>
    <p>Существует одна трудность, связанная с тем, что контекст безопасности приложений отличается от контекста безопасности служб, выполняющихся от имени системной учетной записи. Даже если защита не требуется, было бы нелогично создавать и (или) открывать разделяемые объекты ядра с указателем атрибутов безопасности, установленным в NULL (см. глава 15). Вместо этого необходим, по крайней мере, нулевой список разграничительного контроля доступа (см. главу 15), то есть приложения и служба должны использовать ненулевую структуру атрибутов защиты. В общем случае вы захотите защитить объекты, и этот вопрос также будет рассмотрен в главе 15.</p>
    <p>Следует обратить ваше внимание также на то, что если служба выполняется от имени системной учетной записи, то могут возникать трудности с доступом службы к таким ресурсам, как разделяемые файлы, находящиеся на других машинах.</p>
   </section>
   <section>
    <title>
     <p>Регистрация событий</p>
    </title>
    <p>Службы часто выполняются, внешне ничем себя не проявляя, без диалогового взаимодействия с пользователем. Некоторые службы создают консоль, окно сообщений<a l:href="#n_34" type="note">[34]</a> или окно для взаимодействия с пользователем, но лучше всего записывать информацию о событиях в файл регистрации событий или использовать соответствующие функциональные возможности, предоставляемые Windows. Такая информация сохраняется в реестре, и ее можно просматривать с помощью специальной программы просмотра событий, предоставляемой группой инструментов Administrative Tools, пиктограмма которой находится в панели управления.</p>
    <p>В доступных на Web-сайте книги программах ServiceSK.c и SimpleService.c показано, как организовать регистрацию заслуживающих внимания событий и ошибок в регистрационном файле, а в комментариях к текстам упомянутых программ рассказано о том, как используется регистрация событий. Для этого имеются три функции, описанные в оперативной справочной документации.</p>
    <p>1. RegisterEventSource — позволяет получить дескриптор регистрационного файла.</p>
    <p>2. ReportEvent — используется для внесения записи в регистрационный файл.</p>
    <p>3. DeregisterEventSource — закрывает дескриптор регистрационного файла.</p>
   </section>
   <section>
    <title>
     <p>Замечания по отладке службы</p>
    </title>
    <p>Предполагается, что служба будет выполняться непрерывно, поэтому она должна быть надежной и по возможности лишенной каких бы то ни было дефектов. Несмотря на возможность подключения службы к отладчику и использования журнала регистрации событий для отслеживания операций, выполняемых службой, эти методы являются наиболее подходящими в условиях, когда служба уже развернута.</p>
    <p>Однако на стадии первоначальной разработки и отладки службы часто гораздо легче воспользоваться преимуществами оболочки службы, представленной в программе 13.2.</p>
    <p>• Разработайте сначала "предварительную" версию службы в виде отдельной программы. В таком ключе, например, была разработана программа serverSK.</p>
    <p>• Используйте в программе средства регистрации событий или предусмотрите регистрационный файл.</p>
    <p>• Когда вы придете к заключению, что программа готова к развертыванию в виде службы, переименуйте основную точку входа и свяжите ее с кодом оболочки службы, представленным программой 13.2 (он находится на Web-сайте книги вместе с двумя программами: SimpleService.c и serviceSK.c).</p>
    <p>• Весьма важную роль играет дальнейшее тестирование службы для обнаружения дополнительных логических ошибок и проблем с обеспечением безопасности. Службы могут выполняться от имени системной учетной записи, но не иметь доступа к пользовательским объектам, и обнаружения проблем подобного рода "предварительная" версия службы не гарантирует.</p>
    <p>• Если служба нуждается в интенсивной поддержке, извлеките ее код из оболочки и превратите его вновь в отдельную программу или консольное приложение, используя для этого GUI или текстовый интерфейс. Можно поступить и по-другому, предусмотрев для функции <emphasis>ServiceMain</emphasis> дополнительный аргумент командной строки, используемый в качестве флага отладки или трассировки.</p>
   </section>
   <section>
    <title>
     <p>Резюме</p>
    </title>
    <section>
     <p>Службы Windows предоставляют стандартные возможности подключения пользовательских служб к системе Windows. Используя методы, обсуждавшиеся в этой главе, любую независимую программу можно превратить в службу.</p>
     <p>Для создания служб, а также управления ими и контроля их функционирования можно воспользоваться средствами Administrative Tools (Администрирование) или представленной в этой главе программой ServiceShell. Управление развернутыми службами и их мониторинг осуществляются через SCM, и информация обо всех служб заносится в реестр.</p>
    </section>
    <section>
     <title>
      <p>В следующих главах</p>
     </title>
     <p>В главе 14 описывается асинхронный ввод/вывод, который предоставляет два метода, позволяющих выполнять множественные операции ввода/вывода параллельно с другими видами обработки. При этом использование нескольких потоков не является обязательным и требуется всего лишь один пользовательский поток.</p>
     <p>В большинстве случаев программировать многопоточное выполнение проще, чем асинхронный ввод/вывод, и производительность в первом случае, как правило, выше. В то же время, без асинхронного ввода/вывода не обойтись, работая с портами завершения ввода/вывода, которые оказываются чрезвычайно полезными при построении масштабируемых серверов, способных взаимодействовать с большим количеством клиентов.</p>
     <p>В главе 14 также рассматриваются таймеры ожидания.</p>
    </section>
    <section>
     <title>
      <p>Дополнительная литература</p>
     </title>
     <p>Эта тема подробно обсуждается в [21]. Драйверы устройств и их взаимодействие со службами в настоящей главе не рассматривались; соответствующая информация содержится, например, в [24].</p>
    </section>
   </section>
   <section>
    <title>
     <p>Упражнения</p>
    </title>
    <p>13.1. Расширьте возможности службы serviceSK таким образом, чтобы она могла воспринимать команды приостановки.</p>
    <p>13.2. При опросе состояния службы оболочка ServiceShell просто выводит соответствующие числовые данные. Расширьте возможности службы, обеспечив вывод информации о состоянии службы в текстовой форме.</p>
    <p>13.3. Преобразуйте сервер serverNP (программа 11.3) в службу.</p>
    <p>13.4. Видоизмените службу serviceSK, введя в нее средства регистрации событий. </p>
   </section>
  </section>
  <section>
   <title>
    <p>ГЛАВА 14</p>
    <p>Асинхронный ввод/вывод и порты завершения</p>
   </title>
   <section>
    <p>Операциям ввода и вывода присуща более медленная скорость выполнения по сравнению с другими видами обработки. Причиной такого замедления являются следующие факторы:</p>
    <p>• Задержки, обусловленные затратами времени на поиск нужных дорожек и секторов на устройствах произвольного доступа (диски, компакт-диски).</p>
    <p>• Задержки, обусловленные сравнительно низкой скоростью обмена данными между физическими устройствами и системной памятью.</p>
    <p>• Задержки при передаче данных по сети с использованием файловых, серверов, хранилищ данных и так далее.</p>
    <p>Во всех предыдущих примерах операции ввода/вывода выполняются <emphasis>синхронно с потоком,</emphasis> поэтому весь поток вынужден простаивать, пока они не завершатся.</p>
    <p>В этой главе показано, каким образом можно организовать продолжение выполнения потока, не дожидаясь завершения операций ввода/вывода, что будет соответствовать выполнению потоками <emphasis>асинхронного</emphasis> ввода/вывода. Различные методики, доступные в Windows, иллюстрируются примерами.</p>
    <p>Некоторые из этих методик используются в таймерах ожидания, которые также описываются в настоящей главе.</p>
    <p>Наконец, что особенно важно, изучив стандартные асинхронные операции ввода/вывода, мы сможем использовать <emphasis>порты завершения ввода/вывода,</emphasis> которые оказываются чрезвычайно полезными при построении масштабируемых серверов, способных обеспечивать поддержку большого количества клиентов без создания для каждого из них отдельного потока. Программа 14.4 представляет собой модифицированный вариант разработанного ранее сервера, позволяющий использовать порты завершения ввода/вывода.</p>
   </section>
   <section>
    <title>
     <p>Обзор методов асинхронного ввода/вывода Windows</p>
    </title>
    <p>В Windows выполнение асинхронного ввода/вывода обеспечивается в соответствии с тремя методиками.</p>
    <p>• <strong>Многопоточный ввод/вывод (Multihreaded I/O). </strong>Каждый из потоков внутри процесса или набора процессов выполняет обычный синхронный ввод/вывод, но при этом другие потоки могут продолжать свое выполнение.</p>
    <p>• <strong>Перекрывающийся ввод/вывод (Overlapped I/O). </strong>Запустив операцию чтения, записи или иную операцию ввода/вывода, поток продолжает свое выполнение. Если потоку для продолжения выполнения требуются результаты ввода/вывода, он ожидает, пока не станет доступным соответствующий дескриптор или не наступит заданное событие. В Windows 9x перекрывающийся ввод/вывод поддерживается только для последовательных устройств, например именованных каналов.</p>
    <p><strong>• Процедуры завершения (или расширенный ввод/вывод) (Completion routines (extended I/O)). </strong>Когда наступает завершение операций ввода/вывода, система вызывает специальную <emphasis>процедуру завершения,</emphasis> выполняющуюся внутри потока. Расширенный ввод/вывод для дисковых файлов в Windows 9x не поддерживается.</p>
    <p>Многопоточный ввод/вывод с использованием именованных каналов применен в сервере с многопоточной поддержкой, который рассматривался в главе 11. Программа grepMT (программа 7.1) управляет параллельным выполнением операций ввода/вывода с участием нескольких файлов. Таким образом, мы уже располагаем рядом программ, которые выполняют многопоточный ввод/вывод и тем самым обеспечивают одну из форм асинхронного ввода/вывода.</p>
    <p>Перекрывающийся ввод/вывод является предметом рассмотрения следующего раздела, а в приведенных в нем примерах, реализующих преобразование файлов (из ASCII в UNICODE), эта методика применена для иллюстрации возможностей последовательной обработки файлов. С этой целью используется видоизмененный вариант программы 2.4. Вслед за перекрывающимся вводом/выводом рассматривается расширенный ввод/вывод, использующий процедуры завершения.</p>
    <cite>
     <p><strong>Примечание</strong></p>
     <p>Методы перекрывающегося и расширенного ввода/вывода часто оказываются сложными в реализации, редко обеспечивают какие-либо преимущества в отношении производительности, иногда даже становясь причиной ее ухудшения, а в случае файлового ввода/вывода способны работать лишь под управлением Windows NT. Эти проблемы преодолеваются с помощью потоков, <emphasis>поэтому, вероятно, многие читатели захотят сразу же перейти к разделам, посвященным таймерам ожидания и портам завершения ввода/вывода,</emphasis> возвращаясь к этому разделу по мере необходимости. С другой стороны, элементы асинхронного ввода/вывода присутствуют как в устаревших, так и в новых технологиях, в связи с чем эти методы все-таки стоит изучить.</p>
     <p>Так, технология СОМ на платформе NT5 поддерживает асинхронный вызов методов, поэтому указанная методика может пригодиться многим читателям, которые используют или собираются использовать технологию СОМ. Кроме того, много общего с расширенным вводом/выводом имеют операции асинхронного вызова процедур (глава 10), и хотя лично я предпочитаю использовать потоки, другие могут отдать предпочтение именно этому механизму.</p>
    </cite>
   </section>
   <section>
    <title>
     <p>Перекрывающийся ввод/вывод</p>
    </title>
    <section>
     <p>Первое, что необходимо сделать для организации асинхронного ввода/вывода, будь то перекрывающегося или расширенного, — это установить атрибут перекрывания (overlapped attribute) для файлового или иного дескриптора. Для этого при вызове CreateFile или иной функции, в результате которого создается файл, именованный канал или иной дескриптор, следует указать флаг FILE_FLAG_OVERLAPPED.</p>
     <p>В случае сокетов (глава 12), независимо от того, были они созданы с использованием функции socket или accept, атрибут перекрывания устанавливается по умолчанию в Winsock 1.1, но должен устанавливаться явным образом в Winsock 2.0. Перекрывающиеся сокеты могут использоваться в асинхронном режиме во всех версиях Windows.</p>
     <p>До этого момента структуры OVERLAPPED использовались нами совместно с функцией LockFileEx, а также в качестве альтернативы использованию функции SetFilePointer (глава 3), но они также являются существенным элементом перекрывающегося ввода/вывода. Эти структуры выступают в качестве необязательных параметров при вызове четырех приведенных ниже функций, которые могут блокироваться при завершении операций.</p>
     <p><code>ReadFile</code></p>
     <p><code>WriteFile</code></p>
     <p><code>TransасtNamedPipe</code></p>
     <p><code>ConnectNamedPipe</code></p>
     <p>Вспомните, что при указании флага FILE_FLAG_OVERLAPPED в составе параметра dwAttrsAndFlags (в случае функции CreateFile) или параметра dwOpen-Mode (в случае функции CreateNamedPipe) соответствующие файл или канал могут использоваться только в режиме перекрывания. С анонимными каналами перекрывающийся ввод/вывод не работает.</p>
     <cite>
      <p><strong>Примечание</strong></p>
      <p>В документации по функции CreateFile есть упоминание о том, что использование флага FILE_FLAG_NO_BUFFERING улучшает характеристики быстродействия перекрывающегося ввода/вывода. Эксперименты показывают лишь незначительное повышение производительности (примерно на 15%, что может быть проверено путем экспериментирования с программой 14.1), но вы должны убедиться в том, что суммарный размер считываемых данных при выполнении операций ReadFile или WriteFile, кратен размеру сектора диска. </p>
     </cite>
    </section>
    <section>
     <title>
      <p>Перекрывающиеся сокеты</p>
     </title>
     <p>Одним из наиболее важных нововведений в Windows Sockets 2.0 (глава 12) является стандартизация перекрывающегося ввода/вывода. В частности, сокеты уже не создаются автоматически как дескрипторы файлов с перекрытием. Функция socket создает неперекрывающийся дескриптор. Чтобы создать перекрывающийся сокет, следует вызвать функцию WSASocket, явно запросив создание перекрывающегося совета путем указания значения WSA_FLAG_OVERLAPPED для параметра dwFlags функции WSASocket. </p>
     <cite>
      <p><code>SOCKET WSAAPI WSASocket(int iAddressFamily, int iSocketType, int iProtocol, LPWSAPROTOCOL_INFO lpProtocolInfo, GROUP g, DWORD dwFlags);</code> </p>
     </cite>
     <p>Для создания сокета используйте вместо функции socket функцию WSASocket. Любой сокет, возвращенный функцией accept, будет иметь те же свойства, что и аргумент.</p>
    </section>
    <section>
     <title>
      <p>Следствия применения перекрывающегося ввода/вывода</p>
     </title>
     <p>Перекрывающийся ввод/вывод выполняется в асинхронном режиме. Это имеет несколько следствий.</p>
     <p>• Операции перекрывающегося ввода/вывода не блокируются. Функции ReadFile, WriteFile, TransactNamedPipe и ConnectNamedPipe осуществляют возврат, не дожидаясь завершения операции ввода/вывода.</p>
     <p>• Возвращаемое функцией значение не может быть использовано в качестве критерия успешности или неудачи ее выполнения, поскольку операция ввода/вывода к этому моменту еще не успевает завершиться. Для индикации состояния выполнения ввода/вывода требуется привлечение другого механизма.</p>
     <p>• Возвращенное значение количества переданных байтов также приносит мало пользы, поскольку передача данных могла не завершиться до конца. Для получения такого рода информации Windows должна предоставить другой механизм.</p>
     <p>• Программа может многократно предпринимать попытки чтения или записи с использованием одного и того же перекрывающегося дескриптора файла. Поэтому незначащим оказывается и указатель файла, соответствующий такому дескриптору. Следовательно, должен быть предусмотрен дополнительный метод, обеспечивающий указание позиции в файле для каждой операции чтения или записи. В случае именованных каналов, в силу присущего им последовательного характера обработки данных, это не является проблемой.</p>
     <p>• Для программы должна быть обеспечена возможность ожидания (синхронизации) завершения ввода/вывода. При наличии нескольких незавершенных операций ввода/вывода, связанных с одним и тем же дескриптором, программа должна быть в состоянии определить, какие из операций уже завершились. Операции ввода/вывода вовсе не обязательно завершаются в том же порядке, в каком они начинали выполняться.</p>
     <p>Для преодоления двух последних из перечисленных выше трудностей используются структуры OVERLAPPED.</p>
    </section>
    <section>
     <title>
      <p>Структуры OVERLAPPED</p>
     </title>
     <p>С помощью структуры OVERLAPPED (указываемой, например, параметром lpOverlapped функции ReadFile) можно указывать следующую информацию:</p>
     <p>• Позицию в файле (64 бита), с которой должно начинаться выполнение операции чтения или записи в соответствии с обсуждением, которое содержится в главе 3.</p>
     <p>• Событие (сбрасываемое вручную), которое будет переходить в сигнальное состояние по завершении соответствующей операции.</p>
     <p>Ниже приводится определение структуры OVERLAPPED. </p>
     <cite>
      <p><code>typedef struct_OVERLAPPED {</code></p>
      <p><code> DWORD Internal;</code></p>
      <p><code> DWORD InternalHigh;</code></p>
      <p><code> DWORD Offset;</code></p>
      <p><code> DWORD OffsetHigh;</code></p>
      <p><code> HANDLE hEvent; </code></p>
      <p><code>} OVERLAPPED</code> </p>
     </cite>
     <p>Для задания позиции в файле (указателя) должны использоваться оба поля Offset и OffsetHigh, хотя старшая часть указателя (OffsetHigh) во многих случаях равна 0. Не следует использовать поля Internal и InternalHigh, зарезервированные для системных нужд.</p>
     <p>Параметр hEvent — дескриптор события (созданного посредством функции CreateEvent). Это событие может быть как именованным, так и неименованным, но оно <emphasis>должно</emphasis> быть обязательно сбрасываемым вручную (см. главу 8), если используется для перекрывающегося ввода/вывода; причины этого будут вскоре объяснены. По завершении операции ввода/вывода событие переходит в сигнальное состояние. </p>
     <p>В другом возможном варианте его использования дескриптор hEvent имеет значение NULL; в этом случае программа может ожидать перехода в сигнальное состояние дескриптора файла, который также может выступать в роли объекта синхронизации (см. приведенные далее предостережения). Система использует для отслеживания завершения операций сигнальные состояния дескриптора файла, если дескриптор hEvent равен NULL, то есть объектом синхронизации в этом случае является дескриптор файла.</p>
     <cite>
      <p><strong>Примечание</strong></p>
      <p>В целях удобства термин "дескриптор файла" ("file handle"), используемый по отношению к дескрипторам, указываемым при вызове функций ReadFile, WriteFile и так далее, будет применяться нами даже в тех случаях, когда речь идет о дескрипторах именованного канала или устройства, а не файла.</p>
     </cite>
     <p>При выполнении вызова функций ввода/вывода это событие сразу же сбрасывается системой (устанавливается в несигнальное состояние). Когда операция ввода/вывода завершается, событие устанавливается в сигнальное состояние и остается в нем до тех пор, пока не будет использовано другой операцией ввода/вывода. Событие должно быть сбрасываемым вручную, если его перехода в сигнальное состояние могут ожидать несколько потоков (хотя в наших примерах используется всего один поток), и на момент завершения операции они могут не находиться в состоянии ожидания.</p>
     <p>Даже если дескриптор файла является синхронным (то есть созданным без флага FILE_FLAG_OVERLAPPED), структура OVERLAPPED может послужить в качестве альтернативы функции SetFilePointer для указания позиции в файле. В этом случае возврат после вызова функции ReadFile или иного вызова не происходит до тех пор, операция ввода/вывода пока не завершится. Этой возможностью мы уже воспользовались в главе 3. Также обратите внимание на то, что незавершенные операции ввода/вывода однозначно идентифицируются комбинацией дескриптора файла и соответствующей структуры OVERLAPPED.</p>
     <p>Ниже перечислены некоторые предостережения, которые следует принимать во внимание.</p>
     <p>• Не допускайте повторного использования структуры OVERLAPPED в то время, когда связанная с ней операция ввода/вывода, если таковая имеется, еще не успела завершиться.</p>
     <p>• Аналогичным образом, избегайте повторного использования события, указанного в структуре OVERLAPPED.</p>
     <p>• Если существует несколько незакрытых запросов, относящихся к одному и тому же перекрывающемуся дескриптору, используйте для синхронизации не дескрипторы файлов, а дескрипторы событий.</p>
     <p>• Если структура OVERLAPPED или событие выступают в качестве автоматических переменных внутри блока, обеспечьте невозможность выхода из блока до синхронизации с операцией ввода/вывода. Кроме того, во избежание утечки ресурсов следует позаботиться о закрытии дескриптора до выхода из блока.</p>
    </section>
    <section>
     <title>
      <p>Состояния перекрывающегося ввода/вывода</p>
     </title>
     <p>Возврат из функций ReadFile и WriteFile, а также двух указанных выше функций, относящихся к именованным каналам, в случаях, когда они используются для выполнения перекрывающихся операций ввода вывода, осуществляется немедленно. В большинстве случаев операция ввода/вывода к этому моменту завершена не будет, и возвращаемым значением при чтении и записи будет FALSE. Функция GetLastError возвратит в этой ситуации значение ERROR_IO_PENDING.</p>
     <p>По окончании ожидания перехода объекта синхронизации (события или, возможно, дескриптора файла) в сигнальное состояние, свидетельствующее о завершении операции, вы должны выяснить, сколько байтов было передано. В этом и состоит основное назначение функции GetOverlappedResult. </p>
     <cite>
      <p><code>BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPWORD lpcbTransfer, BOOL bWait)</code></p>
     </cite>
     <p>Указание конкретной операции ввода/вывода обеспечивается сочетанием дескриптора и структуры OVERLAPPED. Значение TRUE параметра bWait указывает на то, что до завершения операции функция GetOverlappedResult должна находиться в состоянии ожидания; в противном случае возврат из функции должен быть немедленным. В любом случае эта функция будет возвращать значение TRUE только после успешного завершения операции. Если возвращаемым значением функции GetOverlappedResult является FALSE, то функция GetLastError возвратит значение ERROR_IO_INCOMPLETE, что позволяет вызывать эту функцию для опроса завершения ввода/вывода.</p>
     <p>Количество переданных байтов хранится в переменной *lpcbTransfer. Всегда убеждайтесь в том, что с момента ее использования в операции перекрывающегося ввода/вывода структура OVERLAPPED остается неизменной.</p>
    </section>
    <section>
     <title>
      <p>Отмена выполнения операций перекрывающегося ввода/вывода</p>
     </title>
     <p>Булевская функция CancelIO позволяет отменить выполнение незавершенных операций перекрывающегося ввода/вывода, связанных с указанным дескриптором (у этой функции имеется всего лишь один параметр). Отменяется выполнение всех инициированных вызывающим потоком операций, использующих данный дескриптор. На операции, инициированные другими потоками, вызов этой функции никакого влияния не оказывает. Отмененные операции завершаются С ошибкой ERROR OPERATION ABORTED.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: использование дескриптора файла в качестве объекта синхронизации</p>
    </title>
    <p>Перекрывающийся ввод/вывод очень удобно и просто реализуется в тех случаях, когда может существовать только одна незавершенная операция. Тогда для целей синхронизации программа может использовать не событие, а дескриптор файла.</p>
    <p>Приведенный ниже фрагмент кода показывает, каким образом программа может инициировать операцию чтения для считывания части файла, продолжить свое выполнение для осуществления других видов обработки, а затем перейти в состояние ожидания перехода дескриптора файла в сигнальное состояние.</p>
    <p><code>OVERLAPPED ov = { 0, 0, 0, 0, NULL /* События не используются. */ };</code></p>
    <p><code>HANDLE hF;</code></p>
    <p><code>DWORD nRead;</code></p>
    <p><code>BYTE Buffer[BUF_SIZE];</code></p>
    <p><code>…</code></p>
    <p><code>hF = CreateFile( …, FILE_FLAG_OVERLAPPED, … );</code></p>
    <p><code>ReadFile(hF, Buffer, sizeof(Buffer), &amp;nRead, &amp;ov);</code></p>
    <p><code>/* Выполнение других видов обработки. nRead не обязательно достоверно.*/</code></p>
    <p><code>/* Ожидать завершения операции чтения. */</code></p>
    <p><code>WaitForSingleObject(hF, INFINITE);</code></p>
    <p><code>GetOverlappedResult(hF, &amp;ov, &amp;nRead, FALSE);</code></p>
   </section>
   <section>
    <title>
     <p>Пример: преобразование файлов с использованием перекрывающегося ввода/вывода и множественной буферизации</p>
    </title>
    <p>Программа 2.4 (atou) осуществляла преобразование ASCII-файла к кодировке UNICODE путем последовательной обработки файла, а в главе 5 было показано, как выполнить такую же последовательную обработку с помощью отображения файлов. В программе 14.1 (atouOV) та же самая задача решается с использованием перекрывающегося ввода/вывода и множественных буферов, в которых хранятся записи фиксированного размера.</p>
    <p>Рисунок 14.1 иллюстрирует организацию программы с четырьмя буферами фиксированного размера. Программа реализована таким образом, чтобы количество буферов можно было определять при помощи символической константы препроцессора, но в нижеследующем обсуждении мы будем предполагать, что существуют четыре буфера.</p>
    <p>Сначала в программе выполняется инициализация всех элементов структур OVERLAPPED, определяющих события и позиции в файлах. Для каждого входного и выходного буферов предусмотрена отдельная структура OVERLAPPED. После этого для каждого из входных буферов инициируется операция перекрывающегося чтения. Далее с помощью функции WaitForMultipleObjects в программе организуется ожидание одиночного события, указывающего на завершение чтения или записи. При завершении операции чтения входной буфер копируется и преобразуется в соответствующий выходной буфер, после чего инициируется операция записи. При завершении записи инициируется следующая операция чтения. Заметьте, что события, связанные с входными и выходными буферами размещаются в единственном массиве, который используется в качестве аргумента при вызове функции WaitForMultipleObjects. </p>
    <image l:href="#Any2FbImgLoader143"/>
    <p><strong>Рис. 14.1.</strong> Модель асинхронного обновления файла</p>
    <empty-line/>
    <subtitle>Программа 14.1. atouOV: преобразование файла с использованием перекрывающегося ввода/вывода </subtitle>
    <p><code>/* Глава 14. atouOV</code></p>
    <p><code>   Преобразование файла из кодировки ASCII в кодировку Unicode с использованием перекрывающегося ввода/вывода. Программа работает только в Windows NT. */</code></p>
    <empty-line/>
    <p><code>#include "EvryThng.h"</code></p>
    <empty-line/>
    <p><code>#define MAX_OVRLP 4 /* Количество перекрывающихся операций ввода/вывода.*/ </code></p>
    <p><code>#define REC_SIZE 0x8000 /* 32 Кбайт: Минимальный размер записи, обеспечивающий приемлемую производительность. */ </code></p>
    <p><code>#define UREC_SIZE 2 * REC_SIZE</code></p>
    <empty-line/>
    <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> HANDLE hInputFile, hOutputFile;</code></p>
    <p><code> /* Каждый из элементов определенных ниже массивов переменных */</code></p>
    <p><code> /* и структур соответствует отдельной незавершенной операции */</code></p>
    <p><code> /* перекрывающегося ввода/вывода. */</code></p>
    <p><code> DWORD nin[MAX_OVRLP], nout[MAX_OVRLP], ic, i;</code></p>
    <p><code> OVERLAPPED OverLapIn[MAX_OVRLP], OverLapOut[MAX_OVRLP];</code></p>
    <p><code> /* Необходимость использования сплошного, двумерного массива */</code></p>
    <p><code> /* диктуется Функцией WaitForMultipleObjects. */</code></p>
    <p><code> /* Значение 0 первого индекса соответствует чтению, значение 1 – записи.*/</code></p>
    <p><code> HANDLE hEvents[2][MAX_OVRLP];</code></p>
    <p><code> /* В каждом из определенных ниже двух буферных массивов первый индекс */</code></p>
    <p><code> /* нумерует операции ввода/вывода. */</code></p>
    <p><code> CHAR AsRec[MAX_OVRLP][REC_SIZE];</code></p>
    <p><code> WCHAR UnRec[MAX_OVRLP][REC_SIZE];</code></p>
    <p><code> LARGE_INTEGER CurPosIn, CurPosOut, FileSize;</code></p>
    <p><code> LONGLONG nRecord, iWaits;</code></p>
    <p><code> hInputFile = CreateFile(argv[1], GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);</code></p>
    <p><code> hOutputFile = CreateFile(argv[2], GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_FLAG_OVERLAPPED, NULL);</code></p>
    <p><code> /* Общее количество записей, подлежащих обработке, вычисляемое */</code></p>
    <p><code> /* на основе размера входного файла. Запись, находящаяся в конце, */</code></p>
    <p><code> /* может быть неполной. */</code></p>
    <p><code> FileSize.LowPart = GetFileSize(hInputFile, &amp;FileSize.HighPart);</code></p>
    <p><code> nRecord = FileSize.QuadPart / REC_SIZE;</code></p>
    <p><code> if ((FileSize.QuadPart % REC_SIZE) != 0) nRecord++;</code></p>
    <p><code> CurPosIn.QuadPart = 0;</code></p>
    <p><code> for (ic = 0; ic &lt; MAX_OVRLP; ic++) {</code></p>
    <p><code>  /* Создать события чтения и записи для каждой структуры OVERLAPPED.*/</code></p>
    <p><code>  hEvents[0][ic] = OverLapIn[ic].hEvent /* Событие чтения.*/</code></p>
    <p><code>   = CreateEvent(NULL, TRUE, FALSE, NULL);</code></p>
    <p><code>  hEvents[1][ic] = OverLapOut[ic].hEvent /* Событие записи. */</code></p>
    <p><code>   = CreateEvent(NULL, TRUE, FALSE, NULL);</code></p>
    <p><code>  /* Начальные позиции в файле для каждой структуры OVERLAPPED. */</code></p>
    <p><code>  OverLapIn[ic].Offset = CurPosIn.LowPart;</code></p>
    <p><code>  OverLapIn[ic].OffsetHigh = CurPosIn.HighPart;</code></p>
    <p><code>  /* Инициировать перекрывающуюся операцию чтения для данной структуры OVERLAPPED. */</code></p>
    <p><code>  if (CurPosIn.QuadPart &lt; FileSize.QuadPart) ReadFile(hInputFile, AsRec[ic], REC_SIZE, &amp;nin[ic], &amp;OverLapIn[ic]); </code></p>
    <p><code>  CurPosIn.QuadPart += (LONGLONG)REC_SIZE;</code></p>
    <p><code> }</code></p>
    <p><code> /* Выполняются все операции чтения. Ожидать завершения события и сразу же сбросить его. События чтения и записи хранятся в массиве событий рядом друг с другом. */</code></p>
    <p><code> iWaits =0; /* Количество выполненных к данному моменту операций ввода/вывода. */</code></p>
    <p><code> while (iWaits &lt; 2 * nRecord) {</code></p>
    <p><code>  ic = WaitForMultipleObjects(2 * MAX_OVRLP, hEvents[0], FALSE, INFINITE) – WAIT_OBJECT_0;</code></p>
    <p><code>  iWaits++; /* Инкрементировать счетчик выполненных операций ввода вывода.*/</code></p>
    <p><code>  ResetEvent(hEvents[ic / MAX_OVRLP][ic % MAX_OVRLP]);</code></p>
    <p><code>  if (ic &lt; MAX_OVRLP) {</code></p>
    <p><code>   /* Чтение завершено. */</code></p>
    <p><code>   GetOverlappedResult(hInputFile, &amp;OverLapIn[ic], &amp;nin[ic], FALSE);</code></p>
    <p><code>   /* Обработать запись и инициировать операцию записи. */</code></p>
    <p><code>   CurPosIn.LowPart = OverLapIn[ic].Offset;</code></p>
    <p><code>   CurPosIn.HighPart = OverLapIn[ic].OffsetHigh;</code></p>
    <p><code>   CurPosOut.QuadPart = (CurPosIn.QuadPart / REC_SIZE) * UREC_SIZE;</code></p>
    <p><code>   OverLapOut[ic].Offset = CurPosOut.LowPart;</code></p>
    <p><code>   OverLapOut[ic].OffsetHigh = CurPosOut.HighPart;</code></p>
    <p><code>   /* Преобразовать запись из ASCII в Unicode. */</code></p>
    <p><code>   for (i =0; i &lt; REC_SIZE; i++) UnRec[ic][i] = AsRec[ic][i];</code></p>
    <p><code>   WriteFile(hOutputFile, UnRec[ic], nin[ic] * 2, &amp;nout[ic], &amp;OverLapOut[ic]);</code></p>
    <p><code>   /* Подготовиться к очередному чтению, которое будет инициировано после того, как завершится начатая выше операция записи. */</code></p>
    <p><code>   CurPosIn.QuadPart += REC_SIZE * (LONGLONG)(MAX_OVRLP);</code></p>
    <p><code>   OverLapIn[ic].Offset = CurPosIn.LowPart;</code></p>
    <p><code>   OverLapIn[ic].OffsetHigh = CurPosIn.HighPart;</code></p>
    <p><code>  } else if (ic &lt; 2 * MAX_OVRLP) { /* Операция записи завершилась. */</code></p>
    <p><code>   /* Начать чтение. */</code></p>
    <p><code>   ic –= MAX_OVRLP; /* Установить индекс выходного буфера. */</code></p>
    <p><code>   if (!GetOverlappedResult (hOutputFile, &amp;OverLapOut[ic], &amp;nout[ic], FALSE)) ReportError(_T("Ошибка чтения."), 0, TRUE);</code></p>
    <p><code>   CurPosIn.LowPart = OverLapIn[ic].Offset;</code></p>
    <p><code>   CurPosIn.HighPart = OverLapIn[ic].OffsetHigh;</code></p>
    <p><code>   if (CurPosIn.QuadPart &lt; FileSize.QuadPart) {</code></p>
    <p><code>    /* Начать новую операцию чтения. */</code></p>
    <p><code>    ReadFile(hInputFile, AsRec[ic], REC_SIZE, &amp;nin[ic], &amp;OverLapIn[ic]);</code></p>
    <p><code>   }</code></p>
    <p><code>  }</code></p>
    <p><code> } </code></p>
    <p><code> /* Закрыть все события. */</code></p>
    <p><code> for (ic = 0; ic &lt; MAX_OVRLP; ic++) {</code></p>
    <p><code>  CloseHandle(hEvents[0][ic]);</code></p>
    <p><code>  CloseHandle(hEvents[1][ic]);</code></p>
    <p><code> }</code></p>
    <p><code> CloseHandle(hInputFile);</code></p>
    <p><code> CloseHandle(hOutputFile);</code></p>
    <p><code> return 0; </code></p>
    <p><code>}</code> </p>
    <p>Программа 14.1 способна работать только под управлением Windows NT. Средства асинхронного ввода/вывода Windows 9x не позволяют использовать дисковые файлы. В приложении В приведены результаты и комментарии, свидетельствующие о сравнительно низкой производительности программы atouOV. Как показали эксперименты, для достижения приемлемой производительности размер буфера должен составлять, по крайней мере, 32 Кбайт, но даже и в этом случае обычный синхронный ввод/вывод работает быстрее. К тому же, производительность этой программы не повышается и в условиях SMP, поскольку в данном примере, в котором обрабатываются всего лишь два файла, ЦП не является критическим ресурсом.</p>
   </section>
   <section>
    <title>
     <p>Расширенный ввод/вывод с использованием процедуры завершения</p>
    </title>
    <section>
     <p>Существует также другой возможный подход к использованию объектов синхронизации. Вместо того чтобы заставлять поток ожидать поступления сигнала завершения от события или дескриптора, система может инициировать вызов определенной пользователем процедуры завершения сразу же по окончании выполнения операции ввода/вывода. Далее процедура завершения может запустить очередную операцию ввода/вывода и выполнить любые необходимые действия по учету использования системных ресурсов. Эта косвенно вызываемая (callback) процедура завершения аналогична асинхронному вызову процедуры, который применялся в главе 10, и требует использования состояний дежурного ожидания (alertable wait states).</p>
     <p>Каким образом процедура завершения может быть указана в программе? Среди параметров или структур данных функций ReadFile и WriteFile не остается таких, которые можно было бы использовать для хранения адреса процедуры завершения. Однако существует семейство расширенных функций ввода/вывода, которые обозначаются суффиксом "Ех" и содержат дополнительный параметр, предназначенный для передачи адреса процедуры завершения. Функциями чтения и записи являются, соответственно, ReadFileEx и WriteFileEx. Кроме того, требуется использование одной из указанных ниже функций дежурного ожидания.</p>
     <p><code>• WaitForSingleObjectEx</code></p>
     <p><code>• WaitForMultipleObjectsEx </code></p>
     <p><code>• SleepEx</code></p>
     <p><code>• SignalObjectAndWait</code></p>
     <p><code>• MsgWaitForMultipleObjectsEx</code></p>
     <p>Расширенный ввод/вывод иногда называют <emphasis>дежурным вводом/выводом</emphasis> (alertable I/O). О том, как использовать расширенные функции, рассказывается в последующих разделах.</p>
     <cite>
      <p><strong>Примечание</strong></p>
      <p>Под управлением Windows 9x расширенный ввод/вывод не может работать с дисковыми файлами и коммуникационными портами. В то же время, средства расширенного ввода/вывода Windows 9x способны работать с именованными каналами, почтовыми ящиками, сокетами и последовательными устройствами.</p>
     </cite>
    </section>
    <section>
     <title>
      <p>Функции ReadFileEx, WriteFileEx и процедурызавершения</p>
     </title>
     <p>Расширенные функции чтения и записи могут использоваться совместно с дескрипторами открытых файлов, именованных каналов и почтовых ящиков, если соответствующий объект открывался (создавался) с установленным флагом FILE_FLAG_OVERLAPPED. Заметьте, что этот флаг устанавливает атрибут дескриптора, и хотя перекрывающийся и расширенный ввод/вывод отличаются друг от друга, к дескрипторам обоих типов асинхронного ввода/вывода применяется один и тот же флаг.</p>
     <p>Перекрывающиеся сокеты (глава 12) могут использоваться совместно с функциями ReadFileEx и WriteFileEx во всех версиях Windows. </p>
     <cite>
      <p><code>BOOL ReadFileEx(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpcr)</code></p>
      <p><code>BOOL WriteFileEx(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpcr)</code> </p>
     </cite>
     <p>С обеими функциями вы уже знакомы, если не считать того, что каждая из них имеет дополнительный параметр, позволяющий указать адрес процедуры завершения. </p>
     <p>Каждой из функций необходимо предоставлять структуру OVERLAPPED, но надобность в указании элемента hEvent этой структуры отсутствует; система игнорирует его. Вместе с тем, этот элемент оказывается очень полезным для передачи такой, например, информации, как порядковый номер, используемый для различения отдельных операций ввода/вывода, что демонстрируется в программе 14.2.</p>
     <p>Сравнивая с функциями ReadFile и WriteFile, можно заметить, что расширенные функции не требуют параметров для хранения количества переданных байтов. Эта информация передается функции завершения, которая должна включаться в программу.</p>
     <p>В функции завершения предусмотрены параметры для счетчика байтов, кода ошибки и адреса структуры OVERLAPPED. Последний из названных параметров требуется для того, чтобы процедура завершения могла определить, какая именно из невыполненных операций завершилась. Заметьте, что ранее высказанные предостережения относительно повторного использования или уничтожения структур OVERLAPPED справедливы здесь в той же мере, что и в случае перекрывающегося ввода/вывода. </p>
     <cite>
      <p><code>VOID WINAPI <emphasis>FileIOCompletionRoutine</emphasis>(DWORD dwError, DWORD cbTransferred, LPOVERLAPPED lpo)</code> </p>
     </cite>
     <p>Как и в случае функции CreateThread, при вызове которой также указывается имя некоторой функции, имя <emphasis>FileIOCompletionRoutine</emphasis> является заменителем, а не фактическим именем процедуры завершения.</p>
     <p>Значения параметра dwError ограничены 0 (успешное завершение) и ERROR_HANDLE_EOF (при попытке выполнить чтение с выходом за пределы файла). Структура OVERLAPPED — это та структура, которая использовалась завершившимся вызовом ReadFileEx или WriteFileEx.</p>
     <p>Прежде чем процедура завершения будет вызвана системой, должны произойти две вещи:</p>
     <p>1. Должна завершиться операция ввода/вывода.</p>
     <p>2. Вызывающий поток должен находиться в состоянии дежурного ожидания, извещая систему о том, что требуется выполнить процедуру завершения, находящуюся в очереди.</p>
     <p>Каким образом поток переходит в состояние дежурного ожидания? Он должен выполнить явный вызов одной из функций дежурного ожидания, описанных в следующем разделе. Тем самым поток создает условия, делающие преждевременное выполнение процедуры завершения невозможным. В состоянии дежурного ожидания поток может находиться только на протяжении того времени, пока длится вызов функции дежурного ожидания; после возврата из этой функции поток выходит из указанного состояния. </p>
     <p>Если оба эти условия удовлетворены, выполняются процедуры завершения, помещенные в очередь в результате завершения операций ввода/вывода. <emphasis>Процедуры завершения выполняются в том же потоке, который выполнил первоначальный вызов функции ввода/вывода и находится в состоянии дежурного ожидания.</emphasis> Поэтому поток должен переходить в состояние дежурного ожидания только тогда, когда для выполнения процедур завершения существуют безопасные условия.</p>
    </section>
    <section>
     <title>
      <p>Функции дежурного ожидания</p>
     </title>
     <p>Всего предусмотрено пять функций дежурного ожидания, но ниже приводятся прототипы только трех из них, которые представляют для нас непосредственный интерес: </p>
     <cite>
      <p><code>DWORD WaitForSingleObjectEx(HANDLE hObject, DWORD dwMilliseconds, BOOL bAlertable)</code></p>
      <p><code>DWORD WaitForMultipleObjectsEx(DWORD cObjects, LPHANDLE lphObjects, BOOL fWaitAll, DWORD dwMilliseconds, BOOL bAlertable)</code></p>
      <p><code>DWORD SleepEx(DWORD dwMilliseconds, BOOL bAlertable)</code> </p>
     </cite>
     <p>В каждой из функций дежурного ожидания имеется флаг bAlertable, который в случае асинхронного ввода/вывода должен устанавливаться в TRUE. Приведенные выше функции являются расширением знакомых вам функций Wait и Sleep.</p>
     <p>Длительность интервалов ожидания указывается, как обычно, в миллисекундах. Каждая из этих трех функций осуществляет возврат, как только наступает <emphasis>любая</emphasis> из перечисленных ниже ситуаций:</p>
     <p>• Дескриптор (дескрипторы) переходит (переходят) в сигнальное состояние, чем удовлетворяются стандартные требования двух из функций ожидания.</p>
     <p>• Истекает интервал ожидания.</p>
     <p>• Все процедуры завершения, находящиеся в очереди потока, прекращают свое выполнение, а значение параметра bAlertable равно TRUE. Процедура завершения помещается в очередь тогда, когда завершается соответствующая ей операция ввода/вывода (рис. 14.2). </p>
     <p>Заметьте, что со структурами OVERLAPPED в функциях ReadFileEx и WriteFileEx не связаны никакие события, поэтому ни один из дескрипторов, указываемых при вызове функции ожидания, не связывается непосредственно с какой-либо определенной операцией ввода/вывода. В то же время, функция SleepEx не связана с объектами синхронизации, и поэтому ее проще всего использовать. В случае функции SleepEx в качестве длительности интервала ожидания обычно указывают значение INFINITE, поэтому возврат из этой функции произойдет только после того, как закончится выполнение одной или нескольких процедур завершения, которые в настоящий момент находятся в очереди.</p>
    </section>
    <section>
     <title>
      <p>Выполнение процедуры завершения и возврат из функции дежурного ожидания</p>
     </title>
     <p>По окончании выполнения операции расширенного ввода/вывода связанная с ней процедура завершения со своими аргументами, определяющими структуру OVERLAPPED, счетчик байтов и код ошибки, помещается в очередь для выполнения.</p>
     <p>Все процедуры завершения, находящиеся в очереди потока, начинают выполняться тогда, когда поток переходит в состояние дежурного ожидания. Они выполняются поочередно, но не обязательно в той же последовательности, в которой завершились операции ввода/вывода. Возврат из функции дежурного ожидания происходит только после того, как осуществят возврат процедуры завершения. Эту особенность важно учитывать для обеспечения правильного функционирования большинства программ, поскольку при этом предполагается, что процедуры завершения получают возможность подготовиться к очередному использованию структуры OVERLAPPED и выполнить другие необходимые действия для перевода программы в известное состояние, прежде чем будет осуществлен возврат из состояния дежурного ожидания.</p>
     <p>Если возврат из функции SleepEx обусловлен выполнением одной или нескольких процедур завершения, находящихся в очереди, то возвращаемым значением функции будет WAIT_TO_COMPLETION, и это же значение будет возвращено функцией GetLastError, вызванной после выполнения возврата одной из функций ожидания.</p>
     <p>В заключение отметим два момента:</p>
     <p>1. При вызове любой из функций дежурного ожидания в качестве значения параметра интервала ожидания используйте INFINITE. В отсутствие возможности истечения интервала ожидания возврат из функций будет осуществляться лишь после того, как закончится выполнение всех процедур завершения или дескрипторы перейдут в сигнальное состояние.</p>
     <p>2. Для передачи информации процедуре завершения общепринято использовать элемент данных hEvent структуры OVERLAPPED, поскольку это поле игнорируется ОС. </p>
     <p>Взаимодействие между основным потоком, процедурами завершения и функциями дежурного ожидания иллюстрирует рис. 14.2. В этом примере запускаются три параллельные операции чтения, две из которых завершаются к тому моменту, когда начинается выполнение дежурного ожидания. </p>
     <image l:href="#Any2FbImgLoader145"/>
     <p><strong>Рис. 14.2. </strong>Асинхронный ввод/вывод с использованием процедур завершения</p>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: преобразование файла с использованием расширенного ввода/вывода</p>
    </title>
    <p>Программа 14.3 (atouEX) представляет собой переработанную версию программы 14.1. Эти программы иллюстрируют различие между двумя методами асинхронного ввода/вывода. Программа atouEx аналогична программе 14.1, но большая часть кода, предназначенного для упорядочения ресурсов, перемещена в ней в процедуру завершения, а многие переменные сделаны глобальными, чтобы процедура завершения могла иметь к ним доступ. Вместе с тем, в приложении В показано, что в отношении быстродействия программа atouEx вполне может конкурировать с другими методами, в которых не используется отображение файлов, тогда как программа atouOV работает медленнее. </p>
    <subtitle>Программа 14.2. atouEx: преобразование файла с использованием расширенного ввода/вывода</subtitle>
    <p><code>/* Глава 14. atouEX</code></p>
    <p><code>   Преобразование файла из ASCII в Unicode средствами РАСШИРЕННОГО ВВОДА/ВЫВОДА. */ </code></p>
    <p><code>/* atouEX файл1 файл2 */</code></p>
    <empty-line/>
    <p><code>#include "EvryThng.h"</code></p>
    <p><code>#define MAX_OVRLP 4</code></p>
    <p><code>#define REC_SIZE 8096 /* Размер блока не имеет столь важного значения в отношении производительности, как в случае atouOV. */ </code></p>
    <p><code>#define UREC_SIZE 2 * REC_SIZE</code></p>
    <empty-line/>
    <p><code>static VOID WINAPI ReadDone(DWORD, DWORD, LPOVERLAPPED); </code></p>
    <p><code>static VOID WINAPI WriteDone(DWORD, DWORD, LPOVERLAPPED);</code></p>
    <empty-line/>
    <p><code>/* Первая структура OVERLAPPED предназначена для чтения, а вторая — для записи. Структуры и буферы распределяются для каждой предстоящей операции. */</code></p>
    <p><code>OVERLAPPED OverLapIn[MAX_OVRLP], OverLapOut [MAX_OVRLP];</code></p>
    <p><code>CHAR AsRec[MAX_OVRLP][REC_SIZE];</code></p>
    <p><code>WCHAR UnRec[MAX_OVRLP][REC_SIZE];</code></p>
    <p><code>HANDLE hInputFile, hOutputFile;</code></p>
    <p><code>LONGLONG nRecord, nDone;</code></p>
    <p><code>LARGE_INTEGER FileSize;</code></p>
    <empty-line/>
    <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> DWORD ic;</code></p>
    <p><code> LARGE_INTEGER CurPosIn;</code></p>
    <p><code> hInputFile = CreateFile(argv[1], GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);</code></p>
    <p><code> hOutputFile = CreateFile(argv[2], GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_FLAG_OVERLAPPED, NULL);</code></p>
    <p><code> FileSize.LowPart = GetFileSize(hInputFile, &amp;FileSize.HighPart);</code></p>
    <p><code> nRecord = FileSize.QuadPart / REC_SIZE;</code></p>
    <p><code> if ((FileSize.QuadPart % REC_SIZE) != 0) nRecord++;</code></p>
    <p><code> CurPosIn.QuadPart = 0;</code></p>
    <p><code> for (ic = 0; ic &lt; MAX_OVRLP; ic++) {</code></p>
    <p><code>  OverLapIn[ic].hEvent = (HANDLE)ic; /* Перегрузить событие. */</code></p>
    <p><code>  OverLapOut[ic].hEvent = (HANDLE)ic; /* Поля. */</code></p>
    <p><code>  OverLapIn[ic].Offset = CurPosIn.LowPart;</code></p>
    <p><code>  OverLapIn[ic].OffsetHigh = CurPosIn.HighPart;</code></p>
    <p><code>  if (CurPosIn.QuadPart &lt; FileSize.QuadPart) ReadFileEx(hInputFile, AsRec[ic], REC_SIZE, &amp;OverLapIn [ic], ReadDone);</code></p>
    <p><code>  CurPosIn.QuadPart += (LONGLONG)REC_SIZE;</code></p>
    <p><code> }</code></p>
    <p><code> /* Выполняются все операции чтения. Войти в состояние дежурного ожидания и оставаться в нем до тех пор, пока не будут обработаны все записи.*/</code></p>
    <p><code> nDone = 0; </code></p>
    <p><code> while (nDone &lt; 2 * nRecord) SleepEx(INFINITE, TRUE);</code></p>
    <p><code> CloseHandle(hInputFile);</code></p>
    <p><code> CloseHandle(hOutputFile);</code></p>
    <p><code> _tprintf(_T("Преобразование из ASCII в Unicode завершено.\n"));</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>static VOID WINAPI ReadDone(DWORD Code, DWORD nBytes, LPOVERLAPPED pOv) {</code></p>
    <p><code> /* Чтение завершено. Преобразовать данные и инициировать запись. */</code></p>
    <p><code> LARGE_INTEGER CurPosIn, CurPosOut;</code></p>
    <p><code> DWORD ic, i;</code></p>
    <p><code> nDone++;</code></p>
    <p><code> /* Обработать запись и инициировать операцию записи. */</code></p>
    <p><code> ic = (DWORD)(pOv-&gt;hEvent);</code></p>
    <p><code> CurPosIn.LowPart = OverLapIn[ic].Offset;</code></p>
    <p><code> CurPosIn.HighPart = OverLapIn[ic].OffsetHigh;</code></p>
    <p><code> CurPosOut.QuadPart = (CurPosIn.QuadPart / REC_SIZE) * UREC_SIZE;</code></p>
    <p><code> OverLapOut[ic].Offset = CurPosOut.LowPart;</code></p>
    <p><code> OverLapOut[ic].OffsetHigh = CurPosOut.HighPart;</code></p>
    <p><code> /* Преобразовать запись из ASCII в Unicode. */</code></p>
    <p><code> for (i = 0; i &lt; nBytes; i++) UnRec[ic][i] = AsRec[ic][i];</code></p>
    <p><code> WriteFileEx(hOutputFile, UnRec[ic], nBytes*2, &amp;OverLapOut[ic], WriteDone);</code></p>
    <p><code> /* Подготовить структуру OVERLAPPED для следующего чтения. */</code></p>
    <p><code> CurPosIn.QuadPart += REC_SIZE * (LONGLONG)(MAX_OVRLP);</code></p>
    <p><code> OverLapIn[ic].Offset = CurPosIn.LowPart;</code></p>
    <p><code> OverLapIn[ic].OffsetHigh = CurPosIn.HighPart;</code></p>
    <p><code> return;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>static VOID WINAPI WriteDone(DWORD Code, DWORD nBytes, LPOVERLAPPED pOv) {</code></p>
    <p><code> /* Запись завершена. Инициировать следующую операцию чтения. */</code></p>
    <p><code> LARGE_INTECER CurPosIn;</code></p>
    <p><code> DWORD ic;</code></p>
    <p><code> nDone++;</code></p>
    <p><code> ic = (DWORD)(pOv-&gt;hEvent);</code></p>
    <p><code> CurPosIn.LowPart = OverLapIn[ic].Offset;</code></p>
    <p><code> CurPosIn.HighPart = OverLapIn[ic].OffsetHigh;</code></p>
    <p><code> if (CurPosIn.QuadPart &lt; FileSize.QuadPart) {</code></p>
    <p><code>  ReadFileEx(hInputFile, AsRec[ic], REC_SIZE, &amp;OverLapIn[ic], ReadDone);</code></p>
    <p><code> }</code></p>
    <p><code> return;</code></p>
    <p><code>}</code></p>
   </section>
   <section>
    <title>
     <p>Асинхронный ввод/вывод сиспользованием нескольких потоков</p>
    </title>
    <p>Перекрывающийся и расширенный ввод/вывод позволяют добиться асинхронного выполнения операций ввода/вывода в пределах единственного потока, хотя для поддержки этой функциональности ОС создает собственные потоки. В том или ином виде методы этого типа часто используются во многих ранних ОС для поддержки ограниченных форм выполнения асинхронных операций в однопоточных системах.</p>
    <p>Однако Windows обеспечивает многопоточную поддержку, поэтому становится возможным достижение того же эффекта за счет выполнения синхронных операций ввода/вывода в нескольких, выполняемых независимо потоках. Ранее эти возможности уже были продемонстрированы на примере многопоточных серверов и программы grepMT (глава 7). Кроме того, потоки обеспечивают концептуально последовательный и, предположительно, гораздо более простой способ выполнения асинхронных операций ввода/вывода. В качестве альтернативы методам, используемым в программах 14.1 и 14.2, можно было бы предоставить каждому потоку собственный дескриптор файла, и тогда каждый из потоков мог бы обрабатывать в синхронном режиме каждую четвертую запись.</p>
    <p>Такой способ использования потоков продемонстрирован в программе atouMT, которая в книге не приводится, но включена в материал, размещенный на Web-сайте. Программа atouMT не только способна выполняться под управлением любой версии Windows, но и более проста по сравнению с любым из двух вариантов программ асинхронного ввода/вывода, поскольку учет использования ресурсов в этом случае менее сложен. Каждый поток просто поддерживает собственные буферы в собственном стеке и выполняет в цикле последовательность синхронных операций чтения, преобразования и записи. При этом производительность программы остается на достаточно высоком уровне.</p>
    <cite>
     <p><strong>Примечание</strong></p>
     <p>В программе atouMT.с, которая находится на Web-сайте, содержатся комментарии по поводу нескольких возможных "ловушек", которые могут поджидать вас при организации доступа одновременно нескольких потоков к одному и тому же файлу. В частности, все отдельные дескрипторы файлов должны создаваться с помощью функции CreateHandle, а не функции DuplicateHandle.</p>
    </cite>
    <p>Лично я предпочитаю использовать многопоточную обработку файлов, а не асинхронные операции ввода/вывода. Потоки легче программировать, и в большинстве случаев они обеспечивают более высокую производительность.</p>
    <p>Существуют два исключения из этого общего правила. Первое из них, как было показано ранее в этой главе, касается ситуаций, в которых может быть только одна невыполненная операция, и в целях синхронизации можно использовать дескриптор файла. Второе, более важное исключение встречается в случае портов завершения асинхронного ввода/вывода, о чем будет говориться в конце настоящей главы. </p>
   </section>
   <section>
    <title>
     <p>Таймеры ожидания</p>
    </title>
    <p>Windows NT поддерживает таймеры ожидания (waitable timers), являющихся одним из типов объектов ядра, осуществляющих ожидание.</p>
    <p>Вы всегда можете создать собственный сигнал синхронизации, создав синхронизирующий поток, который устанавливает событие в результате пробуждения после вызова функции Sleep. В программе serverNP (программа 11.3) сервер также использует синхронизирующий поток для периодической широковещательной рассылки имени своего канала. Поэтому таймеры ожидания обеспечивают хотя и несколько избыточный, но удобный способ организации выполнения задач на периодической основе или в соответствии с определенным расписанием. В частности, таймер ожидания можно настроить таким образом, чтобы сигнал был сгенерирован в строго определенное время.</p>
    <p>Таймер ожидания может быть либо синхронизирующим (synchronization timer), либо сбрасываемым вручную уведомляющим (manual-reset notification timer) таймером. Синхронизирующий таймер связывается с функцией косвенного вызова, аналогичной процедуре завершения расширенного ввода/вывода, тогда как для синхронизации по сбрасываемому вручную уведомляющему таймеру используется функция ожидания.</p>
    <p>Для начала потребуется создать дескриптор таймера, используя для этого функцию CreateWaitableTimer. </p>
    <cite>
     <p><code>HANDLE CreateWaitableTimer(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCTSTR lpTimerName);</code></p>
    </cite>
    <p>Второй параметр, bManualReset, определяет, таймер какого типа должен быть создан — синхронизирующий или уведомляющий. В программе 14.3 используется синхронизирующий таймер, но, изменив комментарии и настройку параметра, вы легко превратите его в уведомляющий таймер. Заметьте, что существует также функция OpenWaitableTimer, которая может использовать необязательное имя, предоставляемое третьим аргументом.</p>
    <p>Первоначально таймер создается в неактивном состоянии, но с помощью функции SetWaitableTimer его можно активизировать и указать начальную временную задержку, а также длительность промежутка времени между периодически вырабатываемыми сигналами.</p>
    <cite>
     <p><code>BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *pDueTime, LONG IPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume);</code> </p>
    </cite>
    <p>hTimer — действительный дескриптор таймера, созданного с использованием функции CreateWaitableTimer.</p>
    <p>Второй параметр, на который указывает указатель pDueTime, может принимать либо положительные значения, соответствующие абсолютному времени, либо отрицательные, соответствующие относительному времени, причем фактические значения выражаются в единицах времени длительностью 100 наносекунд, а их формат описывается структурой FILETIME. Переменные типа FILETIME были введены в главе 3 и уже использовались нами в главе 6 в программе timep (программа 6.2).</p>
    <p>Величина интервала между сигналами, указываемая в третьем параметре, выражается в миллисекундах. Если это значение установлено равным 0, то таймер переводится в сигнальное состояние только один раз. При положительных значениях этого параметра таймер является периодическим и срабатывает периодически до тех пор, пока его действие не будет прекращено вызовом функции CancelWaitableTimer. Отрицательные значения указанного интервала не допускаются.</p>
    <p>Четвертый параметр, pfnCompletionRoutine, применяется в случае синхронизирующего таймера и указывает адрес процедуры завершения, которая вызывается при переходе таймера в сигнальное состояние <emphasis>и при условии,</emphasis> что поток переходит в состояние дежурного ожидания. При вызове этой процедуры в качестве одного из аргументов используется указатель, определяемый пятым параметром, plArgToComplretionRoutine.</p>
    <p>Установив синхронизирующий таймер, вы можете перевести поток в состояние дежурного ожидания путем вызова функции SleepEx, чтобы обеспечить возможность вызова процедуры завершения. В случае сбрасываемого вручную уведомляющего таймера следует организовать ожидание перехода дескриптора таймера в сигнальное состояние. Дескриптор будет оставаться в сигнальном состоянии до следующего вызова функции SetWaitableTimer. Полная версия программы 14.3, находящаяся на Web-сайте, предоставляет вам возможность проводить собственные эксперименты, используя таймер выбранного типа в сочетании с процедурой завершения или ожиданием перехода дескриптора таймера в сигнальное состояние, что в итоге дает четыре различные комбинации.</p>
    <p>Последний параметр, fResume, связан с режимами энергосбережения. Для получения более подробной информации по этому вопросу обратитесь к справочной документации.</p>
    <p>Функция CancelWaitableTimer используется для отмены действия вызванной перед этим функции SetWaitableTimer, но при этом не изменяет сигнальное состояние таймера. Чтобы это сделать, необходимо в очередной раз вызвать функцию SetWaitableTimer.</p>
   </section>
   <section>
    <title>
     <p>Пример: использование таймера ожидания</p>
    </title>
    <section>
     <p>В программе 14.3 демонстрируется применение таймера ожидания для генерации периодических сигналов.</p>
     <subtitle>Программа 14.3. TimeBeep: генерация периодических сигналов </subtitle>
     <p><code>/* Глава 14. TimeBeep.с. Периодическое звуковое оповещение.  */</code></p>
     <p><code>/* Использование: TimeBeep период (в миллисекундах). */</code></p>
     <empty-line/>
     <p><code>#include "EvryThng.h"</code></p>
     <p><code>static BOOL WINAPI Handler(DWORD CntrlEvent); </code></p>
     <p><code>static VOID APIENTRY Beeper(LPVOID, DWORD, DWORD); </code></p>
     <p><code>volatile static BOOL Exit = FALSE; </code></p>
     <p><code>HANDLE hTimer;</code></p>
     <empty-line/>
     <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
     <p><code> DWORD Count = 0, Period;</code></p>
     <p><code> LARGE_INTEGER DueTime;</code></p>
     <p><code> /* Перехват нажатия комбинации клавиш &lt;Ctrl-c&gt; для прекращения операции. См. главу 4. */</code></p>
     <p><code> SetConsoleCtrlHandler(Handler, TRUE);</code></p>
     <p><code> Period = _ttoi(argv[1]) * 1000;</code></p>
     <p><code> DueTime.QuadPart = –(LONGLONG)Period * 10000;</code></p>
     <p><code> /* Параметр DueTime отрицателен для первого периода ожидания и задается относительно текущего времени. Период ожидания измеряется в мс (10<sup>-3 </sup>с), a DueTime — в единицах по 100 нc (10<sup>-7 </sup>с) для согласования с типом FILETIME. */</code></p>
     <p><code> hTimer = CreateWaitableTimer(NULL, FALSE /* "Таймер синхронизации" */, NULL);</code></p>
     <p><code> SetWaitableTimer(hTimer, &amp;DueTime, Period, Beeper, &amp;Count, TRUE);</code></p>
     <p><code> while (!Exit) {</code></p>
     <p><code>  _tprintf(_T("Count = %d\n"), Count);</code></p>
     <p><code>  /* Значение счетчика увеличивается в процедуре таймера. */</code></p>
     <p><code>  /* Войти в состояние дежурного ожидания. */</code></p>
     <p><code>  SleepEx(INFINITE, TRUE);</code></p>
     <p><code> }</code></p>
     <p><code> _tprintf(_T("Завершение. Счетчик = %d"), Count);</code></p>
     <p><code> CancelWaitableTimer(hTimer);</code></p>
     <p><code> CloseHandle(hTimer);</code></p>
     <p><code> return 0; </code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>static VOID APIENTRY Beeper(LPVOID lpCount, DWORD dwTimerLowValue, DWORD dwTimerHighValue) {</code></p>
     <p><code> *(LPDWORD)lpCount = *(LPDWORD)lpCount + 1; </code></p>
     <p><code> _tprintf(_T("Генерация сигнала номер: %d\n"), *(LPDWORD) lpCount);</code></p>
     <p><code> Веер(1000 /* Частота. */, 250 /* Длительность (мс). */);</code></p>
     <p><code> return;</code></p>
     <p><code>}</code></p>
     <empty-line/>
     <p><code>BOOL WINAPI Handler(DWORD CntrlEvent) {</code></p>
     <p><code> Exit = TRUE;</code></p>
     <p><code> _tprintf(_T("Завершение работы\n"));</code></p>
     <p><code> return TRUE; </code></p>
     <p><code>}</code> </p>
    </section>
    <section>
     <title>
      <p>Комментарии к примеру с таймером ожидания</p>
     </title>
     <p>Исходя из типа таймера и используя либо процедуру завершения, либо ожидание перехода дескриптора в сигнальное состояние, можно образовать четыре различных комбинации. Программа 14.3 иллюстрирует использование процедуры завершения и синхронизирующего таймера. Вы сможете тестировать каждую из четырех возможных комбинаций, изменяя комментарии в версии программы TimeBeep.с, доступной на Web-сайте.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Порты завершения ввода/вывода</p>
    </title>
    <section>
     <p>Порты завершения ввода/вывода, поддерживаемые лишь на NT-платформах, объединяют в себе возможности перекрывающегося ввода/вывода и независимых потоков и используются чаще всего в серверных программах. Чтобы выяснить, какими требованиями это может диктоваться, обратимся к серверам, построенным в главах 11 и 12, где каждый клиент поддерживался отдельным рабочим потоком, связанным с сокетом или экземпляром именованного канала. Это решение хорошо работает лишь в тех случаях, когда число клиентов невелико.</p>
     <p>Посмотрим, однако, что произойдет, если число клиентов достигнет 1000. В имеющейся модели для этого потребуется 1000 потоков, для каждого из которых необходимо выделить значительный объем виртуальной памяти. Так, по умолчанию каждому потоку выделяется 1 Мбайт стекового пространства, так что для 1000 потоков потребуется 1 Гбайт, и переключение контекстов потоков может увеличить задержки, обусловленные ошибками из-за отсутствия страниц.<a l:href="#n_35" type="note">[35]</a> Кроме того, потоки будут состязаться между собой за право владения общими ресурсами как на уровне планировщика, так и внутри процесса, и это, как было показано в главе 9, может приводить к снижению производительности. В связи с этим требуется механизм, позволяющий небольшому пулу рабочих потоков обслуживать большое количество клиентов.</p>
     <p>Искомое решение обеспечивается портами завершения ввода/вывода, которые предоставляют возможность создавать ограниченное количество серверных потоков в пуле потоков, имея очень большое количество дескрипторов именованных каналов (или сокетов). При этом дескрипторы не соединяются попарно с отдельными рабочими серверными потоками; серверный поток может обслуживать любой дескриптор, данные которого нуждаются в обработке.</p>
     <p>Итак, порт завершения ввода/вывода — это набор перекрывающихся дескрипторов, и потоки ожидают перехода порта в сигнальное состояние. Когда завершается операция чтения или записи с участием какого-либо дескриптора, один из потоков пробуждается и принимает данные и результаты выполнения операции ввода/вывода. Далее поток может обработать данные и вновь перейти в состояние ожидания перехода порта в сигнальное состояние.</p>
     <p>Прежде всего необходимо создать порт завершения ввода/вывода и присоединить к нему перекрывающиеся дескрипторы.</p>
    </section>
    <section>
     <title>
      <p>Управление портами завершения ввода/вывода</p>
     </title>
     <p>Для создания порта и присоединения к нему дескрипторов используется одна и та же функция — CreateCompletionPort. Необходимость выполнения этой функцией двух разных задач соответственно усложняет использование ее параметров. </p>
     <cite>
      <p><code>HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, DWORD CompletionKey, DWORD NumberOfConcurrentThreads);</code></p>
     </cite>
     <p>Порт завершения ввода/вывода представляет собой совокупность дескрипторов файлов, открытых в режиме OVERLAPPED. Параметр FileHandle — это перекрывающийся дескриптор, присоединяемый к порту. Если задать его значение равным INVALID_DESCRIPTOR_HANDLE, то функция создаст новый порт завершения ввода/вывода и возвратит его дескриптор. В этом случае следующий параметр, ExistingCompletionPort, должен быть установлен в NULL.</p>
     <p>ExistingCompletionPort — порт, созданный при первом вызове функции, к которому должен быть присоединен дескриптор, указанный в первом параметре. В случае успешного выполнения функция возвращает дескриптор порта, иначе — NULL.</p>
     <p>CompletionKey — указывает ключ, который будет включен в пакет завершения для дескриптора FileHandle. Обычно в качестве ключа используется значение индекса массива структур данных, содержащих тип операции, дескриптор и указатель на буфер данных. </p>
     <p>NumberOfConcurrentThreads — предельно допустимое количество потоков, которым разрешено параллельное выполнение. При наличии других потоков сверх этого количества, ожидающих перехода порта в сигнальное состояние, они будут оставаться блокированными, даже если существует дескриптор с доступными данными. Если этот параметр установлен равным 0, то в качестве предела используется количество процессоров, установленных в системе.</p>
     <p>Количество перекрывающихся дескрипторов, которые могут быть связаны с одним портом завершения ввода/вывода, ничем не ограничивается. Первоначальный вызов функции CreateCompletionPort используется для создания порта и указания максимального количества потоков. Для каждого очередного перекрывающегося дескриптора, подлежащего связыванию с данным портом, следует повторно вызывать эту же функцию. К сожалению, способов, позволяющих удалить дескриптор из порта завершения, не существует, и это упущение значительно ограничивает гибкость программ.</p>
     <p>Дескрипторы, связанные с портом не должны использоваться совместно с функциями ReadFileEx и WriteFileEx. В документации Microsoft не рекомендуется разделять файлы и объекты иного типа, используя другие открытые дескрипторы.</p>
    </section>
    <section>
     <title>
      <p>Ожидание порта завершения ввода/вывода</p>
     </title>
     <p>Для выполнения ввода/вывода с участием дескрипторов, связанных с портом, используются функции ReadFile и WriteFile со структурами OVERLAPPED (дескрипторы событий не требуются). Далее операция ввода/вывода помещается в очередь порта завершения.</p>
     <p>Поток ожидает завершения перекрывающейся операции ввода/вывода, находящейся в очереди, не путем ожидания события, а путем вызова функции GetQueueCompletionStatus с указанием порта завершения (completion port). Когда вызывающий поток пробуждается, функция возвращает ключ, который был указан при первоначальном присоединении к порту дескриптора, чья операция завершилась, и этот ключ может указывать количество переданных байтов и идентификационные данные фактического дескриптора, связанного с завершившейся операцией.</p>
     <p>Следует отметить, что уведомление о завершении операции получит не обязательно тот же поток, который инициировал чтение или запись. Уведомление о завершении операции может быть получено любым ожидающим потоком. Поэтому необходимо, чтобы ключ мог идентифицировать дескриптор, связанный с завершившейся операцией.</p>
     <p>Имеется также возможность использовать конечный интервал ожидания (time-out). </p>
     <cite>
      <p><code>BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, LPDWORD lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds);</code> </p>
     </cite>
     <p>Иногда может оказаться удобным, чтобы операция не помещалась в очередь порта завершения ввода/вывода. В этом случае поток может ожидать наступления перекрывающегося события, как показано в программе 14.4 и дополнительном примере, atouMTCP, который находится на Web-сайте. Для указания того, что перекрывающаяся операция <emphasis>не </emphasis>должна помещаться в очередь порта завершения, вы должны установить младший бит дескриптора события (hEvent) в структуре OVERLAPPED; тогда вы получите возможность ожидать наступления события для данной конкретной операции. Такое решение является довольно странным, однако оно документировано, хотя особо и не подчеркивается.</p>
    </section>
    <section>
     <title>
      <p>Отправка уведомления порту завершения ввода/вывода</p>
     </title>
     <p>Поток может отправить в порт событие завершения вместе с ключом, чтобы завершить остающийся невыполненным вызов функции GetQueueCompletionStatus. Вся необходимая для этого информация предоставляется функцией PostQueueCompletionStatus. </p>
     <cite>
      <p><code>BOOL PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, DWORD dwCompletionKey, LPOVERLAPPED lpOverlapped);</code> </p>
     </cite>
     <p>Для пробуждения ожидающих потоков даже в условиях отсутствия завершившихся операций иногда используют метод, суть которого заключается в предоставлении фиктивного значения ключа, например, –1. Ожидающие потоки должны проверять значения ключей, и эта методика может использоваться, например, для того, чтобы сигнализировать потоку о необходимости завершить работу.</p>
    </section>
    <section>
     <title>
      <p>Альтернативы портам завершенияввода/вывода</p>
     </title>
     <p>В главе 9 было показано, как использовать семафор для ограничения количества готовых к выполнению потоков, и этот же метод можно эффективно применять для регулирования пропускной способности в условиях, когда множество потоков соревнуются между собой за право владения ограниченными ресурсами.</p>
     <p>Эту же методику мы могли бы применить и в серверах serverSK (программа 12.2) и serverNP (программа 11.3). Все, что для этого требуется — это организовать ожидание перехода семафора в сигнальное состояние после завершения запроса на чтение, выполнение этого запроса, создание ответа и освобождение семафора перед тем, как записать ответ. Такое решение гораздо проще того, которое реализовано в примере с портом завершения ввода/вывода, приведенном в следующем разделе. Единственная проблема состоит в том, что потоков может оказаться очень много, и для каждой из них требуется собственное стековое пространство, что приведет к большому расходу виртуальной памяти. Остроту этой проблемы можно несколько ослабить, тщательно распределяя необходимые объемы стекового пространства. Упражнение 14.6 включает в себя выполнение экспериментов с альтернативным решением подобного рода, а реализация соответствующего примера находится на Web-сайте.</p>
     <p>Существует еще одна возможность, которую можно использовать при создании масштабируемых серверов. Выборка пакетов рабочих заготовок (work items) из очереди (см. главу 10) может осуществляться с использованием ограниченного количества потоков. Поступающие рабочие заготовки могут помещаться в очередь одной или несколькими главными потоками, как показано в программе 10.5.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: сервер, использующий порты завершения ввода/вывода</p>
    </title>
    <p>Программа 14.4 представляет видоизмененный вариант программы serverNP (программа 11.3), в котором используются порты завершения ввода/вывода. Этот сервер создает небольшой пул серверных потоков и больший пул дескрипторов перекрывающихся каналов, а также ключей завершения, по одному для каждого дескриптора. Перекрывающиеся дескрипторы присоединяются к порту завершения, а затем вызывается функция ConnectNamedPipe. Серверные потоки ожидают сигналов завершения, связанных как с подключениями клиентов, так и с операциями чтения. Когда регистрируется операция чтения, обрабатывается соответствующий клиентский запрос, и результаты возвращаются без использования порта завершения. Вместо этого серверный поток ожидает наступления события после выполнения операции записи, причем младший бит дескриптора события в структуре OVERLAPPED устанавливается в 1.</p>
    <p>В другом возможном варианте решения, отличающемся большей гибкостью, можно было бы закрывать дескриптор при каждом отсоединении клиента и создавать новый дескриптор для каждого нового подключения. Этот способ аналогичен тому, который использовался в случае сокетов в главе 12. Вместе с тем, имеется одна трудность, обусловленная невозможностью удаления дескрипторов из порта завершения, в результате чего использование короткоживущих дескрипторов подобного рода будет приводить к утечке ресурсов. </p>
    <p>Поскольку с большей частью кода вы уже знакомы по предыдущим примерам, она здесь не приводится.</p>
    <subtitle>Программа 14.4. serverCP: сервер, использующий порт завершения </subtitle>
    <p><code>/* Глава 14. ServerCP. Многопоточный сервер.</code></p>
    <p><code>   Версия на основе именованного канала, пример ПОРТА ЗАВЕРШЕНИЯ.</code></p>
    <p><code>   Использование: Server [ИмяПользователя ИмяГруппы]. */</code></p>
    <empty-line/>
    <p><code>#include "EvryThng.h" </code></p>
    <p><code>#include "ClntSrvr.h"</code></p>
    <empty-line/>
    <p><code>/* Здесь определяются сообщения запроса и ответа. */</code></p>
    <p><code>typedef struct { /*Структуры, на которые указывают ключи портов завершения*/</code></p>
    <p><code> HANDLE hNp; /* и которые представляют еще не выполненные операции */</code></p>
    <p><code> REQUEST Req; /* ReadFile и ConnectNamedPipe. */</code></p>
    <p><code> DWORD Type; /* 0 – ConnectNamedPipe; 1 – ReadFile. */</code></p>
    <p><code> OVERLAPPED Ov; </code></p>
    <p><code>} CP_KEY;</code></p>
    <empty-line/>
    <p><code>static CP_KEY Key[MAX_CLIENTS_CP]; /* Доступно всем потокам. */ </code></p>
    <p><code>/* … */</code></p>
    <empty-line/>
    <p><code>_tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> HANDLE hCp, hMonitor, hSrvrThread[MAXCLIENTS];</code></p>
    <p><code> DWORD iNp, iTh, MonitorId, ThreadId;</code></p>
    <p><code> THREAD_ARG ThArgs[MAX_SERVER_TH];</code></p>
    <p><code> /*…*/</code></p>
    <p><code> hCp = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, MAX_SERVER_TH);</code></p>
    <p><code> /* Создать перекрывающийся именованный канал для каждого потенциального */</code></p>
    <p><code> /* клиента, добавить порт завершения и ожидать соединения. */</code></p>
    <p><code> /* Предполагается, что максимальное количество клиентов намного */</code></p>
    <p><code> /* превышает количество серверных потоков. */</code></p>
    <p><code> for (iNp = 0; iNp &lt; MAX_CLIENTS_CP; iNp++) {</code></p>
    <p><code>  memset(&amp;Key[iNp], 0, sizeof(CP_KEY));</code></p>
    <p><code>  Key[iNp].hNp = CreateNamedPipe(SERVER_PIPE, PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED, PIPE_READMODE_MESSAGE | PIPE_TYPE_MESSAGE | PIPE_WAIT, MAX_CLIENTS_CP, 0, 0, INFINITE, pNPSA);</code></p>
    <p><code>  CreateIoCompletionPort(Key[iNp].hNp, hCp, iNp, MAX_SERVER_TH + 2);</code></p>
    <p><code>  Key[iNp].Ov.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);</code></p>
    <p><code>  ConnectNamedPipe(Key[iNp].hNp, &amp;Key[iNp].Ov);</code></p>
    <p><code> }</code></p>
    <p><code> /* Создать рабочие серверные потоки и имя временного файла для каждой из них.*/</code></p>
    <p><code> for (iTh = 0; iTh &lt; MAX_SERVER_TH; iTh++) {</code></p>
    <p><code>  ThArgs[iTh].hCompPort = hCp;</code></p>
    <p><code>  ThArgs[iTh].ThreadNo = iTh;</code></p>
    <p><code>  GetTempFileName(_T("."), _T("CLP"), 0, ThArgs[iTh].TmpFileName); </code></p>
    <p><code>  hSrvrThread[iTh] = (HANDLE)_beginthreadex (NULL, 0, Server, &amp;ThArgs[iTh], 0, &amp;ThreadId);</code></p>
    <p><code> }</code></p>
    <p><code> /* Дождаться завершения всех потоков и "убрать мусор". */</code></p>
    <p><code> /* … */</code></p>
    <p><code> return 0;</code></p>
    <p><code>}</code></p>
    <empty-line/>
    <p><code>static DWORD WINAPI Server(LPTHREAD_ARG pThArg) </code></p>
    <p><code>/* Функция потока сервера.</code></p>
    <p><code>   Имеется по одному потоку для каждого потенциального клиента. */</code></p>
    <p><code>{</code></p>
    <p><code> HANDLE hCp, hTmpFile = INVALID_HANDLE_VALUE;</code></p>
    <p><code> HANDLE hWrEvent = CreateEvent(NULL, TRUE, FALSE, NULL);</code></p>
    <p><code> DWORD nXfer, KeyIndex, ServerNumber;</code></p>
    <p><code> /* … */</code></p>
    <p><code> BOOL Success, Disconnect, Exit = FALSE;</code></p>
    <p><code> LPOVERLAPPED pOv;</code></p>
    <p><code> OVERLAPPED ovResp = {0, 0, 0, 0, hWrEvent}; /*Для ответных сообщений.*/</code></p>
    <p><code> /* Чтобы избежать помещения перекрывающейся операции в очередь порта завершения, должен быть установлен младший бит события. Несмотря на всю странность этого способа, он документирован. */</code></p>
    <p><code> ovResp.hEvent = (HANDLE)((DWORD)hWrEvent | 0x1);</code></p>
    <p><code> GetStartupInfo(&amp;StartInfoCh);</code></p>
    <p><code> hCp = pThArg-&gt;hCompPort;</code></p>
    <p><code> ServerNumber = pThArg-&gt;ThreadNo;</code></p>
    <p><code> while(!ShutDown &amp;&amp; !Exit) __try {</code></p>
    <p><code>  Success = FALSE; /* Устанавливается только в случае успешного завершения всех операций. */</code></p>
    <p><code>  Disconnect = FALSE;</code></p>
    <p><code>  GetQueuedCompletionStatus(hCp, &amp;nXfer, &amp;KeyIndex, &amp;pOv, INFINITE);</code></p>
    <p><code>  if (Key [KeyIndex].Type == 0) { /* Соединение установлено. */</code></p>
    <p><code>   /* Открыть временный файл с результатами для этого соединения. */</code></p>
    <p><code>   hTmpFile = CreateFile(pThArg-&gt;TmpFileName, <emphasis>/* …</emphasis> */);</code></p>
    <p><code>   Key[KeyIndex].Type = 1;</code></p>
    <p><code>   Disconnect = !ReadFile(Key[KeyIndex].hNp, &amp;Key[KeyIndex].Req, RQ_SIZE, &amp;nXfer, &amp;Key[KeyIndex].Ov) &amp;&amp; GetLastError () == ERROR_HANDLE_EOF; /* Первая операция чтения. */</code></p>
    <p><code>   if (Disconnect) continue;</code></p>
    <p><code>   Success = TRUE;</code></p>
    <p><code>  } else {</code></p>
    <p><code>   /* Чтение завершилось. Обработать запрос. */</code></p>
    <p><code>   ShutDown = ShutDown || (_tcscmp (Key[KeyIndex].Req.Record, ShutRqst) == 0);</code></p>
    <p><code>   if (ShutDown) continue;</code></p>
    <p><code>   /* Создать процесс для выполнения команды. */</code></p>
    <p><code>   /* … */ </code></p>
    <p><code>   /* Отвечать по одной строке за один раз. На данном этапе удобно использовать функции библиотеки С для работы со строками. */</code></p>
    <p><code>   fp = _tfopen(pThArg-&gt;TmpFileName, _T("r"));</code></p>
    <p><code>   Response.Status = 0;</code></p>
    <p><code>   /* Поскольку младший бит события установлен, ответные сообщения в очередь порта завершения не помещаются. */</code></p>
    <p><code>   while(_fgetts(Response.Record, MAX_RQRS_LEN, fp) != NULL) {</code></p>
    <p><code>    WriteFile(Key [KeyIndex].hNp, &amp;Response, RS_SIZE, &amp;nXfer, &amp;ovResp);</code></p>
    <p><code>    WaitForSingleObject(hWrEvent, INFINITE);</code></p>
    <p><code>   }</code></p>
    <p><code>   fclose(fp);</code></p>
    <p><code>   /* Уничтожить содержимое временного файла. */</code></p>
    <p><code>   SetFilePointer(hTmpFile, 0, NULL, FILE_BEGIN);</code></p>
    <p><code>   SetEndOfFile(hTmpFile);</code></p>
    <p><code>   /* Отправить признак конца ответа. */</code></p>
    <p><code>   Response.Status = 1;</code></p>
    <p><code>   strcpy(Response.Record, "");</code></p>
    <p><code>   WriteFile(Key[KeyIndex].hNp, &amp;Response, RS_SIZE, &amp;nXfer, &amp;ovResp);</code></p>
    <p><code>   WaitForSingleObject(hWrEvent, INFINITE);</code></p>
    <p><code>   /* Конец основного командного цикла. Получить следующую команду.*/</code></p>
    <p><code>   Disconnect = !ReadFile(Key[KeyIndex].hNp, &amp;Key[KeyIndex].Req, RQ_SIZE, &amp;nXfer, &amp;Key[KeyIndex].Ov) &amp;&amp; GetLastError() == ERROR_HANDLE_EOF; /* Следующее чтение */</code></p>
    <p><code>   if (Disconnect) continue;</code></p>
    <p><code>   Success = TRUE;</code></p>
    <p><code>  }</code></p>
    <p><code> } __finally {</code></p>
    <p><code>  if (Disconnect) {</code></p>
    <p><code>   /* Создать еще одно соединение по этому каналу. */</code></p>
    <p><code>   Key[KeyIndex].Type = 0;</code></p>
    <p><code>   DisconnectNamedPipe(Key[KeyIndex].hNp);</code></p>
    <p><code>   ConnectNamedPipe(Key[KeyIndex].hNp, &amp;Key[KeyIndex].Ov);</code></p>
    <p><code>  }</code></p>
    <p><code>  if (!Success) {</code></p>
    <p><code>   ReportError(_T("Ошибка сервера"), 0, TRUE);</code></p>
    <p><code>   Exit = TRUE;</code></p>
    <p><code>  }</code></p>
    <p><code> }</code></p>
    <p><code> FlushFileBuffers(Key[KeyIndex].hNp);</code></p>
    <p><code> DisconnectNamedPipe(Key[KeyIndex].hNp);</code></p>
    <p><code> CloseHandle(hTmpFile);</code></p>
    <p><code> /* … */</code></p>
    <p><code> _endthreadex(0);</code></p>
    <p><code> return 0;</code></p>
    <p><code> /* Подавление предупреждающих сообщений компилятора. */ </code></p>
    <p><code>}</code> </p>
   </section>
   <section>
    <title>
     <p>Резюме</p>
    </title>
    <section>
     <p>Для выполнения асинхронных операций ввода/вывода в Windows предусмотрены три метода. Самой распространенной и наиболее простой является методика, основанная на использовании потоков, которая, в отличие от двух остальных, способна работать даже под управлением Windows 9x. Каждый из потоков отвечает за выполнение определенной последовательности действий, состоящей из одной или нескольких последовательно выполняющихся, блокирующихся операций ввода/вывода. Кроме того, каждый поток должен располагать собственным дескриптором файла или канала.</p>
     <p>Перекрывающийся ввод/вывод обеспечивает возможность выполнения асинхронных операций одним потоком с использованием одного дескриптора файла, но каждой отдельной операции вместо пары "поток—дескриптор файла" должен предоставляться дескриптор события. При этом требуется организовать ожидание завершения выполнения каждой конкретной операции ввода/вывода по отдельности, а затем очищать системные ресурсы или выполнять любые другие действия, необходимые для управления последовательностью выполнения операций.</p>
     <p>С другой стороны, расширенный ввод/вывод автоматически вызывает код завершения и не требует использования дополнительных событий.</p>
     <p>Одним неоспоримым преимуществом перекрывающегося ввода/вывода является то, что он предоставляет возможность создания портов завершения ввода/вывода, однако, о чем ранее уже говорилось и что иллюстрируется программой atouMTCP, которая находится на Web-сайте, но ценность и этого преимущества несколько снижается из-за того, что для ограничения количества активных потоков в пуле рабочих потоков могут быть использованы семафоры. Дополнительным недостатком портов завершения является то, что они не допускают удаления присоединенных к ним дескрипторов. </p>
     <cite>
      <p>UNIX обеспечивает поддержку потоков средствами Pthreads, что ранее уже обсуждалось.</p>
      <p>В System V UNIX асинхронный ввод/вывод ограничивается потоками и не может использоваться для выполнения операций с файлами и каналами.</p>
      <p>В версии BSD 4.3 для указания события, связанного с дескриптором файла, и выбора функции с целью определения состояния готовности дескрипторов файлов используется комбинация сигналов (SIGIO). Для дескрипторов файлов должен устанавливаться режим O_ASYNC. Такой подход может использоваться только с терминалами и в сетевых коммуникациях.</p>
     </cite>
    </section>
    <section>
     <title>
      <p>В следующих главах</p>
     </title>
     <p>Глава 15 завершает наше обсуждение Windows API демонстрацией методов обеспечения безопасности объектов Windows. Основное внимание уделяется защите файлов, но те же самые методы можно применять и к другим объектам, например, именованным каналам или процессам. </p>
    </section>
   </section>
   <section>
    <title>
     <p>Упражнения</p>
    </title>
    <p>14.1. Воспользуйтесь асинхронным вводом/выводом для слияния нескольких отсортированных файлов в один отсортированный файл большего размера.</p>
    <p>14.2. Приводит ли использование флага FILE_FLAG_MO_BUFFERING к повышению производительности программ atouOV и atouEX, как того можно было бы ожидать в соответствии с утверждениями, содержащимися в описании функции CreateFile? Существуют ли какие-либо ограничения, касающиеся размера файлов?</p>
    <p>14.3. Модифицируйте программу timebeep (программа 14.3), введя в нее сбрасываемый вручную уведомляющий таймер.</p>
    <p>14.4. Модифицируйте клиент именованного канала в программе clientNP (программа 11.2), введя в него перекрывающийся ввод/вывод, чтобы клиент мог продолжать работу после отправки запроса. В результате этого один клиент сможет иметь нескольких невыполненных запросов.</p>
    <p>14.5. Перепишите программу serversk (программа 12.2), представляющую сервер на базе сокетов, введя в нее порты завершения ввода/вывода.</p>
    <p>14.6. Перепишите одну из программ serverSK или serverNP таким образом, чтобы количество готовых к выполнению рабочих потоков ограничивалось семафором. Выполните эксперименты с большим пулом потоков, чтобы выяснить, насколько эффективен такой альтернативный вариант. Находящаяся на Web-сайте программа serverSM является модифицированным вариантом программы serverNP. С увеличением объемов доступной физической памяти и распространением платформы Win64 относительная ценность этого подхода и портов завершения может варьироваться.</p>
    <p>14.7. Используйте программу управления заданиями JobShell (программа 6.3) для работы с большим количеством клиентов и исследуйте сравнительную способность к реагированию серверов serverNP и serverCP. Дополнительную нагрузку могут составить сетевые клиенты. Определите оптимальный интервал значений для количества активных потоков. </p>
   </section>
  </section>
  <section>
   <title>
    <p>ГЛАВА 15</p>
    <p>Безопасность объектов Windows</p>
   </title>
   <section>
    <p>Windows поддерживает тщательно продуманную модель безопасности, которая исключает возможность несанкционированного доступа к таким объектам, как файлы, процессы или отображения файлов. Защитить можно почти любой из совместно используемых (разделяемых) объектов, и программист располагает возможностями управления правами доступа с высокой степенью их детализации.</p>
    <p>Windows как единая система зарегистрирована в Оранжевой книге Управления национальной безопасности США (National Security Agency Orange Book) как система с сертифицированным уровнем безопасности С2, который требует обеспечения разграничительного контроля доступа с возможностью разрешения или запрещения тех или иных прав доступа к объекту на основании идентификационных данных пользователя, пытающегося получить доступ к объекту. Кроме того, система безопасности Windows распространяется на сетевую среду.</p>
    <p>Тема безопасности слишком обширна, чтобы ее можно было полностью рассмотреть в рамках одной главы. Поэтому внимание в данной главе сосредоточено непосредственно на демонстрации того, каким образом API безопасности Windows используется для защиты объектов от несанкционированного доступа. Хотя средства контроля доступа образуют лишь подмножество функциональных средств безопасности Windows, они представляют самый непосредственный интерес для тех, кто хочет ввести элементы защиты в программы, приведенные в данной книге. Самый первый пример, программа 15.1, демонстрирует эмуляцию системы <emphasis>полномочий</emphasis> (permissions) на доступ к файлам, принятой в UNIX, в случае файлов NTFS, тогда как во втором примере в роли защищаемых объектов выступают именованные каналы. Те же принципы далее могут быть использованы для организации защиты других объектов. В списке литературы указаны источники, обратившись к которым вы сможете получить дополнительную информацию по обеспечению безопасности объектов.</p>
    <p>Описанные средства защиты будут работать только под управлением Windows NT, и их нельзя использовать в системах семейства Windows 9x.</p>
   </section>
   <section>
    <title>
     <p>Атрибуты безопасности</p>
    </title>
    <p>В этой главе мы исследуем средства контроля доступа Windows сверху вниз, чтобы увидеть, как строится система безопасности объектов. Вслед за общим обзором, но перед тем, как мы приступим к примерам, будут подробно описаны соответствующие функции Windows. В случае файлов для проверки и изменения некоторых атрибутов безопасности объектов NTFS можно воспользоваться проводником (Windows Explorer).</p>
    <p>Почти для всех объектов, создаваемых при помощи системного вызова Create, предусмотрен параметр атрибутов безопасности (security attributes). Следовательно, программы могут защищать файлы, процессы, потоки, события, семафоры, именованные каналы и так далее. Первым шагом является включение указателя на структуру SECURITY_ATTRIBUTES в вызов Create. До сих пор мы всегда указывали в своих программах значение NULL для этого указателя или же использовали структуру SECURITY_ATTRIBUTES просто для создания наследуемых дескрипторов (глава 6). В реализации защиты объекта важную роль играет элемент lpSecurityDescriptor структуры SECURITY_ATTRIBUTES, являющийся указателем на <emphasis>дескриптор безопасности</emphasis> (security descriptor), который содержит описание владельца объекта и определяет, каким пользователям предоставлены те или иные права доступа или в каких правах им отказано.</p>
    <p>Структура SECURITY_ATTRIBUTES была введена в главе 6, но для удобства мы еще раз приведем ее полное определение.</p>
    <cite>
     <p><code>typedef struct _SECURITY_ATTRIBUTES {</code></p>
     <p><code> DWORD nLength;</code></p>
     <p><code> LPVOID lpSecurityDescriptor;</code></p>
     <p><code> BOOL bInheritHandle; </code></p>
     <p><code>} SECURITY ATTRIBUTES;</code></p>
    </cite>
    <p>Значение параметра nLength следует устанавливать равным:</p>
    <p><code>sizeof(SECURITY_ATTRIBUTES)</code></p>
    <p>Параметр bInheritHandle управляет свойствами наследования дескриптора объекта другими процессами.</p>
    <p>Отдельные компоненты дескриптора безопасности описываются в следующем разделе.</p>
   </section>
   <section>
    <title>
     <p>Общий обзор средств безопасности: дескриптор безопасности</p>
    </title>
    <section>
     <p>Анализ дескриптора безопасности предоставляет хорошую возможность для общего ознакомления с наиболее важными элементами системы безопасности Windows. В этом разделе речь будет идти о самых различных элементах этой системы и функциях, которые ими управляют, и мы приступим к этому, рассмотрев структуру дескриптора безопасности.</p>
     <p>Дескриптор безопасности инициализируется функцией InitializeSecurityDescriptor и состоит из следующих элементов:</p>
     <p>• Идентификационный номер владельца (Security Identifier, SID) (описывается в следующем разделе, в котором рассматривается все, что связано с владельцами объектов).</p>
     <p>• SID группы.</p>
     <p>• Список разграничительного контроля доступа (Discretionary Access Control List, DACL) — список элементов, в явной форме регламентирующих права доступа к объекту для определенных пользователей или групп. В нашем обсуждении термин "ACL", употребляемый без префикса "D", будет относиться к DACL.</p>
     <p>• Системный ACL (System ACL, SACL), иногда называемый <emphasis>ACL аудиторского доступа</emphasis> (audit access ACL).</p>
     <p>Функции SetSecurityDescriptorOwner и SetSecurityDescriptorGroup связывают идентификаторы SID с дескрипторами безопасности, о чем говорится далее в разделе "Идентификаторы безопасности".</p>
     <p>ACL инициализируются функцией Initialize ACL, а затем связываются с дескриптором безопасности с помощью функций SetSecurityDescriptorDacl и SetSecurityDescriptorSacl.</p>
     <p>Атрибуты безопасности подразделяются на <emphasis>абсолютные</emphasis> (absolute) и <emphasis>самоопределяющиеся относительные</emphasis> (self-relative). На данном этапе мы не будем делать различия между ними, но вернемся к этому вопросу далее в настоящей главе. Дескриптор безопасности и его компоненты представлены на рис. 15.1.</p>
    </section>
    <section>
     <title>
      <p>Списки контроля доступа</p>
     </title>
     <p>Каждый ACL состоит из совокупности элементов контроля доступа (Access Control Entry, АСЕ). Существует два типа АСЕ: для разрешения данного вида доступа (allowed) и его запрета (denied).</p>
     <p>Сначала список ACL инициализируют посредством функции InitializeAcl, a затем добавляют в него элементы АСЕ. Каждый АСЕ содержит SID и <emphasis>маску доступа</emphasis> (access mask), определяющую, какие именно права доступа предоставляются пользователю или группе, идентифицируемым по их SID, а в каких им отказано. В качестве типичного примера прав доступа к файлам можно привести права доступа FILE_GENERIC_READ и DELETE.</p>
     <p>Добавление элементов АСЕ в разграничительные списки ACL осуществляется при помощи двух функций — AddAccessAllowedAce и AddAccessDenieddAce. Функция AddAuditAccessAce служит для добавления элементов в SACL, что позволяет отслеживать попытки доступа, осуществляемые с использованием указанного SID. </p>
     <image l:href="#Any2FbImgLoader151"/>
     <p><strong>Рис. 15.1. </strong>Строение дескриптора безопасности</p>
     <empty-line/>
     <p>Наконец, для удаления АСЕ из списка используется функция DeleteAce, а для извлечения — функция GetAce.</p>
    </section>
    <section>
     <title>
      <p>Использование объектов безопасности Windows</p>
     </title>
     <p>В дескриптор безопасности вносятся многочисленные подробные данные, и на рис. 15.1 отражены лишь основные элементы его структуры. Заметьте, что у каждого процесса также имеется свой SID (содержащийся в маркере доступа), который используется ядром для того, чтобы определить, какие виды доступа разрешены или какие виды доступа подлежат аудиту. Кроме того, маркер доступа (access token) может предоставлять владельцу определенные <emphasis>привилегии</emphasis> (privileges) (свойственная данному владельцу способность выполнять операции, перекрывающая <emphasis>права</emphasis> (rights), указанные в списке ACL). Так, администратор может иметь привилегии на выполнение операций чтения и записи ко всем файлам, не имея на это прав, явно заданных в списке ACL данного файла.</p>
     <p>Если пользовательские или групповые идентификаторы доступа не обеспечивают, ядро просматривает права доступа, указанные в ACL. Определяющую роль играет первый встреченный элемент, дающий возможность воспользоваться данной запрошенной услугой или отказывающий в этом. Поэтому очередность, в которой в список вносятся элементы АСЕ, имеет большое значение. Во многих случаях АСЕ, запрещающие доступ, располагаются первыми, чтобы конкретный пользователь, которому необходимо запретить данный вид доступа, не мог получить его, воспользовавшись членством в группе, которой этот вид доступа предоставлен. В то же время, для получения желаемой семантики в программе 15.1 существенно, чтобы элементы АСЕ, предоставляющие и запрещающие доступ, могли располагаться в произвольном порядке. АСЕ, отказывающий во всех видах доступа, может располагаться последним для гарантии того, что доступ не будет разрешен никому, если только он конкретно не указан в АСЕ.</p>
    </section>
    <section>
     <title>
      <p>Права объектов и доступ к объектам</p>
     </title>
     <p>Любой объект, например файл, получает свои права доступа при создании, однако впоследствии эти права могут быть изменены. Процессу требуется доступ к объекту, когда он запрашивает дескриптор, используя для этого, например, вызов функции CreateFile. В одном из параметров запроса дескриптора содержится указание на желаемый вид доступа, например FILE_GENERIC_READ. Если у процесса имеются необходимые права на получение требуемого доступа, запрос завершается успешно. Для различных дескрипторов одного и того же объекта может быть определен различный доступ. Для указания флагов доступа используются те же значения, которые использовались для предоставления прав или отказа в них при создании ACL. </p>
     <cite>
      <p>Стандартом UNIX (без С2 или других расширений) поддерживается более простая модель безопасности. Эта модель ограничивается файлами и основана на предоставлении полномочий доступа к файлам. В рассматриваемых в настоящей главе примерах программ эмулируется система полномочий доступа UNIX.</p>
     </cite>
    </section>
    <section>
     <title>
      <p>Инициализация дескриптора безопасности</p>
     </title>
     <p>Сначала необходимо инициализировать дескриптор безопасности с помощью функции InitializeSecurityDescriptor. Параметр pSecurityDescriptor должен указывать адрес действительной структуры SECURITY_DESCRIPTOR. Эти структуры являются непрозрачными для пользователя и управляются специальными функциями.</p>
     <p>Для параметра dwRevision следует устанавливать значение:</p>
     <p><code>SECURITY_DESCRIPTOR_REVISION</code> </p>
     <cite>
      <p><code>BOOL InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision)</code> </p>
     </cite>
    </section>
   </section>
   <section>
    <title>
     <p>Управляющие флаги дескриптора безопасности</p>
    </title>
    <p>Флаги, входящие в структуру Control дескриптора безопасности, а именно, флаги SECURITY_DESCRIPTOR_CONTROL, определяют, какой смысл приписывается дескриптору безопасности. Некоторые из них устанавливаются и сбрасываются при помощи функций, которые будут рассмотрены далее. Доступ к управляющим флагам обеспечивают функции GetSecurityDescriptorControl и GetSecurityDescriptorControl (доступны в версии NT5), однако эти флаги не будут непосредственно использоваться в наших примерах.</p>
   </section>
   <section>
    <title>
     <p>Идентификаторы безопасности</p>
    </title>
    <p>Для идентификации пользователей и групп Windows использует идентификаторы SID. Программа может отыскивать SID по учетному имени (account name), которое может относиться к пользователю, группе, домену и так далее. Учетное имя может относиться и к удаленной системе. Сначала мы рассмотрим определение SID по учетному имени. </p>
    <cite>
     <p><code>BOOL LookupAccountName(LPCTSTR lpSystemName, LPCTSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPTSTR ReferencedDomainName, LPDWORD cbReferencedDomainName, PSID_NAME_USE peUse)</code> </p>
    </cite>
    <subtitle><emphasis>Параметры</emphasis></subtitle>
    <p>lpSystemName и lpAccountName — указывают на системное и учетное имена. Для параметра lpSystemName часто используется значение NULL, обозначающее локальную систему.</p>
    <p>Sid — возвращаемая информация, хранящаяся в структуре размером *cbSid. Если размер буфера недостаточно велик, функция выполняется с ошибкой, возвращая размер, который требуется.</p>
    <p>ReferencedDomainName — строка, состоящая из *cbReferencedDomainName символов. Параметр длины строки должен инициализироваться размером буфера (для обработки ошибок используются обычные методы). Возвращаемое значение указывает домен, в котором обнаружено данное имя. В случае учетного имени Administrators возвращается значение BUILTIN, тогда как в случае пользовательского учетного имени возвращается имя этого пользователя. </p>
    <p>peUse — указывает на переменную SID_NAME_USE (перечислительный тип данных), проверяемыми значениями которой могут быть SidTypeWellKnownGroup, SidTypeUser, SidTypeGroup и так далее.</p>
    <subtitle><emphasis>Получение имени учетной записи и имени пользователя</emphasis></subtitle>
    <p>При известном SID можно обратить процесс и получить имя учетной записи, используя функцию LookupAccountSid. Эта функция требует указания SID и возвращает соответствующее имя. Возвращаемым именем может быть любое имя, доступное процессу. Некоторые из имен, например Everyone, известны системе. </p>
    <cite>
     <p><code>BOOL LookupAccountSid(LPCTSTR lpSystemName, PSID Sid, LPTSTR lpAccountName, LPDWORD cbName, LPTSTR ReferencedDomainName, LPDWORD cbReferencedDomainName, PSID NAME USE peUse)</code></p>
    </cite>
    <p>Для получения учетного имени пользователя процесса (пользователя, вошедшего в систему) служит функция GetUserName. </p>
    <cite>
     <p><code>BOOL GetUserName(LPTSTR lpBuffer, LPDWORD nSize)</code> </p>
    </cite>
    <p>Указатель на строку с именем пользователя и длина этой строки возвращаются обычным образом.</p>
    <p>Для создания SID и управления ими могут использоваться такие функции, как InitializeSid и AllocateAndInitializeSid. Однако в примерах мы ограничимся использованием только SID, получаемых по учетному имени.</p>
    <p>Полученные SID можно вносить в инициализированные дескрипторы безопасности. </p>
    <cite>
     <p><code>BOOL SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pOwner, BOOL bOwnerDefaulted)</code></p>
     <p><code>BOOL SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pGroup, BOOL bGroupDefaulted)</code> </p>
    </cite>
    <p>pSecurityDescriptor — указатель на соответствующий дескриптор безопасности, a oOwner (или pGroup) — адрес SID владельца (группы). Если для параметра bOwnerDefaulted (или bGroupDefaulted) установлено значение TRUE, то для извлечения информации о владельце (или первичной группе) используется механизм, заданный по умолчанию. В соответствии с этими двумя параметрами устанавливаются флаги SE_OWNER_DEFAULTED и SE_GROUP_DEFAULTED в структуре SECURITY_DESCRIPTOR_CONTROL.</p>
    <p>Аналогичные функции GetSecurityDescriptorOwner и GetSecurityDescriptorGroup возвращают SID (пользователя или группы), извлекая соответствующую информацию из дескриптора безопасности.</p>
   </section>
   <section>
    <title>
     <p>Работа с ACL</p>
    </title>
    <p>В этом разделе показано, как работать со списками ACL, связывать ACL с дескриптором безопасности и добавлять ACL. Взаимосвязь между этими объектами и соответствующими функциями представлена на рис. 15.1.</p>
    <p>Сначала необходимо инициализировать структуру ACL. Поскольку непосредственный доступ к ACL осуществляться не должен, его внутреннее строение для нас безразлично. Однако программа должна предоставить буфер, выступающий в роли ACL; обработка содержимого выполняется соответствующими функциями. </p>
    <cite>
     <p><code>BOOL InitializeAcl(PACL pAcl, DWORD cbAcl, DWORD dwAclRevision)</code> </p>
    </cite>
    <p>pAcl — адрес предоставляемого программистом буфера размером cbAcl байт. В ходе последующего обсуждения и в программе 15.4 будет показано, как определить размер ACL, но для большинства целей размера 1 Кбайт будет вполне достаточно. Значение параметра dwAclRevision следует устанавливать равным ACL_REVISION.</p>
    <p>Далее мы должны добавить АСЕ в желаемом порядке, используя функции AddAccessAllowedAce и AddAccessDeniedAce. </p>
    <cite>
     <p><code>BOOL AddAccessAllowedAce(PACL pAcl, DWORD dwAclRevision DWORD dwAccessMask, PSID pSid)</code></p>
     <p><code>BOOL AddAccessDeniedAce(PACL pAcl, DWORD dwAclRevision, DWORD dwAccessMask, PSID pSid)</code> </p>
    </cite>
    <p>Параметр pAcl указывает на ту же структуру ACL, которая была инициализирована функцией InitializeACL, а параметр dwAclRevision также следует устанавливать равным ACL_REVISION. Параметр pSid указывает на SID, например на тот, который был получен с помощью функции LookupAccountName.</p>
    <p>Права, которые предоставляются или в которых отказывается пользователю или группе, идентифицируемым данным SID, определяются маской доступа (dwAccessMask).</p>
    <p>Последнее, что потребуется сделать — это связать ACL с дескриптором безопасности. В случае разграничительного ACL для этого используется функция SetSecurityDescriptorDacl. </p>
    <cite>
     <p><code>BOOL SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pAcl, BOOL fDaclDefaulted)</code> </p>
    </cite>
    <p>Значение параметра bDaclPresent, равное TRUE, указывает на то, что в структуре pAcl имеется ACL. Если этот параметр равен FALSE, то следующие два параметра, pAcl и fDaclDefaulted, игнорируются. Флаг SE_DACL_PRESENT структуры SECURITY_DESCRIPTOR_CONTROL также устанавливается равным значению этого параметра.</p>
    <p>Значение FALSE параметра fDaclDefaulted указывает на то, что ACL был сгенерирован программистом. В противном случае ACL был получен с использованием механизма, принятого по умолчанию, например, путем наследования; вместе с тем, для указания того, что имеется ACL, значение параметра должно быть равным TRUE. Флаг SE_DACL_PRESENT структуры SECURITY_DESCRIPTOR_CONTROL также устанавливается равным значению этого параметра.</p>
    <p>Доступны и другие функции, предназначенные для удаления и считывания АСЕ из ACL; они обсуждаются далее в этой главе. А теперь настало время обратиться к примеру.</p>
   </section>
   <section>
    <title>
     <p>Пример: использование разрешений на доступ в стиле UNIX к файлам NTFS</p>
    </title>
    <p>Система разрешений на доступ к файлам, принятая в UNIX, предоставляет удобную возможность проиллюстрировать работу системы безопасности Windows, хотя последняя по своему характеру является гораздо более общей, чем стандартные средства защиты UNIX. В приведенной ниже реализации создается девять АСЕ, предоставляющих или запрещающих доступ по чтению, записи или запуску файлов на выполнение владельцу (owner), группе (group) и прочим пользователям (everyone). Предусмотрены две команды. </p>
    <p>1. chmodW — имитирует UNIX-команду chmod. В данной реализации возможности команды расширены за счет того, что в случае отсутствия указанного файла он будет создан, а также за счет того, что пользователю предоставляется возможность указывать имя группы.</p>
    <p>2. lsFP — расширенный вариант команды lsW (программа 3.2). Если запрошен вывод подробной информации, то отображается имя пользователя-владельца файла, а также результат интерпретации существующих ACL, которые могли быть установлены командой chmodW.</p>
    <p>Указанные две команды представлены программами 15.1 и 15.2. В программах 15.3, 15.4 и 15.5 реализованы три вспомогательные функции.</p>
    <p>1. InitializeUnixSA, которая создает действительную структуру атрибутов безопасности, соответствующих набору разрешений доступа UNIX. Эта функция обладает достаточной общностью, чтобы ее можно было применять по отношению к таким объектам, отличным от файлов, как процессы (глава 6), именованные каналы (глава 11) и объекты синхронизации (глава 8).</p>
    <p>2. ReadFilePermissions.</p>
    <p>3. ChangeFilePermissions.</p>
    <cite>
     <p><strong>Примечание</strong></p>
     <p>Приведенные ниже программы являются упрощенными вариантами программ, представленных на Web-сайте книги. В полных вариантах программ используются отдельные массивы AllowedAceMasks и DeniedAceMasks, в то время как в листингах ниже задействован только один массив.</p>
     <p>Использование отдельного массива DeniedAceMasks обеспечивает невозможность запрета прав доступа SYNCHRONIZE, поскольку флаг SYNCHRONIZE устанавливается во всех трех макросах FILE_GENERIC_READ, FILE_GENERIC_WRITE и FILE_GENERIC_EXECUTE, которые являются комбинациями нескольких флагов (см. заголовочный файл WINNT.H). Дополнительные разъяснения предоставляются в полном варианте программы, доступном на Web-сайте. Кроме того, в полном варианте программы проверяется, не указано ли в командной строке групповое имя; ниже мы будем везде предполагать, что указывается имя пользователя.</p>
    </cite>
    <subtitle>Программа 15.1. chmodW: изменение разрешений на доступ к файлу </subtitle>
    <p><code>/* Глава 15. Команда chmodW. */</code></p>
    <p><code>/* chmodW [опции] режим файл [ИмяГруппы].</code></p>
    <p><code>   Изменение режима доступа к именованному файлу.</code></p>
    <p><code>   Опции:</code></p>
    <p><code>    -f Принудительный режим — не выводить предупреждающие сообщения в случае невозможности изменения режима.</code></p>
    <p><code>    –с Создать файл, если он не существует. Необязательное имя группы указывается после имени файла. */ </code></p>
    <p><code>/* Требуются NTFS и Windows NT (под управлением Windows 9x программа работать не будет). */</code></p>
    <empty-line/>
    <p><code>#include "EvryThng.h" </code></p>
    <empty-line/>
    <p><code>int _tmain(int argc, LPTSTR argv[]) {</code></p>
    <p><code> HANDLE hFile, hSecHeap;</code></p>
    <p><code> BOOL Force, CreateNew, Change, Exists;</code></p>
    <p><code> DWORD Mode, DecMode, UsrCnt = ACCT_NAME_SIZE;</code></p>
    <p><code> TCHAR UsrNam[ACCT_NAME_SIZE];</code></p>
    <p><code> int FileIndex, GrpIndex, ModeIndex;</code></p>
    <p><code> /* Массив прав доступа к файлу, следующих в том порядке, который принят в UNIX. */</code></p>
    <p><code> /* Эти права будут различными для объектов различного типа. */</code></p>
    <p><code> /*ПРИМЕЧАНИЕ: в полном варианте программы, находящемся на Web-сайте, */</code></p>
    <p><code> /*используются отдельные массивы масок разрешения и запрещения доступа.*/</code></p>
    <p><code> DWORD AceMasks[] = {</code></p>
    <p><code>  FILE_GENERIC_READ, FILE_GENERIC_WRITE, FILE_GENERIC_EXECUTE</code></p>
    <p><code> };</code></p>
    <p><code> LPSECURITY_ATTRIBUTES pSa = NULL;</code></p>
    <p><code> ModeIndex = Options(argc, argv, _T("fc"), &amp;Force, &amp;CreateNew, NULL);</code></p>
    <p><code> GrpIndex = ModeIndex + 2;</code></p>
    <p><code> FileIndex = ModeIndex + 1;</code></p>
    <p><code> DecMode = _ttoi(argv[ModeIndex]);</code></p>
    <p><code> /* Режим защиты представляет собой восьмеричное число. */</code></p>
    <p><code> Mode = ((DecMode / 100) % 10) * 64 /*Преобразовать в десятичное число.*/</code></p>
    <p><code>      + ((DecMode / 10) % 10) * 8 + (DecMode % 10);</code></p>
    <p><code> Exists = (_taccess(argv[FileIndex], 0) == 0);</code></p>
    <p><code> if (!Exists &amp;&amp; CreateNew) {</code></p>
    <p><code>  /* Файл не существует; создать новый файл. */</code></p>
    <p><code>  GetUserName(UsrNam, &amp;UsrCnt);</code></p>
    <p><code>  pSa = InitializeUnixSA(Mode, UsrNam, argv[GrpIndex], AceMasks, &amp;hSecHeap);</code></p>
    <p><code>  hFile = CreateFile(argv[FileIndex], 0, 0, pSa, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);</code></p>
    <p><code>  CloseHandle(hFile);</code></p>
    <p><code>  HeapDestroy(hSecHeap); /* Освободить память, занимаемую структурами безопасности. */</code></p>
    <p><code> }</code></p>
    <p><code> else if (Exists) { /* Файл существует; изменить разрешения доступа. */</code></p>
    <p><code>  Change = ChangeFilePermissions(Mode, argv[FileIndex], AceMasks);</code></p>
    <p><code> }</code></p>
    <p><code> return 0; </code></p>
    <p><code>}</code> </p>
    <p>В программе 15.2 представлена соответствующая часть команды lsFP, а именно, функция Process Item. </p>
    <subtitle>Программа 15.2. lsFP: перечисление разрешений на доступ к файлу </subtitle>
    <p><code>static BOOL ProcessItem(LPWIN32_FIND_DATA pFileData, DWORD NumFlags, LPBOOL Flags)</code></p>
    <p><code>/* Вывести список атрибутов с указанием разрешений доступа и владельца. */ </code></p>
    <p><code>/* Требуются NTFS и Windows NT (под управлением Windows 9x программа работать не будет). */ </code></p>
    <p><code>{</code></p>
    <p><code> DWORD FType = FileType(pFileData), Mode, i;</code></p>
    <p><code> BOOL Long = Flags[1];</code></p>
    <p><code> TCHAR GrpNam[ACCT_NAME_SIZE], UsrNam[ACCT_NAME_SIZE];</code></p>
    <p><code> SYSTEMTIME LastWrite;</code></p>
    <p><code> TCHAR PermString[] = _T("---------");</code></p>
    <p><code> const TCHAR RWX[] = {'r','w','x'}, FileTypeChar[] = {' ', 'd'};</code></p>
    <p><code> if (FType != TYPE_FILE &amp;&amp; FType != TYPE_DIR) return FALSE;</code></p>
    <p><code> _tprintf(_T("\n"));</code></p>
    <p><code> if (Long) {</code></p>
    <p><code>  Mode = ReadFilePermissions(pFileData-&gt;cFileName, UsrNam, GrpNam);</code></p>
    <p><code>  if (Mode == 0xFFFFFFFF) Mode = 0;</code></p>
    <p><code>  for (i = 0; i &lt; 9; i++) {</code></p>
    <p><code>   if (Mode &gt;&gt; (8 – i) &amp; 0x1) PermString[i] = RWX[i % 3];</code></p>
    <p><code>  }</code></p>
    <p><code>  _tprintf(_T("%c%s 18.7s %8.7s%10d"), FileTypeChar[FType – 1], PermString, UsrNam, GrpNam, pFileData-&gt;nFileSizeLow);</code></p>
    <p><code>  FileTimeToSystemTime(&amp;(pFileData-&gt;ftLastWriteTime), &amp;LastWrite);</code></p>
    <p><code>  _tprintf(_T(" %02d/%02d/%04d %02d:%02d:%02d"), LastWrite.wMonth, LastWrite.wDay, LastWrite.wYear, LastWrite.wHour, LastWrite.wMinute, LastWrite.wSecond);</code></p>
    <p><code> }</code></p>
    <p><code> _tprintf(_T(" %s"), pFileData-&gt;cFileName);</code></p>
    <p><code> return TRUE;</code></p>
    <p><code>}</code> </p>
    <p>Далее мы рассмотрим реализацию вспомогательных функций.</p>
   </section>
   <section>
    <title>
     <p>Пример: инициализация атрибутов защиты</p>
    </title>
    <section>
     <p>Программа 15.3 представляет вспомогательную функцию InitializeUnixSA. Эта функция создает структуру атрибутов безопасности, которая содержит ACL с элементами АСЕ, эмулирующими разрешения на доступ к файлам в UNIX. Существует девять АСЕ, предоставляющих или запрещающих доступ по чтению, записи или запуску файлов на выполнение владельцу (owner), группе (group) и прочим пользователям (everyone). Эта структура не является локальной переменной функции и должна распределяться и инициализироваться, а затем возвращаться вызывающей программе; обратите внимание на массив AceMasks в программе 15.1.</p>
     <subtitle>Программа 15.3. InitUnFp: инициализация атрибутов защиты </subtitle>
     <p><code>/* Задание режима доступа в стиле UNIX посредством элементов АСЕ, хранящихся в структуре SECURITY_ATTRIBUTES. */</code></p>
     <empty-line/>
     <p><code>#include "EvryThng.h"</code></p>
     <p><code>#define ACL_SIZE 1024 </code></p>
     <p><code>#define INIT_EXCEPTION 0x3 </code></p>
     <p><code>#define CHANGE_EXCEPTION 0x4 </code></p>
     <p><code>#define SID_SIZE LUSIZE </code></p>
     <p><code>#define DOM_SIZE LUSIZE</code></p>
     <empty-line/>
     <p><code>LPSECURITY_ATTRIBUTES InitializeUnixSA(DWORD UnixPerms, LPCTSTR UsrNam, LPCTSTR GrpNam, LPDWORD AceMasks, LPHANDLE pHeap) {</code></p>
     <p><code> HANDLE SAHeap = HeapCreate(HEAP_GENERATE_EXCEPTIONS, 0, 0);</code></p>
     <p><code> LPSECURITY_ATTRIBUTES pSA = NULL;</code></p>
     <p><code> PSECURITY_DESCRIPTOR pSD = NULL;</code></p>
     <p><code> PACL pAcl = NULL;</code></p>
     <p><code> BOOL Success;</code></p>
     <p><code> DWORD iBit, iSid, UsrCnt = ACCT_NAME_SIZE;</code></p>
     <p><code> /* Таблицы имен пользователя (User), группы (Group) и прочих пользователей (Everyone), идентификаторов SID и так далее для LookupAccountName и создания SID. */</code></p>
     <p><code> LPCTSTR pGrpNms[3] = {EMPTY, EMPTY, _T("Everyone")};</code></p>
     <p><code> PSID pSidTable[3] = {NULL, NULL, NULL};</code></p>
     <p><code> SID_NAME_USE sNamUse[3] = {SidTypeUser, SidTypeGroup, SidTypeWellKnownGroup};</code></p>
     <p><code> TCHAR RefDomain[3][DOM_SIZE];</code></p>
     <p><code> DWORD RefDomCnt[3] = {DOM_SIZE, DOM_SIZE, DOM_SIZE};</code></p>
     <p><code> DWORD SidCnt[3] = {SID_SIZE, SID_SIZE, SID_SIZE};</code></p>
     <p><code> __try { /* Блок try-except для исключений при распределении памяти. */</code></p>
     <p><code>  *рНеар = SAHeap;</code></p>
     <p><code>  pSA = HeapAlloc(SAHeap, 0, sizeof (SECURITY_ATTRIBUTES));</code></p>
     <p><code>  pSA-&gt;nLength = sizeof(SECURITY_ATTRIBUTES);</code></p>
     <p><code>  pSA-&gt;bInheritHandle = FALSE;</code></p>
     <p><code>  /* Программист может выполнить эти установки позже. */</code></p>
     <p><code>  pSD = HeapAlloc(SAHeap, 0, sizeof(SECURITY_DESCRIPTOR));</code></p>
     <p><code>  pSA-&gt;lpSecurityDescriptor = pSD;</code></p>
     <p><code>  InitializeSecurityDescriptor(pSD, SECURITY DESCRIPTOR REVISION); </code></p>
     <p><code>  /* Получить SID пользователя, группы и прочих пользователей. </code></p>
     <p><code>   * Другие важные подробности можно найти на Web-сайте. */</code></p>
     <p><code>  pGrpNms[0] = UsrNam;</code></p>
     <p><code>  pGrpNms[1] = GrpNam;</code></p>
     <p><code>  for (iSid = 0; iSid &lt; 3; iSid++) {</code></p>
     <p><code>   pSidTable[iSid] = HeapAlloc(SAHeap, 0, SID_SIZE);</code></p>
     <p><code>   LookupAccountName(NULL, pGrpNms[iSid], pSidTable[iSid], &amp;SidCnt[iSid], RefDomain[iSid], &amp;RefDomCnt[iSid], &amp;sNamUse[iSid]);</code></p>
     <p><code>  }</code></p>
     <p><code>  SetSecurityDescriptorOwner(pSD, pSidTable[0], FALSE);</code></p>
     <p><code>  SetSecurityDescriptorGroup(pSD, pSidTable[1], FALSE);</code></p>
     <p><code>  pAcl = HeapAlloc(ProcHeap, HEAP_GENERATE_EXCEPTIONS, ACL_SIZE);</code></p>
     <p><code>  InitializeAcl(pAcl, ACL_SIZE, ACL_REVISION);</code></p>
     <p><code>  /* Добавить все элементы АСЕ, разрешающие и запрещающие доступ. */</code></p>
     <p><code>  for (iBit = 0; iBit &lt; 9; iBit++) {</code></p>
     <p><code>   if ((UnixPerms &gt;&gt; (8 – iBit) &amp; 0x1) != 0 &amp;&amp; AceMasks[iBit%3] != 0) AddAccessAllowedAce(pAcl, ACL_REVISION, AceMasks [iBit%3], pSidTable [iBit/3]);</code></p>
     <p><code>   else if (AceMasks[iBit%3] != 0) AddAccessDeniedAce(pAcl, ACL_REVISION, AceMasks [iBit%3], pSidTable [iBit/3]);</code></p>
     <p><code>  }</code></p>
     <p><code>  /* Добавить запрет доступа для всех АСЕ категории "Прочие". */</code></p>
     <p><code>  Success = Success &amp;&amp; AddAccessDeniedAce(pAcl, ACL_REVISION, STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL, pSidTable[2]);</code></p>
     <p><code>  /* Связать ACL с атрибутом защиты. */</code></p>
     <p><code>  SetSecurityDescriptorDacl(pSD, TRUE, pAcl, FALSE);</code></p>
     <p><code>  return pSA;</code></p>
     <p><code> } /* Конец блока try-except. */</code></p>
     <p><code> __except(EXCEPTION_EXECUTE_HANDLER) { /* Освободить все ресурсы. */</code></p>
     <p><code>  if (SAHeap != NULL) HeapDestroy(SAHeap);</code></p>
     <p><code>  pSA = NULL;</code></p>
     <p><code> }</code></p>
     <p><code> return pSA; </code></p>
     <p><code>}</code> </p>
    </section>
    <section>
     <title>
      <p>Комментарии к программе 15.3</p>
     </title>
     <p>Хотя структура программы 15.3 и может показаться несложной, выполняемую ею операцию вряд ли можно назвать простой. Кроме того, программа иллюстрирует целый ряд моментов, заслуживающих внимания, которые касаются использования средств безопасности Windows.</p>
     <p>• Необходимо распределить в памяти несколько областей, предназначенных для хранения нужной информации, например, идентификаторов SID. Эти области создаются в специально выделенной для этих целей куче, которая по завершении работы должна быть уничтожена вызывающей программой.</p>
     <p>• В данном примере структура атрибутов безопасности относится к файлам, но она также может использоваться с другими объектами, например именованными каналами (глава 11). В программе 15.4 показано, как встроить такую структуру при работе с файлами.</p>
     <p>• Для эмуляции поведения UNIX существенное значение имеет порядок следования элементов АСЕ. Обратите внимание на то, что АСЕ, разрешающие и запрещающие доступ, добавляются в ACL по мере обработки битов, кодирующих полномочия, в направлении слева (Owner/Read) направо (Everyone/Execute). Благодаря этому биты полномочий, заданные, например, кодом защиты 460 (в восьмеричном представлении), будут запрещать пользователю доступ по записи даже в том случае, если он входит в состав группы.</p>
     <p>• Права доступа описываются в АСЕ такими значениями, как FILE_GENERIC_READ или FILE_GENERIC_WRITE, которые аналогичны флагам, используемым в функции CreateFile, хотя добавляются и другие флаги доступа, например SYNCHRONIZE. Эти права указываются в вызывающей программе (в данном случае в программе 15.1), чтобы обеспечить их соответствие объекту.</p>
     <p>• Значение, определенное для константы ACL_SIZE, выбрано достаточно большим, чтобы выделенных для него разрядов хватило для хранения девяти элементов АСЕ. После того как мы рассмотрим программу 15.5, способ определения требуемого размера элемента данных станет для вас очевидным.</p>
     <p>• В функции используются три SID, по одному для каждой из следующих категорий пользователей: User (Пользователь), Group (Группа) и Everyone (Прочие). Для получения имени, используемого в качестве аргумента при вызове функции LookupAccountName, используются три различные методики. Имя обычного пользователя поступает из функции GetUserName. Именем пользователя, относящегося к категории прочих пользователей, является Everyone в SidTypeWellknownGroup. Групповое имя должно предоставляться в виде аргумента командной строки и отыскиваться как SidTypeGroup. Для нахождения групп, которым принадлежит пользователь, требуются определенные сведения о дескрипторах процесса, и решить эту задачу вам предлагается в упражнении 15.12.</p>
     <p>• В версии программы, находящейся на Web-сайте книги, в отличие от той, которая представлена здесь, большое внимание уделено проверке ошибок. В ней даже предусмотрена проверка действительности сгенерированных структур с помощью функций IsValidSecurityDescriptor, IsValidSid и IsValidAcl, названия которых говорят сами за себя. Указанное тестирование ошибок оказалось чрезвычайно полезным на стадии отладки. </p>
    </section>
   </section>
   <section>
    <title>
     <p>Чтение и изменение дескрипторов безопасности</p>
    </title>
    <p>После того как дескриптор безопасности связан с файлом, следующим шагом является определение кода защиты существующего файла и его возможное изменение. Для получения и установления кода защиты файла в терминах дескрипторов безопасности используются следующие функции: </p>
    <cite>
     <p><code>BOOL GetFileSecurity(LPCTSTR lpFileName, SECURITY_INFORMATION secInfo, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD cbSd, LPDWORD lpcbLengthNeeded)</code></p>
     <p><code>BOOL SetFileSecurity(LPCTSTR lpFileName, SECURITY_INFORMATION secInfo, PSECURITY_DESCRIPTOR pSecurityDescriptor)</code> </p>
    </cite>
    <p>Переменная secInfo имеет тип перечисления и принимает значения:</p>
    <p><code>OWNER_SECURITY_INFORMATION</code></p>
    <p><code>GROUP_SECURITY_INFORMATION</code></p>
    <p><code>DACL_SECURITY_INFORMATION</code></p>
    <p><code>SACL_SECURITY_INFORMATION</code></p>
    <p>которые позволяют указать, какую часть дескриптора безопасности необходимо получить или установить. Эти значения могут объединяться при помощи поразрядной операции "или".</p>
    <p>Наилучшим способом определения необходимого размера возвращаемого буфера для функции GetFileSecurity является двукратный вызов этой функции. Во время первого вызова значение параметра cbSd может быть задано равным 0. После того как буфер выделен, вызовите эту функцию второй раз. Этот принцип применяется в программе 15.4.</p>
    <p>Вряд ли следует подчеркивать тот факт, что для выполнения этих операций требуются соответствующие полномочия. Так, для успешного выполнения функции SetFileSecurity необходимо либо иметь полномочия на уровне WRITE_DAC, либо быть владельцем объекта.</p>
    <p>Функции GetSecurityDescriptorOwner и GetSecurityDescriptorGroup позволяют извлекать идентификаторы SID из дескриптора безопасности, полученного при помощи функции GetFileSecurity. Для получения ACL следует воспользоваться функцией GetSecurityDescriptorDacl. </p>
    <cite>
     <p><code>BOOL GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbDaclPresent, PACL *pAcl, LPBOOL lpbDaclDefaulted)</code> </p>
    </cite>
    <p>Параметры этой функции почти полностью совпадают с параметрами функции GetSecurityDescriptorDacl за исключением того, что возвращаются флаги,указывающие на то, действительно ли представлен разграничительный ACL и был ли он установлен по умолчанию или пользователем.</p>
    <p>Чтобы иметь возможность интерпретировать список ACL, необходимо выяснить, сколько элементов АСЕ в нем содержится. </p>
    <cite>
     <p><code>BOOL GetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD cbAclInfo, ACL INFORMATION CLASS dwAclInfoClass) </code></p>
    </cite>
    <p>В большинстве случае параметр информационного класса ACL, dwAclInfoClass, равен AclSizeInformation, а параметр pAclInformation представляет собой структуру типа ACL_SIZE_INFORMATION. Другим возможным значением параметра класса является AclRevisionInformation.</p>
    <p>В структуру ACL_SIZE_INFORMATION входят три элемента, наиболее важным из которых является AceCount, который указывает, сколько элементов содержится в списке. Чтобы выяснить, достаточно ли велик размер ACL, проверьте значения элементов AclBytesInUse и AclBytesFree структуры ACL_SIZE_INFORMATION.</p>
    <p>Функция GetAce извлекает извлекает АСЕ по заданному индексу. </p>
    <cite>
     <p><code>BOOL GetAce(PACL pAcl, DWORD dwAceIndex, LPVOID *pAce)</code> </p>
    </cite>
    <p>Для получения определенного элемента АСЕ (их общее количество теперь известно) следует указать его индекс. рАсе указывает на структуру АСЕ, в которой имеется элемент под названием Header, содержащий, в свою очередь, элемент АсеТуре. Для проверки типа можно использовать значения ACCESS_ALLOWED_ACE и ACCESS DENIED АСЕ. </p>
   </section>
   <section>
    <title>
     <p>Пример: чтение разрешений на доступ к файлу</p>
    </title>
    <p>Программа 15.4 представляет собой функцию ReadFilePermissions, которая используется программами 15.1 и 15.2. Эта программа методично использует описанные выше функции для извлечения нужной информации. Правильная работа этой программы зависит от того факта, что ACL были созданы с помощью программы 15.3. Функция включена в тот же исходный модуль, что и программа 15.3, поэтому соответствующие объявления не повторяются.</p>
    <subtitle>Программа 15.4. ReadFilePermissions: чтение атрибутов безопасности </subtitle>
    <p><code>DWORD ReadFilePermissions(LPCTSTR lpFileName, LPTSTR UsrNm, LPTSTR GrpNm)</code></p>
    <p><code>/* Возвращает разрешения на доступ к файлу в стиле UNIX. */ </code></p>
    <p><code>{</code></p>
    <p><code> PSECURITY_DESCRIPTOR pSD = NULL;</code></p>
    <p><code> DWORD LenNeeded, PBits, iAce;</code></p>
    <p><code> BOOL DaclF, AclDefF, OwnerDefF, GroupDefF;</code></p>
    <p><code> BYTE DAcl[ACL_SIZE];</code></p>
    <p><code> PACL pAcl = (PACL)&amp;DAcl;</code></p>
    <p><code> ACL_SIZE_INFORMATION ASizeInfo;</code></p>
    <p><code> PACCESS_ALLOWED_ACE pAce;</code></p>
    <p><code> BYTE AType;</code></p>
    <p><code> HANDLE ProcHeap = GetProcessHeap();</code></p>
    <p><code> PSID pOwnerSid, pGroupSid;</code></p>
    <p><code> TCHAR RefDomain[2][DOM_SIZE];</code></p>
    <p><code> DWORD RefDomCnt[] = {DOM_SIZE, DOM_SIZE);</code></p>
    <p><code> DWORD AcctSize[] = {ACCT_NAME_SIZE, ACCT_NAME_SIZE};</code></p>
    <p><code> SID_NAME_USE sNamUse[] = {SidTypeUser, SidTypeGroup};</code></p>
    <p><code> /* Получить требуемый размер дескриптора безопасности. */</code></p>
    <p><code> GetFileSecurity(lpFileName, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION, pSD, 0, &amp;LenNeeded);</code></p>
    <p><code> pSD = HeapAlloc(ProcHeap, HEAP_GENERATE_EXCEPTIONS, LenNeeded);</code></p>
    <p><code> GetFileSecurity(lpFileName, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION, pSD, LenNeeded, &amp;LenNeeded);</code></p>
    <p><code> GetSecurityDescriptorDacl(pSD, &amp;DaclF, &amp;pAcl, &amp;AclDefF);</code></p>
    <p><code> GetAclInformation(pAcl, &amp;ASizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation);</code></p>
    <p><code> PBits = 0; /* Вычислить разрешения на доступ на основе ACL. */</code></p>
    <p><code> for (iAce = 0; iAce &lt; ASizeInfo.AceCount; iAce++) {</code></p>
    <p><code>  GetAce(pAcl, iAce, &amp;pAce);</code></p>
    <p><code>  AType = pAce-&gt;Header.AceType;</code></p>
    <p><code>  if (AType == ACCESS_ALLOWED_ACE_TYPE) PBits |= (0x1 &lt;&lt; (8-iAce));</code></p>
    <p><code> } </code></p>
    <p><code> /* Определить имя владельца и владеющей группы. */</code></p>
    <p><code> GetSecurityDescriptorOwner(pSD, &amp;pOwnerSid, &amp;OwnerDefF);</code></p>
    <p><code> GetSecurityDescriptorGroup(pSD, &amp;pGroupSid, &amp;GroupDefF);</code></p>
    <p><code> LookupAccountSid(NULL, pOwnerSid, UsrNm, &amp;AcctSize[0], RefDomain[0], &amp;RefDomCnt[0], &amp;sNamUse[0]);</code></p>
    <p><code> LookupAccountSid(NULL, pGroupSid, GrpNm, &amp;AcctSize[1], RefDomain[1], &amp;RefDomCnt[1], &amp;sNamUse[1]);</code></p>
    <p><code> return PBits; </code></p>
    <p><code>}</code> </p>
   </section>
   <section>
    <title>
     <p>Пример: изменение разрешений на доступ к файлу</p>
    </title>
    <p>Программа 15.5 является последней в нашем собрании функций, предназначенных для работы со средствами защиты файлов. Эта функция, ChangeFilePermissions, заменяет существующий дескриптор безопасности новым, сохраняя идентификаторы SID пользователя и группы, но создавая новый разграничительный список ACL.</p>
    <subtitle>Программа 15.5. ChangeFilePermissions: изменение атрибутов безопасности </subtitle>
    <p><code>BOOL ChangeFilePermissions(DWORD fPm, LPCTSTR FNm, LPDWORD AceMsk) </code></p>
    <p><code>/* Изменить разрешения на доступ к существующему файлу. Разрешения на доступ для группы остаются неизменными. */ </code></p>
    <p><code>{</code></p>
    <p><code> TCHAR UsrNm[ACCT_NAME_SIZE], GrpNm[ACCT_NAME_SIZE];</code></p>
    <p><code> LPSECURITY_ATTRIBUTES pSA;</code></p>
    <p><code> PSECURITY_DESCRIPTOR pSD = NULL;</code></p>
    <p><code> HANDLE hSecHeap;</code></p>
    <p><code> if (_taccess(FNm, 0) != 0) return FALSE;</code></p>
    <p><code> ReadFilePermissions(FNm, UsrNm, GrpNm);</code></p>
    <p><code> pSA = InitializeUnixSA(fPm, UsrNm, GrpNm, AceMsk, &amp;hSecHeap);</code></p>
    <p><code> pSD = pSA-&gt;lpSecurityDescriptor;</code></p>
    <p><code> SetFileSecurity(FileName, DACL_SECURITY_INFORMATION, pSD);</code></p>
    <p><code> HeapDestroy(hSecHeap);</code></p>
    <p><code> return TRUE; </code></p>
    <p><code>}</code> </p>
    <subtitle><emphasis>Комментарии по поводу разрешений на доступ к файлам</emphasis></subtitle>
    <p>В процессе выполнения этих программ весьма интересно контролировать файловую систему через проводник Windows. Эта служебная программа не в состоянии интерпретировать АСЕ, разрешающие и запрещающие доступ, и не может отображать соответствующие разрешения. В Windows 4.0 проводник, сталкиваясь с такими АСЕ, будет генерировать исключения.</p>
    <p>Вместе с тем, использование ACL, разрешающих и запрещающих доступ, необходимо для эмуляции семантики UNIX. Если этим пренебречь, то проводник Windows сможет обеспечить просмотр разрешений. Тогда, например, при коде защиты 0446 пользователь и члены группы смогут осуществлять запись в файл, поскольку это разрешено всем пользователям категории Everyone. В то же время, UNIX действует иначе; пользователю и членам группы эта операция будет запрещена.</p>
    <p>Понаблюдайте также за тем, что происходит, когда вы пытаетесь создать защищенный файл на дискете или в другой FAT-системе, а также когда программа выполняется под управлением Windows 9x.</p>
   </section>
   <section>
    <title>
     <p>Защита объектов ядра и коммуникаций</p>
    </title>
    <section>
     <p>В предыдущих разделах мы говорили главным образом о защите файлов, хотя те же методы можно применять и к другим объектам, построенным по типу файлов, например, именованным каналам (глава 11) или объектам ядра. Наш следующий пример, программа 15.6, предназначен для работы с именованными каналами, с которыми можно обращаться во многом точно так же, как с файлами.</p>
    </section>
    <section>
     <title>
      <p>Защита именованных каналов</p>
     </title>
     <p>Хотя соответствующая часть кода в листинге программы 11.3 опущена, сервер, полный программный код которого находится на Web-сайте книги, предоставляет возможность защиты его именованных каналов для предотвращения доступа к ним пользователей, не обладающих необходимыми полномочиями. Необязательные параметры командной строки позволяют указать имя пользователя и групповое имя:</p>
     <p><code>Server <emphasis>[ИмяПользователя ИмяГруппы]</emphasis></code></p>
     <p>Если имена пользователя и группы опущены, используются коды защиты, заданные по умолчанию. Заметьте, что для создания необязательных атрибутов защиты в полной версии программы 11.3 (которая доступна на Web-сайте) и в программе 15.6 используются методы из программы 15.3. В то же время, вместо вызова функции InitUnixSA мы теперь вызываем более простую функцию InitializeAccessOnlySA, которая обеспечивает предоставление только доступа, разрешенного элементами АСЕ, и помещает последний АСЕ, запрещающий доступ, в конец списка ACL. В программе 15.6 представлены соответствующие участки кода, которые не были отражены в листинге программы 11.3. В случае именованных каналов важное значение имеют следующие права доступа:</p>
     <p>• FILE_GENERIC_READ</p>
     <p>• FILE_GENERIC_WRITE</p>
     <p>• SYNCHRONIZE (разрешает потоку ожидать освобождения канала)</p>
     <p>Если при подключении клиента требуется предоставить все права доступа, можно просто указать уровень доступа STANDARD_RIGHTS_REQUIRED. Для получения полного доступа (дуплексного, входящего, исходящего и так далее) вам также придется воспользоваться маской 0x1FF. В сервере, представленном в программе 15.6, предусмотрена защита экземпляров его именованных каналов с использованием этих прав доступа. Доступ к каналу имеют только клиенты, запущенные на выполнение владельцем канала, хотя предоставление доступа к каналу также членам группы не вызывает никаких сложностей.</p>
     <subtitle>Программа 15.6. ServerNP: защита именованного канала </subtitle>
     <p><code>/* Глава 15. ServerNP. Предусмотрена защита именованного канала.</code></p>
     <p><code> * Многопоточный сервер командной строки. Версия на основе</code></p>
     <p><code> * именованного канала.</code></p>
     <p><code> * Использование: Server [ИмяПользователя ИмяГруппы]. */</code></p>
     <p><code>…</code></p>
     <p><code>_tmain(int argc, LPTSTR argv[]) {</code></p>
     <p><code> …</code></p>
     <p><code> HANDLE hNp, hMonitor, hSrvrThread[MAXCLIENTS];</code></p>
     <p><code> DWORD iNp, MonitorId, ThreadId;</code></p>
     <p><code> DWORD AceMasks[] = /* Права доступа к именованному каналу. */</code></p>
     <p><code>  {STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0X1FF, 0, 0 };</code></p>
     <p><code> LPSECURITY_ATTRIBUTES pNPSA = NULL;</code></p>
     <p><code> …</code></p>
     <p><code> if (argc == 4) /* Необязательный параметр защиты канала. */</code></p>
     <p><code>  pNPSA = InitializeAccessOnlySA(0440, argv[1], argv[2], AceMasks, &amp;hSecHeap);</code></p>
     <p><code> …</code></p>
     <p><code><emphasis> /*</emphasis> Создать экземпляр канала для каждого серверного потока. */</code></p>
     <p><code> …</code></p>
     <p><code> for (iNp = 0; iNp &lt; MAXCLIENTS; iNp++) {</code></p>
     <p><code>  hNp = CreateNamedPipe(SERVER_PIPE, PIPE_ACCESS_DUPLEX, PIPE_READMODE_MESSAGE | PIPE_TYPE_MESSAGE | PIPE_WAIT, MAXCLIENTS, 0, 0, INFINITE, pNPSA);</code></p>
     <p><code>  if (hNp == INVALID_HANDLE_VALUE) ReportError(_T("Невозможно открыть именованный канал."), 1, TRUE);</code></p>
     <p><code> }</code></p>
     <p><code> …</code></p>
     <p><code>}</code> </p>
    </section>
    <section>
     <title>
      <p>Защита объектов ядра и приватных объектов</p>
     </title>
     <p>Многие объекты, такие как процессы, потоки или мьютексы, являются <emphasis>объектами ядра</emphasis> (kernel objects). Для получения и установки дескрипторов безопасности ядра используются функции GetKernelObjectsSecurity и SetKernelObjectsSecurity, аналогичные функциям защиты файлов, описанным в настоящей главе. Однако при этом вы должны знать, какие права доступа соответствуют данному объекту; в следующем разделе показано, как определить эти права. </p>
     <p>Существует также возможность связывания дескрипторов безопасности с приватными, сгенерированными программой объектами, такими как объекты Windows Sockets или патентованные базы данных. Соответствующими функциями являются GetPrivateObjectSecurity и SetPrivateObjectSecurity. Ответственность за принудительное введение определенных прав доступа к таким объектам несет программист, который для изменения дескрипторов безопасности должен использовать функции CreatePrivateObjectSecurity и DestroyPrivateObjectSecurity.</p>
    </section>
    <section>
     <title>
      <p>Значения маски АСЕ</p>
     </title>
     <p>Модели "пользователь, группа, прочие", которую реализует функция InitUnixSA в большинстве случаев будет вполне достаточно, хотя с использованием тех же базовых методов могут реализовываться и другие модели.</p>
     <p>Вместе с тем, для этого необходимо знать фактические значения маски АСЕ, которые соответствуют тому или иному объекту ядра. Эти значения не всегда достаточно хорошо документированы, но для их нахождения можно воспользоваться несколькими способами.</p>
     <p>• Прочитайте документацию с описанием функции открытия интересующего вас объекта. Флаги доступа имеют те же значения, что и флаги, используемые в маске АСЕ. Так, функция OpenMutex использует флаги MUTEX_ALL_ACCESS и SYNCHRONIZE (второй из указанных флагов требуется для любого объекта, который может использоваться с функциями WaitForSingleObject или WaitForMultipleObjects). Другие объекты, например процессы, имеют множество других дополнительных флагов доступа.</p>
     <p>• Полезная в этом отношении информация может содержаться также в документации по функциям "создания" объектов.</p>
     <p>• Проверьте, не содержатся ли флаги, применимые к интересующему вас объекту, в заголовочных файлах WINNT.H и WINBASE.Н.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: защита процесса и его потоков</p>
    </title>
    <p>В документации по функции OpenProcess представлена подробная градация прав доступа, соответствующих самым разнообразным функциям, выполнение которых требует применения дескриптора процесса.</p>
    <p>Так, значение PROCESS_TERMINATE параметра доступа разрешает процессу (а фактически — потока внутри процесса) использовать дескриптор процесса в функции TerminateProcess для завершения процесса.</p>
    <p>Доступ на уровне PROCESS_QUERY_INFORMATION разрешает использование дескриптора процесса при вызове функций GetExitCodeProcess или GetPriorityClass, тогда как уровень доступа PROCESS_ALL_ACCESS разрешает любой доступ, а доступ SYNCHRONIZE требуется для выполнения функций ожидания завершения процесса. </p>
    <p>Чтобы проиллюстрировать эти идеи, на основе программы JobShell, рассмотренной в главе 6, была разработана программа JobShellSecure.c, которая разрешает доступ к управляемому процессу только его владельцу (или администратору). Эта программа находится на Web-сайте книги.</p>
   </section>
   <section>
    <title>
     <p>Обзор дополнительных возможностей защиты объектов</p>
    </title>
    <section>
     <p>О средствах безопасности Windows можно было сказать намного больше, но настоящая глава является лишь введением в эту тему, показывая, как организовать защиту объектов Windows, используя API системы безопасности. В последующих разделах кратко рассмотрены дополнительные вопросы, относящиеся к этой тематике.</p>
    </section>
    <section>
     <title>
      <p>Удаление элементов АСЕ</p>
     </title>
     <p>Функция DeleteAce удаляет АСЕ, определяемый с помощью индекса аналогично тому, как это делается в случае функции GetAce.</p>
    </section>
    <section>
     <title>
      <p>Абсолютные и самоопределяющиеся относительные дескрипторы безопасности</p>
     </title>
     <p>Программа 15.5, позволяющая изменять ACL, удобна тем, что просто заменяет один дескриптор безопасности (SD) другим. В то же время, при замене существующих SD следует проявлять осторожность, поскольку они бывают двух типов: абсолютные (absolute) и самоопределяющиеся относительные (self-relative). Внутреннее устройство этих структур данных для наших целей не имеет значения, однако вы должны понимать, в чем состоит различие между ними, и как переходить от одного из них к другому.</p>
     <p>• В процессе создания SD они являются абсолютными, и входящие в них указатели указывают на различные структуры, находящиеся в памяти. По сути, функция InitializeSecurityDescriptor создает абсолютный SD.</p>
     <p>• При связывании SD с постоянно существующим объектом, например файлом, ОС объединяет все данные, относящиеся к SD, в одну компактную самоопределяющуюся структуру. В то же время, изменение SD (например, изменение ACL) порождает трудности при управлении пространством в пределах структуры абсолютного SD.</p>
     <p>• Имеется возможность преобразовывать SD из одной формы в другую при помощи соответствующих функций Windows. Чтобы преобразовать самоопределяющийся относительный SD, например, возвращенный функцией GetFileSecurity, в абсолютный, используйте функцию MakeAbsoluteSD. Для обратного преобразования SD после внесения необходимых изменений служит функция MakeSelfRelativeSD. Функция MakeAbsoluteSD относится к числу тех функций Windows, которым огромное количество параметров придает устрашающий вид: из одиннадцати ее параметров по два приходится на каждый из четырех компонентов SD, по одному — на входной и выходной SD, а последний параметр предназначен для хранения размера результирующего абсолютного SD.</p>
    </section>
    <section>
     <title>
      <p>Системные списки ACL</p>
     </title>
     <p>Для управления системными списками ACL предусмотрен полный набор функций, однако использовать их может только системный администратор. Системные ACL определяют, какие разрешения на доступ к объекту должны быть зарегистрированы. Основной является функция AddAuditAccessAce, аналогичная функции AddAccessAllowed. В случае системных списков ACL понятие запрещенного доступа отсутствует.</p>
     <p>Двумя другими функциями, предназначенными для работы с системными ACL, являются функции GetSecurityDescrtiptorSacl и SetSecurityDescrtiptorSacl. Эти функции сопоставимы с их аналогами, предназначенными для работы с разграничительными ACL, — GetSecurityDescrtiptorDacl и SetSecurityDescrtiptorDacl.</p>
    </section>
    <section>
     <title>
      <p>Информация, хранящаяся в маркерах доступа</p>
     </title>
     <p>Программа 15.1 не решает задачи получения имен групп, связанных с процессом в его маркере доступа (access token). В ней просто требуется, чтобы имя группы указывал пользователь. Для получения соответствующей информации предназначена функция GetTokenInformation, требующая использования дескриптора процесса (глава 6). Эта задача решается в упражнении 15.12, в котором содержится подсказка к правильному решению. Сам код решения можно найти на Web-сайте книги.</p>
     <p>Кроме того, в маркере доступа хранится информация о привилегиях доступа, так что процесс получает определенный доступ в соответствии со своими идентификационными данными, а не в соответствии с полномочиями доступа, связанными с объектом. Так, администратору требуется доступ, перекрывающий тот, который предоставляется данным конкретным объектом. Здесь опять необходимо обратить ваше внимание на различие между правами доступа (rights) и привилегиями (privileges).</p>
    </section>
    <section>
     <title>
      <p>Управление идентификаторами SID</p>
     </title>
     <p>В наших примерах SID получались по именам пользователя и группы, но вы также можете создавать новые SID с помощью функции AllocateAndlnitializeSid. Дополнительно имеется возможность получать информацию о SID при помощи других функций, а также копировать SID (CopySid) и сравнивать их между собой (CompareSid).</p>
    </section>
    <section>
     <title>
      <p>Протокол защищенных сокетов</p>
     </title>
     <p>Интерфейс Windows Sockets (Winsock), описанный в главе 12, обеспечивает связь между системами по сети. Winsock удовлетворяет промышленным стандартам, что делает возможным взаимодействие с системами, не принадлежащими семейству Windows. Протокол защищенных сокетов (Secure Sockets Layer, SSL), являющийся расширением Winsock, располагает уровень протокола безопасной передачи данных поверх базового транспортного протокола, что обеспечивает возможность аутентификации, шифрования и дешифрации сообщений.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Резюме</p>
    </title>
    <section>
     <p>В Windows реализована тщательно разработанная модель безопасности объектов, возможности которой значительно превышают возможности стандартной системы защиты файлов UNIX. В примерах программ было показано, как эмулировать принятую в UNIX систему разрешений доступа и прав владения, устанавливаемых с помощью функций umask, chmod и chown. Программы также могут устанавливать владельца (группу и пользователя). Описанная эмуляция не является простой, однако результирующие функциональные возможности оказываются гораздо шире стандартных возможностей UNIX. Эта сложность обусловлена требованиями стандарта С2, изложенными в Оранжевой книге (Orange Book C2), в которых для определения списков управления доступом и и владельцами объектов используются маркеры доступа.</p>
    </section>
    <section>
     <title>
      <p>В следующей главе</p>
     </title>
     <p>Эта глава завершает наше рассмотрение Windows API. Следующая глава содержит обсуждение Win64, являющегося 64-битовым расширением Win32 API, и демонстрирует, как добиться того, чтобы программы правильно компоновались и выполнялись как в 32-битовом, так и в 64-битовом режимах.</p>
    </section>
    <section>
     <title>
      <p>Дополнительная литература</p>
     </title>
     <subtitle><emphasis>Windows</emphasis></subtitle>
     <p>Администрирование систем безопасности и политики безопасности Windows обсуждаются в [2]. Углубленному рассмотрению проблем безопасности посвящена книга [32]. </p>
     <subtitle><emphasis>Строение и архитектура Windows NT</emphasis></subtitle>
     <p>Подробное описание внутренней реализации механизмов безопасности Windows содержится в [38].</p>
     <subtitle><emphasis>Стандарт безопасности Orange Book C2</emphasis></subtitle>
     <p>Протокол безопасной передачи данных по сети С2 и другие уровни безопасности определены в публикации Министерства обороны США <emphasis>DoD Trusted Computer System Evaluation Criteria.</emphasis></p>
    </section>
   </section>
   <section>
    <title>
     <p>Упражнения</p>
    </title>
    <p>15.1. Расширьте возможности программы 15.1 таким образом, чтобы несколько групп могли иметь собственные уникальные разрешения доступа. Пары "имя-разрешение" могут выступать в качестве отдельных аргументов функции.</p>
    <p>15.2. Расширьте возможности программы 15.4 таким образом, чтобы она могла выводить список всех групп, в дескрипторах безопасности объектов которых имеются АСЕ.</p>
    <p>15.3. Убедитесь в том, что программа chmodW обеспечивает желаемое ограничение доступа к файлу.</p>
    <p>15.4. Исследуйте, какие атрибуты безопасности по умолчанию вы получаете вместе с файлом.</p>
    <p>15.5. Назовите другие маски доступа, которые можно использовать вместе с АСЕ. Дополнительную информацию вы можете найти в документации Microsoft.</p>
    <p>15.6. Усовершенствуйте программы chmodW и lsFP таким образом, чтобы при попытке обработки файла, не относящегося к системе NTFS, выводилось сообщение об ошибке. Для этого потребуется использовать функцию GetVolumeInformation.</p>
    <p>15.7. Усовершенствуйте программу chmodW, предусмотрев для нее опцию –о, позволяющую указывать, что пользователем программы является пользователь-владелец.</p>
    <p>15.8. Определите фактический размер буфера ACL, необходимый программе 15.3 для хранения элементов АСЕ. В программе 15.3 для этой цели используется 1024 байт. Можете ли вы предложить формулу для расчета необходимого размера буфера ACL?</p>
    <p>15.9. На Web-сайте Cygwin (http://www.cygwin.com) предлагается великолепная Linux-среда с открытым исходным кодом для Windows, предоставляющая командный процессор и реализацию таких команд, как chmod и ls. Установите эту среду и сравните варианты команд, реализованные в этой среде, с теми, которые разработаны в данной книге. Например, будет ли программа lsFP правильно отображать разрешения на доступ к файлу, если они были установлены с помощью соответствующей команды Cygwin, и наоборот. Сравните исходный код, представленный на Web-сайте Cygwin, с примерами из данной главы, что позволит вам критически оценить оба подхода к использованию средств безопасности Windows.</p>
    <p>15.10. В библиотеку совместимости входят функции _open и _unmask, которые позволяют обрабатывать разрешения на доступ к файлам. Исследуйте, каким образом они эмулируют систему разрешений на доступ к файлам, принятую в UNIX, и сравните их с решениями, приведенными в этой главе.</p>
    <p>15.11. Напишите программу для команды whoami, отображающей имя пользователя, который вошел в систему.</p>
    <p>15.12. В программе 15.3, в которой создается дескриптор безопасности, требуется, чтобы программист предоставил имя группы. Модифицируйте программу таким образом, чтобы она создавала разрешения для всех пользовательских групп. <emphasis>Подсказка.</emphasis> Необходимо воспользоваться функцией OpenTokenProcess, возвращающей массив с именами групп, хотя вам потребуется провести некоторые эксперименты для выяснения способа хранения имен групп в массиве. Частичное решение вы найдете в исходном тексте программы, находящемся на Web-сайте.</p>
    <p>15.13. Обратите внимание на то, что в клиент-серверной системе клиенты имеют доступ строго к тем же файлам и другим объектам, которые доступны серверу, установленному на серверной машине с правами доступа сервера. Снимите это ограничение, реализовав так называемое делегирование прав доступа (security delegation), используя функции ImpersonateNamedPipeClient и RevertToSelf. Клиенты, не принадлежащие группе, которая применялась для защиты канала, подключаться к серверу не смогут.</p>
    <p>15.14. Существует ряд других функций Windows, которые вы можете счесть полезными для себя и применить для упрощения или усовершенствования программ, предложенных в качестве примеров. Ознакомьтесь со следующими функциями: AreAllAccessesGranted, AreAnyAccessesGranted, AccessCheck и MapGenericMask. Можете ли вы воспользоваться этими функциями для упрощения или усовершенствования примеров? </p>
   </section>
  </section>
  <section>
   <title>
    <p>ГЛАВА 16</p>
    <p>Программирование в среде Win64</p>
   </title>
   <section>
    <p>Наиболее заметный прогресс в развитии возможностей Windows после появления Windows NT и Windows 95 связан с приходом 64-разрядного программирования и расширением Win32 до Win64. На объединенный API обычно ссылаются просто как на Windows API, и именно такой практики мы придерживались на протяжении всей книги. API Win64 обеспечивает возможность выполнения в Windows наиболее крупных и требовательных в отношении ресурсов приложений уровня предприятий и приложений для научных расчетов. 64-разрядные системы позволяют программам использовать гигантские адресные пространства, которые выходят далеко за предел 4 Гбайт, обусловленный 32-битовой адресацией.</p>
    <p>В данной главе описано нынешнее состояние Win64 и преимущества этого интерфейса, а также рассмотрена соответствующая модель программирования и обсуждены вопросы переносимости программ между различными операционными системами и аппаратными платформами. Это рассмотрение проводится безотносительно к фактическому типу 64-разрядного процессора или конкретной версии Windows, обеспечивающих поддержку Win64. Процесс переноса одного из предыдущих примеров иллюстрирует программа 16.1.</p>
   </section>
   <section>
    <title>
     <p>Нынешнее состояние Win64</p>
    </title>
    <section>
     <p>В данном разделе анализируется состояние поддержки компанией Microsoft интерфейса Win64 на различных системах и процессорах, сложившееся к концу первого полугодия 2004 года. Поскольку ситуация постоянно меняется, приведенную ниже информацию следует рассматривать лишь в качестве "моментального снимка" реального положения дел. Тем не менее, на охватываемых здесь аспектах программирования эволюция поддержки Win64 никак не сказывается.</p>
     <p>По-видимому, в будущем мы окажемся свидетелями значительного прогресса и изменений в этой области, хотя внедрение Win64 происходит довольно-таки медленно. Приведенная ниже информация почерпнута, как правило, на Web-сайтах соответствующих поставщиков и из отраслевых изданий, так что для получения впоследствии более свежих данных вы можете воспользоваться этими же источниками.</p>
    </section>
    <section>
     <title>
      <p>Поддержка процессоров</p>
     </title>
     <p>Win64 поддерживается или, о чем можно говорить почти с полной уверенностью, будет поддерживаться, по крайней мере, на трех различных семействах процессоров:</p>
     <p>• Семейство процессоров Itanium (Itanium Processor family, IPF) компании Intel, архитектура которых полностью отличается от известной архитектуры Intel x86. IPF предоставляет большие регистровые файлы (включающие 128 регистров общего назначения), каналы многоадресных команд, встроенные трехуровневые кэши, а также множество других средств, обеспечивающих высокую производительность и 64-битовую адресацию. В настоящее время на рынок поставляются процессоры Itanium 2, и хотя их предшественник — процессор Itanium — является теперь уже устаревшим, нам будет удобно ссылаться на все семейство просто как на "процессоры Itanium".</p>
     <p>• Процессоры Opteron и Athlon 64 (AMD64) компании AMD, предназначенные, соответственно, для серверов и рабочих станций. Архитектуру AMD64 можно рассматривать как расширение архитектуры Intel x86, допускающее 64-битовую виртуальную адресацию и параллельное выполнение 32– и 64-битовых операций.</p>
     <p>• 32/64-разрядные процессоры компании Intel, сравнимые с процессорами AMD64. Во время написания этой книги ожидалось, что технология 64-разрядного расширения будет применена в первую очередь в процессорах Xeon. Как и прогнозировалось, такие процессоры появились на рынке в конце 2004 года.</p>
    </section>
    <section>
     <title>
      <p>Поддержка Windows</p>
     </title>
     <p>API Win64 компании Microsoft предназначен для поддержки 64-разрядных архитектур таким способом, при котором в существующие исходные и двоичные коды требуется вносить лишь минимальные изменения. В настоящее время имеется несколько отдельных версий Win64.</p>
     <p>• Windows XP 64-bit Edition доступна в виде, по крайней мере, двух версий. Бета-версия компании Microsoft поддерживает только процессор AMD Opteron. Компания Hewlett Packard выводит на рынок несколько моделей рабочих станций на базе процессоров Itanium с уже установленной системой Windows XP-Itanium2.</p>
     <p>• Windows Server 2003 Enterprise Edition for 64-bit Extended Systems в настоящее время также проходит бета-тестирование. Эта версия обеспечивает поддержку процессоров AMD Opteron и Intel Xeon с использованием технологии 64-разрядного расширения.</p>
     <p>• Windows Server 2003 Enterprise Edition for 64-bit Itanium-based Systems поддерживает, как говорит само ее название, серверы и рабочие станции, использующие один или несколько процессоров Itanium. Существует также версия Datacenter Edition. Например, эта версия устанавливается на системах Integrity компании Hewlett Packard, которые в настоящее время также появляются на рынке.</p>
    </section>
    <section>
     <title>
      <p>Поддержка сторонних компаний</p>
     </title>
     <p>На платформе Win64 доступны многочисленные базы данных, математические библиотеки, прикладные системы уровня предприятия, системы с открытым исходным кодом, а также целый ряд других систем. Тем не менее, каждый раз, когда планируется перенос программ на эту платформу, доступность необходимых продуктов сторонних компаний должна предварительно проверяться.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Обзор 64-разрядной архитектуры</p>
    </title>
    <section>
     <p>С точки зрения программиста основная трудность при переходе от 32-разрядной модели к 64-разрядной заключается в том, что размер указателей и таких системных типов данных, как size_t и time_t, теперь может составлять 64 бита. Поэтому виртуальное адресное пространство процесса уже не ограничивается 4 Гбайт (фактически доступны приложениям только 3 Гбайт). Таким образом, перенос программ из Win32 в Win64 по существу требует лишь "удлинения" указателей, с чем связаны лишь самые минимальные последствия для пользовательских данных в модели Windows.</p>
    </section>
    <section>
     <title>
      <p>Необходимость в 64-битовой адресации</p>
     </title>
     <p>Возможности доступа к большим адресным пространствам требуются многим приложениям. Можно было бы привести множество примеров, аналогичных тем, которые перечислены ниже.</p>
     <p>• <strong>Приложения для обработки изображений. </strong>Системы, использующие адресные пространства размером 4 Гбайт, в состоянии обеспечить лишь 20-секундное воспроизведение телевизионного изображения высокой четкости (High-Definition Television, HDTV) в реалистичных цветах.</p>
     <p><strong>• Автоматизированное проектирование механических (Mechanical Computer-Aided Design, MCAD) и электронных (Electronic Computer-Aided Design, ECAD) устройств. </strong>Для проектирования сложных сборочных узлов требуется наличие более 3 Гбайт памяти, а проектирование микросхем предъявляет к памяти несоизмеримо более высокие требования.</p>
     <p>• <strong>Базы данных и хранилища данных. </strong>Использование файлов с размерами в несколько сотен Гбайт не является чем-то необычным, и возможность доступа к виртуальным адресным пространствам сопоставимых размеров значительно упрощает обработку таких файлов.</p>
     <p>Теперь поддержка подобных запросов в отношении адресных пространств большого объема стала реальностью. Пройдет совсем немного времени, и 64-разрядные микропроцессоры станут доступными каждому, а большие объемы физической памяти при разумной стоимости будут поддерживаться на многих системах.</p>
     <p>Потребность в 64-битовой адресации диктуется теми же факторами, которые делают столь желательными и необходимыми файлы гигантских размеров (свыше 4 Гбайт), и теперь, когда имеются достаточно мощные микропроцессоры Itanium, AMD64, а также процессоры, использующие технологию 64-разрядного расширения, вполне естественно ожидать, что Windows должна будет эволюционировать для удовлетворения этих запросов. Использование 64-разрядных ОС существенно в тех случаях, когда Windows отводится заметная роль в прикладных корпоративных и профессиональных системах.</p>
     <p>Тем не менее, многие 32-разрядные приложения смогут работать нормально и на новой платформе, и на первом этапе для их переноса не надо будет ничего предпринимать. Для таких персональных приложений, как Microsoft Office или Adobe PageMaker, в течение некоторого времени переход к 64-битовой адресации, по-видимому, не потребуется. Следовательно, Windows будет поддерживать обратную совместимость.</p>
     <p>Как и следовало ожидать, применение существующих 64-разрядных процессоров часто обеспечивает выигрыш в производительности, но этот выигрыш непосредственно никак не сказывается на программировании на уровне исходного кода.</p>
    </section>
    <section>
     <title>
      <p>Опыт UNIX</p>
     </title>
     <p>PC-системы всегда отставали от универсальных вычислительных систем (мэйнфреймов) и систем на основе UNIX в том, что касается базовых функциональных возможностей и масштабируемости. То же самое остается справедливым и в случае 64-разрядных архитектур.</p>
     <p>• Основные поставщики UNIX-систем предоставляют 48– и 64-разрядные микропроцессоры с начала 90-х годов прошлого столетия.</p>
     <p>• Основные поставщики UNIX-систем поддерживают 64-разрядные API на протяжении примерно того же периода времени.</p>
     <p>• Сообщество пользователей UNIX остановилось на выборе в качестве стандарта так называемой модели LP64, отличающейся от модели Р64, принятой в Win64, о чем далее еще будет говориться.</p>
     <p>• Переходы от 32 к 64 битам всегда осуществлялись сравнительно простым, если не сказать — тривиальным образом, и можно ожидать, что то же самое будет наблюдаться и при переходе от Win32 к Win64.</p>
    </section>
    <section>
     <title>
      <p>Опыт перехода от 16-разрядных версий Windows к 32-разрядным</p>
     </title>
     <p>Переход от 16-разрядных версий Windows к 32-разрядным начался в начале 90-х годов прошлого столетия с появлением Windows NT, и набрал ускорение после того, как использование Windows 95 стало обычным делом. Каким бы соблазнительным ни казалось предположение о том, что нас ожидает повторение той же истории, рассматриваемые нами ситуации отличаются в нескольких аспектах.</p>
     <p>• Windows NT и Windows 95 были первыми из широко используемых "реальных" операционных систем для PC в том смысле, что обе системы поддерживали обмен страницами по запросу, потоки, вытесняющую многозадачность и множество других возможностей, которые были описаны в главе 1.</p>
     <p>• Хотя API Win32 значительно расширил полезное адресное пространство, что делает и Win64, усовершенствования этим не ограничивались. Неуклюжие и устаревшие, несмотря на свою популярность, модели расширенной памяти были заменены другими. Аналогичная модель расширенной памяти (не описывается в данной книге) была введена и в Windows 2000, однако общие последствия этого шага в данном случае были не столь существенными.</p>
     <p>• В API Win32 было введено множество новых функциональных возможностей, чего нельзя сказать о Win64.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Надолго ли хватит 64 бит?</p>
    </title>
    <p>Что касается мира PC, в котором возникла Windows, то можно утверждать, что первоначальная 16-разрядная модель Intel x86 (фактическое адресное пространство которой является 20-битовым) просуществовала в течение более десяти лет, и столько же времени уже существует и 32-разрядная архитектура. Однако переход к Win64 и 64-разрядному программированию, вообще говоря, происходит медленнее, чем происходил аналогичный переход к 32 битам. Вместе с тем, в обоих случаях переход миникомпьютеров и серверов на следующий уровень осуществлялся, по крайней мере, за 10 лет до того, как это начинало происходить с PC. Тогда вполне естественно задаться вопросом о том, следует ли ожидать перехода серверов или PC к 128 битам в будущем. Берусь утверждать, что любое расширение такого рода произойдет не раньше, чем через 10 лет, исходя из одной лишь величины 64-разрядного адресного пространства.</p>
    <p>Предсказания — вещь ненадежная, однако, воспринимая это серьезно лишь наполовину, можно напомнить о часто цитируемом законе Мура, согласно которому отношение "стоимость/производительность" уменьшается вдвое каждые 18 месяцев. В свою очередь, быстродействие и емкость устройств каждые 18 месяцев примерно удваиваются. Применяя эти рассуждения к адресному пространству, можно ожидать, что дополнительный бит адреса нам будет требоваться через каждые 18 месяцев, откуда следует, что 64-разрядная модель будет исправно служить еще целых 48 лет (то есть почти столько же времени, сколько насчитывает вся история современных компьютеров). Оправданы ли такие неформальные выводы, которые встретились мне в одном из официальных источников, покажет время, однако в прошлом запросы к ресурсам PC возрастали гораздо быстрее, чем утверждается в приведенном прогнозе.</p>
   </section>
   <section>
    <title>
     <p>Модель программирования Win64</p>
    </title>
    <section>
     <p>В зависимости от выбора способа представления таких стандартных типов данных С, как указатели и целочисленные типы данных (long, int и short), a также от того, вводятся или не вводятся нестандартные типы данных, возможны несколько вариантов модели 64-разрядного программирования. Напомним, что в стандарте ANSI С размеры типов данных не определяются строго, хотя и требуется, чтобы размер данных типа long int был не меньше размера данных типа int, а размер данных типа int был не меньше размера данных типа short int.</p>
    </section>
    <section>
     <title>
      <p>Цели</p>
     </title>
     <p>Цель состоит в том, чтобы ввести единое определение Windows API (то есть, общее для Win32 и Win64), благодаря чему можно будет использовать единый базовый исходный код. Использование этого единого определения может потребовать внесения некоторые изменений в исходный код, но эти изменения должны быть сведены к минимуму.</p>
     <p>Microsoft выбрала модель LLP64 (целые числа типа long и 64-битовые указатели), на которую обычно ссылаются просто как на модель Р64. В частности, существуют следующие определения типов данных, применимые как к данным со знаком, так и к данным без знака:</p>
     <p>• char — 8 бит, и wchar — 16 бит.</p>
     <p>• short — 16 бит.</p>
     <p>• int — 32 бита.</p>
     <p>• long int — также 32 бита.</p>
     <p>• Размер указателя любого типа, например PVOID, составляет 64 бита.</p>
     <p>Для тех случаев, когда требуются данные строго определенного размера, предусмотрены дополнительные типы данных. Так, компилятор Microsoft различает следующие типы данных: _int16, _int32 и _int64.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Типы данных</p>
    </title>
    <section>
     <p>Приведенные в этой главе таблицы взяты непосредственно из оперативной справочной системы и представляют единую модель данных Windows (Windows Uniform Data Model). Определения типов можно найти в заголовочном файле BASETSD.H, входящем в состав интегрированной среды разработки приложений Microsoft Visual Studio .NET (версия 7.0) и версию 6.0 этой системы.</p>
    </section>
    <section>
     <title>
      <p>Типы данных фиксированной точности</p>
     </title>
     <p>Обозначения типов данных фиксированной точности получаются из обычных обозначений типов данных Win32, таких как DWORD или LONG, добавлением суффикса размера, как показано в табл. 16.1.</p>
     <empty-line/>
     <p>Таблица 16.1. Типы данных фиксированной точности</p>
     <table>
      <tr align="left">
       <th align="left" valign="top">Тип данных</th>
       <th align="left" valign="top">Описание</th>
      </tr>
      <tr align="left">
       <td align="left" valign="top">DWORD32</td>
       <td align="left" valign="top">32-битовое целое без знака</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">DWORD64</td>
       <td align="left" valign="top">64-битовое целое без знака</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">INT32</td>
       <td align="left" valign="top">32-битовое целое со знаком</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">INT64</td>
       <td align="left" valign="top">64-битовое целое со знаком</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">LONG32</td>
       <td align="left" valign="top">32-битовое целое со знаком</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">LONG64</td>
       <td align="left" valign="top">64-битовое целое со знаком</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">UINT32</td>
       <td align="left" valign="top">Целое типа INT32 без знака</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">UINT64</td>
       <td align="left" valign="top">Целое типа INT64 без знака</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">ULONG32</td>
       <td align="left" valign="top">Целое типа LONG32 без знака</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">ULONG64</td>
       <td align="left" valign="top">Целое типа LONG64 без знака</td>
      </tr>
     </table>
    </section>
    <section>
     <title>
      <p>Типы данных, соответствующие точности указателей</p>
     </title>
     <p>Процитируем выдержку из статьи Microsoft под названием "The New Data Types" (доступна на Web-сайте компании Microsoft): "Точность этих типов данных отражает изменение точности указателей (то есть, они становятся 32-битовыми в коде Win32 и 64-битовыми в коде Win64). Поэтому приведение указателей к одному из этих типов при выполнении арифметических операций с указателями является безопасным; при 64-битовой точности указателей размер данных этого типа будет составлять 64 бита. Также и типы данных, соответствующие счетчикам, отражают максимальный размер данных, на которые может ссылаться указатель." Таким образом, эти типы данных обеспечивают автоматическое изменение размеров целочисленных типов данных в зависимости от изменения размеров указателей, в связи с чем их иногда называют полиморфными (polymorphic data types) или <emphasis>платформо-масштабируемыми</emphasis> (platform scaled data types) <emphasis>типами данных.</emphasis> Типы данных, соответствующие точности указателей, перечислены в табл. 16.2, взятой из той же статьи.</p>
     <p>Наиболее важным из них является тип данных SIZE_T, который уже использовался нами при описании размеров блоков памяти в главе 5.</p>
     <p>Наконец, заметьте, что в Win64 размер данных типа HANDLE составляет 64 бита.</p>
     <empty-line/>
     <p>Таблица 16.2. Типы данных, соответствующие точности указателей</p>
     <table>
      <tr align="left">
       <th align="left" valign="top">Тип данных</th>
       <th align="left" valign="top">Описание</th>
      </tr>
      <tr align="left">
       <td align="left" valign="top">DWORD_PTR</td>
       <td align="left" valign="top">Длинное целое без знака, соответствующее точности указателей.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">HALF_PTR</td>
       <td align="left" valign="top">Половина размера указателя. Используется в структурах, содержащих указатель и два поля небольшого размера.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">INT_PTR</td>
       <td align="left" valign="top">Целое со знаком, соответствующее точности указателей.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">LONG_PTR</td>
       <td align="left" valign="top">Длинное целое со знаком, соответствующее точности указателей.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">SIZE_T</td>
       <td align="left" valign="top">Максимальное количество байтов, на которые может ссылаться указатель. Используется для счетчиков, которые должны охватывать весь диапазон возможных значений указателей.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">SSIZE_T</td>
       <td align="left" valign="top">Тип SIZE_T со знаком.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">UHALF_PTR</td>
       <td align="left" valign="top">Тип HALF_PTR без знака.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">UINT_PTR</td>
       <td align="left" valign="top">Тип INT_PTR без знака.</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">ULONG_PTR</td>
       <td align="left" valign="top">Тип LONG_PTR без знака.</td>
      </tr>
     </table>
    </section>
    <section>
     <title>
      <p>Пример: использование указательных типов данных</p>
     </title>
     <p>Аргументом потока, передаваемым функции потока при вызове CreateThread и _beginthreadex (см. главу 7), является указатель типа PVOID. Иногда программист может захотеть передать функции потока только целочисленное значение, указывающее, например, номер потока или индекс данных в глобальной таблице. Тогда функцию потока, интерпретирующую параметр как целое без знака, можно было бы написать следующим образом:</p>
     <p><code>DWORD WINAPI MyThreadFunc(PVOID Index_PTR) {</code></p>
     <p><code> DWORD_PTR Index;</code></p>
     <p><code> …</code></p>
     <p><code> Index = (DWORD_PTR)Index_PTR;</code></p>
     <p><code> …</code></p>
     <p><code>}</code></p>
     <p>Аналогичным образом, зная, что фактический аргумент является целым числом, вы могли бы записать соответствующий участок кода основного потока следующим образом:</p>
     <p><code>…</code></p>
     <p><code>DWORD_PTR Ix;</code></p>
     <p><code>…</code></p>
     <p><code>for (Ix = 0; Ix &lt; NumThreads; Ix++) {</code></p>
     <p><code> hTh[Ix] = _beginthreadex(NULL, 0, MyThreadFunc, (PVOID)Ix, 0, NULL);</code></p>
     <p><code> …</code></p>
     <p><code>}</code></p>
     <p>Заметьте, что в уже существующий код вам придется внести необходимые изменения. Об этом говорится далее в разделе "Перенос существующего кода".</p>
     <cite>
      <p><strong>Предостережение</strong></p>
      <p>Пока, по крайней мере, в случае первоначальных вариантов реализации, не следует рассчитывать на получение доступа ко всему виртуальному адресному пространству. Размер виртуальных адресных пространств может ограничиваться такими, например, значениями, как 512 Гбайт, что соответствует ограничению данных 39 битами. Можно надеяться, что со временем, по мере эволюции процессоров и систем, указанный верхний предел увеличится.</p>
     </cite>
    </section>
    <section>
     <title>
      <p>Различия между Windows и UNIX</p>
     </title>
     <p>В Windows и UNIX выбраны различные стратегии. Большинство поставщиков UNIX-систем реализуют модель LP64, в которой размер как длинного целочисленного, так и указательного типов данных составляет 64 бита. Такую модель иногда называют моделью "I32, LP64", чтобы подчеркнуть тот факт, что размер данных типа int по-прежнему составляет 32 бита. Таким образом, различие между обеими системами в рассматриваемом нами смысле сводится к различию в размерах целых чисел типа long. К тому же, типы данных, перечисленные в таблицах 16.1 и 16.2, приняты только в Windows.</p>
     <p>Для каждой из двух моделей имеются разумные обоснования, и в белых страницах "Aspen", фигурирующих в списке дополнительной литературы к этой главе, приводятся аргументы, объясняющие выбор, сделанный в UNIX. И все же, было бы гораздо удобнее, если бы в обеих ОС действовали одни и те же соглашения.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Перенос имеющегося программного кода</p>
    </title>
    <section>
     <p>Единая модель данных Windows призвана минимизировать объем возможных изменений исходного кода, но полностью избежать необходимости внесения изменений невозможно. Например, такие функции, как HeapCreate и HeapAlloc (глава 5), которые имеют дело непосредственно с распределением памяти и размерами блоков памяти, должны использовать либо 32-битовое, либо 64-битовое поле, в зависимости от модели. Точно так же, следует всегда тщательно проверять код, чтобы выяснить, не используются ли в нем скрытые допущения относительно размеров полей и указателей.</p>
     <p>Сначала будут описаны изменения, связанные с использованием API, которые, главным образом, касаются функций управления памятью.</p>
    </section>
    <section>
     <title>
      <p>Изменения, связанные с использованием API</p>
     </title>
     <p>Наиболее заметные изменения, связанные с использованием API, затрагивают функции управления памятью, введенные в главе 5. В новых определениях в полях счетчиков используется тип данных SIZE_T (см. табл. 16.2). Например, теперь прототип функции HeapAlloc будет иметь следующий вид: </p>
     <cite>
      <p><code>LPVOID HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);</code> </p>
     </cite>
     <p>Количество запрошенных байтов, указываемое в третьем поле, выражается данными типа SIZE_T и поэтому является 32– или 64-битовым целым без знака. Ранее данные в этом поле имели тип DWORD (всегда 32 бита).</p>
     <p>Данные типа SIZE_T используются в соответствии с необходимостью в главе 5.</p>
    </section>
    <section>
     <title>
      <p>Изменения, связанные с устранением неявных допущений относительно предполагаемых размеров элементов данных</p>
     </title>
     <p>Источником многих проблем могут служить различного рода допущения относительно размеров данных. Несколько возможных примеров этого приводятся ниже.</p>
     <p>• Тип DWORD больше нельзя использовать при указании размера блоков памяти. Вместо него следует применять типы данных SIZE_T или DWORD64.</p>
     <p>• Необходимо тщательно проверять размеры полей, используемых взаимодействующими процессами, независимо от того, выполняются ли они на одной и той же или на разных системах. Так, в главе 12 для того, чтобы перенос программы на системы UNIX или Win64 не приводил к возникновению 64-битовых полей, поля размера в сообщениях сокетов определялись с использованием типа данных LONG32. При организации связи между процессами Windows, использующими разные модели, размеры блоков памяти не должны превышать 2 Гбайт.</p>
     <p>• Для вычисления размера структур или типов данных следует использовать функцию sizeof; эти размеры будут разными для Win32 и Win64, если в структуру данных входят указатели или элементы данных SIZE_T. Литеральные константы размеров должны быть исключены (разумеется, этому совету было бы неплохо следовать при любых обстоятельствах).</p>
     <p>• Необходимо проверять, не содержаться ли в объединениях, в которых указатели используются совместно с арифметическими типами данными, неявные предположения относительно размеров типов данных.</p>
     <p>• Любое приведение типов или иное преобразование, в котором участвуют указатели и данные арифметического типа должно тщательно проверяться. Обратитесь, например, к фрагментам кода, приведенным в разделе "Пример: использование указательных типов данных". </p>
     <p>• В частности, остерегайтесь неявного приведения 32-битовых целых к 64-битовым в вызовах функций. Нет никакой гарантии, что старшие 32 бита будут очищены, в результате чего функция может получить в качестве аргумента очень большое 64-битовое целое значение.</p>
     <p>• Указатели выравниваются по 8-байтовым границам, в результате чего дополнение структур, обусловленное выравниванием, может увеличить размер структуры данных сверх необходимого и даже отрицательно повлиять на производительность. Перемещение указателей в начало структуры минимизирует последствия ее "разбухания".</p>
     <p>• При выводе на печать указателей вместо спецификатора формата %x используйте спецификатор %p, а при выводе платформо-масштабируемых данных, например типа SIZE_T, — спецификатор %ld.</p>
     <p>• Функции setjmp и longjmp должны использовать заголовочный файл &lt;setjmp.h&gt;, а не какие-либо допущения относительно возможного размера переменной jmp_buf, в которой должен храниться указатель.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Пример: перенос программы sortMM (программа 5.5)</p>
    </title>
    <section>
     <p>В программе sortMM (программа 5.5) интенсивно используются указатели, и в частности, арифметика указателей. Подготовка этой программы к переносу, в результате чего ее можно будет компоновать и выполнять под управлением как Win32, так и Win64, иллюстрирует обычно используемые методики, а также демонстрирует, как легко невольно сделать допущения относительно размера указателя.</p>
    </section>
    <section>
     <title>
      <p>Использование предупреждающих сообщений компилятора</p>
     </title>
     <p>Какое бы большое значение визуальная проверка кода ни играла для обнаружения и устранении любых проблем, связанных с переходом к Win64, всегда целесообразно использовать компилятор или какое-либо иное средство, обеспечивающее просмотр кода и выдачу соответствующих предупреждающих сообщений.</p>
     <p>Входящий в состав Microsoft Visual Studio 7.0 (.NET) компилятор C++ компании Microsoft может конфигурироваться для выдачи таких сообщений. Для этого достаточно задать в командной строке компилятора опции –Wp64 и –W3. В Visual Studio для установки этих опций потребуется выполнить следующие действия:</p>
     <p>• Выберите страницу Project Properties (Свойства проекта).</p>
     <p>• Откройте папку C++.</p>
     <p>• Щелкните на кнопке General (Общие). </p>
     <p>• Выберите вкладку Detect 64-bit Portability Issues (Определять элементы переноса в 64 разряда) и выберите вариант Yes (/Wp64) (Да (/Wp64)). Оставьте для уровня диагностики (warning level) значение 3.</p>
     <p>После этого, в процессе сборки проекта в окне вывода будут отображаться соответствующие предупреждающие сообщения. При построении в Microsoft Visual Studio 7.0 проектов, которые находятся на Web-сайте книги, вывод предупреждающих сообщений конфигурировался именно так, как описано выше.</p>
    </section>
    <section>
     <title>
      <p>Код до подготовки к переносу</p>
     </title>
     <p>Большая часть программного кода sortMM.с не приводит к выдаче предупреждающих сообщений, но один участок кода на шаге 6 (см. программу 5.5) вызывает их генерацию. Соответствующий фрагмент кода вместе с номерами строк представлен в программе 16.1. Имейте в виду, что в последующих версиях этой программы номера строк могут поменяться. </p>
     <subtitle>Программа 16.1. sortMM.с: код до подготовки к переносув Win64, часть 1</subtitle>
     <p><code>…</code></p>
     <p><code>54 LPBYTE pXFile = NULL, pX;</code></p>
     <p><code>55 TCHAR _based (pInFile) *pIn;</code></p>
     <p><code>…</code></p>
     <p><code>130</code></p>
     <p><code>131 if (!NoPrint)</code></p>
     <p><code>132  for (iKey = 0; iKey &lt; FsX / RSize; iKey++) {</code></p>
     <p><code>133   WriteFile(hStdOut, &amp;ChNewLine, TSIZE, &amp;nWrite, NULL);</code></p>
     <p><code>134</code></p>
     <p><code>135   /* Приведение типа рХ играет весьма важную роль, поскольку это</code></p>
     <p><code>136      указатель на байт, а нам нужны четыре байта указателя типа _based. */</code></p>
     <p><code>137   pIn = (TCHAR _based(pInFile)*)*(LPDWORD)pX; </code></p>
     <p><code>138</code></p>
     <p><code>139   while ((*pIn != CR || *(pIn + 1) != LF) &amp;&amp; (DWORD)pIn &lt; FsIn) {</code></p>
     <p><code>140    WriteFile(hStdOut, pIn, TSIZE, &amp;nWrite, NULL);</code></p>
     <p><code>141    pIn++;</code></p>
     <p><code>142   }</code></p>
     <p><code>143   pX += RSize;</code></p>
     <p><code>144  }</code> </p>
     <p>Сообщения компилятора далее приводятся, но прежде чем ознакомиться с ними, вы, возможно, захотите просмотреть код, чтобы определить возможные причины выдачи будущих предупреждающих сообщений. Не забывайте о том, что нашей целью является придание программе такого вида, который обеспечивает ее сборку и корректное выполнение как в режиме Win32, так и в режиме Win64.</p>
    </section>
    <section>
     <title>
      <p>Предупреждающие сообщения компилятора</p>
     </title>
     <p>Предупреждающие сообщения компилятора для этого фрагмента кода отчетливо демонстрируют неявное предположение о том, что размер указателя составляет 4 байта.</p>
     <p><code>SORTMM.C(137) : warning C4312: 'type cast' : conversion from 'DWORD' to 'TCHAR __based(pInFile) *' of greater size</code></p>
     <p><code>SORTMM.C(139) : warning C4311: 'type cast' : pointer truncation from 'TCHAR __based(pInFile) *' to 'DWORD'</code></p>
     <p>Первое предупреждение (строка 137) является существенным. Разыменование рХ после его приведения (type cast) к типу LPDWORD приводит к 32-битовому значению, которое затем назначается указателю pIn. Почти с полной уверенностью можно утверждать, что разыменование pIn вызовет исключение или приведет к возникновению иной серьезной ошибки. Правильным решением для строки 137 будет замена приведения к типу LPDWORD приведением к типу указателя LPTSTR следующим образом:</p>
     <p><code>pIn = (TCHAR _based(pInFile)*)*(DWORD_PTR)pX;</code></p>
     <p>Сообщение для строки 139 довольно интересно, поскольку мы сравниваем базовый указатель с размером файла. Если предположить, что файл не является гигантским, то на это предупреждение можно не обращать внимания. При этих условиях можно было бы проигнорировать и сообщение для строки 137. Однако мы учтем перспективу и приготовимся к работе с гигантскими файлами, пусть даже типом FsSize пока и является DWORD. Допуская полный диапазон значений указателя, мы должны преобразовать строку 139 следующим образом:</p>
     <p><code>while ((*pIn != CR || *(pIn + 1) != LF) &amp;&amp; (SIZE_T)pIn &lt; (SIZE_T)FsIn) {</code></p>
     <p>Второй сегмент, относящийся к шагу 2b, порождает дополнительные предупреждающие сообщения, связанным с усечением типов (pointer truncation). Соответствующий фрагмент кода представлен в программе 16.2.</p>
     <subtitle>Программа 16.2. sortMM: код до подготовки к переносу в Win64, часть 2</subtitle>
     <p><code>…</code></p>
     <p><code>40  DWORD, KStart, KSize;</code></p>
     <p><code>174 /* Шаг 2b: Получить первый ключ; определить размер и начальный адрес ключа. */ </code></p>
     <p><code>175</code></p>
     <p><code>176  KStart = (DWORD) pInScan;</code></p>
     <p><code>177  /* Вычисляем адрес начала поля ключа. */</code></p>
     <p><code>178  while (*pInScan !=''&amp;&amp; *pInScan != '\t') pInScan++;</code></p>
     <p><code>179  /* Вычисленный конец поля ключа. */ </code></p>
     <p><code>180 </code></p>
     <p><code>181  KSize = ((DWORD)pInScan – KStart) / TSIZE;</code> </p>
     <p>Компилятор выводит следующие предупреждающие сообщения:</p>
     <p><code>SORTMM.C(176) : warning C4311: 'type cast' : pointer truncation from 'TCHAR __based(pInFile) *' to 'DWORD'</code></p>
     <p><code>SORTMM.C(181) : warning C4311: 'type cast' : pointer truncation from 'TCHAR __based(pInFile) *' to 'DWORD'</code></p>
     <p>Исправления сводятся к использованию DWORD_PTR в качестве типа данных в строке 40 и при приведении типов в строках 176 и 181.</p>
     <p>Дополнительные сообщения такого же характера появляются на шаге 2с в конце функции CreateIndexFile. На Web-сайте книги находится видоизмененный файл sortMM64.с, который пригоден как для Win32, так и для Win64, и использование которого позволяет избавиться от появления предупреждающих сообщений.</p>
    </section>
    <section>
     <title>
      <p><strong>Предупреждающие сообщения и необходимые изменения, </strong>касающиеся других программ</p>
     </title>
     <p>Во всех примерах проектов программ, размещенных на Web-сайте книги, опции установлены таким образом, чтобы в необходимых случаях компилятор выводил предупреждающие сообщения, касающиеся 64-битовых типов данных. Большинство программ компилировались без выдачи предупреждающих сообщений, так что никакие изменения для них не потребовались.</p>
     <p>В то же время, программа atouEX (программа 14.2) потребовала нескольких изменений, вызванных необходимостью использования типа данных DWORD_PTR для целочисленной переменной, хранящейся в поле hEvent структуры OVERLAPPED. Это обусловлено тем, что в Win64 размер данных типа HANDLE составляет 64 бита. Необходимые изменения отмечены в листинге программы, находящемся на Web-сайте.</p>
     <p>Некоторые предупреждения могут быть проигнорированы. Например, такие функции, как strlen(), возвращают значения типа size_t. Длина строки будет часто назначаться переменным типа DWORD, вызывая появление предупреждающих сообщений относительно "потери точности" ("loss of precision"). Во всех практических ситуациях на предупреждения такого рода можно не обращать внимания.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Резюме</p>
    </title>
    <section>
     <p>64-разрядный Windows API обеспечивает возможность выполнения на Windows-платформах, использующих 64-разрядные процессоры следующего поколения, большинства корпоративных, научных и инженерных приложений с высокими запросами к ресурсам. Предприняв всего лишь нескольких мер предосторожности, можно гарантировать выполнение программ как на платформе Win32, так и на платформе Win64. </p>
    </section>
    <section>
     <title>
      <p>Дополнительная литература</p>
     </title>
     <p>Наилучшими информационными источниками являются библиотеки MSDN и информация, размещенные на Web-сайте компании Microsoft. Ниже приведены некоторые рекомендованные ссылки, почерпнутые на Web-сайте компании Microsoft и из других источников.</p>
     <p>• Подготовленная специалистами компании Microsoft статья "New Data Types" доступна по адресу http://msdn.microsoft.com/library/default.asp?url=/library/en-us/win64/win64/the_new_data_types.asp. Таблицы 16.1 и 16.2 взяты именно из этой статьи.</p>
     <p>• "Introduction to Developing Applications for the 64-bit Version of Windows" — неплохое краткое введение в различные модели программирования. Эта статья доступна по адресу http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnnetserv/html/ws03-64-bitwindevover.asp. Статья содержит также краткий обзор архитектуры процессоров Itanium, хотя Itanium — не единственные процессоры, на которых может выполняться Win64.</p>
     <p>• Описание схемы UNIX "Aspen", подводящей прочный фундамент под модель LP64, доступно по адресу http://www.opengroup.org/public/tech/aspen/lp64_wp.htm.</p>
     <p>• В статье "Migration Tips", доступной по адресу http://msdn.microsoft.com/library/default.asp?url=/library/en-us/win64/win64/migration_tips.asp, вы найдете хорошие советы по переносу программ с 32-разрядных на 64-разрядные платформы, а также ряд полезных ссылок. Произведя поиск в Web, вы сможете найти дополнительную информацию и рекомендации.</p>
     <p>Если вас интересуют общие вопросы архитектуры компьютеров, обратитесь к книге [16], являющейся стандартом в этой области. Информация, касающаяся процессоров Itanium, приводится в [44].</p>
     <p>Обширная информация, касающаяся архитектур, основанных на 64-разрядном расширении, представлена на Web-сайтах компаний Intel и AMD:</p>
     <p>http://www.intel.com и http://www.amd.com/us-en</p>
    </section>
   </section>
   <section>
    <title>
     <p>Упражнения</p>
    </title>
    <p>16.1. Предположим, что p1 и р2 — указатели, связанные соотношением p1 &gt; р2, и вы хотите получить расстояние между двумя элементами, вычитая один указатель из другого. При каких условиях будет действительным выражение: (DWORD)p1 – (DWORD)р2? Следует ли заменить это выражение на (DWORD)(p1 – р2), если расстояние между элементами невелико? <emphasis>Подсказка.</emphasis> Примите во внимание свойства обеих комплементарных арифметик. </p>
    <p>16.2. Избавьтесь от выдачи компилятором предупреждающих сообщений относительно 64-битовых переменных, если таковые выводятся, в других программах, например, sortBT (программа 5.1) и ThreeStage (программа 10.5), в которых интенсивно используются указатели.</p>
    <p>16.3. Если у вас имеется доступ к системе Win64, протестируйте 64-разрядные программы. Убедитесь также, что компоновка программ в 32-разрядном режиме по-прежнему осуществляется корректно.</p>
   </section>
  </section>
  <section>
   <title>
    <p>ПРИЛОЖЕНИЕ А</p>
    <p>Использование примеров программ</p>
   </title>
   <section>
    <p>На Web-сайте книги (http://www.awprofessional.com/titles/0321256190) находится zip-архив, который содержит исходные тексты всех примеров программ, а также соответствующие заголовочные файлы, служебные функции, файлы проектов и исполняемые файлы. Ряд программ демонстрируют дополнительные возможности и предоставляют решения отдельных упражнений, однако на Web-сайте приведены решения не для всех упражнений и представлены не все из упоминающихся в книге альтернативных вариантов реализации программ.</p>
    <p>• Все программы тестировались под управлением Windows 2000, XP и Server 2003 на самых различных системах, от лэптопов до серверов. В необходимых случаях тестирование осуществлялось под управлением Windows 9x, хотя многие программы — особенно те, которые предлагаются на более поздних этапах изложения материала — под управлением Windows 9x и даже NT 4.0 выполняться не будут.</p>
    <p>• Сборка и выполнение программ осуществлялись как с включенными определениями UNICODE, так и без таковых. Под управлением Windows 9x будут работать лишь те программы, в которых возможность работы с символами в кодировке UNICODE не предусмотрена.</p>
    <p>• В подавляющем большинстве случаев компиляция программ в интегрированной среде разработки Microsoft Visual C++ версий 7.0 и 6.0 не будет сопровождаться выдачей предупреждающих сообщений, если для критерия серьезности ошибок (warning level), которые должны сопровождаться выводом диагностических сообщений компилятора, установлено значение 3. Однако существуют некоторые незначительные исключения, например, вывод сообщения "Отсутствует оператор return в основной программе" ("no return from main program") в случае использования функции ExitProcess.</p>
    <p>• Для проектов Microsoft Visual Studio .NET и Microsoft Visual Studio C++ 6.0 предусмотрены разные каталоги, каковыми являются каталоги Projects7 и Projects6. Соответствующие исполняемые файлы программ помещаются в каталоги run7 и run6.</p>
    <p>• В программах широко применяются функции обобщенной библиотеки С, а также такие специфические для используемых типов компиляторов ключевые слова, как __try, __except или __leave. Начиная с главы 7, важную роль в программах играют многопоточная библиотека С времени выполнения и функции _beginthreadex и _endthreadex.</p>
    <p>• Предоставляются как файлы проектов (в их окончательной (release), а не отладочной (debug) форме), так и make-файлы. Все проекты достаточно просты, характеризуются минимальным количеством зависимостей (dependencies) и их можно быстро создать заново в любой желаемой конфигурации с получением либо отладочной, либо окончательной версии.</p>
    <p>• Проекты для построения всех программ, за исключением статических и динамических библиотек, ориентированы на создание <emphasis>консольных</emphasis> приложений.</p>
    <p>Для сборки программ можно воспользоваться также такими инструментальными средствами, распространяемыми в рамках проекта программного обеспечения с открытым исходным кодом (GNU), как компиляторы gcc и g++, входящие в состав комплекта инструментов Gnu Compiler Collection (http://gcc.gnu.org/). Читатели, заинтересованные в подобных средствах разработки, должны ознакомиться с действующим на условиях GNU проектом MinGW (http://www.mingw.org), который описывается как "совокупность свободно доступных и свободно распространяемых заголовочных файлов и библиотек импорта, специфических для Windows, объединенных с наборами инструментов GNU, что позволяет создавать программы для среды Windows, не зависящие от динамических библиотек С времени выполнения, выпускаемых третьими сторонами". В то же время, при тестировании большинства примеров программ, приведенных в книге, я эти средства не применял, но весьма успешно использовал возможности MinGW, и мне даже удавалось выполнять межплатформенную сборку для создания исполняемых программ и DLL-библиотек Windows в Linux-системах. Более того, я имел возможность убедиться в чрезвычайно высокой эффективности систем диагностики ошибок и вывода предупреждающих сообщений компиляторов gcc и g++ при разработке 64-разрядных программ.</p>
   </section>
   <section>
    <title>
     <p>Структура каталогов</p>
    </title>
    <section>
     <p>Основной каталог носит название WindowsSmpEd3 (от <emphasis>Windows Sample Programs, Edition 3</emphasis>). Для каждой главы предусмотрен отдельный подкаталог. Все заголовочные файлы находятся в каталоге Include, а в каталоге Utilities содержатся такие часто используемые функции, как ReportError или PrintStrings. Готовые проекты помещены в каталоги Projects6 и Projects7 (для Visual C++ 6.0 и 7.0 соответственно). Исполняемые программы и библиотеки DLL для всех проектов хранятся в каталогах run6 и run7. В каталоге TimeTest содержатся файлы, которые требуются для тестирования производительности программ, описанного в приложении В. Прежде чем мы приступим к описанию содержимого отдельных подкаталогов WindowsSmpEd3, необходимо вкратце рассмотреть остальное содержимое Web-сайта.</p>
    </section>
    <section>
     <title>
      <p>Учебные пособия (слайды)</p>
     </title>
     <p>В каталоге Overheads содержатся слайды Power Point. Слайды включены для удобства преподавателей колледжей и университетов, которые захотят воспользоваться материалом книги в курсах своих лекций. Слайды не предназначены для коммерческого использования.</p>
    </section>
    <section>
     <title>
      <p>Каталог Utility</p>
     </title>
     <p>В каталог Utility включены семь файлов с исходными кодами служебных функций, которые требуются для примеров программ.</p>
     <p>1. Файл ReprtErr.с содержит функции ReportError (программа 2.2) и ReportException (программа 4.1). За исключением программ grep и wc, а также программ, приведенных в главе 1, каждая из программ, запускаемых на выполнение как процесс программами из примеров, нуждается в этом файле.</p>
     <p>2. Файл PrintMsg.c содержит функции PrintStrings, PrintMsg и ConsolePrint (программа 2.1). Так как эти функции вызываются функцией ReprtErr.с, то этот исходный файл также требуется почти во всех проектах.</p>
     <p>3. Файл Options.с содержит функцию, которая обрабатывает параметры командной строки и часто используется, начиная с главы 2. Включайте этот исходный файл в проект любой программы, в которой используются параметры командной строки. Соответствующий листинг приведен в программе А.7.</p>
     <p>4. Файл Wstrings.с содержит исходный код функции wmemchr, используемой в файле Options.с. Включайте этот файл в проекты в соответствии с необходимостью. Также не исключено, что вы захотите добавить и другие функции, предназначенные для работы с обобщенными строками.</p>
     <p>5. Файл SkipArg.с обеспечивает обработку командной строки путем пропуска одного поля аргумента при каждом вызове. Его листинг приведен в программе А.8.</p>
     <p>6. Файл GetArgs.с содержит функцию, которая преобразует строку символов к виду argc, argv[]. Эта функция полезна при разбиении командной строки на отдельные аргументы, как это делается, например, в случае командной строки, получаемой из функции GetCommandLine, введенной в главе 6. Листинг этого файла приведен в программе А.8.</p>
     <p>7. Файл Version.с реализует функцию DllGetVersion для библиотеки DLL, построенной из этих модулей.</p>
     <p>Перечисленные функции можно компилировать и компоновать вместе с вызывающими программами. Однако проще скомпоновать их отдельно в виде библиотеки, статической или динамической. В проекте Utility_3_0 эти файлы с исходными кодами используются для создания библиотеки DLL, а в проекте utulityStatic — для создания статической библиотеки.</p>
    </section>
    <section>
     <title>
      <p>Каталог Include</p>
     </title>
     <p>В каталоге Include описаны многочисленные файлы. Одни из них используются почти во всех примерах, другие нужны только для одной или двух программ. Перечень наиболее важных файлов приводится ниже.</p>
     <p>1. EvryThng.h, как говорит само его название, включает почти все определения, которые требуются для обычных программ, как однопоточных, так и многопоточных. В частности, он включает файлы Envirmnt.h и Support.h. Соответствующий листинг приведен в программе А.1.</p>
     <p>2.  Exclude.h содержит определения ряда переменных препроцессора, исключающих определения, которые не требуются ни одной из программ, представленных в данной книге. Эта мера позволяет ускорить компиляцию и уменьшить размер предварительно скомпилированных заголовочных файлов.</p>
     <p>3.  Envirmnt.h содержит согласованные определения переменных препроцессора UNICODE и _UNICODE, а также определения языка и подъязыка, используемые функцией ReportError. Листинг этого файла приведен в программе A.3.</p>
     <p>4. Support.h содержит определения многих общих функций, например, ReportError, а также ряд часто используемых символических констант. Соответствующий листинг представлен в программе A.3.</p>
     <p>5. ClntSrvr.h используется начиная с главы 11. В нем содержатся определения структур сообщений, используемых для запросов и ответов, а также определения именованных каналов сервера и клиента, почтовых ящиков, длительностей интервалов ожидания и т.п. См. программу А.5.</p>
     <p>6. JobMgt.h используется в программах управления задачами в конце главы 6. См. программу А.5.</p>
    </section>
    <section>
     <title>
      <p>Распределение программ по главам</p>
     </title>
     <p>В каталоге каждой главы содержатся все программы, относящиеся к данной главе (за исключением тех, которые были помещены в каталог Utility), а также всевозможные дополнительные программы. Соответствующий их перечень, сопровождаемый кратким описанием служебных программ, представлен ниже. В названиях некоторых программ присутствует суффикс "x"; в эти программы намеренно внесены дефекты, чтобы проиллюстрировать распространенные ошибки программирования.</p>
     <cite>
      <p><strong>Примечание</strong></p>
      <p>Имена многих программ, например, программ tail и touch, которые рассматривались в главе 7, совпадают с названиями утилит UNIX, работу которых они имитируют. Во избежание путаницы вы можете дать этим программам другие имена. Некоторые программы уже переименованы таким образом; в качестве примера можно указать программы lsW и cpW. </p>
     </cite>
     <subtitle><emphasis>Глава 1</emphasis></subtitle>
     <p>• срС.с — программа 1.1.</p>
     <p>•  cpW.c — программа 1.2; cpwFA.c — ее модифицированный вариант, обеспечивающий лучшую производительность. См. результаты в приложении В.</p>
     <p>• cpCF.с — программа 1.3.</p>
     <p>• К числу других программ относятся UNIX-версия этой программы (cpU.с), а также программа (cpUC.c), скомпонованная с использованием библиотеки совместимости UNIX, предоставляемой Visual C++. CpwFA.с — вариант Cpw.c, обеспечивающий повышенное быстродействие за счет использования буферов большого размера, флагов последовательного просмотра и других методик, введенных в главе 2.</p>
     <subtitle><emphasis>Глава 2</emphasis></subtitle>
     <p>• Программы 2.1 и 2.2 находятся в упомянутом ранее каталоге Utility.</p>
     <p>• cat.с — программа 2.3.</p>
     <p>• atou.с — программа 2.4.</p>
     <p>• Asc2Un.c — программа 2.5; Asc2UnFA.c и Asc2UnNB.c — ее версии, обеспечивающие лучшую производительность. Все три файла реализуют функцию Asc2Un, которая вызывается программой 2.5.</p>
     <p>• pwd.c — программа 2.6; pwda.c — модифицированный вариант, обеспечивающий выделение необходимого объема памяти для размещения пути доступа.</p>
     <p>• cd.c — реализация команды UNIX, осуществляющей переход к другому каталогу; эта программа не совпадает с той, которая используется в главе 2.</p>
     <subtitle><emphasis>Глава 3</emphasis></subtitle>
     <p>• RandomAccess.с — программа 3.1.</p>
     <p>• lsW.c — программа 3.2. rmW.c — аналогичная программа, предназначенная для удаления файлов.</p>
     <p>• touch.с — программа 3.3.</p>
     <p>• getn.c — дополнительная программа для чтения записей фиксированной длины, иллюстрирующая доступ к файлам и вычисление позиции в файле.</p>
     <p>• lsReg.с — программа 3.4.</p>
     <p>• FileSize.с — приведенное в учебных целях решение, позволяющее определить, является ли выделенное для файла пространство разреженным.</p>
     <p>• TestLock.с — осуществляет блокирование файла.</p>
     <p>• tail.с — требуется как часть упражнения 3.3. </p>
     <subtitle><emphasis>Глава 4</emphasis></subtitle>
     <p>• Программа 4.1 включена в файл ReprtErr.c, находящийся в каталоге Utulity.</p>
     <p>• toupper.c — программа 4.2. toupperX.c содержит преднамеренно внесенные ошибки; их устранение послужит для вас хорошим упражнением.</p>
     <p>• Exception.с — программа 4.3, а также функция фильтра — программа 4.4.</p>
     <p>• Ctrlc.с — программа 4.5.</p>
     <subtitle><emphasis>Глава 5</emphasis></subtitle>
     <p>• sortBT.c — представляет программы 5.1 и 5.2; sortBTSR.c — вариант, в котором отсутствует опция отказа от сериализации при вызове функций управления памятью, что используется для выяснения влияния этого фактора на производительность в случае простых приложений. Читатель может самостоятельно убедиться в том, что наблюдаемый эффект является весьма незначительным.</p>
     <p>• Asc2UnMM.с — функция для программы 5.3.</p>
     <p>• sortFL.с — программа 5.4, a sortHP.с — аналогичная программа, за исключением того, что вместо отображения файлов используется их считывание в буфер, выделяемый в памяти.</p>
     <p>• sortMM.с — программы 5.5 и 5.6.</p>
     <p>• atouEL.c — программа 5.7, a Asc2UnDll.c и Asc2UnmmDLL.c — исходные файлы для требуемых библиотек DLL. Asc2Unmmfl.c — еще один вариант, очищающий память при завершении выполнения, что может приводить к общему замедлению программы, но оставляет систему в безопасном состоянии.</p>
     <p>• HeapNoSr.c — тестовая программа для количественной оценки эффекта использования флага HEAP_NO_SERIALIZE при распределении памяти. Эту программу можно использовать при выполнении упражнения 5.1.</p>
     <p>• RandFile.c — генерирует текстовые файлы заданного размера со случайными ключами; такие файлы удобны для тестирования функций сортировки и используются для генерирования текстовых файлов большого размера во многих тестах с целью определения временных характеристик выполнения программ.</p>
     <p>• clear.с — простая программа, выделяющая и инициализирующая память крупными блоками до наступления сбоя. Эта программа используется в перерывах между тестами синхронизации для гарантии того, что данные не кэшируются в памяти, ибо это могло бы искажать результаты тестов. </p>
     <subtitle><emphasis>Глава 6</emphasis></subtitle>
     <p>• grepMP.c — программа 6.1. grep.с — исходный файл программы поиска заданных символьных шаблонов, которая вызывается как процесс программой grepMP.c.</p>
     <p>• timep.с — программа 6.2.</p>
     <p>• JobShell.c — программа 6.3, a JobMgt.c предоставляет функции поддержки программ 6.4, 6.5 и 6.6.</p>
     <p>• catHA.c и grepMPha.c — модифицированные версии других программ, предназначенных для демонстрации передачи дескриптора в командной строке, что используется при решении упражнения 6.2.</p>
     <p>• version.с — получает сведения об операционной системе, включая номер ее версии.</p>
     <subtitle><emphasis>Глава 7</emphasis></subtitle>
     <p>• grepMT.c — программа 7.1. grepMTx.c — ее вариант с преднамеренно введенными дефектами; устранение этих дефектов предлагается в упражнении 7.7.</p>
     <p>• sortMT.c — программа 7.2. sortMTx.c — ее вариант с преднамеренно введенными дефектами.</p>
     <p>• wcMT.с — решение упражнения 7.6. Имеются также две версии с преднамеренно введенными дефектами и еще одна версия, сериализующая обработку файла, которая предусмотрена для анализа временных характеристик выполнения программ.</p>
     <p>• Во всех соответствующих проектах используется библиотека С с многопоточной поддержкой, о чем говорится в тексте главы.</p>
     <subtitle><emphasis>Глава 8</emphasis></subtitle>
     <p>• simplePC.с — программа 8.1.</p>
     <p>• eventPC.с — программа 8.2.</p>
     <subtitle><emphasis>Глава 9</emphasis></subtitle>
     <p>• statsMX.c — программа 9.1. Ее различными вариантами являются statsNS.c, statsCS.cn statsIN.c.</p>
     <p>• TimedMutualExclusion.c — используется для исследования временных характеристик, предлагаемого в тексте главы и упражнениях. </p>
     <subtitle><emphasis>Глава 10</emphasis></subtitle>
     <p>• В программе 10.1 содержится часть файла SynchObj.h, находящегося в каталоге Include. Остальная часть указанного файла содержится в программе 10.3.</p>
     <p>• ThbObject.c — программа 10.2. testTHB — соответствующая тестовая программа.</p>
     <p>• QueueObj.с — программа 10.4, различными вариантами которой являются программы QueueObjCS.c (используется объект CRITICAL_SECTION), QueueObjSOAW.c (используется функция SignalObjectAndWait) и версия, использующая сигнальную модель.</p>
     <p>• ThreeStage.c — программа 10.5, для проекта которой требуются файлы Messages.с и QueueObj.c.</p>
     <p>• QueueObjCancel.с — программа 10.6, которая работает в сочетании с программой ThreeStageCancel.c.</p>
     <p>• MultiSem.c — вместе с тестовой программой TestMultiSem.c образует решение упражнения 10.11.</p>
     <p>• MultiPCav.c — использует Pthreads; будет очень неплохо, если в качестве упражнения вы попытаетесь преобразовать эту программу к форме, использующей Windows API или библиотеку Pthreads с открытым исходным кодом.</p>
     <subtitle><emphasis>Глава 11</emphasis></subtitle>
     <p>• pipe.с — программа 11.1. Для демонстрации работы этой программы удобно использовать команду wc.с. pipeNP.с — вариант, использующий именованный канал.</p>
     <p>• clientNP.с — программа 11.2.</p>
     <p>• serverNP.с — программа 11.3.</p>
     <p>• SrvrBcst.c — программа 11.4.</p>
     <p>• LocSrver.с — программа 11.5.</p>
     <subtitle><emphasis>Глава 12</emphasis></subtitle>
     <p>• clientSK.с — программа 12.1.</p>
     <p>• serverSK.c — программа 12.2.</p>
     <p>• command. с — программа 12.3.</p>
     <p>• SendReceiveSKST.c — программа 12.4, a serverSKST.c и clientSKST.c — соответствующие варианты программ serverSK.c и clientSK.с, незначительно модифицированных для обеспечения потокового ввода/вывода. Программу SendReceiveSKST.c следует компоновать как библиотеку DLL, которая должна неявно связываться с проектами сервера и клиента.</p>
     <p>• SendReceiveSKHA.c — программа 12.5, a serverSKHA.c — соответствующий сервер, который использует DLL. Программа clientSKST.c будет работать с этим сервером.</p>
     <subtitle><emphasis>Глава 13</emphasis></subtitle>
     <p>• SimpleService.c — программа 13.2; дополнительно включает все, что требуется для программы 13.1.</p>
     <p>• ServiceShell.с — программа 13.3.</p>
     <p>• ServiceSK.с — это программа serverSK (программа 12.2), преобразованная в службу.</p>
     <subtitle><emphasis>Глава 14</emphasis></subtitle>
     <p>• atouOV. с — программа 14.1.</p>
     <p>• atouEX.c — программа 14.2, выполняющая ту же задачу с использованием расширенного ввода/вывода.</p>
     <p>• atouMT.с — выполняет ту же задачу с использованием многопоточного режима вместо асинхронного ввода/вывода Win32. atouMT_dh.с — неправильная версия, включенная для иллюстрации одной интересной, хотя и сопряженной с определенными рисками возможности дублирования дескрипторов.</p>
     <p>• atouMTCP.с — использует порты завершения ввода/вывода.</p>
     <p>• TimeBeep.с — программа 14.3.</p>
     <p>• serverCP.c — программа 14.4, представляющая собой версию программы serverMT, в которой используются порты завершения ввода/вывода и перекрывающийся ввод/вывод.</p>
     <subtitle><emphasis>Глава 15</emphasis></subtitle>
     <p>• chmodW.с — программа 15.1, в которую добавлены возможности различения элементов АСЕ, предоставляющих и отменяющих разрешения доступа (как описано в тексте). chmodBSD.c — видоизмененный вариант программы, в котором используется функция BuildSecurityDescriptor.</p>
     <p>• lsFP.с — программа 15.2.</p>
     <p>• InitUnFp.c — код для программ 15.3, 15.4 и 15.5. Эти функции нужны программам 15.1 и 15.2. Кроме того, в исходном модуле содержится код, показывающий, как получить имя группы-владельца, что вам предлагается самостоятельно сделать в упражнении 15.12. </p>
     <p>• TestFp.c — дополнительная тестовая программа, которая оказалась полезной в процессе тестирования.</p>
     <p>• serverNP_secure.с — программа 15.6.</p>
     <p>• JobShell_secure.c и JobMgt_secure.с — усовершенствованные варианты программ для системы управления заданиями, которая рассматривается в главе 6.</p>
     <subtitle><emphasis>Глава 16</emphasis></subtitle>
     <p>Для этой главы предусмотрен только один файл с исходным кодом, а именно, sortMM64.c, который представляет собой программу sortMM.c из главы 5, усовершенствованную таким образом, чтобы она могла выполняться на обеих платформах Win32 и Win64.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Листинги включаемых файлов</p>
    </title>
    <subtitle>EvryThng.h</subtitle>
    <subtitle>Программа А.1. Заголовочный файл EvryThng.h </subtitle>
    <p><code>/* EvryThng.h – Включает все стандартные и пользовательские */ </code></p>
    <p><code>/* заголовочные файлы. */ </code></p>
    <p><code>#include "Exclude.h" /* Исключает описания, которые не требуются для примеров программ.*/ </code></p>
    <p><code>#include "envirmnt.h" </code></p>
    <p><code>#include &lt;windows.h&gt; </code></p>
    <p><code>#include &lt;tchar.h&gt; </code></p>
    <p><code>#include &lt;stdio.h&gt; </code></p>
    <p><code>#include &lt;io.h&gt; </code></p>
    <p><code>#include "support.h" </code></p>
    <p><code>#ifdef _MT</code></p>
    <p><code>#include &lt;process.h&gt; </code></p>
    <p><code>/* DWORD_PTR (целое без знака, соответствующее точности указателя)</code></p>
    <p><code> * используется для целых чисел, преобразуемых в дескрипторы или указатели.</code></p>
    <p><code> * Благодаря этому в Win64 не будут выводиться предупреждающие сообщения,</code></p>
    <p><code> * касающиеся взаимных преобразований 32-битовых и 64-битовых данных,</code></p>
    <p><code> * поскольку в Win64 дескрипторы HANDLE и указатели являются 64-битовыми</code></p>
    <p><code> * (см. главу 16). Этот режим активизируется только в том случае,</code></p>
    <p><code> * если определена символическая константа _Wp64.</code></p>
    <p><code> */</code></p>
    <p><code>#if !defined(_Wp64) </code></p>
    <p><code>#define DWORD_PTR DWORD </code></p>
    <p><code>#define LONG_PTR LONG </code></p>
    <p><code>#define INT_PTR INT </code></p>
    <p><code>#endif </code></p>
    <subtitle>Envirmnt.h</subtitle>
    <subtitle>Программа А.2. Включаемый файл Envirmnt.h </subtitle>
    <p><code>/* Envirmnt.h — Здесь определяются константы UNICODE и _МТ. */</code></p>
    <p><code>/* Лучше и проще определить константу UNICODE в проекте. */</code></p>
    <p><code>/* Используйте команды меню: Project…Settings…C/C++. Затем, перейдя */</code></p>
    <p><code>/* в окно Project Options, добавьте в нижней части: /D "UNICODE". */</code></p>
    <p><code>/* Проделайте то же самое для констант _МТ и _STATIC_LIB. */</code></p>
    <empty-line/>
    <p><code>//#define UNICODE </code></p>
    <p><code>#undef UNICODE </code></p>
    <p><code>#ifdef UNICODE </code></p>
    <p><code>#define _UNICODE </code></p>
    <p><code>#endif</code></p>
    <p><code>#ifndef UNICODE </code></p>
    <p><code>#undef _UNICODE </code></p>
    <p><code>#endif</code></p>
    <p><code>//#define _STATICLIB</code></p>
    <p><code>/* Определите _STATICLIB, если создаете */</code></p>
    <p><code>/* или компонуете статическую библиотеку. */ </code></p>
    <p><code>#define LANG_DFLT LANG_ENGLISH </code></p>
    <p><code>#define SUBLANG_DFLT SUBLANG_ENGLISH_US</code></p>
    <subtitle>Support.h</subtitle>
    <subtitle>Программа А.З. Включаемый файл Support.h </subtitle>
    <p><code>/* Support.h */</code></p>
    <p><code>/* Содержит определения всех символических констант и распространенных служебных функций, используемых в примерах программ. */</code></p>
    <p><code>/* НЕСМОТРЯ НА ВКЛЮЧЕНИЕ ОПИСАНИЙ КОНСТАНТ UTILITY_EXPORTS И _STATICLIB, ИХ ЛУЧШЕ ОПРЕДЕЛЯТЬ НЕ ЗДЕСЬ, А В ПРОЕКТЕ. */ </code></p>
    <p><code>/* Имя "UTILITY_EXPORTS" генерируется средой разработки Visual Studio, если вы создаете проект DLL с именем "Utility", но его также можно определить в командной строке С. */</code></p>
    <p><code>// UTILITY_3_0_EXPORTS определяется в проекте UTILITY_3_0.</code></p>
    <p><code>#if defined(UTILITY_3_0_EXPORTS) </code></p>
    <p><code>#define LIBSPEC _declspec(dllexport)</code></p>
    <p><code>#elif defined(__cplusplus)</code></p>
    <p><code>#define LIBSPEC extern "C" _declspec(dllimport)</code></p>
    <p><code>#else</code></p>
    <p><code>#define LIBSPEC _declspec(dllimport)</code></p>
    <p><code>#endif</code></p>
    <empty-line/>
    <p><code>#define EMPTY _T("") </code></p>
    <p><code>#define YES _T("y") </code></p>
    <p><code>#define NO _T("n") </code></p>
    <p><code>#define CR 0x0D </code></p>
    <p><code>#define LF 0x0A</code></p>
    <p><code>#define TSIZE sizeof(TCHAR)</code></p>
    <empty-line/>
    <p><code>/* Предельные значения и константы. */</code></p>
    <p><code>#define TYPE_FILE 1 /* Используется в ls, rm, и lsFP. */</code></p>
    <p><code>#define TYPE_DIR 2</code></p>
    <p><code>#define TYPE_DOT 3</code></p>
    <p><code>#define MAX_OPTIONS 20 /* Максимальное количество параметров командной строки.*/ </code></p>
    <p><code>#define MAX_ARG 1000 /* Максимальное количество аргументов командной строки.*/ </code></p>
    <p><code>#define MAX_COMMAND_LINE MAX_PATH+50 /*Максимальный размер командной строки*/</code></p>
    <empty-line/>
    <p><code>/* Часто используемые функции. */</code></p>
    <p><code>LIBSPEC BOOL ConsolePrompt(LPCTSTR, LPTSTR, DWORD, BOOL);</code></p>
    <p><code>LIBSPEC BOOL PrintStrings(HANDLE, ...);</code></p>
    <p><code>LIBSPEC BOOL PrintMsg(HANDLE, LPCTSTR);</code></p>
    <p><code>LIBSPEC VOID ReportError(LPCTSTR, DWORD, BOOL);</code></p>
    <p><code>LIBSPEC VOID ReportException(LPCTSTR, DWORD);</code></p>
    <p><code>LIBSPEC DWORD Options(int, LPCTSTR *, LPCTSTR, ...);</code></p>
    <p><code>LIBSPEC LPTSTR SkipArg(LPCTSTR);</code></p>
    <p><code>LIBSPEC VOID GetArgs(LPCTSTR, int *, LPTSTR *);</code></p>
    <empty-line/>
    <p><code>/* Набор функций для работы с обобщенными строками в стиле string.h. Создавались по мере необходимости – первоначально была только одна функция! Реализация взята из [27]. */</code></p>
    <p><code>LIBSPEC LPCTSTR wmemchr(LPCTSTR, TCHAR, DWORD);</code></p>
    <empty-line/>
    <p><code>#ifdef _UNICODE /* Это объявление уже должно было быть добавлено. */</code></p>
    <p><code>#define _tstrrchr wcsrchr</code></p>
    <p><code>#else</code></p>
    <p><code>#define _tstrrchr strrchr</code></p>
    <p><code>#endif</code></p>
    <empty-line/>
    <p><code>#ifdef _UNICODE /* Это объявление уже должно было быть добавлено. */</code></p>
    <p><code>#define _memtchr wmemchr</code></p>
    <p><code>#else</code></p>
    <p><code>#define _memtchr memchr</code></p>
    <p><code>#endif</code></p>
    <empty-line/>
    <p><code>/* Функции безопасности. */</code></p>
    <p><code>LPSECURITY_ATTRIBUTES InitializeUnixSA(DWORD, LPTSTR, LPTSTR, LPDWORD, LPHANDLE);</code></p>
    <p><code>LPSECURITY_ATTRIBUTES InitializeAccessOnlySA(DWORD, LPTSTR, LPTSTR, LPDWORD, LPHANDLE);</code></p>
    <p><code>DWORD ReadFilePermissions(LPTSTR, LPTSTR, LPTSTR);</code></p>
    <p><code>BOOL ChangeFilePermissions(DWORD, LPTSTR, LPDWORD, LPDWORD);</code></p>
    <p><code>/* В упрощенной форме доступны в Visual C++ Version 5.0. */</code></p>
    <p><code>//PSECURITY_DESCRIPTOR InitializeSD(DWORD, LPTSTR, LPTSTR, LPDWORD);</code></p>
    <empty-line/>
    <p><code>/* Константы, которые требуются для функций безопасности. */</code></p>
    <p><code>#define LUSIZE 1024</code></p>
    <p><code>#define ACCT_NAME_SIZE LUSIZE</code> </p>
    <subtitle>JobMgt.h</subtitle>
    <subtitle>Программа А.4. Включаемый файл JobMgt.h </subtitle>
    <p><code>/* JobMgt.h — Определения, необходимые для управления задачами. Глава 6. */ </code></p>
    <p><code>/* Код выхода для программы управления задачами в случае прекращения их выполнения. */</code></p>
    <empty-line/>
    <p><code>#define JM_EXIT_CODE 0x1000</code></p>
    <empty-line/>
    <p><code>typedef struct _JM_JOB {</code></p>
    <p><code> DWORD ProcessId;</code></p>
    <p><code> TCHAR CommandLine[MAX_PATH]; </code></p>
    <p><code>} JM_JOB; </code></p>
    <p><code>#define SJM_JOB sizeof (JM_JOB)</code></p>
    <empty-line/>
    <p><code>/* Функции управления задачами. */</code></p>
    <p><code>DWORD GetJobNumber(PROCESS_INFORMATION *, LPCTSTR);</code></p>
    <p><code>BOOL DisplayJobs(void);</code></p>
    <p><code>DWORD FindProcessId(DWORD);</code></p>
    <p><code>BOOL GetJobMgtFileName(LPTSTR);</code> </p>
    <subtitle>ClntSrvr.h</subtitle>
    <subtitle>Программа А.5. Включаемый файл ClntSrvr.h </subtitle>
    <p><code>/* Определения для программ, обеспечивающих клиент-серверное взаимодействие*/ </code></p>
    <p><code>/* Сообщения запроса и ответа. Сообщения имеют кодировку ASCII, поскольку запрос может поступать от системы Windows 95. */</code></p>
    <p><code>#define MAX_RQRS_LEN 0x1000</code></p>
    <empty-line/>
    <p><code>typedef struct {</code></p>
    <p><code> DWORD32 RqLen; /* Размер структуры запроса, исключая размер этого поля. */</code></p>
    <p><code> CHAR Command;</code></p>
    <p><code> BYTE Record[MAX_RQRS_LEN]; </code></p>
    <p><code>} REQUEST;</code></p>
    <empty-line/>
    <p><code>typedef struct {</code></p>
    <p><code> DWORD32 RsLen; /* Размер структуры ответа, исключая размер этого поля*/</code></p>
    <p><code> CHAR Status;</code></p>
    <p><code> BYTE Record[MAX_RQRS_LEN]; </code></p>
    <p><code>} RESPONSE;</code></p>
    <empty-line/>
    <p><code>#define RQ_SIZE sizeof(REQUEST)</code></p>
    <p><code>#define RQ_HEADER_LEN RQ_SIZE-MAX_RQRS_LEN</code></p>
    <p><code>#define RS_SIZE sizeof(RESPONSE)</code></p>
    <p><code>#define RS_HEADER_LEN RS_SIZE-MAX_RQRS_LEN</code></p>
    <empty-line/>
    <p><code>/* Структура почтового сообщения. */ </code></p>
    <p><code>typedef struct {</code></p>
    <p><code> DWORD msStatus; </code></p>
    <p><code> DWORD msUtilization;</code></p>
    <p><code> TCHAR msName[MAX_PATH]; </code></p>
    <p><code>} MS_MESSAGE;</code></p>
    <empty-line/>
    <p><code>#define MSM_SIZE sizeof(MS_MESSAGE)</code></p>
    <p><code>#define CS_TIMEOUT 5000 /* Интервал ожидания для взаимодействия через именованный канал и мониторинга производительности. */</code></p>
    <p><code>#define MAXCLIENTS 10 </code></p>
    <p><code>#define MAX_SERVER_TH 4 /* Максимальное количество серверных потоков для программы serverNPCP.*/</code></p>
    <p><code>#define MAX_CLIENTS_CP 16 /* Максимальное количество клиентов для программы serverNPCP.*/</code></p>
    <empty-line/>
    <p><code>/* Имена серверных и клиентских каналов и почтовых ящиков. */</code></p>
    <p><code>#define SERVER_PIPE _Т("\\\\.\\PIPE\\SERVER")</code></p>
    <p><code>#define CLIENT_PIPE _T("\\\\.\\PIPE\\SERVER")</code></p>
    <p><code>#define SERVERBROADCAST _T("SrvrBcst.exe")</code></p>
    <p><code>#define MS_SRVNAME _T("\\\\.\\MAILSLOT\\CLS_MAILSLOT")</code></p>
    <p><code>#define MS_CLTNAME _T("\\\\.\\MAILSLOT\\CLS_MAILSLOT")</code></p>
    <p><code>#define MX_NAME _T("ClientServerMutex")</code></p>
    <p><code>#define SM_NAME _T("ClientServerSemaphore")</code></p>
    <empty-line/>
    <p><code>/* Команды для функции поддержки статистики. */</code></p>
    <p><code>#define CS_INIT 1</code></p>
    <p><code>#define CS_RQSTART 2</code></p>
    <p><code>#define CS_RQCOMPLETE 3</code></p>
    <p><code>#define CS_REPORT 4</code></p>
    <p><code>#define CS_TERMTHD 5</code></p>
    <empty-line/>
    <p><code>/* Функции поддержки клиент-серверной системы. */ </code></p>
    <p><code>BOOL LocateServer(LPTSTR); </code></p>
    <subtitle>Exclude.h</subtitle>
    <p>В программе А.6 определяются многочисленные переменные, позволяющие исключить определения, которые не требуются для примеров программ, приведенных в данной книге. Этот вопрос подробно обсуждается в [30].</p>
    <subtitle>Программа А.6. Включаемый файл Exclude.h</subtitle>
    <p><code>/* Exclude.h — Определения переменных для исключения ненужных заголовочных файлов. За дополнительными разъяснениями обратитесь в [30]. */</code></p>
    <p><code>#define WIN32_LEAN_AND_MEAN</code></p>
    <p><code>/* Весьма эффективная мера, уменьшающая размер предварительно скомпилированного заголовочного файла (pch) почти в два раза. */</code></p>
    <p><code>/* Эти определения также уменьшают размер pch-файла и уменьшают время компиляции. Все программы в данной книге будут компилироваться с этими определениями. От использования средств защиты можно отказаться при помощи оператора #define NOSECURITY. */ </code></p>
    <p><code>#define NOATOM </code></p>
    <p><code>#define NOCLIPBOARD </code></p>
    <p><code>#define NOCOMM </code></p>
    <p><code>#define NOCTLMGR </code></p>
    <p><code>#define NOCOLOR </code></p>
    <p><code>#define NODEFERWINDOWPOS </code></p>
    <p><code>#define NODESKTOP </code></p>
    <p><code>#define NODRAWTEXT </code></p>
    <p><code>#define NOEXTAPI </code></p>
    <p><code>#define NOGDICAPMASKS </code></p>
    <p><code>#define NOHELP </code></p>
    <p><code>#define NOICONS </code></p>
    <p><code>#define NOTIME </code></p>
    <p><code>#define NOIMM </code></p>
    <p><code>#define NOKANJI </code></p>
    <p><code>#define NOKERNEL </code></p>
    <p><code>#define NOKEYSTATES </code></p>
    <p><code>#define NOMCX </code></p>
    <p><code>#define NOMEMMGR </code></p>
    <p><code>#define NOMENUS </code></p>
    <p><code>#define NOMETAFILE </code></p>
    <p><code>#define NOMSG </code></p>
    <p><code>#define NONCMESSAGES </code></p>
    <p><code>#define NOPROFILER </code></p>
    <p><code>#define NORASTEROPS </code></p>
    <p><code>#define NORESOURCE </code></p>
    <p><code>#define NOSCROLL </code></p>
    <p><code>#define NOSERVICE </code></p>
    <p><code>#define NOSHOWWINDOW </code></p>
    <p><code>#define NOSOUND </code></p>
    <p><code>#define NOSYSCOMMANDS </code></p>
    <p><code>#define NOSYSMETRICS </code></p>
    <p><code>#define NOSYSPARAMS </code></p>
    <p><code>#define NOTEXTMETRIC </code></p>
    <p><code>#define NOVIRTUALKEYCODES </code></p>
    <p><code>#define NOWH </code></p>
    <p><code>#define NOWINDOWSTATION </code></p>
    <p><code>#define NOWINMESSAGES </code></p>
    <p><code>#define NOWINOFFSETS </code></p>
    <p><code>#define NOWIMSTYLES </code></p>
    <p><code>#define OEMRESOURCE</code> </p>
   </section>
   <section>
    <title>
     <p>Дополнительные служебные программы</p>
    </title>
    <p>Имеются три дополнительных программы, а именно, Options, SkipArg и GetArgs, которые достаточно полезны, чтобы привести здесь их листинги. В то же время, ни одна из этих программ не привязана жестко к Win32. </p>
    <subtitle>Options.с</subtitle>
    <p>Эта функция просматривает командную строку в поиске слов, начинающихся с символа "-" (дефис), проверяет отдельные символы и устанавливает булевские параметры. Хотя эта функция и аналогична UNIX-функции getopt, она обладает меньшими возможностями.</p>
    <subtitle>Программа А.7. Функция Options </subtitle>
    <p><code>/* Служебная функция для извлечения флагов опций из командной строки. */</code></p>
    <p><code>#include "EvryThng.h"</code></p>
    <p><code>#include &lt;stdarg.h&gt;</code></p>
    <empty-line/>
    <p><code>DWORD Options(int argc, LPCTSTR argv[], LPCTSTR OptStr, ...)</code></p>
    <p><code>/* argv — командная строка. Параметры (опции), если они нужны, начинаются с символа '-' в argv[1], argv[2], ….</code></p>
    <p><code>OptStr — текстовая строка, содержащая все возможные параметры, находящиеся во взаимно-однозначном соответствии с адресами булевских переменных в списке аргументов (...). Эти флаги устанавливаются тогда и только тогда, когда символ соответствующей опции встречается в argv[1], argv[2], …Возвращаемым значением является индекс (в argv) первого аргумента, указанного вслед за опциями. */</code></p>
    <p><code>{</code></p>
    <p><code> va_list pFlagList;</code></p>
    <p><code> LPBOOL pFlag;</code></p>
    <p><code> int iFlag = 0, iArg;</code></p>
    <p><code> va_start(pFlagList, OptStr);</code></p>
    <p><code> while ((pFlag = va_arg(pFlagList, LPBOOL)) != NULL &amp;&amp; iFlag &lt; (int)_tcslen(OptStr)) {</code></p>
    <p><code>  *pFlag = FALSE;</code></p>
    <p><code>  for (iArg = 1; !(*pFlag) &amp;&amp; iArg &lt; argc &amp;&amp; argv[iArg][0] == '-'; iArg++) *pFlag = _memtchr(argv[iArg], OptStr[iFlag], _tcslen(argv[iArg])) != NULL;</code></p>
    <p><code>  iFlag++;</code></p>
    <p><code> }</code></p>
    <p><code> va_end(pFlagList);</code></p>
    <p><code> for (iArg = 1; iArg &lt; argc &amp;&amp; argv[iArg][0] == '-'; iArg++);</code></p>
    <p><code> return iArg; </code></p>
    <p><code>}</code> </p>
    <subtitle>SkipArg.с</subtitle>
    <p>Эта функция обрабатывает командную строку, пропуская одно поле, отделенное пробельным символом. Впервые используется в программе timep (программа 6.2).</p>
    <subtitle>Программа А.8. Функция SkipArg </subtitle>
    <p><code>/* SkipArg.с</code></p>
    <p><code>   Пропуск одного аргумента командной строки – символы табуляции и пробела пропускаются. */ </code></p>
    <p><code>#include "EvryThng.h"</code></p>
    <empty-line/>
    <p><code>LPTSTR SkipArg(LPCTSTR targv) {</code></p>
    <p><code> LPTSTR p;</code></p>
    <p><code> p = (LPTSTR)targv;</code></p>
    <p><code> /* Перейти к следующему символу табуляции или пробела. */</code></p>
    <p><code> while (*р != '\0' &amp;&amp; *р != TSPACE &amp;&amp; *р != TAB) p++;</code></p>
    <p><code> /* Пропустить символы табуляции и пробела и перейти к следующему аргументу. */</code></p>
    <p><code> while (*р != '\0' &amp;&amp; (*р == TSPACE || *р == TAB)) p++;</code></p>
    <p><code> return р; </code></p>
    <p><code>}</code> </p>
    <subtitle>GetArgs.с</subtitle>
    <p>Эта функция просматривает строку, отыскивая слова, разделенные символами пробелов или табуляции, и помещает результат в массив строк, передаваемый функции. Эта функция может пригодиться для преобразования командной строки в массив argv[] и впервые используется в программе JobShell в главе 6. Функция Win32 CommandLineToArgW решает ту же задачу, но сфера ее применимости ограничивается символами Unicode.</p>
    <subtitle>Программа А.9. Функция GetArgs </subtitle>
    <p><code>/* GetArgs. Преобразует командную строку к виду argc/argv. */</code></p>
    <p><code>#include "EvryThng.h"</code></p>
    <empty-line/>
    <p><code>VOID GetArgs(LPCTSTR Command, int *pArgc, LPTSTR argstr[]) {</code></p>
    <p><code> int i, icm = 0;</code></p>
    <p><code> DWORD ic = 0;</code></p>
    <p><code> for (i = 0; ic &lt; _tcslen(Command); i++) {</code></p>
    <p><code>  while (ic &lt; _tcslen(Command) &amp;&amp; Command[ic] != TSPACE &amp;&amp; Command [ic] != TAB) {</code></p>
    <p><code>   argstr[i][icm] = Command[ic];</code></p>
    <p><code>   ic++;</code></p>
    <p><code>   icm++;</code></p>
    <p><code>  }</code></p>
    <p><code>  argstr[i][icm] = '\0';</code></p>
    <p><code>  while (ic &lt; _tcslen(Command) &amp;&amp; (Command[ic] == TSPACE || Command[ic] == TAB)) ic++;</code></p>
    <p><code>  icm = 0;</code></p>
    <p><code> }</code></p>
    <p><code> if (pArgc != NULL) *pArgc = i;</code></p>
    <p><code> return; </code></p>
    <p><code>}</code> </p>
   </section>
  </section>
  <section>
   <title>
    <p>ПРИЛОЖЕНИЕ Б</p>
    <p>Сопоставление функций Windows, UNIX и библиотеки С</p>
   </title>
   <p>В этом приложении приводятся таблицы, в которых представлены функции Windows (Win32 и Win64), описанные в основном тексте, а также сопоставимые с ними функции UNIX/Linux<a l:href="#n_36" type="note">[36]</a> и стандартной библиотеки ANSI С, если таковые имеются.</p>
   <p>Таблицы расположены в порядке следования глав (некоторые таблицы объединяют данные, относящиеся к нескольким главам). В пределах каждой главы данные в таблицах отсортированы сначала в соответствии с их функциональным назначением (файловая система, управление каталогами и так далее), а затем по именам функций Windows.</p>
   <p>В каждой из строк таблицы представлена следующая информация:</p>
   <p>• Функциональная область (категория).</p>
   <p>• Имя функции Windows.</p>
   <p>• Имя соответствующей функции UNIX. В некоторых случаях существует несколько таких функций.</p>
   <p>• Имя соответствующей функции библиотеки С, если таковая имеется.</p>
   <p>Используемые в таблицах обозначения нуждаются в некоторых пояснениях.</p>
   <p>• В библиотеке функций Microsoft Visual C++ содержатся некоторые функции, совместимые с UNIX. Так, функция _open является функцией библиотеки совместимости, эквивалентной UNIX-функции open. Выделение имени функции UNIX курсивом означает, что эта функция является совместимой. Символ звездочки в конце имени функции указывает на существование версии функции, ориентированной на работу с расширенными символами UNICODE. Так, существует функция _wopen.</p>
   <p>• Программа, в которой используются только функции стандартной библиотеки С и отсутствуют вызовы функций Windows или UNIX, должны компилироваться, компоноваться и выполняться в обеих системах. В то же время, возможности такой программы в отношении работы с файлами и выполнения операций ввода/вывода будут ограниченными.</p>
   <p>• Функция, следующая за разделительной запятой, является альтернативной версией, часто использующей другие характеристики или эмулирующей какой-то один из аспектов функции Windows.</p>
   <p>• Разделение функций символом точки с запятой указывает на то, что эмуляция функции Windows достигается за счет последовательного использования этих функций. Так, функции CreateProcess соответствуют функции fork; exec.</p>
   <p>• Подчеркивание имени элемента указывает на глобальную переменную, например errno.</p>
   <p>• В некоторых случаях UNIX-эквивалент указывается в обобщенной форме с использованием такой, например, терминологии, как "функции терминального ввода/вывода" в случае Windows-функции AllocConsole. Часто приводится только соответствующий простой комментарий наподобие "Используйте библиотеку С", как это сделано в случае функции GetTempFileName. В других случаях ситуация обращается. Так, для функций управления сигналами в UNIX (функция sigaddset и подобные ей) в столбце "Windows" содержатся записи "Используйте SEH, VEH", означающие, что для обеспечения желаемого поведения программы программист должен установить структурные или векторные обработчики исключений и функции фильтров. В отличии от UNIX, группы процессов в Windows не поддерживаются, и в подобных случаях в столбце "Windows" ставится прочерк, что, впрочем, не помешало нам эмулировать отношения между процессами при управлении заданиями в главе 6.</p>
   <p>• Многочисленные прочерки, особенно, когда они относятся к библиотеке С, встречаются в тех случаях, когда сопоставимые функции или наборы функций отсутствуют. Именно такая ситуация наблюдается, например, для функций управления каталогами.</p>
   <p>• В таблицах к главам 7—10 в качестве функций UNIX фигурируют функции потоков POSIX (Pthreads), хотя они и не являются частью UNIX. Кроме того, хотя во многих реализациях UNIX имеются собственные объекты синхронизации, аналогичные событиям, мьютексам и семафорам, мы не пытались отразить их в таблицах.</p>
   <p>Как правило, более точная совместимость наблюдается для функций, фигурирующих в начальных главах книги, особенно для функций управления файлами. С переходом к более развитым функциональным возможностям различия между системами становятся все более ощутимыми, и во многих случаях эквивалентные функции библиотеки С отсутствуют. Так, модели безопасности в UNIX и Windows существенно отличаются друг от друга, и поэтому отображенные соотношения между ними являются, в лучшем случае, приближенными.</p>
   <p>Указанные функциональные соответствия не являются точными. Между всеми тремя системами имеется множество отличий, как существенных, так и незначительных. Поэтому данные таблицы могут служить лишь ориентиром. Многие из отмеченных отличий отдельно обсуждаются в главах книги.</p>
   <subtitle>Главы 2 и 3: управление файлами и каталогами</subtitle>
   <table>
    <tr align="left">
     <th align="left" valign="top">Область</th>
     <th align="left" valign="top">Windows</th>
     <th align="left" valign="top">UNIX</th>
     <th align="left" valign="top">Библиотека С</th>
     <th align="left" valign="top">Примечания</th>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Консольный ввод/вывод</td>
     <td align="left" valign="top">AllocConsole</td>
     <td align="left" valign="top">Терминальный ввод/вывод</td>
     <td align="left" valign="top"><strong>-</strong></td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Консольный ввод/вывод</td>
     <td align="left" valign="top">FreeConsole</td>
     <td align="left" valign="top">Терминальный ввод/вывод</td>
     <td align="left" valign="top"><strong>-</strong></td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Консольный ввод/вывод</td>
     <td align="left" valign="top">ReadConsole</td>
     <td align="left" valign="top"><emphasis>read</emphasis></td>
     <td align="left" valign="top">getc, scanf, gets</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Консольный ввод/вывод</td>
     <td align="left" valign="top">SetConsoleMode</td>
     <td align="left" valign="top">ioctl</td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Консольный ввод/вывод</td>
     <td align="left" valign="top">WriteConsole</td>
     <td align="left" valign="top"><emphasis>write</emphasis></td>
     <td align="left" valign="top">putc, printf, puts</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление каталогами</td>
     <td align="left" valign="top">CreateDirectory </td>
     <td align="left" valign="top"><emphasis>mkdir*</emphasis></td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top">Создание нового каталога</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление каталогами</td>
     <td align="left" valign="top">FindClose</td>
     <td align="left" valign="top"><emphasis>closedir* </emphasis></td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">Закрытие дескриптора поиска</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление каталогами </td>
     <td align="left" valign="top">FindFirstFile </td>
     <td align="left" valign="top"><emphasis>opendir*, readdir*</emphasis></td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top">Поиск первого файла, соответствующего шаблону</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление каталогами</td>
     <td align="left" valign="top">FindNextFile </td>
     <td align="left" valign="top"><emphasis>readdir* </emphasis></td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top">Поиск следующих файлов, соответствующих шаблону</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление каталогами </td>
     <td align="left" valign="top">GetCurrentDirectory </td>
     <td align="left" valign="top"><emphasis>getcwd* </emphasis></td>
     <td align="left" valign="top"><emphasis>-</emphasis></td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление каталогами </td>
     <td align="left" valign="top">GetFullPathName </td>
     <td align="left" valign="top"><emphasis>- </emphasis></td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление каталогами </td>
     <td align="left" valign="top">GetSystemDirectory </td>
     <td align="left" valign="top">Известные пути доступа </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление каталогами </td>
     <td align="left" valign="top">RemoveDirectory </td>
     <td align="left" valign="top"><emphasis>rmdir, unlink* </emphasis></td>
     <td align="left" valign="top">remove</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление каталогами </td>
     <td align="left" valign="top">SearchPath </td>
     <td align="left" valign="top">Используйте opendir, readdir </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top">Поиск указанного файла по указанному пути</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление каталогами </td>
     <td align="left" valign="top">SetCurrentDirectory </td>
     <td align="left" valign="top"><emphasis>chdir</emphasis>*, fchdir </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">Смена рабочего каталога</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Обработка ошибок </td>
     <td align="left" valign="top">FormatMessage </td>
     <td align="left" valign="top">strerror </td>
     <td align="left" valign="top">perror</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Обработка ошибок </td>
     <td align="left" valign="top">GetLastError </td>
     <td align="left" valign="top">errno </td>
     <td align="left" valign="top">errno </td>
     <td align="left" valign="top">Глобальная переменная</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Обработка ошибок </td>
     <td align="left" valign="top">SetLastError </td>
     <td align="left" valign="top">errno </td>
     <td align="left" valign="top">errno </td>
     <td align="left" valign="top">Глобальная переменная</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Блокирование файлов </td>
     <td align="left" valign="top">LockFile </td>
     <td align="left" valign="top">fcntl(cmd=F_GETLK,…) </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Блокирование файлов </td>
     <td align="left" valign="top">LockFileEx</td>
     <td align="left" valign="top">fcntl(cmd=F_GETLK,…) </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Блокирование файлов</td>
     <td align="left" valign="top">UnlockFile</td>
     <td align="left" valign="top">fcntl(cmd=F_GETLK,…) </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Блокирование файлов </td>
     <td align="left" valign="top">UnlockFileEx </td>
     <td align="left" valign="top">fcntl(cmd=F_GETLK,…) </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">CloseHandle (в данном случае закрытие дескриптора файла) </td>
     <td align="left" valign="top"><emphasis>close* </emphasis></td>
     <td align="left" valign="top">fclose </td>
     <td align="left" valign="top">CloseHandle не ограничивается файлами</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">CopyFile </td>
     <td align="left" valign="top">open; read; write; close </td>
     <td align="left" valign="top">fopen; fread; fwrite; fclose </td>
     <td align="left" valign="top">Дублирование файла</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система</td>
     <td align="left" valign="top">CreateFile</td>
     <td align="left" valign="top"><emphasis>open*, creat*</emphasis></td>
     <td align="left" valign="top">fopen</td>
     <td align="left" valign="top">Открытие/ создание файла</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система</td>
     <td align="left" valign="top">DeleteFile</td>
     <td align="left" valign="top"><emphasis>unlink*</emphasis></td>
     <td align="left" valign="top">remove</td>
     <td align="left" valign="top">Удаление файла</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система</td>
     <td align="left" valign="top">FlushFileBuffers</td>
     <td align="left" valign="top">fsynch</td>
     <td align="left" valign="top">fflush</td>
     <td align="left" valign="top">Запись буферизованных данных в файл</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система</td>
     <td align="left" valign="top">GetFileAttributes </td>
     <td align="left" valign="top"><emphasis>stat*, fstat*, </emphasis>lstat </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">GetFileInformationByHandle </td>
     <td align="left" valign="top"><emphasis>stat*, fstat*,</emphasis> lstat </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">Заполнение структуры информацией о файле</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">GetFileSize </td>
     <td align="left" valign="top"><emphasis>stat*, fstat*,</emphasis> lstat </td>
     <td align="left" valign="top">ftell, fseek </td>
     <td align="left" valign="top">Получение размера файла в байтах</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">GetFileTime </td>
     <td align="left" valign="top"><emphasis>stat*, fstat*</emphasis>, lstat </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">GetFileType </td>
     <td align="left" valign="top"><emphasis>stat*, fstat*,</emphasis> lstat</td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top">Определение типа устройства или файла</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">GetStdHandle </td>
     <td align="left" valign="top">Используйте файловые дескрипторы 0, 1 или 2 </td>
     <td align="left" valign="top">Используйте stdin, stdout, stderr</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">GetTempFileName</td>
     <td align="left" valign="top">Используйте библиотеку С</td>
     <td align="left" valign="top">tmpnam </td>
     <td align="left" valign="top">Создание уникального имени файла</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">GetTempFileName, CreateFile </td>
     <td align="left" valign="top">Используйте библиотеку С </td>
     <td align="left" valign="top">tmpfile </td>
     <td align="left" valign="top">Создание временного файла</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">GetTempPath </td>
     <td align="left" valign="top">/temp path </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">Получение пути к каталогу для временных файлов</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система</td>
     <td align="left" valign="top">MoveFile, MoveFileEx</td>
     <td align="left" valign="top">Используйте библиотеку С</td>
     <td align="left" valign="top">rename</td>
     <td align="left" valign="top">Переименование файла или каталога</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">CreateHardLink </td>
     <td align="left" valign="top">link, <emphasis>unlink* </emphasis></td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top">Windows не поддерживает ссылки</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">symlink </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">Создание символической ссылки</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">readlink </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">Чтение имени в символической ссылке</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">Отсутствует; ReadFile возвращает 0 байт </td>
     <td align="left" valign="top">Отсутствует; read возвращает 0 байт </td>
     <td align="left" valign="top">feof </td>
     <td align="left" valign="top">Количество оставшихся до конца файла байтов</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">Отсутствует; используйте многократные вызовы ReadFile </td>
     <td align="left" valign="top">readv </td>
     <td align="left" valign="top">Отсутствует; используйте многократные вызовы freads </td>
     <td align="left" valign="top">Фрагментированное чтение</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">Отсутствует; используйте многократные вызовы WriteFile </td>
     <td align="left" valign="top">writev </td>
     <td align="left" valign="top">Отсутствует; используйте многократные вызовы fwrites </td>
     <td align="left" valign="top">Запись со слиянием</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">ReadFile </td>
     <td align="left" valign="top">read </td>
     <td align="left" valign="top">fread </td>
     <td align="left" valign="top">Чтение данных из файла</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">SetEndOfFile </td>
     <td align="left" valign="top"><emphasis>chsize* </emphasis></td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">SetFileAttributes </td>
     <td align="left" valign="top">fcntl </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">SetFilePointer </td>
     <td align="left" valign="top"><emphasis>lseek</emphasis></td>
     <td align="left" valign="top">fseek </td>
     <td align="left" valign="top">Установка указателя файла</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">SetFilePointer (установка в 0) </td>
     <td align="left" valign="top">lseek(0) </td>
     <td align="left" valign="top">rewind</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">SetFileTime </td>
     <td align="left" valign="top"><emphasis>utime* </emphasis></td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">SetStdHandle </td>
     <td align="left" valign="top">close, <emphasis>dup*, dup2*</emphasis> или fcntl</td>
     <td align="left" valign="top">freopen </td>
     <td align="left" valign="top">dup2 или fcntl</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Файловая система </td>
     <td align="left" valign="top">WriteFile </td>
     <td align="left" valign="top">write </td>
     <td align="left" valign="top">fwrite </td>
     <td align="left" valign="top">Запись данных в файл</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Получение сведений о системе</td>
     <td align="left" valign="top">GetDiskFreeSpace </td>
     <td align="left" valign="top"><strong>- </strong></td>
     <td align="left" valign="top"><strong>-</strong></td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Получение сведений о системе </td>
     <td align="left" valign="top">GetSystemInfo </td>
     <td align="left" valign="top">getrusage</td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Получение сведений о системе</td>
     <td align="left" valign="top">GetVersion</td>
     <td align="left" valign="top">uname</td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Получение сведений о системе </td>
     <td align="left" valign="top">GetVolumeInformation </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top"><strong>-</strong></td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Получение сведений о системе </td>
     <td align="left" valign="top">GlobalMemoryStatus </td>
     <td align="left" valign="top">getrlimit </td>
     <td align="left" valign="top"><strong>-</strong></td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Получение сведений о системе </td>
     <td align="left" valign="top">Ряд предопределенных констант </td>
     <td align="left" valign="top">sysconf, pathconf, fpathconf </td>
     <td align="left" valign="top"><strong>-</strong></td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Дата и время </td>
     <td align="left" valign="top">GetSystemTime </td>
     <td align="left" valign="top">Используйте библиотеку С </td>
     <td align="left" valign="top">time, gmtime</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Дата и время </td>
     <td align="left" valign="top">См. программу ls (Программа 3.2) </td>
     <td align="left" valign="top">Используйте библиотеку С </td>
     <td align="left" valign="top">asctime</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Дата и время</td>
     <td align="left" valign="top">CompareFileTime</td>
     <td align="left" valign="top">Используйте библиотеку С</td>
     <td align="left" valign="top">difftime</td>
     <td align="left" valign="top">Сравнение "календарных" значений даты и времени</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Дата и время</td>
     <td align="left" valign="top">FileTimeToLocalFileTime, FileTimeToSystemTime</td>
     <td align="left" valign="top">Используйте библиотеку С</td>
     <td align="left" valign="top">localtime</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Дата и время</td>
     <td align="left" valign="top">FileTimeToSystemTime</td>
     <td align="left" valign="top">Используйте библиотеку С</td>
     <td align="left" valign="top">gmtime</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Дата и время </td>
     <td align="left" valign="top">GetLocalTime</td>
     <td align="left" valign="top">Используйте библиотеку С</td>
     <td align="left" valign="top">time, localtime</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Дата и время</td>
     <td align="left" valign="top">См. программу touch (программа 3.3)</td>
     <td align="left" valign="top">Используйте библиотеку С</td>
     <td align="left" valign="top">strftime</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Дата и время</td>
     <td align="left" valign="top">SetLocalTime </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Дата и время</td>
     <td align="left" valign="top">SetSystemTime</td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Дата и время</td>
     <td align="left" valign="top">Вычитание значений отметок времени</td>
     <td align="left" valign="top">Используйте библиотеку С</td>
     <td align="left" valign="top">difftime</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Дата и время</td>
     <td align="left" valign="top">SystemTimeToFileTime</td>
     <td align="left" valign="top">Используйте библиотеку С</td>
     <td align="left" valign="top">mktime</td>
     <td align="left" valign="top"/>
    </tr>
   </table>
   <subtitle>Глава 4: обработка исключений</subtitle>
   <table>
    <tr align="left">
     <th align="left" valign="top">Область </th>
     <th align="left" valign="top">Windows </th>
     <th align="left" valign="top">UNIX </th>
     <th align="left" valign="top">Библиотека С</th>
    </tr>
    <tr align="left">
     <td align="left" valign="top">SEH </td>
     <td align="left" valign="top">__try–__except </td>
     <td align="left" valign="top">Используйте сигналы библиотеки С </td>
     <td align="left" valign="top">Используйте сигналы библиотеки С</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">SEH </td>
     <td align="left" valign="top">__try–__finally </td>
     <td align="left" valign="top">Используйте сигналы библиотеки С </td>
     <td align="left" valign="top">Используйте сигналы библиотеки С</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">SEH </td>
     <td align="left" valign="top">AbnormalTermination </td>
     <td align="left" valign="top">Используйте сигналы библиотеки С </td>
     <td align="left" valign="top">Используйте сигналы библиотеки С</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">SEH </td>
     <td align="left" valign="top">GetExceptionCode </td>
     <td align="left" valign="top">Используйте сигналы библиотеки С </td>
     <td align="left" valign="top">Используйте сигналы библиотеки С</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">SEH </td>
     <td align="left" valign="top">RaiseException </td>
     <td align="left" valign="top">Используйте сигналы библиотеки С </td>
     <td align="left" valign="top">signal, raise</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Сигналы </td>
     <td align="left" valign="top">Используйте блок __finally </td>
     <td align="left" valign="top">Используйте библиотеку С </td>
     <td align="left" valign="top">atexit</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Сигналы </td>
     <td align="left" valign="top">Используйте библиотеку С или TerminateProcess </td>
     <td align="left" valign="top">kill </td>
     <td align="left" valign="top">raise</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Сигналы </td>
     <td align="left" valign="top">Используйте библиотеку С </td>
     <td align="left" valign="top">Используйте библиотеку С </td>
     <td align="left" valign="top">signal</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Сигналы </td>
     <td align="left" valign="top">Используйте SEH, VEH </td>
     <td align="left" valign="top">sigemptyset</td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Сигналы </td>
     <td align="left" valign="top">Используйте SEH, VEH</td>
     <td align="left" valign="top">sigfillset</td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Сигналы</td>
     <td align="left" valign="top">Используйте SEH, VEH</td>
     <td align="left" valign="top">sigaddset</td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Сигналы </td>
     <td align="left" valign="top">Используйте SEH, VEH</td>
     <td align="left" valign="top">sigdelset</td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Сигналы</td>
     <td align="left" valign="top">Используйте SEH, VEH</td>
     <td align="left" valign="top">sigismember</td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Сигналы</td>
     <td align="left" valign="top">Используйте SEH, VEH</td>
     <td align="left" valign="top">sigprocmask</td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Сигналы</td>
     <td align="left" valign="top">Используйте SEH, VEH</td>
     <td align="left" valign="top">sigpending</td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Сигналы</td>
     <td align="left" valign="top">Используйте SEH, VEH</td>
     <td align="left" valign="top">sigaction</td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Сигналы</td>
     <td align="left" valign="top">Используйте SEH, VEH</td>
     <td align="left" valign="top">sigsetjmp</td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Сигналы</td>
     <td align="left" valign="top">Используйте SEH, VEH</td>
     <td align="left" valign="top">siglongjmp</td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Сигналы</td>
     <td align="left" valign="top">Используйте SEH, VEH</td>
     <td align="left" valign="top">sigsuspendf</td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Сигналы</td>
     <td align="left" valign="top">Используйте SEH, VEH</td>
     <td align="left" valign="top">psignal</td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Сигналы</td>
     <td align="left" valign="top">Используйте SEH, VEH или библиотеку С</td>
     <td align="left" valign="top">Используйте библиотеку С</td>
     <td align="left" valign="top">abort</td>
    </tr>
   </table>
   <p><emphasis>Примечание.</emphasis> Многие поставщики систем UNIX предоставляют собственные средства обработки исключений.</p>
   <subtitle>Глава 5: управление памятью, отображение файлов и библиотеки DLL</subtitle>
   <table>
    <tr align="left">
     <th align="left" valign="top">Область </th>
     <th align="left" valign="top">Windows </th>
     <th align="left" valign="top">UNIX </th>
     <th align="left" valign="top">Библиотека С</th>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Отображение файлов </td>
     <td align="left" valign="top">CreateFileMapping </td>
     <td align="left" valign="top">shmget </td>
     <td align="left" valign="top"><strong>-</strong></td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Отображение файлов </td>
     <td align="left" valign="top">MapViewOfFile </td>
     <td align="left" valign="top">mmap, shmat </td>
     <td align="left" valign="top"><strong>-</strong></td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Отображение файлов </td>
     <td align="left" valign="top">MapViewOfFileEx </td>
     <td align="left" valign="top">mmap, shmat </td>
     <td align="left" valign="top"><strong>-</strong></td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Отображение файлов </td>
     <td align="left" valign="top">OpenFileMapping </td>
     <td align="left" valign="top">shmget </td>
     <td align="left" valign="top"><strong>-</strong></td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Отображение файлов </td>
     <td align="left" valign="top">UnmapViewOfFile </td>
     <td align="left" valign="top">munmap, shmdt, shmctl </td>
     <td align="left" valign="top"><strong>-</strong></td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление памятью </td>
     <td align="left" valign="top">GetProcessHeap </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top"><strong>-</strong></td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление памятью </td>
     <td align="left" valign="top">GetSystemInfo </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top"><strong>-</strong></td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление памятью </td>
     <td align="left" valign="top">HeapAlloc </td>
     <td align="left" valign="top">sbrk, brk или библиотека С </td>
     <td align="left" valign="top">malloc, calloc</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление памятью </td>
     <td align="left" valign="top">HeapCreate </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление памятью </td>
     <td align="left" valign="top">HeapDestroy </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление памятью </td>
     <td align="left" valign="top">HeapFree </td>
     <td align="left" valign="top">Используйте библиотеку С </td>
     <td align="left" valign="top">free</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление памятью </td>
     <td align="left" valign="top">HeapReAlloc </td>
     <td align="left" valign="top">Используйте библиотеку С</td>
     <td align="left" valign="top">realloc</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление памятью </td>
     <td align="left" valign="top">HeapSize </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Разделяемая память </td>
     <td align="left" valign="top">CloseHandle (в данном случае закрытие дескриптора объекта отображения файла) </td>
     <td align="left" valign="top">shmctl </td>
     <td align="left" valign="top"><emphasis>-</emphasis></td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Разделяемая память </td>
     <td align="left" valign="top">CreateFileMapping, OpenFileMapping </td>
     <td align="left" valign="top">shmget </td>
     <td align="left" valign="top"><emphasis>-</emphasis></td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Разделяемая память </td>
     <td align="left" valign="top">MapViewOfFile </td>
     <td align="left" valign="top">shmat </td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Разделяемая память </td>
     <td align="left" valign="top">UnmapViewOfFile </td>
     <td align="left" valign="top">shmdt </td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Библиотеки DLL </td>
     <td align="left" valign="top">LoadLibrary </td>
     <td align="left" valign="top">dlopen </td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Библиотеки DLL </td>
     <td align="left" valign="top">FreeLibrary </td>
     <td align="left" valign="top">dlclose </td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Библиотеки DLL </td>
     <td align="left" valign="top">GetProcAddress </td>
     <td align="left" valign="top">dlsyn </td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Библиотеки DLL</td>
     <td align="left" valign="top">DllMain</td>
     <td align="left" valign="top">pthread_once</td>
     <td align="left" valign="top">-</td>
    </tr>
   </table>
   <subtitle>Глава 6: управление процессами</subtitle>
   <table>
    <tr align="left">
     <th align="left" valign="top">Область </th>
     <th align="left" valign="top">Windows </th>
     <th align="left" valign="top">UNIX </th>
     <th align="left" valign="top">Библиотека С </th>
     <th align="left" valign="top">Примечания</th>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top">CreateProcess </td>
     <td align="left" valign="top">fork(); <emphasis>execl()*,</emphasis> system() </td>
     <td align="left" valign="top"><strong>- </strong></td>
     <td align="left" valign="top">Существует 6 функций ехесхх</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top">ExitProcess </td>
     <td align="left" valign="top">_exit </td>
     <td align="left" valign="top">exit</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top">GetCommandLine </td>
     <td align="left" valign="top">argv[] </td>
     <td align="left" valign="top">argv[]</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами</td>
     <td align="left" valign="top">GetCurrentProcess </td>
     <td align="left" valign="top"><emphasis>getpid*</emphasis></td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top">GetCurrentProcessId </td>
     <td align="left" valign="top"><emphasis>getpid*</emphasis></td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top">GetEnvironmentStrings </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">getenv</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top">GetEnvironmentVariable </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">getenv</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top">GetExitCodeProcess </td>
     <td align="left" valign="top">wait, waitpid </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top">GetProcessTimes </td>
     <td align="left" valign="top">times, wait3, wait4 </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top">GetProcessWorkingSetSize </td>
     <td align="left" valign="top">wait3, wait4 </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами</td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"><emphasis>execl*,execv*,execle*,execve*,execlp*,execvp*</emphasis> </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">В Windows прямой эквивалент отсутствует</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">fork, vfork </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">В Windows прямой эквивалент отсутствует</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">getppid </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">Отношения "предок/потомок" в Windows отсутствуют</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">getgid, getegid </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">Понятие группы процессов в Windows отсутствует</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">getpgrp </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top"><strong>- </strong></td>
     <td align="left" valign="top">setpgid </td>
     <td align="left" valign="top"><strong>-</strong></td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">setsid </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top"><strong>- </strong></td>
     <td align="left" valign="top">tcgetpgrp </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top"><strong>- </strong></td>
     <td align="left" valign="top">tcsetpgrp </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top">OpenProcess </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top">SetEnvironmentVariable </td>
     <td align="left" valign="top">putenv </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">putenv не включена в стандартную библиотеку С</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление процессами </td>
     <td align="left" valign="top">TerminateProcess </td>
     <td align="left" valign="top">kill </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: процесс </td>
     <td align="left" valign="top">WaitForMultipleObjects (в данном случае ожидание дескрипторов процесса) </td>
     <td align="left" valign="top">waitpid</td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: процесс </td>
     <td align="left" valign="top">WaitForSingleObject (в данном случае ожидание дескриптора процесса) </td>
     <td align="left" valign="top">wait, waitpid</td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Таймеры </td>
     <td align="left" valign="top">KillTimer </td>
     <td align="left" valign="top">alarm(0) </td>
     <td align="left" valign="top"><strong>-</strong></td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Таймеры </td>
     <td align="left" valign="top">SetTimer </td>
     <td align="left" valign="top">alarm </td>
     <td align="left" valign="top"><strong>-</strong></td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Таймеры </td>
     <td align="left" valign="top">Sleep </td>
     <td align="left" valign="top">sleep </td>
     <td align="left" valign="top"><strong>-</strong></td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Таймеры</td>
     <td align="left" valign="top">Sleep</td>
     <td align="left" valign="top">poll или select без указания файлового дескриптора</td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
   </table>
   <subtitle>Глава 7: Потоки и планирование выполнения</subtitle>
   <table>
    <tr align="left">
     <th align="left" valign="top">Область </th>
     <th align="left" valign="top">Windows </th>
     <th align="left" valign="top">UNIX/Pthreads</th>
     <th align="left" valign="top">Примечания</th>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление потоками </td>
     <td align="left" valign="top">CreateRemoteThread </td>
     <td align="left" valign="top"><strong>-</strong></td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">TLS </td>
     <td align="left" valign="top">TlsAlloc </td>
     <td align="left" valign="top">pthread_key_alloc</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">TLS </td>
     <td align="left" valign="top">TlsFree </td>
     <td align="left" valign="top">pthread_key_delete</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">TLS </td>
     <td align="left" valign="top">TlsGetValue </td>
     <td align="left" valign="top">pthread_getspecific</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">TLS </td>
     <td align="left" valign="top">TlsSetValue </td>
     <td align="left" valign="top">pthread_setspecific</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление потоками </td>
     <td align="left" valign="top">CreateThread, _beginthreadex </td>
     <td align="left" valign="top">pthread_create</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление потоками </td>
     <td align="left" valign="top">ExitThread, _endthreadex </td>
     <td align="left" valign="top">pthread_exit</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление потоками </td>
     <td align="left" valign="top">GetCurrentThread </td>
     <td align="left" valign="top">pthread_self</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление потоками </td>
     <td align="left" valign="top">GetCurrentThreadId </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление потоками </td>
     <td align="left" valign="top">GetExitCodeThread </td>
     <td align="left" valign="top">pthread_yield</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление потоками </td>
     <td align="left" valign="top">ResumeThread </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление потоками </td>
     <td align="left" valign="top">SuspendThread </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление потоками </td>
     <td align="left" valign="top">TerminateThread </td>
     <td align="left" valign="top">pthread_cancel </td>
     <td align="left" valign="top">pthread_cancel является более безопасной</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Управление потоками </td>
     <td align="left" valign="top">WaitForSingleObject (в данном случае ожидание дескриптора потока) </td>
     <td align="left" valign="top">pthread_join</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Приоритет потоков </td>
     <td align="left" valign="top">GetPriorityClass </td>
     <td align="left" valign="top">pthread_attr_getschedpolicy, getpriority</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Приоритет потоков </td>
     <td align="left" valign="top">GetThreadPriority </td>
     <td align="left" valign="top">pthread_attr_getschedparam</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Приоритет потоков </td>
     <td align="left" valign="top">SetPriorityClass </td>
     <td align="left" valign="top">pthread_attr_setschedpolicy, setpriority, nice</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Приоритет потоков</td>
     <td align="left" valign="top">SetThreadPriority</td>
     <td align="left" valign="top">pthread_attr_setschedparam</td>
     <td align="left" valign="top"/>
    </tr>
   </table>
   <p><emphasis>Примечание. </emphasis>Будучи частью всех современных систем UNIX, потоки Pthreads доступны также в системах, отличных от UNIX.</p>
   <subtitle>Главы 8-10: синхронизация потоков</subtitle>
   <table>
    <tr align="left">
     <th align="left" valign="top">Область </th>
     <th align="left" valign="top">Windows </th>
     <th align="left" valign="top">UNIX/Pthreads </th>
     <th align="left" valign="top">Примечания</th>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: критические разделы </td>
     <td align="left" valign="top">DeleteCriticalSection </td>
     <td align="left" valign="top">Для эмуляции объектов критических разделов используйте мьютексы. </td>
     <td align="left" valign="top">Библиотека С в данном случае не применима</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: критические разделы </td>
     <td align="left" valign="top">EnterCriticalSection </td>
     <td align="left" valign="top">Некоторые системы предоставляют собственные эквиваленты. </td>
     <td align="left" valign="top">Библиотека С в данном случае не применима</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: критические разделы </td>
     <td align="left" valign="top">InitializeCriticalSection </td>
     <td rowspan="2" align="center" valign="middle">&#8595;</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: критические разделы </td>
     <td align="left" valign="top">LeaveCriticalSection</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: события </td>
     <td align="left" valign="top">CloseHandle (в данном случае закрытие дескриптора события) </td>
     <td align="left" valign="top">pthread_cond_destroy</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: события </td>
     <td align="left" valign="top">CreateEvent </td>
     <td align="left" valign="top">pthread_cond_init</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: события </td>
     <td align="left" valign="top">PulseEvent </td>
     <td align="left" valign="top">pthread_cond_signal </td>
     <td align="left" valign="top">Вручную сбрасываемое событие</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: события </td>
     <td align="left" valign="top">ResetEvent </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: события </td>
     <td align="left" valign="top">SetEvent </td>
     <td align="left" valign="top">pthread_cond_broadcast </td>
     <td align="left" valign="top">Автоматически сбрасываемое событие</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: события </td>
     <td align="left" valign="top">WaitForSingleObject (в данном случае ожидание дескриптора события) </td>
     <td align="left" valign="top">pthread_cond_wait</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: события </td>
     <td align="left" valign="top">WaitForSingleObject (в данном случае ожидание дескриптора события) </td>
     <td align="left" valign="top">pthread_timed_wait</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: мьютексы </td>
     <td align="left" valign="top">CloseHandle (в данном случае закрытие дескриптора мьютекса) </td>
     <td align="left" valign="top">pthread_mutex_destroy</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: мьютексы </td>
     <td align="left" valign="top">CreateMutex </td>
     <td align="left" valign="top">pthread_mutex_init</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: мьютексы </td>
     <td align="left" valign="top">ReleaseMutex </td>
     <td align="left" valign="top">pthread_mutex_unlock</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: мьютексы </td>
     <td align="left" valign="top">WaitForSingleObject(в данном случае ожидание дескриптора мьютекса) </td>
     <td align="left" valign="top">pthread_mutex_lock</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: семафоры </td>
     <td align="left" valign="top">CreateSemaphore </td>
     <td align="left" valign="top">semget</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: семафоры </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">semctl </td>
     <td align="left" valign="top">Непосредственная поддержка всех опций в Windows отсутствует</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: семафоры </td>
     <td align="left" valign="top">OpenSemaphore </td>
     <td align="left" valign="top">semget</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: семафоры </td>
     <td align="left" valign="top">ReleaseSemaphore </td>
     <td align="left" valign="top">semop (+)</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Синхронизация: семафоры</td>
     <td align="left" valign="top">WaitForSingleObject (в данном случае закрытие дескриптора семафора)</td>
     <td align="left" valign="top">semop (-)</td>
     <td align="left" valign="top">Windows может выполнять ожидание только одного счетчика</td>
    </tr>
   </table>
   <subtitle>Глава 11: Взаимодействие между процессами</subtitle>
   <table>
    <tr align="left">
     <th align="left" valign="top">Область </th>
     <th align="left" valign="top">Windows </th>
     <th align="left" valign="top">UNIX </th>
     <th align="left" valign="top">Библиотека С </th>
     <th align="left" valign="top">Примечания</th>
    </tr>
    <tr align="left">
     <td align="left" valign="top">IPC </td>
     <td align="left" valign="top">CallNamedPipe </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">CreateFile, WriteFile, ReadFile, CloseHandle</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">IPC </td>
     <td align="left" valign="top">CloseHandle (pipe handle) </td>
     <td align="left" valign="top">close, msgctl </td>
     <td align="left" valign="top">pclose</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">IPC </td>
     <td align="left" valign="top">ConnectNamedPipe </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">IPC </td>
     <td align="left" valign="top">CreateMailslot </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">IPC </td>
     <td align="left" valign="top">CreateNamedPipe </td>
     <td align="left" valign="top">mkfifo, msgget </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">IPC </td>
     <td align="left" valign="top">CreatePipe </td>
     <td align="left" valign="top"><emphasis>pipe </emphasis></td>
     <td align="left" valign="top">popen </td>
     <td align="left" valign="top">He является частью стандартной библиотеки С — см. [40]</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">IPC </td>
     <td align="left" valign="top">DuplicateHandle </td>
     <td align="left" valign="top"><emphasis>dup, dup2,</emphasis> or fcntl </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">Или используйте стандартные имена файлов CONIN$, CONOUT$</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">IPC </td>
     <td align="left" valign="top">GetNamedPipeHandleState </td>
     <td align="left" valign="top"><emphasis>stat, fstat,</emphasis> lstat64 </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">IPC </td>
     <td align="left" valign="top">GetNamedPipeInfo </td>
     <td align="left" valign="top"><emphasis>stat, fstat, </emphasis>lstat </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">IPC </td>
     <td align="left" valign="top">ImpersonateNamedPipeClient </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">IPC </td>
     <td align="left" valign="top">PeekNamedPipe </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">IPC </td>
     <td align="left" valign="top">ReadFile (в данном случае используется дескриптор именованного канала) </td>
     <td align="left" valign="top">read (fifo), msgsnd </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">IPC </td>
     <td align="left" valign="top">RevertToSelf </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">IPC </td>
     <td align="left" valign="top">SetNamedPipeHandleState </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">IPC </td>
     <td align="left" valign="top">TransactNamedPipe </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">WriteFile; ReadFile</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">IPC </td>
     <td align="left" valign="top">WriteFile (в данном случае используется дескриптор именованного канала) </td>
     <td align="left" valign="top">write (fifo), msgrcv </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Разное </td>
     <td align="left" valign="top">GetComputerName </td>
     <td align="left" valign="top">uname </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Разное </td>
     <td align="left" valign="top">SetComputerName </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность</td>
     <td align="left" valign="top">SetNamedPipeIdentity</td>
     <td align="left" valign="top">Используйте второй промежуточный бит каталога</td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
   </table>
   <subtitle>Глава 14: асинхронный ввод/вывод</subtitle>
   <table>
    <tr align="left">
     <th align="left" valign="top">Область </th>
     <th align="left" valign="top">Windows </th>
     <th align="left" valign="top">UNIX </th>
     <th align="left" valign="top">Библиотека С </th>
     <th align="left" valign="top">Примечания</th>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Асинхронный ввод/вывод </td>
     <td align="left" valign="top">GetOverlappedResult </td>
     <td align="left" valign="top"><strong>- </strong></td>
     <td align="left" valign="top"><strong>-</strong></td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Асинхронный ввод/вывод </td>
     <td align="left" valign="top">ReadFileEx </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top">Расширенный ввод/ вывод с процедурой завершения</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Асинхронный ввод/вывод </td>
     <td align="left" valign="top">SleepEx </td>
     <td align="left" valign="top"><strong>- </strong></td>
     <td align="left" valign="top"><strong>- </strong></td>
     <td align="left" valign="top">Ожидание в дежурном режиме</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Асинхронный ввод/вывод </td>
     <td align="left" valign="top">WaitForMultipleObjects (в данном случае ожидание дескрипторов файлов) </td>
     <td align="left" valign="top">poll, select </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top"/>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Асинхронный ввод/вывод </td>
     <td align="left" valign="top">WaitForMultipleObjectsEx </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top"><strong>- </strong></td>
     <td align="left" valign="top">Ожидание в дежурном режиме</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Асинхронный ввод/вывод </td>
     <td align="left" valign="top">WriteFileEx </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top">Расширенный ввод/ вывод с процедурой завершения</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Асинхронный ввод/вывод</td>
     <td align="left" valign="top">WaitForSingleObjectEx</td>
     <td align="left" valign="top">waitpid</td>
     <td align="left" valign="top"><strong>-</strong></td>
     <td align="left" valign="top">Ожидание в дежурном режиме</td>
    </tr>
   </table>
   <subtitle>Глава 15: Безопасность объектов Windows</subtitle>
   <table>
    <tr align="left">
     <th align="left" valign="top">Область </th>
     <th align="left" valign="top">Windows </th>
     <th align="left" valign="top">UNIX </th>
     <th align="left" valign="top">Примечания</th>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">AddAccessAllowedAce </td>
     <td align="left" valign="top">chmod, fchmod </td>
     <td rowspan="4" align="left" valign="top">Средства защиты объектов библиотекой С не поддерживаются</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">AddAccessDeniedAce </td>
     <td align="left" valign="top">chmod, fchmod</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">AddAuditAce </td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">CreatePrivateObjectSecurity </td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">DeleteAce </td>
     <td align="left" valign="top">chmod, fchmod</td>
     <td rowspan="23" align="center" valign="middle">&#8595;</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">DestroyPrivateObjectSecurity </td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">GetAce </td>
     <td align="left" valign="top"><emphasis>stat*, fstat*, lstat</emphasis></td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">GetAclInformation </td>
     <td align="left" valign="top"><emphasis>stat*, fstat*, lstat</emphasis></td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">GetFileSecurity </td>
     <td align="left" valign="top"><emphasis>stat*, fstat*, lstat</emphasis></td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">GetPrivateObjectSecurity </td>
     <td align="left" valign="top"><emphasis>-</emphasis></td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">GetSecurityDescriptorDacl </td>
     <td align="left" valign="top"><emphasis>stat*, fstat*, lstat</emphasis></td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">GetUserName </td>
     <td align="left" valign="top">getlogin</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">InitializeAcl </td>
     <td align="left" valign="top">-</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">InitializeSecurityDescriptor </td>
     <td align="left" valign="top">umask</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">LookupAccountName </td>
     <td align="left" valign="top">getpwnam, getgrnam</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">LookupAccountSid </td>
     <td align="left" valign="top">getpwuid, getuid, geteuid</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">getpwend, setpwent, endpwent</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">-</td>
     <td align="left" valign="top">getgrent, setgrent, endgrent</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">setuid, seteuid, setreuid</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">- </td>
     <td align="left" valign="top">setgid, setegid, setregid</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">OpenProcessToken </td>
     <td align="left" valign="top">getgroups, setgroups, initgroups</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">SetFileSecurity </td>
     <td align="left" valign="top"><emphasis>chmod*, fchmod</emphasis></td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">SetPrivateObjectSecurity </td>
     <td align="left" valign="top"><emphasis>-</emphasis></td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">SetSecurityDescriptorDacl </td>
     <td align="left" valign="top"><emphasis>umask</emphasis></td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">SetSecurityDescriptorGroup </td>
     <td align="left" valign="top">chown, fchown, lchown</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность </td>
     <td align="left" valign="top">SetSecurityDescriptorOwner </td>
     <td align="left" valign="top">chown, fchown, lchown</td>
    </tr>
    <tr align="left">
     <td align="left" valign="top">Безопасность</td>
     <td align="left" valign="top">SetSecurityDescriptorSacl</td>
     <td align="left" valign="top">-</td>
    </tr>
   </table>
  </section>
  <section>
   <title>
    <p>ПРИЛОЖЕНИЕ В</p>
    <p>Результаты измерения производительности</p>
   </title>
   <section>
    <p>В примерах программ представлено широкое разнообразие альтернативных методик решения одних и тех же задач, как это было, например, при рассмотрении копирования файлов или преобразования текстовых файлов из кодировки ASCII в Unicode, и поэтому рассуждения о сравнительных преимуществах этих методик в отношении производительности являются вполне уместными. Однако в процессе создания приложений одних рассуждений подобного рода мало, и требуется точное знание количественных характеристик, позволяющих судить о влиянии того или иного выбора варианта реализации на производительность, а также о том, каковы в этом смысле потенциальные преимущества той или иной версии Windows, конфигурации оборудования или средств Windows, таких как потоки или асинхронный ввод/вывод. Программа timep (программа 6.2) позволяет измерять реальное (истекшее), пользовательское и системное (затраченное функциями ядра) время, необходимое для выполнения программ, и предоставляет удобный способ измерения производительности и определения ее зависимости от выбора методик и принципов программирования.</p>
   </section>
   <section>
    <title>
     <p>Тестовые конфигурации</p>
    </title>
    <section>
     <p>Тестирование производилось путем выполнения на ряде хост-систем репрезентативного набора приложений из числа приведенных в данной книге примеров программ.</p>
    </section>
    <section>
     <title>
      <p>Приложения</p>
     </title>
     <p>В приведенных ниже таблицах приведены временные характеристики, полученные с использованием программы timep при выполнении тестовых программ на нескольких различных системах. Для этой цели были выбраны следующие функциональные области:</p>
     <p><strong>1. Копирование файлов. </strong>Показатели производительности определялись для нескольких различных методик, с помощью которых выполнялась эта операция, включая использование библиотеки С и Windows-функции CopyFile. Копирование файлов позволяет сосредоточить внимание на операциях ввода/вывода, не сопровождаемых обработкой данных.</p>
     <p><strong>2. Преобразование символов из кодировки ASCII в кодировку Unicode. </strong>В этой серии тестов выяснялась зависимость производительности от использования отображения файлов, буферов большого размера, флагов Windows, задающих последовательный режим обработки, и операций асинхронного ввода/вывода. Преобразование символов позволяет сосредоточить внимание на операциях ввода/вывода, сопровождаемых незначительной обработкой данных в процессе их перемещения из одного буфера в другой.</p>
     <p><strong>3. Поиск заданных текстовых шаблонов. </strong>Эта серия тестов проводилась с использованием программы grep в ее многопроцессорной и многопоточной формах. Тестировалась также простая последовательная обработка файлов, которая по своей производительности на однопроцессорных системах оказалась вполне конкурентоспособной по отношению к двум другим методикам. При поиске образцов увеличивается доля обработки данных в расходовании процессорного времени и уменьшается доля операций вывода.</p>
     <p><strong>4. Сортировка файлов. </strong>Эта серия тестов демонстрирует, какое влияние на производительность оказывает использование отображения файлов и обработка файлов в памяти, а также переход к многопоточному режиму выполнения. При сортировке основная доля времени, по крайней мере, в случае крупных файлов, приходится не на файловые операции ввода/вывода, а на обработку данных процессором.</p>
     <p><strong>5. Многопоточная система "производитель/потребитель". </strong>Эта серия тестов позволила исследовать влияние на производительность различных методов синхронизации, используемых для реализации системы с многопоточной очередизацией, что дало возможность оценить сравнительные достоинства и недостатки обсуждавшихся в главах 8-10 моделей, основанных на применении объектов CRITICAL_SECTION, мьютексов и функции SignalObjectAndWait, а также сигнальной и широковещательной моделей переменных условий.</p>
     <p>Программы для всех перечисленных приложений компоновались с использованием Microsoft Visual C++ 7.0 и 6.0 в виде окончательных (release), а не отладочных (debug) версий. Выполнение отладочных версий программ привело бы к заметному искажению картины показателей производительности. Специально проведенные тесты с интенсивной загрузкой процессора показали, что в этом случае доля дополнительных накладных расходов может достигать 80%, не говоря уже о том, что размеры отладочных исполняемых модулей превышают размеры модулей окончательных версий в два-три раза.</p>
    </section>
    <section>
     <title>
      <p>Хост-системы</p>
     </title>
     <p>Показатели производительности измерялись на четырех современных (по состоянию на 2004 год) системах, характеризующихся широким разнообразием конфигураций ЦП, памяти и ОС. Во всех случаях использовалась файловая система NTFS. В некоторых случаях приводятся также данные, полученные на устаревших системах.</p>
     <p>1. Лэптоп, процессор Pentium с частотой 1 ГГц, ОС Windows 2000 Professional.</p>
     <p>2. Лэптоп, процессор Intel Celeron с частотой 2 ГГц, ОС Windows XP.</p>
     <p>3. PC с процессором Pentium, ОС Windows 2000.</p>
     <p>4. Четырехпроцессорная система Windows 2000 Server с ОС NT 5.0. В качестве процессоров были использованы четыре процессора Intel Xeon с частотой 1,8 ГГц. Эта система позволила исследовать, насколько увеличиваются показатели производительности в результате применения нескольких высокопроизводительных процессоров.</p>
     <p>В примерах, связанных с обработкой файлов, представлены также результаты, полученные на устаревшей NT-системе на основе PC, в которой использовался процессор Pentium III с частотой 500 МГц, что позволило сравнить между собой показатели производительности для файловых систем FAT и NTFS, хотя файловая система FAT уже не так распространена, как прежде. Во всех случаях файловые системы были заполнены не более чем на 50% и характеризовались лишь незначительной фрагментацией.</p>
     <p>Во время проведения тестов никакие другие задачи, кроме тестовых программ, на системах не выполнялись. Неплохим показателем относительного быстродействия процессоров могут служить результаты, полученные, в частности, при выполнении таких программ, как программы сортировки, интенсивно использующие процессор.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Измерение производительности</p>
    </title>
    <section>
     <p>Каждое приложение выполнялось на хост-системе по пять раз. Перед каждым запуском приложения физическая память очищалась, чтобы исключить повышение показателей производительности за счет файлов и программ, кэшированных в памяти или файлах подкачки. В представленных в последующих разделах таблицах приведены усредненные данные. Время измеряется в секундах.</p>
     <p>Каждая таблица сопровождается комментариями. Вполне очевидно, что делать какие-либо обобщенные выводы в отношении производительности довольно рискованно, поскольку на временные характеристики производительности программ оказывают влияние самые разнообразные факторы, включая свойства самих программ. В то же время, такие тесты позволяют выявлять некоторые закономерности и исследовать изменение производительности в зависимости от использования тех или иных файловых и операционных систем или тех или иных методик программирования. Кроме того, необходимо иметь в виду, что в процессе тестирования измеряется время, прошедшее с момента начала выполнения программы до ее завершения, но не учитывается время, необходимое системе для сброса содержимого буферов на диск. Наконец, при проведении тестов никаких попыток воспользоваться специфическими возможностями или параметрами системы, как то использование разделенных на полосы дисков, варьирование размеров блоков данных при обмене с дисками, разбиение дисков на несколько разделов и тому подобное, не предпринималось.</p>
     <p>Монитор производительности Windows, доступный через пиктограмму Administrative Tools (Администрирование), находящуюся в панели управления, отображает данные о работе процессора, ядра, пользовательских и других процессов в графическом виде. Это средство предоставляет отличные дополнительные возможности для изучения свойств программ помимо тех, которые обеспечиваются приведенными здесь результатами измерений.</p>
     <p>Полученные результаты указывают на варьирование производительности в широких пределах в зависимости от используемых ЦП, файловой системы, дисковой конфигурации, особенностей программы, а также множества других факторов. Все программы, применяемые для проведения необходимых измерений, находятся на Web-сайте книги, что дает вам возможность самостоятельно выполнить эти тесты на своей системе.</p>
    </section>
    <section>
     <title>
      <p>Копирование файлов</p>
     </title>
     <p>Пять различных вариантов реализации программ копирования файлов использовались для копирования файла размером 25,6 Мбайт (400 000 записей размером 64 байта каждая, сгенерированных с помощью программы RandFile из главы 5). В первых двух столбцах табл. В.1 представлены результаты, полученные на лэптопе (LT) устаревшей модели, в котором установлен процессор Pentium с частотой 500 МГц, что позволяет сопоставить между собой показатели производительности в случае файловых систем NTFS и FAT.</p>
     <p>1. Программа cpC (программа 1.1) использует библиотеку С. В этом тесте измеряется эффект варианта реализации, выполняющегося поверх Windows, хотя библиотека и предоставляет возможность использования эффективной буферизации или применения других методик.</p>
     <p>2. Программа cpW (программа 1.2) является реализацией, в которой используются непосредственно средства Windows с буфером небольшого размера (256 байт).</p>
     <p>3. Программа cpwFA — "быстрый" вариант реализации с использованием буфера большого размера (8192 байта, что кратно размеру сектора диска на всех хост-системах) и флагов Windows, задающих последовательный режим обработки как для входных, так и для выходных файлов.</p>
     <p>4. Программа cpCF (программа 1.3) использует функцию Windows CopyFile для выяснения того, является ли реализация, ограничивающаяся единственным системным вызовом, более эффективной по сравнению с другими методиками.</p>
     <p>5. Программа cpUC (программа 1.1) — реализация в стиле UNIX, использующая буфер небольшого размера (аналогично программе cpW). Эта программа была незначительно изменена, чтобы обеспечить возможность использования библиотеки совместимости с UNIX, входящей в состав Visual C++.</p>
     <p>В то время как приведенные результаты представляют величины, усредненные по пяти тестовым запускам, сами значения истекшего времени могут меняться в широких пределах. Так, для программы cpUC (последний ряд) среднее значение истекшего времени в третьем столбце данных (Pentium LT, W2000) составило 7,77 секунды, тогда как минимальное и максимальное значения составляли соответственно 1,87 и 11,71 секунды. Такая широкая вариация значений была типичной почти во всех случаях и на всех системах.</p>
     <subtitle><emphasis>Комментарии</emphasis></subtitle>
     <p>1. Применение файловой системы NTFS вовсе не гарантирует лучшую по сравнению с системой FAT производительность. Более того, иногда более быстрой оказывается именно FAT, в чем можно убедиться, сравнивая данные, приведенные в столбцах 1 и 2.</p>
     <p>2. Библиотеки совместимости С и UNIX обеспечивают сопоставимую производительность, которая во многих случаях превосходит производительность простейших вариантов реализации, использующих средства Windows.</p>
     <p>3. Процессорное время, потребляемое как функциями ядра ("Системное время"), так и пользовательскими функциями ("Пользовательское время"), является минимальным. Следовательно, быстродействие процессора оказывает лишь самое незначительное влияние на производительность, оцениваемую по истекшему времени.</p>
     <p>4. Как и следовало ожидать, высокопроизводительные серверные SMP-системы действительно обеспечивают гораздо более быструю обработку файлов, чем лэптопы и PC. Дополнительные тесты, выполненные в системе Windows Server 2003, обладающей еще более высоким быстродействием, показали еще лучшие результаты (здесь они не представлены), причем значения истекшего времени оказались примерно в два раза меньшими по сравнению со значениями, приведенными в крайнем справа столбце таблицы.</p>
     <p>5. Использование буферов большого размера, флагов последовательной обработки или функции CopyFile не обеспечивают систематического или существенного выигрыша в производительности, оцениваемой по истекшему времени. Вместе с тем, весьма небольшие значения показателей пользовательского времени для программ cpwFA и cpCF представляют интерес, и этим можно воспользоваться в некоторых ситуациях, даже если показатели истекшего времени при этом не улучшатся. Одна из систем, а именно, лэптоп с процессором Pentium, не подходит под данное обобщение. Как ранее уже отмечалось, процессорное время составляет лишь небольшую долю истекшего времени.</p>
     <p>6. Показатели истекшего времени являются в высшей степени переменчивыми, причем в некоторых случаях отношение результатов, полученных в идентичных тестах, которые выполнялись в идентичных условиях, достигало значения 10:1.</p>
     <empty-line/>
     <p>Таблица В.1. Показатели производительности программ копирования файлов</p>
     <table>
      <tr align="left">
       <th rowspan="3" align="left" valign="top"/>
       <th align="left" valign="top">ЦП </th>
       <th align="left" valign="top">Pentium III </th>
       <th align="left" valign="top">Pentium III </th>
       <th align="left" valign="top">Pentium LT </th>
       <th align="left" valign="top">Celeron LT </th>
       <th align="left" valign="top">Xeon </th>
       <th align="left" valign="top">4&#215;Xeon</th>
      </tr>
      <tr align="left">
       <th align="left" valign="top">ОС </th>
       <th align="left" valign="top">W2000 </th>
       <th align="left" valign="top">W2000 </th>
       <th align="left" valign="top">W2000 </th>
       <th align="left" valign="top">XP </th>
       <th align="left" valign="top">W2000 </th>
       <th align="left" valign="top">W2000</th>
      </tr>
      <tr align="left">
       <th align="left" valign="top">Файловая система </th>
       <th align="left" valign="top">FAT </th>
       <th align="left" valign="top">NTFS </th>
       <th align="left" valign="top">NTFS </th>
       <th align="left" valign="top">NTFS </th>
       <th align="left" valign="top">NTFS </th>
       <th align="left" valign="top">NTFS</th>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">cpC</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">8,62 </td>
       <td align="left" valign="top">14,69</td>
       <td align="left" valign="top">12,75</td>
       <td align="left" valign="top">7,23</td>
       <td align="left" valign="top">6,03</td>
       <td align="left" valign="top">2,67</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время </td>
       <td align="left" valign="top">0,12</td>
       <td align="left" valign="top">0,12</td>
       <td align="left" valign="top">0,10</td>
       <td align="left" valign="top">0,10</td>
       <td align="left" valign="top">0,09</td>
       <td align="left" valign="top">0,06</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">0,24</td>
       <td align="left" valign="top">0,52</td>
       <td align="left" valign="top">1,39</td>
       <td align="left" valign="top">0,39</td>
       <td align="left" valign="top">0,25</td>
       <td align="left" valign="top">0,36</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">cpW</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">8,49</td>
       <td align="left" valign="top">13,35</td>
       <td align="left" valign="top">25,48</td>
       <td align="left" valign="top">7,10</td>
       <td align="left" valign="top">8,94</td>
       <td align="left" valign="top">2,95</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время</td>
       <td align="left" valign="top">0,13</td>
       <td align="left" valign="top">0,12</td>
       <td align="left" valign="top">0,06</td>
       <td align="left" valign="top">0,04</td>
       <td align="left" valign="top">0,04</td>
       <td align="left" valign="top">0,13 </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">0,88</td>
       <td align="left" valign="top">1,37</td>
       <td align="left" valign="top">4,61</td>
       <td align="left" valign="top">0,62</td>
       <td align="left" valign="top">0,56</td>
       <td align="left" valign="top">0,13</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">cpwFA</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">8,35</td>
       <td align="left" valign="top">12,59</td>
       <td align="left" valign="top">7,35</td>
       <td align="left" valign="top">8,25</td>
       <td align="left" valign="top">9,10</td>
       <td align="left" valign="top">2,36</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время </td>
       <td align="left" valign="top">0,01</td>
       <td align="left" valign="top">0,02</td>
       <td align="left" valign="top">0,03</td>
       <td align="left" valign="top">0,01</td>
       <td align="left" valign="top">0,01</td>
       <td align="left" valign="top">0,02</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">0,40</td>
       <td align="left" valign="top">0,50</td>
       <td align="left" valign="top">0,82</td>
       <td align="left" valign="top">0,29</td>
       <td align="left" valign="top">0,20</td>
       <td align="left" valign="top">0,19</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">cpCF</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">8,00</td>
       <td align="left" valign="top">11,69</td>
       <td align="left" valign="top">2,57</td>
       <td align="left" valign="top">6,50</td>
       <td align="left" valign="top">7,62</td>
       <td align="left" valign="top">2,97</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время</td>
       <td align="left" valign="top">0,02</td>
       <td align="left" valign="top">0,01</td>
       <td align="left" valign="top">0,02</td>
       <td align="left" valign="top">0,02</td>
       <td align="left" valign="top">0,01</td>
       <td align="left" valign="top">0,02</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">0,19</td>
       <td align="left" valign="top">0,25</td>
       <td align="left" valign="top">0,53</td>
       <td align="left" valign="top">0,19</td>
       <td align="left" valign="top">0,12</td>
       <td align="left" valign="top">0,17</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">cpUC</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">7,84</td>
       <td align="left" valign="top">13,14</td>
       <td align="left" valign="top">21,01</td>
       <td align="left" valign="top">9,98</td>
       <td align="left" valign="top">7,77</td>
       <td align="left" valign="top">3,53</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время</td>
       <td align="left" valign="top">0,72</td>
       <td align="left" valign="top">0,66</td>
       <td align="left" valign="top">0,47</td>
       <td align="left" valign="top">0,34</td>
       <td align="left" valign="top">0,34</td>
       <td align="left" valign="top">0,42 </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">0,40</td>
       <td align="left" valign="top">0,67</td>
       <td align="left" valign="top">3,12</td>
       <td align="left" valign="top">0,34</td>
       <td align="left" valign="top">0,36</td>
       <td align="left" valign="top">0,41</td>
      </tr>
     </table>
    </section>
    <section>
     <title>
      <p>Преобразование символов из кодировки ASCII в Unicode</p>
     </title>
     <p>Измерения выполнялись для восьми программ, каждая из которых преобразовывала файл размером 12,8 Мбайт в файл размером 25,6 Мбайт. Соответствующие результаты представлены в табл. В.2.</p>
     <p>1. Программа atou (программа 2.4) сопоставима с программой cpW, использующей буфер небольшого размера.</p>
     <p>2. Программа atouSS — первый из "быстрых" вариантов реализации, основанных на программе atou. В нем применяются флаги последовательного режима обработки и буфер небольшого размера. Эта, а также две следующие программы сгенерированы на основе одного и того же проекта, atouLBSS, но с определением разных комбинаций макросов.</p>
     <p>3. Программа atouLB использует буфер большого размера (8192 байта), но не использует флаги последовательного режима обработки.</p>
     <p>4. Программа atouLSFP использует буфер большого размера и флаги последовательного режима обработки, но кроме этого предварительно устанавливает требуемый размер выходного файла. Эта мера продемонстрировала свою высокую эффективность.</p>
     <p>5. Программа atouMM использует отображение файлов для операций файлового ввода/вывода и вызывает функции, листинг которых приведен в программе 5.3.</p>
     <p>6. Программа atouMT представляет собой многопоточную реализацию приведенной в главе 14 программы, основанной на схеме множественной буферизации без применения асинхронного ввода/вывода.</p>
     <p>7. Программа atouOV (программа 14.1) использует перекрывающийся ввод/вывод и не может выполняться на двух системах семейства Windows 9x.</p>
     <p>8. Программа atouEX (программа 14.2) использует перекрывающийся ввод/вывод и не будет выполняться на двух системах семейства Windows 9x.</p>
     <subtitle><emphasis>Комментарии</emphasis></subtitle>
     <p>1. Результаты показывают, что применение буферов увеличенного размера и флагов последовательной обработки (а возможно, и сочетания этих факторов) обеспечивает некоторый выигрыш в производительности.</p>
     <p>2. Предварительная установка размера выходного файла (atouLSFP) очень эффективна и приводит к резкому повышению производительности на всех однопроцессорных системах. В то же время, преимущества SMP-систем оказались весьма незначительными. Эту же методику можно было применить и в предыдущих примерах копирования файлов.</p>
     <p>3. В этих примерах процессорное время составляет лишь незначительную долю общего времени.</p>
     <p>4. Помимо того, что использование перекрывающегося ввода/вывода ограничивается системами Windows NT и его трудно программировать, он обеспечивает очень низкую производительность. Заметьте, что основная доля общего времени приходится не на пользовательское или системное время, а на реальное время. Создается впечатление, что в случае NT4 система испытывает трудности с планированием доступа к диску, и это препятствие нельзя было устранить путем изменения размера буфера (как большую, так и в меньшую сторону) до тех пор, пока не были использованы буферы размером 65 Кбайт. В NT5 эта проблема не возникает.</p>
     <p>5. Ни расширенный ввод/вывод, ни многопоточный режим не обеспечивают сколько-нибудь заметного повышения производительности.</p>
     <p>6. Использование отображения файлов в операциях ввода/вывода способно увеличивать производительность, обеспечивая ее повышение примерно на 30% по сравнению с остальными методами. Результаты для SMP-сервера оказались еще лучшими.</p>
     <empty-line/>
     <p>Таблица В.2. Показатели производительности программ преобразования символов из кодировки ASCII в Unicode</p>
     <table>
      <tr align="left">
       <th rowspan="3" align="left" valign="top"/>
       <th align="left" valign="top">ЦП </th>
       <th align="left" valign="top">Pentium III </th>
       <th align="left" valign="top">Pentium III </th>
       <th align="left" valign="top">Pentium LT </th>
       <th align="left" valign="top">Celeron LT </th>
       <th align="left" valign="top">Xeon </th>
       <th align="left" valign="top">4&#215;Xeon</th>
      </tr>
      <tr align="left">
       <th align="left" valign="top">ОС </th>
       <th align="left" valign="top">W2000 </th>
       <th align="left" valign="top">W2000 </th>
       <th align="left" valign="top">W2000 </th>
       <th align="left" valign="top">XP </th>
       <th align="left" valign="top">W2000 </th>
       <th align="left" valign="top">W2000</th>
      </tr>
      <tr align="left">
       <th align="left" valign="top">Файловая система </th>
       <th align="left" valign="top">FAT </th>
       <th align="left" valign="top">NTFS </th>
       <th align="left" valign="top">NTFS </th>
       <th align="left" valign="top">NTFS </th>
       <th align="left" valign="top">NTFS </th>
       <th align="left" valign="top">NTFS</th>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">atou</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">3,24</td>
       <td align="left" valign="top">7,16</td>
       <td align="left" valign="top">33,53</td>
       <td align="left" valign="top">6,27</td>
       <td align="left" valign="top">5,77</td>
       <td align="left" valign="top">2,77</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время</td>
       <td align="left" valign="top">0,31</td>
       <td align="left" valign="top">0,33</td>
       <td align="left" valign="top">0,01</td>
       <td align="left" valign="top">0,06</td>
       <td align="left" valign="top">0,06</td>
       <td align="left" valign="top">0,08</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">0,46</td>
       <td align="left" valign="top">0,72</td>
       <td align="left" valign="top">3,55</td>
       <td align="left" valign="top">0,54</td>
       <td align="left" valign="top">0,63</td>
       <td align="left" valign="top">0,63</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">atouSS</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">3,77</td>
       <td align="left" valign="top">6,21</td>
       <td align="left" valign="top">43,53</td>
       <td align="left" valign="top">10,12</td>
       <td align="left" valign="top">5,68</td>
       <td align="left" valign="top">2,48</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время</td>
       <td align="left" valign="top">0,20</td>
       <td align="left" valign="top">0,23</td>
       <td align="left" valign="top">0,11</td>
       <td align="left" valign="top">0,07</td>
       <td align="left" valign="top">0,04</td>
       <td align="left" valign="top">0,14</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">0,52</td>
       <td align="left" valign="top">0,81</td>
       <td align="left" valign="top">3,17</td>
       <td align="left" valign="top">0,04</td>
       <td align="left" valign="top">0,35</td>
       <td align="left" valign="top">0,81</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">atouLB</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">4,38</td>
       <td align="left" valign="top">6,41</td>
       <td align="left" valign="top">28,51</td>
       <td align="left" valign="top">5,95</td>
       <td align="left" valign="top">4,75</td>
       <td align="left" valign="top">2,47</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время</td>
       <td align="left" valign="top">0,10</td>
       <td align="left" valign="top">0,07</td>
       <td align="left" valign="top">0,05</td>
       <td align="left" valign="top">0,03</td>
       <td align="left" valign="top">0,03</td>
       <td align="left" valign="top">0,08 </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">0,26</td>
       <td align="left" valign="top">0,34</td>
       <td align="left" valign="top">0,63</td>
       <td align="left" valign="top">0,19</td>
       <td align="left" valign="top">0,21</td>
       <td align="left" valign="top">0,187</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">atouLSFP</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">5,17</td>
       <td align="left" valign="top">1,38</td>
       <td align="left" valign="top">1,28</td>
       <td align="left" valign="top">2,03</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">0,07</td>
       <td align="left" valign="top">0,05</td>
       <td align="left" valign="top">0,09</td>
       <td align="left" valign="top">0,06 </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">0,61</td>
       <td align="left" valign="top">0,16</td>
       <td align="left" valign="top">0,10</td>
       <td align="left" valign="top">0,11</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">atouMM</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">4,35</td>
       <td align="left" valign="top">2,75</td>
       <td align="left" valign="top">3,46</td>
       <td align="left" valign="top">3,90</td>
       <td align="left" valign="top">3,74</td>
       <td align="left" valign="top">0,77 </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время</td>
       <td align="left" valign="top">0,27</td>
       <td align="left" valign="top">0,29</td>
       <td align="left" valign="top">0,09</td>
       <td align="left" valign="top">0,07</td>
       <td align="left" valign="top">0,05</td>
       <td align="left" valign="top">0,14 </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">0,19</td>
       <td align="left" valign="top">0,19</td>
       <td align="left" valign="top">0,16</td>
       <td align="left" valign="top">0,14</td>
       <td align="left" valign="top">0,10</td>
       <td align="left" valign="top">0,09</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">atouMT</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">4,84</td>
       <td align="left" valign="top">6,18</td>
       <td align="left" valign="top">5,83</td>
       <td align="left" valign="top">6,61</td>
       <td align="left" valign="top">5,99</td>
       <td align="left" valign="top">3,55 </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время</td>
       <td align="left" valign="top">0,14</td>
       <td align="left" valign="top">0,15</td>
       <td align="left" valign="top">0,26</td>
       <td align="left" valign="top">0,04</td>
       <td align="left" valign="top">0,06</td>
       <td align="left" valign="top">0,02 </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">0,45</td>
       <td align="left" valign="top">0,46</td>
       <td align="left" valign="top">0,66</td>
       <td align="left" valign="top">0,33</td>
       <td align="left" valign="top">0,15</td>
       <td align="left" valign="top">0,31</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">atouOV</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">9,54</td>
       <td align="left" valign="top">8,85</td>
       <td align="left" valign="top">32,42</td>
       <td align="left" valign="top">6,84</td>
       <td align="left" valign="top">5,63</td>
       <td align="left" valign="top">3,17</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время</td>
       <td align="left" valign="top">0,14</td>
       <td align="left" valign="top">0,12</td>
       <td align="left" valign="top">0,21</td>
       <td align="left" valign="top">0,06</td>
       <td align="left" valign="top">0,06</td>
       <td align="left" valign="top">0,06 </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">0,24</td>
       <td align="left" valign="top">0,23</td>
       <td align="left" valign="top">0,42</td>
       <td align="left" valign="top">0,18</td>
       <td align="left" valign="top">0,21</td>
       <td align="left" valign="top">0,17</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">atouEX</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">5,67</td>
       <td align="left" valign="top">5,92</td>
       <td align="left" valign="top">30,65</td>
       <td align="left" valign="top">6,50</td>
       <td align="left" valign="top">5,19</td>
       <td align="left" valign="top">2,64 </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время</td>
       <td align="left" valign="top">1,10</td>
       <td align="left" valign="top">1,50</td>
       <td align="left" valign="top">0,29</td>
       <td align="left" valign="top">0,35</td>
       <td align="left" valign="top">0,41</td>
       <td align="left" valign="top">0,64 </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">1,19</td>
       <td align="left" valign="top">1,74</td>
       <td align="left" valign="top">0,77</td>
       <td align="left" valign="top">0,69</td>
       <td align="left" valign="top">0,59</td>
       <td align="left" valign="top">1,91</td>
      </tr>
     </table>
    </section>
    <section>
     <title>
      <p>Поиск заданных комбинаций символов</p>
     </title>
     <p>Тестирование производительности путем выполнения поиска определенных текстовых шаблонов в содержимом файлов производилось с использованием трех различных методов, что позволило оценить сравнительную эффективность многопоточного и многопроцессного режимов, а также простой последовательной обработки файлов (см. табл. В.З).</p>
     <p>1. Программа grepMP (программа 6.1) использует параллельные процессы, каждый из которых обрабатывает отдельный файл. Результаты измерений системного и пользовательского времени не приводятся, поскольку программа timep позволяет хронометрировать лишь родительские процессы.</p>
     <p>2. Программа grepMT (программа 7.1) использует параллельные потоки.</p>
     <p>3. Программа grepSQ — это пакетный файл DOS, обеспечивающий выполнение поиска шаблонов по очереди в каждом из файлов. В этом случае также приводятся только результаты, относящиеся к реальному времени.</p>
     <p>В этом тесте использовались 20 файлов с размерами в пределах от нескольких Кбайт до 1 Мбайт.</p>
     <subtitle><emphasis>Комментарии</emphasis></subtitle>
     <p>1. В большинстве случаев все три методики приводят к близким результатам на однопроцессорных системах. Исключением является лэптоп с процессором Pentium, для которого версия grepMP систематически оказывалась самой медленной.</p>
     <p>2. Многопоточный режим обладает лишь незначительными преимуществами по сравнению с многопроцессным даже на однопроцессорных системах.</p>
     <p>3. Показатели пользовательского и системного времени имеют ощутимо заметные значения лишь в случае многопоточных версий</p>
     <p>4. SMP-системы демонстрируют выигрыш в производительности, который достигается и при использовании многопоточного режима или нескольких однопоточных процессов. Заметьте, что общее пользовательское время превышает реальное время, поскольку характеризует одновременно все четыре процесса.</p>
     <p>5. Тот факт, что последовательная обработка файлов приводит на однопроцессорных системам к аналогичным результатам, говорит о том, что простейшее решение нередко оказывается и самым лучшим.</p>
     <empty-line/>
     <p>Таблица В.З. Показатели производительности программ поисказаданных комбинаций символов</p>
     <table>
      <tr align="left">
       <th rowspan="3" align="left" valign="top"/>
       <th align="left" valign="top">ЦП </th>
       <th align="left" valign="top">Pentium LT </th>
       <th align="left" valign="top">Celeron LT </th>
       <th align="left" valign="top">Xeon </th>
       <th align="left" valign="top">4&#215;Xeon</th>
      </tr>
      <tr align="left">
       <th align="left" valign="top">ОС </th>
       <th align="left" valign="top">W2000 </th>
       <th align="left" valign="top">XP </th>
       <th align="left" valign="top">W2000 </th>
       <th align="left" valign="top">W2000</th>
      </tr>
      <tr align="left">
       <th align="left" valign="top">Файловая система </th>
       <th align="left" valign="top">NTFS </th>
       <th align="left" valign="top">NTFS </th>
       <th align="left" valign="top">NTFS </th>
       <th align="left" valign="top">NTFS</th>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">grepMP</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">14,72</td>
       <td align="left" valign="top">3,95</td>
       <td align="left" valign="top">10,58</td>
       <td align="left" valign="top">0,63</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">-</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">-</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">grepMT</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">7,08</td>
       <td align="left" valign="top">3,61</td>
       <td align="left" valign="top">8,09</td>
       <td align="left" valign="top">0,73</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время</td>
       <td align="left" valign="top">0,30</td>
       <td align="left" valign="top">0,41</td>
       <td align="left" valign="top">0,27</td>
       <td align="left" valign="top">2,23 </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">0,09</td>
       <td align="left" valign="top">0,47</td>
       <td align="left" valign="top">0,13</td>
       <td align="left" valign="top">0,28</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">grepSQ</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">6,71</td>
       <td align="left" valign="top">3,86</td>
       <td align="left" valign="top">6,71</td>
       <td align="left" valign="top">0,97</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">-</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">-</td>
       <td align="left" valign="top">-</td>
      </tr>
     </table>
    </section>
    <section>
     <title>
      <p>Сортировка файлов</p>
     </title>
     <p>Для тестирования четырех вариантов реализации программ сортировки из главы 5 использовался целевой файл, состоящий из 100 000 записей размером 64 байта каждая (всего 6,4 Мбайт). Вывод отсортированного файла во всех случаях подавлялся, чтобы можно было оценивать только время, необходимое для выполнения собственно сортировки. После этого тестировалась многопоточная сортировка (программа 7.2) файла размером 25 Мбайт, состоящего из 400 000 записей размером 64 байта каждая, с использованием одной, двух и четырех потоков. В каждом отдельном запуске использовался отдельный файл, генерируемый программой RandFile, которая находится в каталоге главы 5. Результаты для разных запусков заметно различались между собой.</p>
     <p>1. Программа sortBT (программа 5.1) создает бинарное дерево поиска, требующее выделения минимального объема памяти под каждую запись. Эта программа интенсивно использует процессор.</p>
     <p>2. Программа sortFL (программа 5.4) создает отображение файла перед тем, как использовать программу qsort. Тестировалась также программа sortFLSR (доступ к куче подвергался сериализации), однако существенных отличий от предыдущего варианта замечено не было.</p>
     <p>3. Текст программы sortHP в книге не приводился. Эта программа предварительно распределяет буфер для файла, а затем сортирует файл, считанный в этот буфер, а не его отображение, как программа sortFL.</p>
     <p>4. Программа sortMM (программа 5.5) создает постоянно существующий индексный файл.</p>
     <p>5. Программа sortMT (программа 7.2) реализует многопоточную сортировку слиянием. Результаты представлены в строках sortMT1, sortMT2 и sortMT4 в соответствии с количеством параллельных потоков. Результаты могут значительно меняться в зависимости от характера сортируемых данных, хотя размер и случайный характер распределения значений данных сглаживают эти различия, что, как правило, характерно для базового алгоритма быстрой сортировки, который использован для реализации функции qsort библиотеки С.</p>
     <subtitle><emphasis>Комментарии</emphasis></subtitle>
     <p>1. Реализация, использующая алгоритм бинарного дерева (программа sortBT), интенсивно использует процессор; кроме того, память в ней распределяется отдельно для каждой записи.</p>
     <p>2. Применение отображения файлов и чтение файла в предварительно выделенный буфер обеспечивают примерно одинаковую производительность, но в этих тестах отображение файлов ничем особенным себя не проявило, а в некоторых случаях даже значительно ухудшало результаты. Вместе с тем, в ряде случаев как sortFL, так и sortHP обеспечивали превосходные результаты.</p>
     <p>3. Суммарное пользовательское и системное время иногда превышает истекшее время, даже если используется только один поток.</p>
     <p>4. Программа sortMT демонстрирует возможности SMP-систем. В некоторых случаях использование дополнительных потоков приводило к повышению производительности и на однопроцессорных системах.</p>
     <empty-line/>
     <p>Таблица В.4. Показатели производительности программ сортировки файлов</p>
     <table>
      <tr align="left">
       <th rowspan="3" align="left" valign="top"/>
       <th align="left" valign="top">ЦП </th>
       <th align="left" valign="top">Pentium LT </th>
       <th align="left" valign="top">Celeron LT </th>
       <th align="left" valign="top">Xeon </th>
       <th align="left" valign="top">4&#215;Xeon</th>
      </tr>
      <tr align="left">
       <th align="left" valign="top">ОС </th>
       <th align="left" valign="top">W2000  </th>
       <th align="left" valign="top">XP </th>
       <th align="left" valign="top">W2000 </th>
       <th align="left" valign="top">W2000</th>
      </tr>
      <tr align="left">
       <th align="left" valign="top">Файловая система</th>
       <th align="left" valign="top">NTFS</th>
       <th align="left" valign="top">NTFS</th>
       <th align="left" valign="top">NTFS</th>
       <th align="left" valign="top">NTFS</th>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">sortBT</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">- </td>
       <td align="left" valign="top">9,61 </td>
       <td align="left" valign="top">- </td>
       <td align="left" valign="top">-</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время </td>
       <td align="left" valign="top">- </td>
       <td align="left" valign="top">1,84 </td>
       <td align="left" valign="top">- </td>
       <td align="left" valign="top">-</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время </td>
       <td align="left" valign="top">- </td>
       <td align="left" valign="top">7,44 </td>
       <td align="left" valign="top">- </td>
       <td align="left" valign="top">-</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">sortFL</td>
       <td align="left" valign="top">Реальное время </td>
       <td align="left" valign="top">11,15 </td>
       <td align="left" valign="top">0,78 </td>
       <td align="left" valign="top">1,74 </td>
       <td align="left" valign="top">5,38</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время </td>
       <td align="left" valign="top">4,81 </td>
       <td align="left" valign="top">0,41 </td>
       <td align="left" valign="top">0,26 </td>
       <td align="left" valign="top">5,19</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время </td>
       <td align="left" valign="top">0,15 </td>
       <td align="left" valign="top">0,09 </td>
       <td align="left" valign="top">0,09 </td>
       <td align="left" valign="top">0,02</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">sortHP </td>
       <td align="left" valign="top">Реальное время </td>
       <td align="left" valign="top">1,76 </td>
       <td align="left" valign="top">0,34 </td>
       <td align="left" valign="top">1,52 </td>
       <td align="left" valign="top">1,30</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время </td>
       <td align="left" valign="top">1,62 </td>
       <td align="left" valign="top">0,22 </td>
       <td align="left" valign="top">0,15 </td>
       <td align="left" valign="top">1,28</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время </td>
       <td align="left" valign="top">0,11 </td>
       <td align="left" valign="top">0,05 </td>
       <td align="left" valign="top">0,03 </td>
       <td align="left" valign="top">0,04</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">sortMM </td>
       <td align="left" valign="top">Реальное время </td>
       <td align="left" valign="top">0,99 </td>
       <td align="left" valign="top">1,44 </td>
       <td align="left" valign="top">1,92 </td>
       <td align="left" valign="top">1,39</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время </td>
       <td align="left" valign="top">0,31 </td>
       <td align="left" valign="top">0,18 </td>
       <td align="left" valign="top">0,15 </td>
       <td align="left" valign="top">0,38</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время </td>
       <td align="left" valign="top">0,68 </td>
       <td align="left" valign="top">0,47 </td>
       <td align="left" valign="top">0,36 </td>
       <td align="left" valign="top">1,03</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">sortMT1 </td>
       <td align="left" valign="top">Реальное время </td>
       <td align="left" valign="top">3,18 </td>
       <td align="left" valign="top">3,58 </td>
       <td align="left" valign="top">6,80 </td>
       <td align="left" valign="top">0,14</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время </td>
       <td align="left" valign="top">0,01 </td>
       <td align="left" valign="top">0,95 </td>
       <td align="left" valign="top">0,01 </td>
       <td align="left" valign="top">0,05</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время </td>
       <td align="left" valign="top">0,46 </td>
       <td align="left" valign="top">0,16 </td>
       <td align="left" valign="top">0,16 </td>
       <td align="left" valign="top">0,11</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">sortMT2 </td>
       <td align="left" valign="top">Реальное время </td>
       <td align="left" valign="top">2,10 </td>
       <td align="left" valign="top">1,22</td>
       <td align="left" valign="top">6,70 </td>
       <td align="left" valign="top">0,13</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время </td>
       <td align="left" valign="top">0,01 </td>
       <td align="left" valign="top">1,05 </td>
       <td align="left" valign="top">0,01 </td>
       <td align="left" valign="top">0,02</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время </td>
       <td align="left" valign="top">0,40 </td>
       <td align="left" valign="top">0,16 </td>
       <td align="left" valign="top">0,16 </td>
       <td align="left" valign="top">0,13</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">sortMT4 </td>
       <td align="left" valign="top">Реальное время </td>
       <td align="left" valign="top">2,20 </td>
       <td align="left" valign="top">1,49 </td>
       <td align="left" valign="top">6,22 </td>
       <td align="left" valign="top">0,13</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время </td>
       <td align="left" valign="top">0,01 </td>
       <td align="left" valign="top">1,18 </td>
       <td align="left" valign="top">0,01 </td>
       <td align="left" valign="top">0,12</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">0,16</td>
       <td align="left" valign="top">0,15</td>
       <td align="left" valign="top">0,16</td>
       <td align="left" valign="top">0,09</td>
      </tr>
     </table>
    </section>
    <section>
     <title>
      <p>Множество потоков, соревнующихся между собой за обладание единственным ресурсом</p>
     </title>
     <p>Целью этой серии тестов являлось сравнение эффективности различных стратегий реализации функций управления очередями программы 10.4 с использованием программы 10.5 (трехступенчатый конвейер) в качестве тестового приложения. Тесты выполнялись на четырехпроцессорной (Intel Xeon, 1 ГГц) системе Windows 2000 Server с организацией 1, 2, 4, 8, 16, 32 и 64 потоков, но во всех семи случаях каждого потока поручалось выполнение 1000 единиц работы. В идеальном случае можно было бы ожидать линейного увеличения реального времени с увеличением количества потоков, но соревновательность между потоками за право владения единственным мьютексом (или объектом CS) может приводить к нелинейному снижению этого показателя). Обратите внимание, что эти тесты не затрагивают файловую систему.</p>
     <p>Использовались шесть различных стратегий реализации, результаты применения которых представлены в отдельных столбцах табл. В.5.</p>
     <empty-line/>
     <p>Таблица В.5. Производительность многопоточных реализаций на четырехпроцессорном сервере</p>
     <table>
      <tr align="left">
       <th rowspan="3" align="left" valign="top">К-во потоков </th>
       <th rowspan="3" align="left" valign="top"/>
       <th align="left" valign="top">Широковещат.модель </th>
       <th align="left" valign="top">Широковещат.модель </th>
       <th align="left" valign="top">Широковещат. модель </th>
       <th align="left" valign="top">Сигнальная модель </th>
       <th align="left" valign="top">Сигнальная модель </th>
       <th align="left" valign="top">Сигнальная модель</th>
      </tr>
      <tr align="left">
       <th align="left" valign="top">Mtx, Evt </th>
       <th align="left" valign="top">CritSec, Evt </th>
       <th align="left" valign="top">Mtx, Evt </th>
       <th align="left" valign="top">Mtx, Evt </th>
       <th align="left" valign="top">CritSec, Evt </th>
       <th align="left" valign="top">Mtx, Evt</th>
      </tr>
      <tr align="left">
       <th align="left" valign="top">Т/О 5мс </th>
       <th align="left" valign="top">Т/О 25мс </th>
       <th align="left" valign="top">SigObjWait </th>
       <th align="left" valign="top">Т/О неопределен </th>
       <th align="left" valign="top">Т/О неопределен </th>
       <th align="left" valign="top">SigObjWait</th>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">1</td>
       <td align="left" valign="top">Реальное время </td>
       <td align="left" valign="top">0,03 </td>
       <td align="left" valign="top">0,03 </td>
       <td align="left" valign="top">0,05 </td>
       <td align="left" valign="top">0,05 </td>
       <td align="left" valign="top">0,03 </td>
       <td align="left" valign="top">0,05</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время</td>
       <td align="left" valign="top">0,03 </td>
       <td align="left" valign="top">0,06 </td>
       <td align="left" valign="top">0,03 </td>
       <td align="left" valign="top">0,05 </td>
       <td align="left" valign="top">0,08 </td>
       <td align="left" valign="top">0,05</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время </td>
       <td align="left" valign="top">0,06 </td>
       <td align="left" valign="top">0,02 </td>
       <td align="left" valign="top">0,09 </td>
       <td align="left" valign="top">0,08 </td>
       <td align="left" valign="top">0,02 </td>
       <td align="left" valign="top">0,06</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">2 </td>
       <td align="left" valign="top">Реальное время </td>
       <td align="left" valign="top">0,14 </td>
       <td align="left" valign="top">0,27 </td>
       <td align="left" valign="top">0,09 </td>
       <td align="left" valign="top">0,08 </td>
       <td align="left" valign="top">0,06 </td>
       <td align="left" valign="top">0,08</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время </td>
       <td align="left" valign="top">0,13 </td>
       <td align="left" valign="top">0,05 </td>
       <td align="left" valign="top">0,14  </td>
       <td align="left" valign="top">0,17 </td>
       <td align="left" valign="top">0,11 </td>
       <td align="left" valign="top">0,08</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время </td>
       <td align="left" valign="top">0,11 </td>
       <td align="left" valign="top">0,06 </td>
       <td align="left" valign="top">0,16 </td>
       <td align="left" valign="top">0,09 </td>
       <td align="left" valign="top">0,11 </td>
       <td align="left" valign="top">0,17</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">4 </td>
       <td align="left" valign="top">Реальное время </td>
       <td align="left" valign="top">0,39</td>
       <td align="left" valign="top">0,59</td>
       <td align="left" valign="top">0,23</td>
       <td align="left" valign="top">0,19</td>
       <td align="left" valign="top">0,16</td>
       <td align="left" valign="top">0,20</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время </td>
       <td align="left" valign="top">0,18 </td>
       <td align="left" valign="top">0,17 </td>
       <td align="left" valign="top">0,22 </td>
       <td align="left" valign="top">0,26 </td>
       <td align="left" valign="top">0,17 </td>
       <td align="left" valign="top">0,19</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время </td>
       <td align="left" valign="top">0,30 </td>
       <td align="left" valign="top">0,22 </td>
       <td align="left" valign="top">0,41 </td>
       <td align="left" valign="top">0,31 </td>
       <td align="left" valign="top">0,22 </td>
       <td align="left" valign="top">0,31</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">8</td>
       <td align="left" valign="top">Реальное время </td>
       <td align="left" valign="top">0,83 </td>
       <td align="left" valign="top">0,92 </td>
       <td align="left" valign="top">0,73 </td>
       <td align="left" valign="top">0,36 </td>
       <td align="left" valign="top">0,34 </td>
       <td align="left" valign="top">0,36</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время</td>
       <td align="left" valign="top">0,34</td>
       <td align="left" valign="top">0,36</td>
       <td align="left" valign="top">0,55</td>
       <td align="left" valign="top">0,52</td>
       <td align="left" valign="top">0,45</td>
       <td align="left" valign="top">0,45</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">0,98</td>
       <td align="left" valign="top">1,00</td>
       <td align="left" valign="top">1,00</td>
       <td align="left" valign="top">0,69</td>
       <td align="left" valign="top">0,39</td>
       <td align="left" valign="top">0,75</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">16</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">2,42</td>
       <td align="left" valign="top">2,30</td>
       <td align="left" valign="top">2,38</td>
       <td align="left" valign="top">0,75</td>
       <td align="left" valign="top">0,69</td>
       <td align="left" valign="top">0,75</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время</td>
       <td align="left" valign="top">1,17</td>
       <td align="left" valign="top">1,31</td>
       <td align="left" valign="top">1,22</td>
       <td align="left" valign="top">0,81</td>
       <td align="left" valign="top">0,81</td>
       <td align="left" valign="top">0,88 </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">3,69</td>
       <td align="left" valign="top">3,05</td>
       <td align="left" valign="top">3,39</td>
       <td align="left" valign="top">1,45</td>
       <td align="left" valign="top">1,08</td>
       <td align="left" valign="top">1,33</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">32</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">7,56</td>
       <td align="left" valign="top">7,50</td>
       <td align="left" valign="top">7,98</td>
       <td align="left" valign="top">1,50</td>
       <td align="left" valign="top">1,50</td>
       <td align="left" valign="top">1,50</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время</td>
       <td align="left" valign="top">3,33</td>
       <td align="left" valign="top">3,73</td>
       <td align="left" valign="top">2,56</td>
       <td align="left" valign="top">1,75</td>
       <td align="left" valign="top">1,69</td>
       <td align="left" valign="top">1,78</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">12,52</td>
       <td align="left" valign="top">10,72</td>
       <td align="left" valign="top">11,03</td>
       <td align="left" valign="top">3,13</td>
       <td align="left" valign="top">2,00</td>
       <td align="left" valign="top">2,69</td>
      </tr>
      <tr align="left">
       <td rowspan="3" align="left" valign="top">64</td>
       <td align="left" valign="top">Реальное время</td>
       <td align="left" valign="top">27,72</td>
       <td align="left" valign="top">26,23</td>
       <td align="left" valign="top">29,31</td>
       <td align="left" valign="top">3,14</td>
       <td align="left" valign="top">2,95</td>
       <td align="left" valign="top">3,20 </td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Пользовательское время</td>
       <td align="left" valign="top">7,89</td>
       <td align="left" valign="top">10,75</td>
       <td align="left" valign="top">7,22</td>
       <td align="left" valign="top">3,73</td>
       <td align="left" valign="top">3,69</td>
       <td align="left" valign="top">3,47</td>
      </tr>
      <tr align="left">
       <td align="left" valign="top">Системное время</td>
       <td align="left" valign="top">46,70</td>
       <td align="left" valign="top">40,33</td>
       <td align="left" valign="top">36,67</td>
       <td align="left" valign="top">6,28</td>
       <td align="left" valign="top">3,89</td>
       <td align="left" valign="top">5,47</td>
      </tr>
     </table>
     <p>В комментариях, помещенных вслед за программой 10.4, обсуждаются результаты и разъясняются преимущества различных реализаций, а здесь мы лишь отметим, что результаты для сигнальной модели изменяются пропорционально изменению количества потоков, тогда как в случае широковещательной модели, особенно для вариантов с 32 и 64 потоками, это не так. Можно также видеть, что в случае широковещательной модели система потребляет значительную долю процессорного времени, ибо выполняются, вычисляют предикат и осуществляют немедленный возврат в состояние ожидания множество потоков.</p>
     <p>1. Широковещательная модель, мьютекс (Mtx), событие (Evt), раздельные вызовы функций освобождения и ожидания. Конечный период ожидания (Time-out, TO) устанавливался равным 5 миллисекундам, что являлось оптимальным значением для 16-поточного варианта.</p>
     <p>2. Широковещательная модель, объект CRITICAL_SECTION (CritSec), событие, раздельные вызовы функций освобождения и ожидания. Настраиваемый период ожидания устанавливался равным 5 миллисекундам, что являлось оптимальным значением для 16-поточного варианта.</p>
     <p>3. Широковещательная модель, мьютекс, событие, атомарный вызов SignalObjectAndWait (SigObjWait).</p>
     <p>4. Сигнальная модель, мьютекс, событие, раздельные вызовы функций освобождения и ожидания.</p>
     <p>5. Сигнальная модель, объект CRITICAL_SECTION, событие, раздельные вызовы функций освобождения и ожидания.</p>
     <p>6. Сигнальная модель, мьютекс, событие, атомарный вызов SignalObjectAndWait.</p>
    </section>
   </section>
   <section>
    <title>
     <p>Выполнение тестов</p>
    </title>
    <p>На Web-сайте книги в каталоге TimeTest находятся пакетные файлы, с помощью которых вы сможете запускать тесты как под управлением Windows 2000/NT, так и под управлением Windows 9x:</p>
    <p><code>• cpTIME.bat</code></p>
    <p><code>• cpTIME.bat</code></p>
    <p><code>• atouTIME.bat</code></p>
    <p><code>• grepTIME.bat</code></p>
    <p><code>• sortTIME.bat</code></p>
    <p><code>• threeST.bat</code></p>
    <p>Для всех тестов, кроме тестов последней серии, текстовые ASCII-файлы большого размера создавались с помощью программы RandFile.</p>
   </section>
  </section>
  <section>
   <title>
    <p>Библиография</p>
   </title>
   <p>1. Beveridge, Jim, and Wiener, Robert. <emphasis>Multithreading Applications in Win32: The Complete Guide to Threads,</emphasis> Addison-Wesley, Reading, MA, 1997. ISBN: 0-201-44234-5.</p>
   <p>2. Bott, Ed, and Siechert, Carl. <emphasis>Microsoft Windows Security Inside Out for Windows XP and Windows 2000,</emphasis> Microsoft Press, Redmond, WA, 2002. ISBN: 0-735-61632-9.</p>
   <p>3. Box, Don. <emphasis>Essential COM,</emphasis> Addison-Wesley, Reading, MA, 1998. ISBN: 0-201-63446-5.</p>
   <p>4. Box, Don (editor), et al. <emphasis>Effective COM: 50 Ways to Improve Your COM and MTS Based Applications,</emphasis> Addison-Wesley, Reading, MA, 1999. ISBN: 0-20-1-37968-6.</p>
   <p>5. Brain, Marshall, and Reeves, Ron. <emphasis>Win32 System Services: The Heart of Windows 98 and Windows 2000, Third Edition,</emphasis> Prentice Hall, Englewood Cliffs, NJ, 2000. ISBN: 0-13-022557-6.</p>
   <p>6. Butenhof, David. <emphasis>Programming with POSIX Threads,</emphasis> Addison-Wesley, Reading, MA, 1997. ISBN: 0-201-63392-2.</p>
   <p>7. Cohen, Aaron, Woodring, Mike, and Petrusha, Ronald. <emphasis>Win32 Multithreaded Programming,</emphasis> О'Reilley &amp; Associates, Sebastopol, CA, 1998. ISBN: 1-565-92296-4.</p>
   <p>8. Comer, Douglas E., and Stevens, David L. <emphasis>Internetworking with TCP/IP, Volume III: Client-Server Programming and Applications, Windows Sockets Version,</emphasis> Prentice Hall, Upper Saddle River, NJ, 1997. ISBN: 0-13-848714-6.</p>
   <p>9. Custer, Helen. <emphasis>Inside Windows NT,</emphasis> Microsoft Press, Redmond, WA, 1993. ISBN: 155615-481-X. <emphasis>Second edition by David Solomon replaces this book, which in turn is replaced by Solomon and Russinovich (both in this bibliography).</emphasis></p>
   <p>10. Custer, Helen. <emphasis>Inside the Windows NT File System,</emphasis> Microsoft Press, Redmond, WA, 1994. ISBN: 155615-660-X.</p>
   <p>11. Department of Defense. <emphasis>U.S. Department of Defense Trusted Computer System Evaluation Criteria,</emphasis> formerly known as <emphasis>DoD Trusted Computer System Evaluation Criteria</emphasis>, DoD 5200.28-STD, DoD Computer Security Center, 1985. Available at http://www.radium.ncsc.mil/tpep/library/rainbow.</p>
   <p>12. Donahoo, Michael, and Calvert, Kenneth. <emphasis>TCP/IP Sockets in C: Practical Guide for Programmers,</emphasis> Morgan Kaufmann, San Francisco, CA, 2000. ISBN: 1-55860-826-5.</p>
   <p>13. Eddon, G., and Eddon, D. <emphasis>Inside Distributed COM,</emphasis> Microsoft Press, Redmond, WA, 1998. ISBN: 1-57231-849-X.</p>
   <p>14. Feuer, Alan. <emphasis>MFC Programming,</emphasis> Addison-Wesley, Reading, MA, 1997. ISBN: 0-201-63358-2.</p>
   <p>15. Gilly, Daniel, and the staff of O'Reilly &amp; Associates, Inc. <emphasis>UNIX in a Nutshell,</emphasis> O'Reilly &amp; Associates, Inc., Sebastopol, CA, 1992. ISBN: 1-56592-001-5.</p>
   <p>16. Hennessy, John L., and Patterson, David A. <emphasis>Computer Architecture: A Quantitative Approach, Third Edition,</emphasis> Morgan Kaufmann, San Francisco, CA, 2003. ISBN: 1-55860-596-7.</p>
   <p>17. Hipson, Peter D. <emphasis>Expert Guide to Windows NT 4 Registry,</emphasis> Sybex, 1999. ISBN: 0-7821-1983-2.</p>
   <p>18. Josutis, Nicolai M. <emphasis>The C++ Standard Library: A Tutorial and Reference,</emphasis> Addison-Wesley, Reading, MA, 1999. ISBN: 0-20-137926-0.</p>
   <p>19. Kano, Nadine. <emphasis>Developing International Applications for Windows 95 and Windows NT,</emphasis> Microsoft Press, Redmond, WA, 1995. ISBN: 1-55615-840-8.</p>
   <p>20. Kernighan, Brian W., and Ritchie, Dennis M. <emphasis>The С Programming Language, Second Edition</emphasis>, Prentice-Hall, Englewood Cliffs, NJ, 1988. ISBN: 0-13-110370-9.</p>
   <p>21. Miller, Kevin. <emphasis>Professional NT Services,</emphasis> WROX, Indianapolis, IN, 1998. ISBN: 1-86100-130-4.</p>
   <p>22. Naik, Dilip. <emphasis>Inside Windows Storage — Server Storage Technologies for Windows 2000, Windows Serve r2003, and Beyond,</emphasis> Addison-Wesley, Boston, MA, 2003. ISBN: 0-321-12698-X.</p>
   <p>23. Nottingham, Jason P., Makofsky, Steven, and Tucker, Andrew. <emphasis>SAMS Teach Yourself Windows CE Programming in 24 Hours,</emphasis> SAMS, Indianapolis, IN, 1999. ISBN: 0-6723-1658-7.</p>
   <p>24. Oney, Walter. <emphasis>Programming the Microsoft Windows Driver Model, Second Edition</emphasis>, Microsoft Press, Redmond, WA, 2002. ISBN: 0-735-61803-8.</p>
   <p>25. Petzold, Charles. <emphasis>Programming Windows, Fifth Edition,</emphasis> Microsoft Press, Redmond, WA, 1998. ISBN: 1-572-31995-X.</p>
   <p>26. Pham, Thuan, and Garg, Pankaj. <emphasis>Multithreaded Programming with Win32,</emphasis> Prentice-Hall, Englewood Cliffs, NJ, 1998. ISBN: 0-130-10912-6.</p>
   <p>27. Plauger, P.J. <emphasis>The Standard С Library,</emphasis> Prentice-Hall, Englewood Cliffs, NJ, 1992. ISBN: 0-13-131509-9.</p>
   <p>28. Quinn, Bob, and Shute, Dave. <emphasis>Windows Sockets Network Programming,</emphasis> Addison-Wesley, Reading, MA, 1996. ISBN: 0-201-63372-8.</p>
   <p>29. Raymond, Eric S. <emphasis>The Art of UNIX Programming,</emphasis> Addison-Wesley, Boston, MA, 2003. ISBN: 0-131-42901-9.</p>
   <p>30. Rector, Brent, and Newcomer, Joseph M. <emphasis>Win 32 Programming,</emphasis> Addison-Wesley, Reading, MA, 1997. ISBN: 0-201-63492-9.</p>
   <p>31. Richter, Jeffrey. <emphasis>Programming Applications for Microsoft Windows</emphasis> (formerly <emphasis>Advanced Windows NT: The Developer's Guide to the Win32 Application Programming Interface </emphasis>in previous editions), Microsoft Press, Redmond, WA, 1999. ISBN: 1-57-231996-8.</p>
   <p>32. Richter, Jeffrey, and Clark, Jason. <emphasis>Programming Server-Side Applications for Microsoft Windows 2000,</emphasis> Microsoft Press, Redmond, WA, 2000. ISBN: 0-73-560753-2.</p>
   <p>33. Robbins, Kay A., and Robbins, Steven. <emphasis>Practical UNIX Programming: A Guide to Concurrency, Communication, and Multithreading,</emphasis> Prentice-Hall, Englewood Cliffs, NJ, 1995. ISBN: 0-13-443706-3.</p>
   <p>34. Sedgewick, Robert. <emphasis>Algorithms in C,</emphasis> Addison-Wesley, Reading, MA, 1990. ISBN: 0201-51425-7.</p>
   <p>35. Silberschatz, Abraham, Gagne, Greg, and Galvin, Peter B. <emphasis>Operating System Concepts, Sixth Edition,</emphasis> Wiley Textbooks, Hoboken, NJ, 2002. ISBN: 0-471-25060-0.</p>
   <p>36. Sinha, Alok K. <emphasis>Network Programming in Windows NT,</emphasis> Addison-Wesley, Reading, MA, 1996. ISBN: 0-201-59056-5.</p>
   <p>37. Solomon, David. <emphasis>Inside Windows NT, Second Edition,</emphasis> Microsoft Press, Redmond, WA, 1998. ISBN: 1-57-231677-2.</p>
   <p>38. Solomon, David, and Russinovich, Mark. <emphasis>Inside Windows 2000,</emphasis> Microsoft Press, Redmond, WA, 2000. ISBN: 1-73-561021-5.</p>
   <p>39. Standish, Thomas A. <emphasis>Data Structures, Algorithms and Software Principles in C,</emphasis> Addison-Wesley, Reading, MA, 1995. ISBN: 0-201-59118-9.</p>
   <p>40. Stevens, W. Richard. <emphasis>Advanced Programming in the UNIX Environment,</emphasis> Addison-Wesley, Reading, MA, 1992. ISBN: 0-201-56317-7.</p>
   <p>41. Stevens, W. Richard. <emphasis>TCP/IP Illustrated, Volume3: TCP for Transactions, HTTP, NNTP, and the UNIX Domain Protocols,</emphasis> Addison-Wesley, Reading, MA, 1996. ISBN:0-201-63495-3.</p>
   <p>42. Stevens, W. Richard. <emphasis>UNIX Network Programming — Networking APIs: Sockets and XTI, Volume I,</emphasis> Prentice-Hall, Upper Saddle River, NJ, 1998. ISBN: 0-13-490012-X.</p>
   <p>43. Sutton, Stephen A. <emphasis>Windows NT Security Guide,</emphasis> Addison-Wesley, Reading, MA, 1997. ISBN: 0-201-41969-6.</p>
   <p>44. Triebel, Walter A. <emphasis>Itanium Architecture for Software Developers,</emphasis> Intel Press, 2000. ISBN: 0-970-28464-0.</p>
   <p>45. Unicode Consortium, The. <emphasis>The Unicode Standard, Version 2.0,</emphasis> Addison-Wesley, Reading, MA, 1996. ISBN: 0-201-48345-9.</p>
   <p>46. Weiss, Mark Allen. <emphasis>Data Structures and Algorithm Analysis in C,</emphasis> Addison-Wesley, Reading, MA, 1993. ISBN: 0-8053-5440-9.</p>
   <p>47. Williams, Robert, and Walla, Mark. <emphasis>The Ultimate Windows Server 2003 System Administrator's Guide,</emphasis> Addison-Wesley, Boston, MA, 2003. ISBN: 0-201-79106-4.</p>
   <p>48. Керниган, Брайан, Ритчи, Деннис, <emphasis>Язык программирования Си,</emphasis> "Невский Диалект", 2000.</p>
   <p>49. Реймонд, Эрик, <emphasis>Искусство программирования для UNIX,</emphasis> Издательский дом "Вильямс", 2005.</p>
  </section>
 </body>
 <body name="notes">
  <title>
   <p>Примечания</p>
  </title>
  <section id="n_1">
   <title>
    <p>1</p>
   </title>
   <p>Тем не менее, в тех местах книги, где речь идет о средствах, неприменимых в Windows 9х, делаются соответствующие оговорки.</p>
  </section>
  <section id="n_2">
   <title>
    <p>2</p>
   </title>
   <p>Автор вовсе не стремится каким-либо образом дополнить существующие коммерческие продукты, а также продукты с открытым исходным кодом, в которых предоставляются полные наборы утилит UNIX. Хотя приводимые примеры и могут найти практическое применение, они предназначены, главным образом, для того, чтобы продемонстрировать возможности функций Windows. Как бы то ни было, читатели, не знакомые с UNIX, не будут испытывать каких-либо трудностей в понимании программ или их функциональности.</p>
  </section>
  <section id="n_3">
   <title>
    <p>3</p>
   </title>
   <p>Замечания, сделанные в адрес UNIX, в равной степени относятся также к Linux и некоторым другим системам, поддерживающим POSIX API.</p>
  </section>
  <section id="n_4">
   <title>
    <p>4</p>
   </title>
   <p>Иногда, имея в виду в основном серверы, но не исключая и персональные приложения, говорят о возможной угрозе преобладанию Windows со стороны Linux. Хотя сама по себе эта тема является чрезвычайно интересной, размышления о путях будущего развития систем, не имеющие непосредственного отношения к рассмотрению сравнительных достоинств и недостатков Windows и Linux, выходят за рамки данной книги.</p>
  </section>
  <section id="n_5">
   <title>
    <p>5</p>
   </title>
   <p>О том, насколько разнообразен круг систем, на которых может быть развернута Windows, говорит хотя бы тот факт, что диапазон компьютеров, использованных для тестирования приведенных в этой книге примеров программ, простирается от давно забытой 486-й модели с 16 Мбайт ОЗУ до четырехпроцессорного (процессоры Xeon с рабочей частотой 2 ГГц) сервера масштаба предприятия, оборудованного ОЗУ емкостью 8 Гбайт.</p>
  </section>
  <section id="n_6">
   <title>
    <p>6</p>
   </title>
   <p>Протоколы Windows Sockets и RPC не являются частью самой Windows, что не воспрепятствовало описанию сокетов в данной книге, поскольку они самым непосредственным образом укладываются в рамки интересующей нас общей темы и используемого подхода.</p>
  </section>
  <section id="n_7">
   <title>
    <p>7</p>
   </title>
   <p>Несмотря на аналогию между упомянутыми дескрипторами и дескрипторами HWND и HDC, используемыми при написании программ для Windows GUI, между ними существует ряд отличий.</p>
  </section>
  <section id="n_8">
   <title>
    <p>8</p>
   </title>
   <p>Такие типы, как PVOID, входят в include-файлы без префикса, но в примерах мы будем придерживаться правил их употребления, принятых во многих книгах и документации Microsoft.</p>
  </section>
  <section id="n_9">
   <title>
    <p>9</p>
   </title>
   <p>О том, какими быстрыми темпами улучшаются показатели стоимости и производительности, вы можете судить хотя бы по тому факту, что еще в 1997 году в первом издании этой книги автор, без тени смущения или неловкости, в качестве необходимых требований указывал 16 Мбайт ОЗУ и 256 Мбайт свободного места на жестком диске. Для написания настоящего, третьего издания книги используется лэптоп стоимостью менее $1000, с объемом ОЗУ в более чем 10 раз превышающим прежний (что больше ранее требуемого объема дискового пространства), 100-кратной емкостью жесткого диска и 50-кратным превышением быстродействия процессора по сравнению с аналогичными характеристиками компьютера стоимостью $2500, который использовался при подготовке первого издания.</p>
  </section>
  <section id="n_10">
   <title>
    <p>10</p>
   </title>
   <p>В приложении А показано, как исключить ненужные определения для ускорения компиляции и экономии дискового пространства.</p>
  </section>
  <section id="n_11">
   <title>
    <p>11</p>
   </title>
   <p>Обратите внимание на то, что логика цикла зависит от принятого в стандарте ANSI С порядка вычисления логических операций "и" (&amp;&amp;) и "или" (||) в направлении слева направо.</p>
  </section>
  <section id="n_12">
   <title>
    <p>12</p>
   </title>
   <p>Символ подчеркивания (_) указывает на то, что данная функция или ключевое слово предоставляются компилятором Microsoft С, тогда как буквы t и Т указывают на то, что данная функция предназначена для работы с обобщенными символами, имеющими расширенную форму. Аналогичные возможности предлагаются и другими средами разработки приложений, хотя используемые в них имена функций и ключевые слова могут отличаться от приведенных выше.</p>
  </section>
  <section id="n_13">
   <title>
    <p>13</p>
   </title>
   <p>В соответствии со сложившейся практикой для обозначения длинных указателей на параметры, представленные строками символов, используется префикс l.</p>
  </section>
  <section id="n_14">
   <title>
    <p>14</p>
   </title>
   <p>Во время написания данной книги даже недорогие системы на базе лэптопов комплектовались жесткими дисками емкостью 40 Гбайт и более, и поэтому даже в случае малых систем средства для работы с файлами, размеры которых превышают 4 Гбайт, является не только желательными, но и необходимыми.</p>
  </section>
  <section id="n_15">
   <title>
    <p>15</p>
   </title>
   <p>Сравнение функций SetFilePointer и GetCurrentDirectory демонстрирует непоследовательность стиля программирования Windows. В некоторых случаях для передачи входных и выходных значений применяются только параметры.</p>
  </section>
  <section id="n_16">
   <title>
    <p>16</p>
   </title>
   <p>Вместе с тем, рассчитывать на 100-наносекундную точность не следует; точность измерения времени может быть различной в зависимости от характеристик оборудования.</p>
  </section>
  <section id="n_17">
   <title>
    <p>17</p>
   </title>
   <p>Гораздо более удобным и последовательным было бы использование для управления реестром дескрипторов типа HANDLE. Существуют также и другие ничем не оправданные отклонения от принятой в Windows практики.</p>
  </section>
  <section id="n_18">
   <title>
    <p>18</p>
   </title>
   <p>Заметьте, что суффикс "Ех" следует использовать или опускать в точном соответствии с приведенными именами функций. Функция, в названии которой присутствует этот суффикс, является расширением функции, в названии которой этот суффикс отсутствует.</p>
  </section>
  <section id="n_19">
   <title>
    <p>19</p>
   </title>
   <p>Возможно, это дело вкуса, — то ли индивидуального, то ли корпоративного, — но многие программисты никогда не пользуются оператором goto и избегают употребления оператора break, кроме случаев его совместного использования с операторами switch и иногда — в циклах, а также совместного использования с операторами continue. Те, кто мыслит трезво, не спешат определять свою позицию в этом отношении. Обработчики завершения и исключений могут решать многие из тех задач, для решения которых вам хотелось бы привлечь оператор goto и операторы, снабженные метками.</p>
  </section>
  <section id="n_20">
   <title>
    <p>20</p>
   </title>
   <p>Этот оператор является специфическим для компилятора Microsoft С и предоставляет эффективный способ выхода из блока try…finally без аварийного завершения выполнения.</p>
  </section>
  <section id="n_21">
   <title>
    <p>21</p>
   </title>
   <p>Цены на модули памяти постоянно снижаются, а "типичный" объем доступной памяти увеличивается, поэтому назвать, какой именно объем памяти является типичным, довольно затруднительно. Во время написания данной книги недорогие системы снабжались памятью объемом 128-256 Мбайт. В большинстве случаев такой памяти будет вполне достаточно, но она не является оптимальной для Windows XP. Для систем Windows Server 2003 требуемый объем памяти обычно гораздо больше указанного.</p>
  </section>
  <section id="n_22">
   <title>
    <p>22</p>
   </title>
   <p>Понятие потоков вводится в главе 7.</p>
  </section>
  <section id="n_23">
   <title>
    <p>23</p>
   </title>
   <p>Обычно для создания объектов типа X используются системные вызовы CreateX. Функция HeapCreate является исключением из этого правила.</p>
  </section>
  <section id="n_24">
   <title>
    <p>24</p>
   </title>
   <p>Утверждение относительно согласованности отображенных представлений файлов, видимых разными процессами, неприменимо к сетевым файлам. Файлы должны быть локальными.</p>
  </section>
  <section id="n_25">
   <title>
    <p>25</p>
   </title>
   <p>В главе 10 рассказывается о косвенном методе, позволяющем одному потоку возбуждать исключения в другом, причем эта же методика применима и к потокам, принадлежащим разным процессам.</p>
  </section>
  <section id="n_26">
   <title>
    <p>26</p>
   </title>
   <p>Рабочий набор — это набор страниц виртуального адресного пространства, которые ОС считает необходимым загрузить в память, прежде чем пытаться запустить любой из потоков процесса. Эта тема освещается в большинстве руководств по ОС.</p>
  </section>
  <section id="n_27">
   <title>
    <p>27</p>
   </title>
   <p>Как объясняется в следующей главе, мьютексы — это объекты синхронизации, владельцами которых могут быть потоки.</p>
  </section>
  <section id="n_28">
   <title>
    <p>28</p>
   </title>
   <p>Использование в данном случае контрольной суммы, вычисляемой в результате применения операции исключающего "или" к битам сообщения, носит исключительно иллюстративный характер. Существует множество других, более совершенных методик проверки целостности данных, которые и должны использоваться в промышленных приложениях.</p>
  </section>
  <section id="n_29">
   <title>
    <p>29</p>
   </title>
   <p>Выбирая необходимый тип объекта, руководствуйтесь следующим правилом: если упоминавшиеся ограничения приемлемы — используйте объекты CRITICAL_SECTION, если же имеется несколько процессов или требуются возможности мьютексов — применяйте мьютексы.</p>
  </section>
  <section id="n_30">
   <title>
    <p>30</p>
   </title>
   <p>Как показано в главе 10, в упражнении с семафором (упражнение 10.11), системные службы Windows предоставляют возможность организации взаимодействия между процессами также посредством отображаемых файлов. Дополнительные механизмы IPC включают файлы, сокеты, удаленные вызовы процедур, СОМ и отправку сообщений через почтовые ящики. Сокеты рассматриваются в главе 12.</p>
  </section>
  <section id="n_31">
   <title>
    <p>31</p>
   </title>
   <p>Это утверждение нуждается в дополнительных разъяснениях. Для большинства сетевых приложений и высокоуровневых протоколов (http, ftp и так далее) более предпочтительным является интерфейс Windows Sockets API, особенно в тех случаях, когда требуется обеспечить межплатформенное взаимодействие с системами, отличными от Windows, на основе протокола TCP/IP. Многие разработчики предпочитают ограничивать использование именованных каналов лишь случаями IPC в пределах обособленной системы или в сетях Windows.</p>
  </section>
  <section id="n_32">
   <title>
    <p>32</p>
   </title>
   <p>Заметьте, что функция TransactNamedPipe не только предлагает более удобный способ использования пары функций WriteFile и ReadFile, но и обеспечивает определенные преимущества в плане производительности. Один из экспериментов продемонстрировал повышение пропускной способности канала в интервале от 57% (небольшие сообщения) до 24% (крупные сообщения).</p>
  </section>
  <section id="n_33">
   <title>
    <p>33</p>
   </title>
   <p>Эта терминология может несколько сбивать с толку, поскольку системы Windows предоставляют многочисленные услуги, которые не относятся к услугам, оказываемым службами Windows Services. Однако использование на протяжении всей этой книги термина "Windows" в тех местах, где имеется в виду API, кое-кем также может восприниматься неоднозначно.</p>
  </section>
  <section id="n_34">
   <title>
    <p>34</p>
   </title>
   <p>Если служба вызывает функцию MessageBox, то в качестве типа окна сообщения следует указать MB_SERVICE_NOTIFICATION. Тогда сообщения будут отображаться на активном рабочем столе, даже если ни один из пользователей еще не успел войти в систему на данном компьютере.</p>
  </section>
  <section id="n_35">
   <title>
    <p>35</p>
   </title>
   <p>В будущем, благодаря развитию платформы Win64 и предоставлению больших объемов физической памяти, острота этой проблемы, по всей видимости, снизится.</p>
  </section>
  <section id="n_36">
   <title>
    <p>36</p>
   </title>
   <p>Точнее говоря, "UNIX" означает функции стандарта POSIX, описанные в спецификации <emphasis>The Single UNIX Specification </emphasis>(http://www.opengroup.org/onlinepubs/007908799/). Эта спецификация реализуется в UNIX и Linux. В свою очередь, исторически эта спецификация возникла на основе UNIX. </p>
  </section>
 </body>
 <binary id="Any2FbImgLoader48" content-type="image/jpeg">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
Sg9KUd6Rup+lH8ApD1px7/571G3U1//Z</binary>
 <binary id="Any2FbImgLoader53" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAoHBwgHBgoICAgLCgoLDhgQDg0NDh0VFhEYIx8l
JCIfIiEmKzcvJik0KSEiMEExNDk7Pj4+JS5ESUM8SDc9Pjv/wAALCAFCAdABAREA/8QAHwAA
AQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQR
BRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RF
RkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ip
qrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/9oACAEB
AAA/APZqKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKRulcJpht79IrjUtcvId
Sur6aCS2S4I43Moh8sH5QFAO4YIPOapS2rW+hW2y7vpGudZe2k83UpE3Ro0wA3k/L90dOuKb
q11d2H2C0E9xBprwbtRkS/aZ4YzMoZg/U9lJGNqk4r0eEKEAQ5XA2nOePrUlFFFFFFVLa/W5
vbq1VGBtSqux6FmXdgfQEfnTNS1JdNSNmgnnM0gjRIUDMWwT3I7A1nr4u05t4RbhmSHzSpj2
sSCwKAEg78o/y/7JqVfEls88Uaw3JSRkjM3lfu45GAKoxz15A9ASAarR+MLdrOe5m0+9g8q3
e5VHVCZY1OGK4YjqRwcVo6Zq6ak0sZt57WeHb5kE4AZdwyDwSCDg8g9jU9zqVlaSNHcXkMLJ
EZmV3AIQHBY+2TjNQxaqkmsNpphlVvI89JWA2SLkA4Oc8EjqBVxJ4ZJJI45Ud4iA6qwJQkZA
I7cUssqQRPLIwVEUszHsByTWNJ4psbWz0+41AmzbUCBDE/LHPQcd8Y4681tFiKxNN8URaiPN
awu7S2MbyLczqojIQ4bkMcfjjPNXY9d0qW3kuI9StmhiIDuJAQpPIz9e1PfV9OjAL39uoMJn
BMgwYx1f/d96to6yRh0YMrDIIOQR61U0/URfyXUfkTQtbS+WyygAngEMME8EGjVdVtNGsZL2
+nWGCPq7dKiutYhi0c6lBidGA8leV81mOFAyO5IFaK5KjcMHuKWiiiiiiiiiiiiiiiiiiiii
iiiikOCOarrp9kl2btbSAXJGDMIxvI/3utNn0vT7q1Nrc2NvNAX3mKSIMu7Oc4PfPelj0ywh
hMEVlbxxFSpjWJQu09RjHQ1YVVRQqgKoGAB2FOoopM0UtJWTpNncWmsaw0kREFzOk0UhYHd+
7UMPUYK9D68VLrFne3SWz2DwCa3nEuJ87SNrDHHP8Vc1qngC61VRLNqaC58mRi6xYUXDOGVw
M5wql0wT0atRdAvUnNotzANNN0LrbtPm7gQwT027gDnrjj3qhH4JuINNuYoZ7SO5vLWWC5YR
ttkLZKN1yCCTn1B9hW/penXVvcT3d7PFJNKqIFhQqiIoOAMkknJJJ+npWf4l8O3muXsEsc9v
HHaRl4VdCS0+4EbyOseByvc4PYVZNhqh8Sx6gzWX2QW/ksoD+byQxwenUflU+kWt3E99cXkV
tHJcXTMghQA+WPlQuf4mwM598dqXXbKfUrFbKJlWKaVBcknkxA5YD3OMfQmrE1haXbwyz28c
jQHdEXXPln1HoeKskHtXH2HhHVNOt2Fvc2CTLHJGGWJwJg7ZJkGcEjJxx179aur4dvoJhLDN
asbeaN4FkQ4cLF5Z3nse4I6VTufBl1cCzU3Ft/o0cjj5G2+c0nmY2Zw0YPG09veurt0dLeNZ
AiuFAYRj5Qcc49qoaZaajBqV/PeG1MVzIHjEO7cuFC4OfYZq5eWVvf27QXUKTQtgtG4yrYOe
R9RWfcabLPqemqoVdPst0uzPLSABYxj0ALH6gVrjoKWiiiiiiiiiiiiiiiiiiuL+Ivj5/A9r
ZmGxF3PduwUO+1VC4znHOeRXEf8AC7vEJ/5laP8AOT/Cj/hdviEkAeFo9x4A/ecn8qib40eM
EJDeG7YFeoME3H603/hdfi7/AKF60/78y/40f8Lr8Xf9C9af9+Zf8aUfGvxZznw7a+37qX/G
gfGvxX/F4ctj9IpR/WpR8bfEeTu8LxEdsCQUv/C7vEP/AEK0f5yf4Uo+M3iuf5bXwrGXHJ/d
yvx9Bio2+MfjRQC3hiAA55NvN/jTP+F0+L+f+Kctfl6/uJuP1pP+F1+Lv+hetP8AvzL/AI0f
8Lr8Xf8AQvWn/fmX/GnL8a/FO07/AA3bluxEcoH5Zp4+NniQAZ8MQk4HQSfjTv8AhdviH/oV
o/8AyJ/hSL8ctZgvYW1Dw/DFZs3zAbw7AddpPB/Kva8AHOKWk6UcUZpaKSiigDFLRRRRRRSY
FLRRRRRRRRRRRRRRRRRRRXjvx/h/0TRZ95GJJU29uinNesaZL5+lWk2MeZAjY9MqDU0ziKJp
WzhFLHHtXEv4o1zTdFtdfvXtbi11AEx20URVoMozx/Nk7h8oDcd+OlSaX4xv47dItRtLi71S
eSMLZwwpEUVoy4Iy5BX5G5JznjFS3PxG06ONWht5nE1q00MjFQGYRmTbtzu7EE4xnjNQaR40
vFh+z6lb3F3q8pWRLC3tliZYim7cMuQV9yc54xWhD44tJbmRWs7mK2Rbd/tTlAhWZtsZxnI5
znI4waV/HmkRnDmXJnWBNoDCRmkeMFcHkZQkn0xVmw8W2GpaNd6taxzva2iFnbaPmIXcyrzy
R0PvUA8aWNzNJFpsFzqEsczRGOALk7FVnIyQCBuA9zwKhj8c21wLkWmn3s72s6W7p8iHzWfY
E+Y8Huc9BSDx5bSNBbw6fdyX9xHvjs1KeYcNIG5LY+Xyzk57ilPxD0RbH7W7yKmXypxvAWPz
M7c5wRgD3qOD4kaNLCzvvidElZo3dOfLCtgMDtYkMMYPYipbzx1p8JltkMou1jmYL5YbZ5ZA
ywz0JPHPODWj4a1wa5Z3D+ZHJJaXL20rxKRGzLg5TPJGCOfrWxXjP7QEJA0Off8A89k2/wDf
BzXs9FVdR+3Gyf8As77P9q42fad3l9RnO3npmknF4bm1+zyQrCGP2gOpLMu042nsd2OvagC9
/tJmZ4fsXlAKgU+Z5meST0xjtVodKWiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiivIf2gP+QXo
3/XeX+Qr1DRf+QFp/wD16x/+girpAIwelYMHgzSIHwftE1uu/wAq1lmLQw7wQ2xe3BI9snGK
qT+B7cG1+zX17GyXAlluDOTOVWNkVFfsBu/nUkfgDQopleOOdY1IPkCX922E2cjv8pI69yaV
fAumopZbvUBc54u/tJ85V27dgbHC47fj1ptwfD3hz7ZFcRv5cemrLKkib0MEOVAGeCeenU5F
Z1npPhKa9X7LFMZJbaJwwOFhjd2nX2XJHbtgVof2LoGkeHdRhinaLT7mBklCTDHCFWK/7ZHX
1IFRx+GPDv2WEwTyWahEZDFceU6oyKm045wwC5z36U//AIRrw3aTxXq3X2YW83msPtW2OR1c
keZ2bazcZ6cCpn8GaPcIk0MlxFIBmK5t59rqCXPyt6HzG/Aj0qW68F6DeQ20U1kpFtCYUYcN
sKbMFup46Z781GfBOlSxut3JdXjvHJG0tzLvbDhQccYBwoxgcc0k3gXRJlulaOUfbHleZhId
zGRQrc+mBx6VrabpNppKypZoY0lYMVzwuFVAB6DCirh6V4t+0A373Q0yfuzHGeP4e1e1UUlV
X1PT478WEl3Al0VDCFnAYgnAwO/Sl/tGw8wx/bLfeNwK+Yufl+9xnt39KfFeWszqkVxFIzIJ
FVXBJQ9GHt70y/vY9PtWuZVdlUqNsYyzFmCgAfUirPaqVxqKQ6lDZbWZ5I3ldh0jRccn6k4H
403Sda0/WUlewukuFicoxU5wQcf0pNT1iDS3hSSC6mebOxbeBpTxyenSli1zTHhgla9hh+0I
skaTOI3ZT0+U4NWfttp50kP2mHzIhukTeNyD1I7Cliu7a4x5NxHLlQ42ODlT0PHb3qrqepjT
Ilc2tzclsnbAm4gAZJOSABj8+1WrW5iu7WK5gffFMgdG9VIyD+VVbbWtPutTuNOhuke5t1Bk
jDcjOe34c/UVJDfpcahc2kauTa7N7/w7mGdv1AwT/vCrlFFFFFFFFFFFFFFFFFFFFeQ/H/8A
5Bejf9d5f/QRXqGi/wDIC0//AK9o/wD0EVdozRS0mcVzviXw/c6zf6TPA6LFbzEXiOf9bASG
K++WRK51/AepnRbmxZ4ZZJbqbaWfAFv5TRxL07BvwzUmseCblnvfsGl2FxbTLMkNo7CNIi8U
aiQcYBDI3Tn5uDUR8BahcK9tNDaLIjSzLqO/MkjFAI0IxnCMF68YQYqOH4danDb3LXMsN/Kz
RyQhpTGUkJ3zsG2kZMmCMgjAxiu60S1ubDRbO0u2jaaCFUcwrtTIGOBjp+Aq/mjIoBzRmjtX
iv7QH/Hzon+5L/Na9rqvd31rYIJLu6ht0Y4DTSBAT6ZNVf8AhItE/wCgzp//AIFJ/jVSSCWb
Wo9Y05NPuYZrdYmmZ/mwHJypAORgnj1FRWWlPa63qeo3en2BiuW3iaPLzFQoUAgr6A9D3qLw
ZZhYJr14pF+Y21r50RjkW2jY+WCGGe5P0xWnr9vJc6eqwo8jxTwyhEbBbbIpI9+AeK0mOFzW
dp9lOuoX99dYEk8gjiAOdsKfdH4ksx+tWNP0ux0qOSOxtkgSVzI4T+Jz1Y+59azPENhfXl1Z
SWtrFcJD5hdXu3gOSoAwVBPrVF9A1SZEe4NlczwxQxo8pJL7ZA7Fjt9sD16nFTRaBdRXkbeX
ZsltNNMkvPmTmQN8r8cD5uTznA4pfCnh6fQEKTCCTfCgaXcWkVgMFAxAzGMZUds4q5r9pqF/
BFbWjReQzH7UjyFDImOEBAOAT174471qW6FLdEKIhCgbU+6vHQe1Vk0uztb2fUYLZftk64kk
z80gA4BPpx+FR6FYS2OmqLkqbuZ2nuGXoZGOT9QOAPYCtKiiiiiiiiiiiiiiiiiiiivHvj+7
fY9EXA2eZKT9cLV+w8BeM5dPtpI/iBdxI8KMqBWwoIHH3q0tL8EeLrHVbW6u/HV1d28MqvJb
sjYlUHlT83euh8U6Be+ILOCCw1y50h4pd5ltxksMEbTyOOc1zcfw48SQoEj+I2qhR28sn/2e
tPQfBuu6TrEN7e+Nb/UoI9261ljwr5UgZ+Y9Cc/hVvxT4c1bXLi3k07xNd6MsSlXWBciQk9T
8w6f1rD/AOFeeJ/+ij6p/wB+v/s62vDPhnVtCu5pdR8UXmspIgVI50wEOc5HzH6VU8R+EvEO
sa0bvT/GF1pVqUVfs8SkgEdT94daxz8OfF0xKXPxEvzH/sI2c/8AfYrqPCPhq98NwXMd7r11
q7TOGV7gEeWAOgyTWLq/w/1nUdZu7628b6jYx3Lki3jUlYx6D5x/KoR8OfEq9PiNqvXP+rP/
AMXXU+G9IvtF0022oaxPq8pkL/aJ1wwBA+XqeOP1rmp/APiWa4klT4h6nEruWCLFwoJ6D5+1
M/4V74o/6KPqn/fo/wDxdddo+m3mnaBHp91qkt9cojA3kgw7EkkHGT0yB17V4J8U/D+r6FNp
x1fxDPrEk6ybDKCBGAR0yT1z+lfR1RzW8NwoWeFJVByA6hh+tQ/2Zp//AD423/flf8Kp3uua
Zo1wllIsiHy/MIht2ZYo843MVGFGaRfE2ms4RTLk3Jtv9UfvA4z/ALuQRu6ZBqI+LtJ+zzT5
uCkSCRf9HfMqEhdyDHzLkjkeoqR/E+npaxT+XdsZJ/s4hW1cyq+3dgpjI4Ga0LS8t762S4tn
8yJx8rYI9iMHkH2NSefDu2+amd23G4dfT61Q03XbXVJpIoormF0XeonhMfmJkjcueoyK0gQw
BBBBoooopaKKKKKKKKKKKKKKKKKKKKKKK8a/aAJ8rRBnjM3/ALLXq+i8aFp//XtH/wCgir1F
FFFYfizXJfD+kx3cKwFpLmOHdOWCIGbG445wKqL4ytbPSobq7Zb5pPNYtpaNKirHjcTnkYBG
aml8b6JBNMkskyJFuHntCRG7Ljcqt0JGefx9DUuqeIvI8KXOu6bb/aliieRFkbywyrn5sntx
n3FbELF4lcjG5QafS0UlLSHpXiv7QH/Hzon+5L/Na9roorndX03Vp9akubAWojmsTas87n5C
XySFA547ZFZSeA5k1w6gb5djTMCmDnyDHhV/3hIS2e+ann0TXb3Tvs1zHZK1va/ZoTFKy+bl
ky5OPk+VOAM8nrxU39j6rp/y2MEF0qX32qNri5YOwZGDBmKsSQSAD/d+nOxo1nPY6eI7kxme
SR5ZfKGEDMxYgewzjPesZNAvF8V/2x9ktREZzmASHGNmPtHT/Wn7uOm3vmpbOLWLSDUby8sY
ri+ljZk2XG4ORnZEo2jag456kkmtjRbP7BotnaGCG3MUShooM+WhxyFzzjOavUUUUUUUUUUU
UUUUUUUUUUUUUUUUV4z+0B/q9D+s3/stes6OCui2IPUW0YP/AHyKuUtFFFZuuaQutWUcBuZb
Zop0njkiAJDIcjgggismPwTaBriSa+uppbmGdJZGCAs0oUM+AAAdqqAOnHrUdz4CsbxWjuLy
6ktQZGitjtKRNJjeRxk554JI+Y1pjw7A3hufQXnma0mjeFTkb442zhAfRQcDPYVrooRFUdFA
FOoooopO1eKftAMPtmiJnkRyn9Vr2yiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiivGvj
/wD6vRPrN/7LXc6l4gk0DRdKkhihkjntwipI53q2wFWOP4B/G3Yc1oiSZdfsXa7Yie0k3wLJ
mEspQhlHX+I8+lbS9BS0UUUUUhOKWiiiiikrxD4/uTqWjR7uBDIcY6fMO/4V7hRRVS6kv1ur
VbWCGSBnIuHeQqyLjgqMcnP0oWS+/tJ0aGEWXlApIHJkL55BXGAMd80tpJfPJcC8giiRZSID
HIWLx4GC3Awc545q1RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRXjP7QH+r0T6zf8Asteqw6XY
3FpbNcWsUrLbeUGZATsKgMv0PcU5dE0pJ4LhdPtxLboEhfyxmNR0APYCrwx2paKa5YKdoyfS
nUlFFLRRSZFLRRXhnx//AOQzpH/Xs/8A6FXudFFNZ9oJ9Pes9desW1Q6dmXzg2zd5beXv27t
m/GN23nFaOeM0Z9qp6hqtppcSSXbsokfYipGzsxxnhVBPQVbVg6hh0NQrewNeNZh8zpGJGQD
opJAJ/EH8qbf6ja6ZbG5vZRDCCAXIJAz9KdJfW8V3DaPIBNOrPGh/iC43Y+mRUwbPanUUUUU
UUUUUUUUUUUUUUUUUUUUV5D8f1X+ztFcjnzpRn2wtXbDwL42utPtrhfiFdRrLErhBEx2ggHH
3qv2HgTxlbahbXFx4+ubiGKVXkhMRxIoOSv3u44ro/Fnhy78RWMMFlrV1pEsUm8y2xILDGMH
BFcr/wAKv8Q/9FD1f/vp/wD4utTw54F1nRNbhv7rxjqGowoGDW0+4q+VIGcsehOfwq/4q8M6
tr1xby6b4lutHEKMCsC5EhJGCeR0rEX4f+KtvzfETUs98R//AGVbHhjwvrei388+p+KbrV4p
IgiRTJgI2c7up+n41V8TeEfE2say15pfjC40u2ZFUW0cZIBA5PDDrWT/AMK48XTALcfES/Kg
k/u0ZT7c766fwj4a1Dw5DdR32v3WsGdlZGuM5jwDkDJPX+lYur/D7W9Q1i5v7bxvqVlHNIXS
3jLbIx6D56qJ8MvESHK/EPVs++4/+z113hvRb3RdM+y3+rz6rN5hfz5xhsHGF6ngf1rm5/Af
iiaeWVPiBqMQdmZUWPhQTwB83QVA/wAPfFvl/u/iJqAfj70Zx7/xV2Gjabfad4fj0+81SS+u
0VwbyRcMxJJBxntkD8K8E+KXh3V9CuNOfWPEEusyzo4RpEK+WARwMk9c19H0UVyfirQ73VtR
ie1tGeOKHM26cKl2u8H7ORngHG7djtjuat+Rqk/iZZbuwJsbc4tWSZdqEr80jL1LZO0DoBk9
61NVsW1LS5rMTGFpQBvAzjkHpkenrVbQtHl0eGWOW7N0ZHDbihXHGMck+lUvEOnNe6lpsh0Q
6jHA7F2MiLsyMfxMD1549K6FRha5e+s55L3xFD/Z0l79ttoWiQSeWJAFKlQ/8JB5/GqqaVrk
HhPV9Ons3vr+4yguBOi/aQyABsE/JtAC474zzmta7iurrVdBcWkkQgaWaYtg+WPLKbSQSMku
O/Y1Lbwyy+Lbq5ew8uKC1SGK6MrZlySzAJnbgcc4zk1s0UUUUUUUUUUUUUUUUUUUUUUUUV5F
+0B/yCtG/wCu8v8A6CK9P0T/AJAWn/8AXrH/AOgir1FFFFZfiHWP7D0o3vlpIfNjiAklEagu
4XJYg4AzmqTeLrGw02C71mSG2M5fYLZzcqVXq25V6AEE+lXD4m0VbyS0bUYhPEpLIc8YAJGe
hIBGQORTbzWJWsUudGgS/MkpjDNJ5cSBc7mZsHAG0jocnFTaBqq63o1tqSxtELhN2xjnHJHB
7jjg9xWjRRRRSHpXiv7QH/Hzon+5L/Na9rooooooopKAMd6WkIzRiloooooooooooooooooo
oooooooryL9oD/kFaN/13l/9BFen6L/yAtP/AOvWP/0EVeoooorN1/Sm1jTPsqSpE6zRyq0k
fmLlHDYK5GQcVhQ+B3UXXmain+lJcblitxGivMqqSoycABBx3JJzzRP4Ha4D28up7rEySypB
5I3K0gw4LZ5XBbA4PzdeBU954UuLjw/baJDqnlQW8oJ3QBvMiXOyJhkZH3c+uOetb2nwTW1l
FDcSpNLGoVnjj8tTj0XsParVFFFFJ2rxT9oE/wClaIM/8s5f5rXtlFFVLyW9imtVtbRZ45Jd
s7NKE8pMH5gP4ucDHvQJb3+1GgNoosxCGFx5oyZM427fpzmi0lvJZ7pbq0EEccu2BxKG81MD
5iP4ecjHtVuiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiivIv2gP+QVo3/XeX/0EV2tzrz6B4c0
q4Nr58MlukZIk2lXMfyDGOQTwT/D1PANSXsuqHU9PMF2/nSNG0lnGAYo4/8AlqztjJ9FPHIH
HWujHIpaKKKSlpKKWiiiikrw74/n/ic6OP8Ap3f/ANCFe5UUVXmvIILmC3lkVJLhisSn+MgZ
IH4AmrFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFeRftAf8grRv+u8v/oIr0Sw0qxv9I0ya
6tkleOyWNC3ZXQBh+I4p6eGNGju4ruOyCTRIiIyOygKn3BgHBA7ZrVAwMUtFFFFFFFFFFFFF
eGfH/wD5DWkf9ez/APoVe50UVia4kk2p6IkRcMt6ZCVGcKI3zn2OQPxrbooooooooooooooo
oooooooooooooooooooryL9oD/kFaN/13l/9BFen6L/yAtP/AOvWP/0EVeoooooooooooooo
orwz4/8A/Ia0j/r2f/0Kvc6KKbtGc96dRSUm9SxTcNwGSM84paqyalaRGYSXUSeQVEu5gPL3
fdz6ZzVocioZrqGGeGB5VWWckRoerYGTj6Cph0paKKKKKKKTnNLRRRRRRRRRRRRRRRSZFeQ/
H9h/ZmjLnnzpTj/gK16DDq8el6HpaG3uLmWW1UpFboGYhUBY4JHT8zT5PE1uk3li0vWA8rdI
IeF8zG3jOe/OBxg1La6/DdXkVssMoMss0asduAYjgk85we1XL+5ltLYywWsl1JkKsMZALEnH
U8Aeppml6gNTs1uBG0fzMjISDtZWKsMjg8g8irtFFFFFFFFFFFeGfH//AJDWkf8AXs//AKFX
udJmjPtXHarY63ceKZHRrlYBJA1rJCMqij/WA5cAZ5zkEkEY6VFa6dra6teTx2txDBMlytkr
z5+zSH+N+eQ55Uc7PxqKfSNQbSZE0201Kzdmh+1C5uDKZlBPmBBvznkZIK5qtLbzWs+j2d+u
o3iyx3W22E/kSMNyFBjzOQuTjLFgOe1attptxZ6xp93qNje3t0bOKNp4ZiVSRS2d/wAwHRhz
jnHrXXKQV4rj7lfL0PxXDcQs80k0rAbcmRXRRGR6joPbbXW2yyJaxJK26RUAc5zk45rK1FJF
8UaROdxhEU6HC8K5CkZPuARWyOQKWiiiiiiiiiiiiiiiiiiiiiiisTXPEcOmzRafbW8l/qly
C0FnEcEgdXZuiJ7n8M1zGg+HfHjapNdal4hbTbJpcrZRMLo7c9A8gOAfz+lYX7QCk6dor87R
LKP0Wu2m0u61bw/pItVsZohaKStyGBDFF2ujryCOfrnqKZ/wjGpR6xHqCSWU1xHFFEt7MH84
BRhzgfKS3P0zVjTvCxsNXh1FVsll824eeSOEh5RIcqM57cZ9cVqa3aX17pr2+n3CW8shCtI2
eEz82COQSM4PapdNtGsrCG2ZYU8pdoWFSFAHQDJJ6VboooooooooopK8N+P246zpDbfl+zuA
3qd1e51V1DTbTVIBBeRs8YbcAsjJz9VINZx8IaGVCm1lwO32qX/4qrpGn6FpZJbyLW3XJLMz
YBPqck8mrAlh83yi6+Zt3bM846ZxUjbEQsxCqoySTwBVA3+iXEUd4buxkRW2xzGRCA3XAb1q
b+0dOCB/t1tsKFw3nLgrnBPXpnjNWVKlQVIIPQjvVa01GwvpZorS6hneBtsqxuCUPvVh5I4U
Z3dUVRkknAAqG+u4LK1kubmQRxRDLse1WB0FLRRRRRRRRRRRRRRRRRRRRRSVj+I9cOjWcYto
vtN/dv5NnbA/62Q+vooHJPYCk8O6ANHgkluZftepXZD3l4w5lb0Hoo6Adq2cCvI/j9/yC9G/
67y/+gir+kfF/wALado+n2Mwvle3tI0bFvxkKBjrzWpZ/F/wrf3sFnBJeebcSLGgNsQMk4H8
66HxL4mtPC2nx3t7DczI8gjC28e9skE9PTiuY/4XHoP/AEDdY/8AAT/69aGh/EvSNf1eDTLa
y1KKWfO15rfagwCeTn2q74o8baf4Ult4722vJ2uFZl+zQ78AYBzzx1rC/wCFx6D/ANA3WP8A
wF/+vWt4a+IGleKdSlsLK3vYZoofOP2mHYCuQPX1IqPxH8R9G8MaudMvYL2SYRLLmCIONpzz
17YrKHxo8Mvu8qDU5WVgAqW3LfrXSeFfF9n4sjuZLO1u7dbZlVvtMewtkHpz7Vk6r8UdH0fV
bjTriw1R5LdyjNFb7lJ9jmqn/C49B/6Busf+An/166nw74htvEul/wBoWkNxDH5jJtuI9jZH
t6VzM/xf0K3mkik07VsxuVJFrwSDjjmmH4yaABk6dq4A7m1/+vXXabrlrqnh6PW4ElW2khMo
VwA+0Z7evFeBfFXxjpvi+906bTobiNbeJ1czptJJI6cn0NfR9FFY2rRf2hqthp5DeUj/AGuY
gHBCEbFJ6cuQcf7NH/CM2f8Awk48Qb5PtXleVtz8hHrj19/wqfxBEs2gXkLWk92rx7TDbkCR
geDtz3HX8K5We0vprDKW91C76gJEu4rBPPKiIr5jxkYzn5c4yQAcUmo6fcTwMbW0vbCFbCVW
SOzRzLmXO3GCQW+9getdzEQ0KkKVBAwCMEVzvhx1vNWuLyTT7iyeOLyYYXtTEscW7ON3RmJG
eOB+edLxBocPiHSJdNnmlhSUgmSFtrjBzwaqXdg8k+l6SqO1pb4nnfHyt5eNin3LkNj/AGa3
h05paKKKKKKKKKKKKKKKKKKKKKaxAUkkADkk9q5Pw0v/AAkes3PiuXJtxutdLVhwIQcPIPd2
HX0ArraWvIvj/wD8gvRv+u0v/oIr0fw1Cq+FtJV413LYwg8d9grT8pOoRRj/AGaULS496Me9
JtpJJFiTfI6qo6liABTUaKceZG6OOm5SCKd5a5JwMnjOKjcxQDc3loM9ThalWlxRj3oxSbRS
kZ60gUBdoAxXhvx9ULrOkAAf8ez9v9qvdKKKjaaFJEjeRFeQkIpYAsQMnHrxUlJRgelFFFLS
YopaKKKKKKKKKKKKKKKKKKKKK5nxteTHTodEspCl7rU32SNl6xoRmV/wTP4kVv2VpDYWcNpb
oI4YEEcaDoqgYA/Sp6K8i/aA/wCQVo3/AF3l/wDQRXp+iZ/sHT89fssWcf7oq9RRRRXLfEeP
zfCEgKqVF1bM++MyIFEyEllHVQMkj0rmrfUb25t4rLTJv7PhgW6nEuk2nkxThURlYq6nALlx
gdSOtPn8SeIFSZobq4a9CSFrM24CRxCIMkmcZ5bHc5yRjir1z9u1jRNB+3S3Juf7ZT7ZGIwP
LZS+UxjlFIGD3GDXdqMZp1FFFFFeGfH/AP5DWkf9ez/+hV7nRRWJrrD+0dFRdnmtf5UsucAR
Pux6ccZ9626KKKKKKKKKKKKKKKKKKKKKKKKKKKKKK5fTx/a/j7UL88waRCtjB3Hmvh5SPcDY
v511FFFeRftAf8grRv8ArvL/AOgivTdHkVNE05SwBNrHgE8n5RV5WDjKkEdiO9OooopCMikK
5GMmjbx1oC4706iiiiiivDPj/wD8hrSP+vZ//Qq9xWRHJCsGKnBwc4NOoppVSwYqCy9DjkU6
iiiiiiiiiiiiiiiiiiiiiiiiiiiiiq99dxWFjPeTnbFbxtI59Aoyf5VjeB7OS38LW09wMXN8
zXs+eu+Ul/0BA/CuhooryL9oD/kFaN/13l/9BFdRrTLFoGgzW0sUeqhIorMyKTnzECP09A27
/gIrrNOsYdN0+3sYBiK3jWNc9SAMVZoooooooooooooorwz4/wD/ACGtI/69n/8AQq9Y0dgf
EOuiMRiNZYQdvUv5QLZ/DbW3RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRXMfEB2k8OppkZxJq
t1FZD/ddhv8A/HQ1dKiLHGqIAFUAADsKdRRXkX7QH/IK0b/rvL/6CK7sazFo3h/TZ5rW5lQ2
qFmgjDBQEXrkjqSAB1JPFb0Unmor7WXcobawwRnsfepKKKKKKKKKKKKKKK8M+P8A/wAhrSP+
vZ//AEKvbo444S7JGqGRtzFRjcfU+9P388Amjd7Gl3exoJxTI545WZY3Vypw21gdp9D6U5mC
9aN3tRuo3du9G72NKDmgkAEnoKAc0tFFFFFFFFFFFFFFFFFFFctrBF9490GxC7hZwz30gPQH
AjT9WauoHSlooryH4/8A/IL0b/rvL/6Ctd9HoqavomjM93c25too5U8lgAW8vAJBBzjOR781
t28P2eBIt7uEULudtzNjuT3NS0UUUUUUUUUUUUUV4Z8f/wDkNaR/17P/AOhV0TW9p/ZNylhF
NLeQ/a2vo4w5DrHIXQMOmTtVV74Y9s1Jpv2uSeefxLCywGeIXzBGVJQYi0bMB/CCwU47gZ6U
y5ha78iO1VbiTyLk2LSSSLKIFkzG0fqwUtgEjOB2NXVmsrzxDdXFnJLLqMs1pNZum4M8ZVQ+
R0C4Dbs+vrXeXJxbSkytENh/eKMlPccdqwPAkFrB4fj+zzNMxP71nhEbb8YOcKpPrk5PPWrX
i3P9joWYrALqD7TjjMXmLu59PX2zWDeR23/CU6psEv8AaZubY25j3ZaMoodfTbgNnt+NYdjH
qzSLA1rMkFrFcJbPbAhhHGyJKMnkl/nZT1+b2rRvE0qUrDpwin037ZAIknkdYfNZXDKDyf7j
HtnHfNOJ0rytPj1u4kWa3triBizuHhlVlI2kHkgHCnkkY9a7TR3uX0izkvAy3LQIZQwwd20Z
z6Vi2c1/daxPo1/cPLb2cMv2uRkULcLIf3XOBghdwIHpWj4Tlkm8Lac8rmQ+QAHIwXUcK34g
A/jWxRRRRRRRRRRRRRRRRRRSHoa5vT1Fx8QdXmOCbaxtoVP93cXcj/0E/lXSUtFFeRfH6ENp
GkT7uUnkTbnrlQc/p+temeHpRN4b0yUDAeziYD0ygrQzRRS0UUUUlFFGR60UtFJXiHx/jP8A
aWjTZGDDIuPow/xr24c96Me9NB3cqcjNOxgdc0Z56fjS470yaGOeJopUWSNxhlYZBHuKcFwM
A47cUnegjHc0HhSxIAA5JoGHHB/KqltpFnam4MUZzcnMxd2ffxjncT24q3HGsUYjRQqKMKqj
AA7AU+iiiiiiiiiiiiiiiiiikPSuZ8IAzal4kv2zmbVGiXP92NEQfqDXT0UUV538X/Cuq+Jt
DszpUX2iWzmZngBAZlIxkfTHT3ri7W4+MdlaQ2tvaXaQwRrHGvkRHCgYA/IVN/aXxoC7fst1
1zn7PFmgJ8bGUkfa8Nzy8AI/XinInxtRSMXJyQcs9ucfrUvm/G7/AJ4yf+S/+NHmfG7/AJ5S
/wDkv/jR5vxu/wCeUv8A5L/41GLv41mPf5Fxjnjy4M/l1pn2/wCNX/PvdcDP+phpPtfxpn/d
CG8Ut38qJcfielHkfGzBGbz/AL+W/wDjSfZ/jb/evP8Av7B/jS+T8bN2c3n/AH8t/wDGpg3x
uUk+XMcnPJt+P1p3mfG7/nlL/wCS/wDjSeb8bs48mX/yX/xqP7Z8a8Z8i5/79Q1m6h4R+Jfj
W/tU1y2dVhyqzTmNFiU9TheT09DXs+lB38Ta3JIeVMEaLuzhNmc47ZLHj2qzr19Lp2lTTW+G
uXAit0J+9Kx2oPzP86yb7w1qX9laTY6Zqslr9ikVp34JnA5bqDgk5Oe2e9dMowgBJOO5rzvR
dRsrKdrhZYQiLc4minkLQru4MqNx1IA/Cr0Gs6nBZrDea8old4PtNw9si/Yw8ZY54xywABbg
Z5pl14m1eOCze3uo5fMSfeyxA7okcKLgJ1bjJ2g8444rsbOQyWcEnnrcFo1PnIMLJx94D0PW
sHRWtbrxPqk41SK6uEl2LCCpaJAqjjByBnI+ta+vWV5qGj3FpYXRtbiVdqzYztz1yO/GfT6i
s3Ulujpen6FNcGW8vyI55B18tRulbgDjHy/8CFdCihBtAAAGAB2p1FFFFFFFFFFFFFFFFFFF
FJXNfD4+Z4TiuznN5cT3Bz/tysa6aiiikxRRiiloopKMD0oopaKKKSjA9KMCjAqGOzt4bqW6
jhRZplVZJAOWC5wD9MmnyQxTFPMjV9jB13DO0joR71JSUjIGBB5B9aRo1YFWG4HqDyDR5Yzm
lCADA4HoKasMasWVFDHqQoBNSVGYYzMJiimQKVDEcgHqM/gPyqSiiiiiiiiiiiiiiiiiiiii
quqTC20m8nJwIoHfPphSazPBMH2fwVo0eMH7FExGMcsoY/zrdooooooooooooooooooooooo
oorjPFFzBHr8qXGqXFns0wyQrFcFMy+ZhSFB+Zs8Ywc+lYiajri68LB1uSn9oMRKJGBEwQy7
Dzgx7Cq7fXNP1HUVTQ2mstZnleXTWkvmN0w8uXcm0/8ATNixZcccduKvw3CNai11W+ms1j1X
YYWvmBijMZKjzcgsrY3DnvjtXR+GriW50dXaeS4RZZFhnk+9LGHIVie/Hfv171QGuXJ8anSm
1TT/ALOn3oNuJQSuVQEtyxwzHAwFA9a1NGv5b6XUC1zazxQXTQx+QGym0DKuTwWBPbitSiii
iiiiiiiiiiiiiiiiiiisXxlP9m8F61MGCslhNgn12HH61e0mIQaPZQgkiO3jUE98KBVyiiii
iiiiiiiiiiiiiiiiiiiiiomtoXmEzRI0ijCuVBI+h607y1znAznPTvUbWdsyyK0ERWQ7nBQY
Y+p9aWW0tp12ywRSDjh0BHHSpAgUADgAYAFRfYrXz/P+zxed/wA9Ng3fn1pbe1gtIzHbxJEh
YsVQYGSck/Ukk1NRRRRRRRRRRRRRRRRRRRRRRXO+Pdv/AAg+rK5GHg289ySAP51vQrshRP7q
gfpUlFFFFFFFFFFFFFFFFFFFFFFFFFc7rur3thqtnbW0lgkc/L/aSwYKGG9sggBQvrnLMBW5
IzLE7KCWUEgY5J9KyNE1fUtQu2jvNKks4wm4O6sMn05FT+INUl0eC3vD5S2YnVbySTOYozkb
hj0bbnPYmptFuLy60q3ub6ONJ5l3lIgQFUn5evOcYz71TlaTUfFcUKSEW+mRebKAfvyuCFB+
i7j/AMCFbZGcVylnrlzbeHbfWLmRZIJ71/tTyNxbRGRlGMdlwoOfc1vaNdXF7pcN1dRLFJMC
4Rc8KT8uffbjPvUIv9TOs/ZTokgs8kfbftEe3p/czu68VeuUWSCRHlaJWUgurbSvuD2rl5r6
ePwHZ38V5I81uYXMnmZMuJFUqx77gSD7mt3UL6W2vrC2hNsTcylWWaQq5UKSSgA+Yj8OKuzC
QxOIiok2nbu6Zxxn2rmyPH4GAPDh+XPSfr6df1p8cnjoIPMtdBZu5WaYD8tpoDeOFyDb6E/P
DLLMvH0waQ6h40hA3+HtMn5wfK1Jlz7gNH/WlfX/ABDCR53g+6ZejNBeQv8AkCQaX/hMkiH+
l+H9dthnkmyMg/8AIZapLfx14ZuHEZ1aK3kOPkug0DDPs4FaNlrWn6heXVpa3CyTWhUSqpzg
MMqR6gjv7VfooooooormviGM+CNRBGQfK/8ARqV0gGKWiiiiiiiiiiiiiiiiiiiiiiiiiqd1
pWnXtxHcXdjbzzRDCPLGGZRnPBPTmrRVaXArP1nS11myNnJdTQROR5giCneP7p3A8Gr4A2gV
HDawW7yvDGEaZ/MkI/ibAGT+AA/CpaxtR8OxXemzafb3MlrBczNJOqqH3hjll+bOAT6eprYU
beBx7UuBmmyRRzxtHKiyIwwysMgj3FVf7H04W0dslpFHBFKsyxRrsUOpyDge/P4VI9hay38V
88Qa4gRo43P8Ktjdj67RVmkPSvItc+N1zY67dafp2ipcRW8hi3yOwZiDgnAHAzWcfjb4pzx4
dt8dv3cv+NIPjb4o5z4dt+nGElp4+NviPjPhmH7vYSdaePjfr4UBvC8ZPcgyD+lRXXxk1W9h
aG68HQTRsCCsm8jB/wCA1zOmeKpdC1uLVtA8NS6c3SaFZpJIpkPVSGHHYgg8Yrp2+POrqu5v
DkABOMmV/wDCk/4XxrUo2weH7bzD0+d2/QCk/wCF2+Kf+hdtv+/cv+NL/wALt8Ucf8U7b+/y
S805Pjd4lDkv4bgK9gBID+dPHxw8QAfN4XjJ9jIP6Uv/AAvDXv8AoVk/76k/wpB8cddPTwsn
/fT/AOFUtV+Md9qtjJp+oeFo2hlK7k86RSSCGHIGeoFWD8c/EMxzbeHbfA658x/5YpP+F2+K
f+hdtv8Av3L/AI06P43eJg37zw3Ay+irIP8AGn/8Lv8AEOf+RYjIz6ydPyra8IfF+41/xNBo
2o6OtmbnKxsjkkNjIyCOmAea9RooooooooooooooooooooorD1nU9RttUsrGwitC14snz3DM
NhQA5wOo5x9SKoW3iXU7nxC1mumFrSO6NrI4QgoQuS+4nBGegxnBBp9nrGprol5fXEthM8DS
bETcpwkhU7sn0FTXuuXsNpey20dpM9tex26q0pUOrbcZPZvn+nFJe6vrNnIkf2ewkaO0a5nI
kYA7WAwnHoc5PcV0KHK5FYmh6rqV/qN3FdR2Yt4SVjlgdjvYH5hyOdvAJHGTjtV3W9QOnaVP
Oi7psCOFf70jEKo/MiptOtns9Pt7aSZpnijVGkY5LkDkn61kT6/dQ+IP7H8iEzyToYQS3z2+
3LyfVSCMf7vrWjpt/Je3N8hNs0dtP5SGGXe3CgkOMfKwJ6VoUUUV4p8PwIPjb4ggjAEZa5GC
M8CUV7SFGBS7R6D8qNo9B+VG0eg/Kk2j0H5UbR6D8qb5SYwUU/8AARSiJAchFB9hTto9B+VG
0eg/KjaPQflRtHoPyo2j0H5Um0eg/KkMak52qfqKFjVeiqPoKdtHoPyo2j0H5UhUY6CvF/EQ
8j9ofTnj+VpHg3H1yu0/pXtVFFFFFFFFFFFFFFFFFFJkUtFVLrStOvp457uygnlh/wBW8kYY
pzngnpyBQdK09r8ag1jbm7AwJzGN/wD311pqaPpkc1xMmn2yyXQKzsIlzKD1Dcc596iPhzRD
aG0Ok2f2cuJDF5C7dwGA2Mdcd6lfRtMkXa9hbsvk+Rhowf3fXZ/u+1W1VUUKoAA6AVVtNI02
wnaezsbeCVwQzxxhSQTkjj35qWe0hunhaaMOYJBJHn+FgCM/qamxis1NKI159VkuHlYw+THG
yKBEpIJwQM8kd/b0qzYWFtp0LQ2sQjR5HlbuWZiWYk/U1aooorxTwJ/yXXxB/v3X/owV1N1r
mq2PiCe7lnvhp8OqG3diY2txH5YOwJ9/cWIAPTmrz+NtSi09rl9Kt9/2RL5QtyWHkMGODhc7
/lxgAjnOcA02b4jW8ULyC0J2NKGJYhAqgYbfjac7ux4oi+IP2q7t7a309t15cSQWxlcoGCsm
Gbj5QVYsPXgd6S0+If8Aactpa6bY+bdXaRlVmZokR23kgsV5ACHlc5JqMfEpEvoopdOdYnTc
5VizRkBy38O0gGMgfMCc9Kls/iIjpE+oadLZpI4w5VyNrRs68bQSflwcDHcE1EfifapDFI9j
ISyGSREbJiTyBKCeP4idoHsT2q/pPjC7vNA1a/vtMNrPpiGQxksoddm8feAI9DxjjI4qtH4+
l1KdrfSLCOWRpH8hrmYxRyxIiuzg4OM7sL279KWPxzc3kl3BZafGZbW5jtT5s+FLySbV5AOV
xkkjvwKbB47vLi+j0mPTIjqkpKohmIh+VpA5L7eg8rgYyc9OKij+JtubEXEthJFKUklMBYlv
LWPerA4wQTxSn4kLawO2o6e8DqkpUqkrLIVVGAGUDYO/BJAAxT1+I8bzXEMemySPbR3DzBH4
XygCBnHVsk47AZra8JeIT4k02e6KQAw3BhzBKZEbCq2QSB/ex07Vu0Uh6V4t4o/5OE0r/ft/
5GvaqKKKKKKKKKKKKKKKKKKytNuZX1vVbSRpXSBomjLKNqhk5UHvyM8+tatFFFFFFFFFFFFF
FFFeKeBP+S6+IP8Afuv/AEYK9V/4RnRW1X+1TpsBvS2/zSMndjG7HTOOM9ai/wCEO8P/AGd7
f+yoBG7hyACDkZxg5yByRgcYJqefw3o1zam1m0+FoCWPllePm4b88U6bw9pNx5nm2MLeZkuc
YJJKnP5ov5CmT+GdHuYEgmskZI0SOPBIKKhJXaQcjGTyD3pieFNDjmjlTT41aJAiKCdgABAy
ucHgnkjuaWx8L6NpxBtbJUIYsCWZiPlK4BJOBtJAHQA8UW/hbRLX/UadAgypI25ztQxrnPXC
kjHvUlr4e0mysJ7C3sYktrkETR4yJARgg55PHH0pl14X0S9gENxpsDRgg4C7eihAOO20bcdM
cUHwxopuoLr+zoBNbMXhZV27CTnOBweefaibwvotxDJFJYRlZW3PglSTljnIORy7dP7xqeTR
dOmtYLWS0iaG3Qxxx7flVSu0jHptJFQW/hjR7WJo4bNVVldGyzMWDgBgSTk5CgfhTX8K6G8U
kR06LZKzs4GRuLABieechQD9K0LWytrLzfs8Kxec+9wowC2AM/kAPwqxRSHpXi3ij/k4TSv9
+3/ka9qooooooooooooooooooqra2SW1zczqXZ7lw7lmzjAAAHoMD+dWqKKKKKKKKKKKKKKK
K8U8Cf8AJdfEH+/df+jBXtQ6ClpkjFYmYdQCa4a38S6xpdpp+r63qME9heWklw8UVrsaPagY
ANu564q1F8RbG4gWW00+9usCZpRAY2ESxhSx3bsNw4xgnvT1+I+iTXNxDAZZRCkjK6lcSFAC
ygZyOvBIAODzRdfEC0sbT7RdabeRBJ5IJlZ4sxsm3PO/B+8MAZPBqVvHenNbGW3RpXELytGZ
UQxhZBH85J+Tk557D14qWPxlav4estba3ljtrq5FvIWYYgy5TeT0K7h1HYg1lw/EqKeYFNFu
xaGWOL7S0iDBkBKHbnOCBn8ac/xKhh05ri60a6tptscqwyyxqGidWZX3k4H3SMdc4psHxQ0y
bUBaCzuV32/noxdMkeSZuVzkDaMZ6Zpj/FKztoN15pk9vcHay27zx5ZGj8zdnOB8vbuSBVqX
4laIkZMfnSyjDC3BUSGMw+bvCk9McfWobj4p6LH532e3u7oRSGMtHsVSVj3thmYDgcY6k9M1
f8Q+OLbw/p9hfTWrSRX0RlXMqxlQFDY56thuAPSk8TarqtqLF9OkkgtpVaSe4jtftLx4AKgx
g52nJywyRgdOtZ9vr+tX+riGLUVEQjtmLWmnPcRPvXLHfxtB7Z6DrT9P8aXN1PZ2ckUnnzar
LatJ9mYRGNC/R+m75VrjPE//ACcJpX+/b/yr2qiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
iivFPAef+F6a/n+9df8AowV7UOgpaRlDKVPQjFY9x4V0q70630+eJ3t7aBoI13nIVl2nn1wB
zWbP4Gt57q33ajfNBHFMsxac+bPv2DBb+7hcYGO1Le+AdNnDpb3N3aRSSBzDDNiNckFtq9iS
o657+tQH4dWFzJdG81C/nWd3Kt52HCuF3qTjkFlB4x6dK077wZouoTpcSQNHOiqPOhby3Yqy
sGJHJYFRyar6r4TWTwhN4d02RY4bliJHuWaQqrNucg9S2SSM8ZNPn8FaW0EqwrJGzNC6Df8A
KrRJsj49MdR3qhafDXSE0+1jubi9kvIFQfahcneoCbNinsmCeMd6U/DHQ/IWBLrU44VCgRpd
EAEJsz067ePpVq7+H+iXVw1ypura4KxossExRkVI/LCqewKnBqSXwJocto9sY5lRmLZEnzD9
15WAeuNv61Xb4ceHmjWExTG3VAogLgxgiPyw+CPvAZwfU5rQ1Dwnpup2lnbXLXGyzhaCMxzF
CyMoVlbHXIUZp+o+GLDUY7cB7izktYzFDNaTGJ0jOAUyOxwPyquPB1hDMslld6hYgLGvl2ty
URlQYAI78de5q5F4esLeGGKNZAkN212g3niRixP4fMeK8q8THb+0JpfAPzQdfoa9pooooooo
ooooooooooooooooooooooooooooor5+0TxJp/hX4va7qGrSOsJmuY90Ue4ljJ6fhXdH45eE
gSBHqBA7iEc/+PUf8Lx8JZH7vUOev7kcf+PVMPjX4N3f6+8/8Bj/AI0v/C6/Bn/Pe7/8BjR/
wuvwZ/z3u/8AwGNH/C6/Bn/Pe7/8BjR/wuvwZ/z3u/8AwGNNf42eDlUsst45/ui3IJ/M1D/w
vLwn/wA8tQ/78r/8VTl+N/hAlQRfruzkmAfL+tTf8Lr8G/8APe8/8BzR/wALr8Gf897v/wAB
jR/wuvwZ/wA97v8A8BjR/wALr8Gf897v/wABjR/wuvwZ/wA97v8A8BzUcvxv8IR42G+kz/dg
xj8zUZ+OfhPH+q1D/vyv/wAVUh+Nng7A+e+5/wCnfp+tSf8AC6/BmP8Aj4u//AY1wh8QWXin
446VqWl75LdpIlHmJtPyqc8e1e90UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUlfNXxgiji
+I+oCNFQMsbHaMZJQZP1riaKKKKKKKKKKKKKKKKKK9F+B8UcnjiRnjVjHZuyFhkqcqMj0OCa
+h6KKKKKKKKKKKKKKKKKK//Z</binary>
 <binary id="Any2FbImgLoader57" content-type="image/jpeg">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</binary>
 <binary id="Any2FbImgLoader66" content-type="image/jpeg">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</binary>
 <binary id="Any2FbImgLoader73" content-type="image/png">iVBORw0KGgoAAAANSUhEUgAAAfoAAAACCAYAAACwox6JAAAAAXNSR0ICQMB9xQAAAAlwSFlz
AAAOxAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUATWljcm9zb2Z0IE9mZmljZX/tNXEAAAAk
SURBVFjD7cMBDQAwCAMwrE8Z0n6wQdqklaRU1ZtXz6eqntsfruz0sRwfr6QAAAAASUVORK5C
YII=</binary>
 <binary id="Any2FbImgLoader74" content-type="image/jpeg">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
PPvX/9k=</binary>
 <binary id="Any2FbImgLoader77" content-type="image/jpeg">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
/iqydLtZ5NJs5BGQGgQgEjP3R71//9k=</binary>
 <binary id="Any2FbImgLoader78" content-type="image/jpeg">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</binary>
 <binary id="Any2FbImgLoader80" content-type="image/jpeg">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
NHAoYq4YZKxg9QO9f//Z</binary>
 <binary id="Any2FbImgLoader84" content-type="image/jpeg">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
bmNVG8Nnl2r/2Q==</binary>
 <binary id="Any2FbImgLoader87" content-type="image/jpeg">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
JP8AVL/uD+ZrUtu3+4KsV//Z</binary>
 <binary id="Any2FbImgLoader88" content-type="image/jpeg">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
Kn+FXre3htYFgt4Y4Yk4WONQqr9AK//Z</binary>
 <binary id="Any2FbImgLoader94" content-type="image/jpeg">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
9aq+K/Htr4g0VtOhsponeVSHdgQMZP8ASv/Z</binary>
 <binary id="Any2FbImgLoader97" content-type="image/jpeg">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
/9k=</binary>
 <binary id="Any2FbImgLoader100" content-type="image/jpeg">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</binary>
 <binary id="Any2FbImgLoader101" content-type="image/jpeg">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</binary>
 <binary id="Any2FbImgLoader102" content-type="image/jpeg">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
2Q==</binary>
 <binary id="Any2FbImgLoader104" content-type="image/jpeg">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
2Q==</binary>
 <binary id="Any2FbImgLoader106" content-type="image/jpeg">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</binary>
 <binary id="Any2FbImgLoader110" content-type="image/jpeg">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
KKKKKKKKKKK//9k=</binary>
 <binary id="Any2FbImgLoader117" content-type="image/jpeg">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</binary>
 <binary id="Any2FbImgLoader121" content-type="image/jpeg">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</binary>
 <binary id="Any2FbImgLoader122" content-type="image/jpeg">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</binary>
 <binary id="Any2FbImgLoader126" content-type="image/jpeg">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</binary>
 <binary id="Any2FbImgLoader139" content-type="image/jpeg">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</binary>
 <binary id="Any2FbImgLoader143" content-type="image/jpeg">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
7NVWb78//Af6VWq1pf8AyGLP/rvH/wChCv/Z</binary>
 <binary id="Any2FbImgLoader145" content-type="image/jpeg">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
t0UkZHGQPav/2Q==</binary>
 <binary id="Any2FbImgLoader151" content-type="image/jpeg">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
f7fbyM0tk6KqrIGJJPTgV//Z</binary>
 <binary id="_.jpg" content-type="image/jpeg">/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAASUkqAAgAAAAEABoBBQABAAAAPgAAABsB
BQABAAAARgAAACgBAwABAAAAAgAAADEBAgAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABAAAA
UGFpbnQuTkVUIHYzLjM1AP/bAEMADwoLDQsJDw0MDREQDxIXJhgXFRUXLiEjGyY3MDk4NjA1
NDxEVkk8QFJBNDVLZkxSWVxhYmE6SGpyaV5xVl9hXf/bAEMBEBERFxQXLBgYLF0+NT5dXV1d
XV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXf/AABEIAV0A
9QMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMD
AgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZ
GiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImK
kpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp
6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIE
BAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXx
FxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeI
iYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo
6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/AO3n+7inr0ps/wB0U9elMQop1ApRSGFFLRQAmKMU
tFACUUtFACYpKdSUAJRS0GkA2ilpKYCiloFFABRiiigBKMUuKKAEopaSgBDSUp4pKAENebeO
CB4hkyufkXv7V6TXn/iiIXHjBITHuDhBjnJoNKW5y2V/u/rSbgD939a7T/hF7DzNuRjbvz82
NmM7uv4VyupwraX8sAjACNjBzx+tBupp7GXf4MqsBjK80UXpyycAcdqKRjLc9vm6D6VIvSo5
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
2Q==</binary>
</FictionBook>
